@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2012  Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@setfilename ../../info/text
@node Text, Non-ASCII Characters, Markers, Top
@chapter Text
@cindex text

  This chapter describes the functions that deal with the text in a
buffer.  Most examine, insert, or delete text in the current buffer,
often operating at point or on text adjacent to point.  Many are
interactive.  All the functions that change the text provide for undoing
the changes (@pxref{Undo}).

  Many text-related functions operate on a region of text defined by two
buffer positions passed in arguments named @var{start} and @var{end}.
These arguments should be either markers (@pxref{Markers}) or numeric
character positions (@pxref{Positions}).  The order of these arguments
does not matter; it is all right for @var{start} to be the end of the
region and @var{end} the beginning.  For example, @code{(delete-region 1
10)} and @code{(delete-region 10 1)} are equivalent.  An
@code{args-out-of-range} error is signaled if either @var{start} or
@var{end} is outside the accessible portion of the buffer.  In an
interactive call, point and the mark are used for these arguments.

@cindex buffer contents
  Throughout this chapter, ``text'' refers to the characters in the
buffer, together with their properties (when relevant).  Keep in mind
that point is always between two characters, and the cursor appears on
the character after point.

@menu
* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
                        How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Transposition::    Swapping two portions of a buffer.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Base 64::          Conversion to or from base 64 encoding.
* Checksum/Hash::    Computing cryptographic hashes.
* Parsing HTML/XML:: Parsing HTML and XML.
* Atomic Changes::   Installing several buffer changes "atomically".
* Change Hooks::     Supplying functions to be run when text is changed.
@end menu

@node Near Point
@section Examining Text Near Point
@cindex text near point

  Many functions are provided to look at the characters around point.
Several simple functions are described here.  See also @code{looking-at}
in @ref{Regexp Search}.

In the following four functions, ``beginning'' or ``end'' of buffer
refers to the beginning or end of the accessible portion.

@defun char-after &optional position
This function returns the character in the current buffer at (i.e.,
immediately after) position @var{position}.  If @var{position} is out of
range for this purpose, either before the beginning of the buffer, or at
or beyond the end, then the value is @code{nil}.  The default for
@var{position} is point.

In the following example, assume that the first character in the
buffer is @samp{@@}:

@example
@group
(string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position
This function returns the character in the current buffer immediately
before position @var{position}.  If @var{position} is out of range for
this purpose, either at or before the beginning of the buffer, or beyond
the end, then the value is @code{nil}.  The default for
@var{position} is point.
@end defun

@defun following-char
This function returns the character following point in the current
buffer.  This is similar to @code{(char-after (point))}.  However, if
point is at the end of the buffer, then @code{following-char} returns 0.

Remember that point is always between characters, and the cursor
normally appears over the character following point.  Therefore, the
character returned by @code{following-char} is the character the
cursor is over.

In this example, point is between the @samp{a} and the @samp{c}.

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(string (preceding-char))
     @result{} "a"
(string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char
This function returns the character preceding point in the current
buffer.  See above, under @code{following-char}, for an example.  If
point is at the beginning of the buffer, @code{preceding-char} returns
0.
@end defun

@defun bobp
This function returns @code{t} if point is at the beginning of the
buffer.  If narrowing is in effect, this means the beginning of the
accessible portion of the text.  See also @code{point-min} in
@ref{Point}.
@end defun

@defun eobp
This function returns @code{t} if point is at the end of the buffer.
If narrowing is in effect, this means the end of accessible portion of
the text.  See also @code{point-max} in @xref{Point}.
@end defun

@defun bolp
This function returns @code{t} if point is at the beginning of a line.
@xref{Text Lines}.  The beginning of the buffer (or of its accessible
portion) always counts as the beginning of a line.
@end defun

@defun eolp
This function returns @code{t} if point is at the end of a line.  The
end of the buffer (or of its accessible portion) is always considered
the end of a line.
@end defun

@node Buffer Contents
@section Examining Buffer Contents

  This section describes functions that allow a Lisp program to
convert any portion of the text in the buffer into a string.

@defun buffer-substring start end
This function returns a string containing a copy of the text of the
region defined by positions @var{start} and @var{end} in the current
buffer.  If the arguments are not positions in the accessible portion
of the buffer, @code{buffer-substring} signals an
@code{args-out-of-range} error.

Here's an example which assumes Font-Lock mode is not enabled:

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
     @result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
     @result{} "he contents of buffer foo\n"
@end group
@end example

If the text being copied has any text properties, these are copied into
the string along with the characters they belong to.  @xref{Text
Properties}.  However, overlays (@pxref{Overlays}) in the buffer and
their properties are ignored, not copied.

For example, if Font-Lock mode is enabled, you might get results like
these:

@example
@group
(buffer-substring 1 10)
     @result{} #("This is t" 0 1 (fontified t) 1 9 (fontified t))
@end group
@end example
@end defun

@defun buffer-substring-no-properties start end
This is like @code{buffer-substring}, except that it does not copy text
properties, just the characters themselves.  @xref{Text Properties}.
@end defun

@defun buffer-string
This function returns the contents of the entire accessible portion of
the current buffer as a string.  It is equivalent to
@w{@code{(buffer-substring (point-min) (point-max))}}.
@end defun

@defun filter-buffer-substring start end &optional delete
This function passes the buffer text between @var{start} and @var{end}
through the filter functions specified by the wrapper hook
@code{filter-buffer-substring-functions}, and returns the result.  The
obsolete variable @code{buffer-substring-filters} is also consulted.
If both of these variables are @code{nil}, the value is the unaltered
text from the buffer, i.e.@: what @code{buffer-substring} would
return.

If @var{delete} is non-@code{nil}, this function deletes the text
between @var{start} and @var{end} after copying it, like
@code{delete-and-extract-region}.

Lisp code should use this function instead of @code{buffer-substring},
@code{buffer-substring-no-properties},
or @code{delete-and-extract-region} when copying into user-accessible
data structures such as the kill-ring, X clipboard, and registers.
Major and minor modes can add functions to
@code{filter-buffer-substring-functions} to alter such text as it is
copied out of the buffer.
@end defun

@defvar filter-buffer-substring-functions
This variable is a wrapper hook (@pxref{Running Hooks}), whose members
should be functions that accept four arguments: @var{fun},
@var{start}, @var{end}, and @var{delete}.  @var{fun} is a function
that takes three arguments (@var{start}, @var{end}, and @var{delete}),
and returns a string.  In both cases, the @var{start}, @var{end}, and
@var{delete} arguments are the same as those of
@code{filter-buffer-substring}.

The first hook function is passed a @var{fun} that is equivalent to
the default operation of @code{filter-buffer-substring}, i.e. it
returns the buffer-substring between @var{start} and @var{end}
(processed by any @code{buffer-substring-filters}) and optionally
deletes the original text from the buffer.  In most cases, the hook
function will call @var{fun} once, and then do its own processing of
the result.  The next hook function receives a @var{fun} equivalent to
this, and so on.  The actual return value is the result of all the
hook functions acting in sequence.
@end defvar

@defvar buffer-substring-filters
This variable is obsoleted by
@code{filter-buffer-substring-functions}, but is still supported for
backward compatibility.  Its value should should be a list of
functions which accept a single string argument and return another
string.  @code{filter-buffer-substring} passes the buffer substring to
the first function in this list, and the return value of each function
is passed to the next function.  The return value of the last function
is passed to @code{filter-buffer-substring-functions}.
@end defvar

@defun current-word &optional strict really-word
This function returns the symbol (or word) at or near point, as a
string.  The return value includes no text properties.

If the optional argument @var{really-word} is non-@code{nil}, it finds a
word; otherwise, it finds a symbol (which includes both word
characters and symbol constituent characters).

If the optional argument @var{strict} is non-@code{nil}, then point
must be in or next to the symbol or word---if no symbol or word is
there, the function returns @code{nil}.  Otherwise, a nearby symbol or
word on the same line is acceptable.
@end defun

@defun thing-at-point thing
Return the @var{thing} around or next to point, as a string.

The argument @var{thing} is a symbol which specifies a kind of syntactic
entity.  Possibilities include @code{symbol}, @code{list}, @code{sexp},
@code{defun}, @code{filename}, @code{url}, @code{word}, @code{sentence},
@code{whitespace}, @code{line}, @code{page}, and others.

@example
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------

(thing-at-point 'word)
     @result{} "Peace"
(thing-at-point 'line)
     @result{} "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
     @result{} nil
@end example
@end defun

@node Comparing Text
@section Comparing Text
@cindex comparing buffer text

  This function lets you compare portions of the text in a buffer, without
copying them into strings first.

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
This function lets you compare two substrings of the same buffer or two
different buffers.  The first three arguments specify one substring,
giving a buffer (or a buffer name) and two positions within the
buffer.  The last three arguments specify the other substring in the
same way.  You can use @code{nil} for @var{buffer1}, @var{buffer2}, or
both to stand for the current buffer.

The value is negative if the first substring is less, positive if the
first is greater, and zero if they are equal.  The absolute value of
the result is one plus the index of the first differing characters
within the substrings.

This function ignores case when comparing characters
if @code{case-fold-search} is non-@code{nil}.  It always ignores
text properties.

Suppose the current buffer contains the text @samp{foobarbar
haha!rara!}; then in this example the two substrings are @samp{rbar }
and @samp{rara!}.  The value is 2 because the first substring is greater
at the second character.

@example
(compare-buffer-substrings nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@section Inserting Text
@cindex insertion of text
@cindex text insertion

@cindex insertion before point
@cindex before point, insertion
  @dfn{Insertion} means adding new text to a buffer.  The inserted text
goes at point---between the character before point and the character
after point.  Some insertion functions leave point before the inserted
text, while other functions leave it after.  We call the former
insertion @dfn{after point} and the latter insertion @dfn{before point}.

  Insertion moves markers located at positions after the insertion
point, so that they stay with the surrounding text (@pxref{Markers}).
When a marker points at the place of insertion, insertion may or may
not relocate the marker, depending on the marker's insertion type
(@pxref{Marker Insertion Types}).  Certain special functions such as
@code{insert-before-markers} relocate all such markers to point after
the inserted text, regardless of the markers' insertion type.

  Insertion functions signal an error if the current buffer is
read-only or if they insert within read-only text.

  These functions copy text characters from strings and buffers along
with their properties.  The inserted characters have exactly the same
properties as the characters they were copied from.  By contrast,
characters specified as separate arguments, not part of a string or
buffer, inherit their text properties from the neighboring text.

  The insertion functions convert text from unibyte to multibyte in
order to insert in a multibyte buffer, and vice versa---if the text
comes from a string or from a buffer.  However, they do not convert
unibyte character codes 128 through 255 to multibyte characters, not
even if the current buffer is a multibyte buffer.  @xref{Converting
Representations}.

@defun insert &rest args
This function inserts the strings and/or characters @var{args} into the
current buffer, at point, moving point forward.  In other words, it
inserts the text before point.  An error is signaled unless all
@var{args} are either strings or characters.  The value is @code{nil}.
@end defun

@defun insert-before-markers &rest args
This function inserts the strings and/or characters @var{args} into the
current buffer, at point, moving point forward.  An error is signaled
unless all @var{args} are either strings or characters.  The value is
@code{nil}.

This function is unlike the other insertion functions in that it
relocates markers initially pointing at the insertion point, to point
after the inserted text.  If an overlay begins at the insertion point,
the inserted text falls outside the overlay; if a nonempty overlay
ends at the insertion point, the inserted text falls inside that
overlay.
@end defun

@defun insert-char character count &optional inherit
This function inserts @var{count} instances of @var{character} into the
current buffer before point.  The argument @var{count} should be an
integer, and @var{character} must be a character.  The value is @code{nil}.

This function does not convert unibyte character codes 128 through 255
to multibyte characters, not even if the current buffer is a multibyte
buffer.  @xref{Converting Representations}.

If @var{inherit} is non-@code{nil}, then the inserted characters inherit
sticky text properties from the two characters before and after the
insertion point.  @xref{Sticky Properties}.
@end defun

@defun insert-buffer-substring from-buffer-or-name &optional start end
This function inserts a portion of buffer @var{from-buffer-or-name}
(which must already exist) into the current buffer before point.  The
text inserted is the region between @var{start} and @var{end}.  (These
arguments default to the beginning and end of the accessible portion of
that buffer.)  This function returns @code{nil}.

In this example, the form is executed with buffer @samp{bar} as the
current buffer.  We assume that buffer @samp{bar} is initially empty.

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

@defun insert-buffer-substring-no-properties from-buffer-or-name &optional start end
This is like @code{insert-buffer-substring} except that it does not
copy any text properties.
@end defun

  @xref{Sticky Properties}, for other insertion functions that inherit
text properties from the nearby text in addition to inserting it.
Whitespace inserted by indentation functions also inherits text
properties.

@node Commands for Insertion
@section User-Level Insertion Commands

  This section describes higher-level commands for inserting text,
commands intended primarily for the user but useful also in Lisp
programs.

@deffn Command insert-buffer from-buffer-or-name
This command inserts the entire accessible contents of
@var{from-buffer-or-name} (which must exist) into the current buffer
after point.  It leaves the mark after the inserted text.  The value
is @code{nil}.
@end deffn

@deffn Command self-insert-command count
@cindex character insertion
@cindex self-insertion
This command inserts the last character typed; it does so @var{count}
times, before point, and returns @code{nil}.  Most printing characters
are bound to this command.  In routine use, @code{self-insert-command}
is the most frequently called function in Emacs, but programs rarely use
it except to install it on a keymap.

In an interactive call, @var{count} is the numeric prefix argument.

Self-insertion translates the input character through
@code{translation-table-for-input}.  @xref{Translation of Characters}.

This command calls @code{auto-fill-function} whenever that is
non-@code{nil} and the character inserted is in the table
@code{auto-fill-chars} (@pxref{Auto Filling}).

@c Cross refs reworded to prevent overfull hbox.  --rjc 15mar92
This command performs abbrev expansion if Abbrev mode is enabled and
the inserted character does not have word-constituent
syntax. (@xref{Abbrevs}, and @ref{Syntax Class Table}.)  It is also
responsible for calling @code{blink-paren-function} when the inserted
character has close parenthesis syntax (@pxref{Blinking}).

@vindex post-self-insert-hook
The final thing this command does is to run the hook
@code{post-self-insert-hook}.  You could use this to automatically
reindent text as it is typed, for example.

Do not try substituting your own definition of
@code{self-insert-command} for the standard one.  The editor command
loop handles this function specially.
@end deffn

@deffn Command newline &optional number-of-newlines
This command inserts newlines into the current buffer before point.
If @var{number-of-newlines} is supplied, that many newline characters
are inserted.

@cindex newline and Auto Fill mode
This function calls @code{auto-fill-function} if the current column
number is greater than the value of @code{fill-column} and
@var{number-of-newlines} is @code{nil}.  Typically what
@code{auto-fill-function} does is insert a newline; thus, the overall
result in this case is to insert two newlines at different places: one
at point, and another earlier in the line.  @code{newline} does not
auto-fill if @var{number-of-newlines} is non-@code{nil}.

This command indents to the left margin if that is not zero.
@xref{Margins}.

The value returned is @code{nil}.  In an interactive call, @var{count}
is the numeric prefix argument.
@end deffn

@defvar overwrite-mode
This variable controls whether overwrite mode is in effect.  The value
should be @code{overwrite-mode-textual}, @code{overwrite-mode-binary},
or @code{nil}.  @code{overwrite-mode-textual} specifies textual
overwrite mode (treats newlines and tabs specially), and
@code{overwrite-mode-binary} specifies binary overwrite mode (treats
newlines and tabs like any other characters).
@end defvar

@node Deletion
@section Deleting Text
@cindex text deletion

@cindex deleting text vs killing
  Deletion means removing part of the text in a buffer, without saving
it in the kill ring (@pxref{The Kill Ring}).  Deleted text can't be
yanked, but can be reinserted using the undo mechanism (@pxref{Undo}).
Some deletion functions do save text in the kill ring in some special
cases.

  All of the deletion functions operate on the current buffer.

@deffn Command erase-buffer
This function deletes the entire text of the current buffer
(@emph{not} just the accessible portion), leaving it
empty.  If the buffer is read-only, it signals a @code{buffer-read-only}
error; if some of the text in it is read-only, it signals a
@code{text-read-only} error.  Otherwise, it deletes the text without
asking for any confirmation.  It returns @code{nil}.

Normally, deleting a large amount of text from a buffer inhibits further
auto-saving of that buffer ``because it has shrunk''.  However,
@code{erase-buffer} does not do this, the idea being that the future
text is not really related to the former text, and its size should not
be compared with that of the former text.
@end deffn

@deffn Command delete-region start end
This command deletes the text between positions @var{start} and
@var{end} in the current buffer, and returns @code{nil}.  If point was
inside the deleted region, its value afterward is @var{start}.
Otherwise, point relocates with the surrounding text, as markers do.
@end deffn

@defun delete-and-extract-region start end
This function deletes the text between positions @var{start} and
@var{end} in the current buffer, and returns a string containing the
text just deleted.

If point was inside the deleted region, its value afterward is
@var{start}.  Otherwise, point relocates with the surrounding text, as
markers do.
@end defun

@deffn Command delete-char count &optional killp
This command deletes @var{count} characters directly after point, or
before point if @var{count} is negative.  If @var{killp} is
non-@code{nil}, then it saves the deleted characters in the kill ring.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@deffn Command delete-backward-char count &optional killp
@cindex deleting previous char
This command deletes @var{count} characters directly before point, or
after point if @var{count} is negative.  If @var{killp} is
non-@code{nil}, then it saves the deleted characters in the kill ring.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@deffn Command backward-delete-char-untabify count &optional killp
@cindex tab deletion
This command deletes @var{count} characters backward, changing tabs
into spaces.  When the next character to be deleted is a tab, it is
first replaced with the proper number of spaces to preserve alignment
and then one of those spaces is deleted instead of the tab.  If
@var{killp} is non-@code{nil}, then the command saves the deleted
characters in the kill ring.

Conversion of tabs to spaces happens only if @var{count} is positive.
If it is negative, exactly @minus{}@var{count} characters after point
are deleted.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@defopt backward-delete-char-untabify-method
This option specifies how @code{backward-delete-char-untabify} should
deal with whitespace.  Possible values include @code{untabify}, the
default, meaning convert a tab to many spaces and delete one;
@code{hungry}, meaning delete all tabs and spaces before point with
one command; @code{all} meaning delete all tabs, spaces and newlines
before point, and @code{nil}, meaning do nothing special for
whitespace characters.
@end defopt

@node User-Level Deletion
@section User-Level Deletion Commands

  This section describes higher-level commands for deleting text,
commands intended primarily for the user but useful also in Lisp
programs.

@deffn Command delete-horizontal-space &optional backward-only
@cindex deleting whitespace
This function deletes all spaces and tabs around point.  It returns
@code{nil}.

If @var{backward-only} is non-@code{nil}, the function deletes
spaces and tabs before point, but not after point.

In the following examples, we call @code{delete-horizontal-space} four
times, once on each line, with point between the second and third
characters on the line each time.

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Four times.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command delete-indentation &optional join-following-p
This function joins the line point is on to the previous line, deleting
any whitespace at the join and in some cases replacing it with one
space.  If @var{join-following-p} is non-@code{nil},
@code{delete-indentation} joins this line to the following line
instead.  The function returns @code{nil}.

If there is a fill prefix, and the second of the lines being joined
starts with the prefix, then @code{delete-indentation} deletes the
fill prefix before joining the lines.  @xref{Margins}.

In the example below, point is located on the line starting
@samp{events}, and it makes no difference if there are trailing spaces
in the preceding line.

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

After the lines are joined, the function @code{fixup-whitespace} is
responsible for deciding whether to leave a space at the junction.
@end deffn

@deffn Command fixup-whitespace
This function replaces all the horizontal whitespace surrounding point
with either one space or no space, according to the context.  It
returns @code{nil}.

At the beginning or end of a line, the appropriate amount of space is
none.  Before a character with close parenthesis syntax, or after a
character with open parenthesis or expression-prefix syntax, no space is
also appropriate.  Otherwise, one space is appropriate.  @xref{Syntax
Class Table}.

In the example below, @code{fixup-whitespace} is called the first time
with point before the word @samp{spaces} in the first line.  For the
second invocation, point is directly after the @samp{(}.

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end deffn

@deffn Command just-one-space &optional n
@comment !!SourceFile simple.el
This command replaces any spaces and tabs around point with a single
space, or @var{n} spaces if @var{n} is specified.  It returns
@code{nil}.
@end deffn

@deffn Command delete-blank-lines
This function deletes blank lines surrounding point.  If point is on a
blank line with one or more blank lines before or after it, then all but
one of them are deleted.  If point is on an isolated blank line, then it
is deleted.  If point is on a nonblank line, the command deletes all
blank lines immediately following it.

A blank line is defined as a line containing only tabs and spaces.

@code{delete-blank-lines} returns @code{nil}.
@end deffn

@node The Kill Ring
@section The Kill Ring
@cindex kill ring

  @dfn{Kill functions} delete text like the deletion functions, but save
it so that the user can reinsert it by @dfn{yanking}.  Most of these
functions have @samp{kill-} in their name.  By contrast, the functions
whose names start with @samp{delete-} normally do not save text for
yanking (though they can still be undone); these are ``deletion''
functions.

  Most of the kill commands are primarily for interactive use, and are
not described here.  What we do describe are the functions provided for
use in writing such commands.  You can use these functions to write
commands for killing text.  When you need to delete text for internal
purposes within a Lisp function, you should normally use deletion
functions, so as not to disturb the kill ring contents.
@xref{Deletion}.

  Killed text is saved for later yanking in the @dfn{kill ring}.  This
is a list that holds a number of recent kills, not just the last text
kill.  We call this a ``ring'' because yanking treats it as having
elements in a cyclic order.  The list is kept in the variable
@code{kill-ring}, and can be operated on with the usual functions for
lists; there are also specialized functions, described in this section,
that treat it as a ring.

  Some people think this use of the word ``kill'' is unfortunate, since
it refers to operations that specifically @emph{do not} destroy the
entities ``killed''.  This is in sharp contrast to ordinary life, in
which death is permanent and ``killed'' entities do not come back to
life.  Therefore, other metaphors have been proposed.  For example, the
term ``cut ring'' makes sense to people who, in pre-computer days, used
scissors and paste to cut up and rearrange manuscripts.  However, it
would be difficult to change the terminology now.

@menu
* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yanking::                How yanking is done.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::    Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill ring data.
@end menu

@node Kill Ring Concepts
@comment  node-name,  next,  previous,  up
@subsection Kill Ring Concepts

  The kill ring records killed text as strings in a list, most recent
first.  A short kill ring, for example, might look like this:

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
When the list reaches @code{kill-ring-max} entries in length, adding a
new entry automatically deletes the last entry.

  When kill commands are interwoven with other commands, each kill
command makes a new entry in the kill ring.  Multiple kill commands in
succession build up a single kill ring entry, which would be yanked as a
unit; the second and subsequent consecutive kill commands add text to
the entry made by the first one.

  For yanking, one entry in the kill ring is designated the ``front'' of
the ring.  Some yank commands ``rotate'' the ring by designating a
different element as the ``front''.  But this virtual rotation doesn't
change the list itself---the most recent entry always comes first in the
list.

@node Kill Functions
@comment  node-name,  next,  previous,  up
@subsection Functions for Killing

  @code{kill-region} is the usual subroutine for killing text.  Any
command that calls this function is a ``kill command'' (and should
probably have @samp{kill} in its name).  @code{kill-region} puts the
newly killed text in a new element at the beginning of the kill ring or
adds it to the most recent element.  It determines automatically (using
@code{last-command}) whether the previous command was a kill command,
and if so appends the killed text to the most recent entry.

@deffn Command kill-region start end
This function kills the text in the region defined by @var{start} and
@var{end}.  The text is deleted but saved in the kill ring, along with
its text properties.  The value is always @code{nil}.

In an interactive call, @var{start} and @var{end} are point and
the mark.

If the buffer or text is read-only, @code{kill-region} modifies the kill
ring just the same, then signals an error without modifying the buffer.
This is convenient because it lets the user use a series of kill
commands to copy text from a read-only buffer into the kill ring.
@end deffn

@defopt kill-read-only-ok
If this option is non-@code{nil}, @code{kill-region} does not signal an
error if the buffer or text is read-only.  Instead, it simply returns,
updating the kill ring but not changing the buffer.
@end defopt

@deffn Command copy-region-as-kill start end
This command saves the region defined by @var{start} and @var{end} on
the kill ring (including text properties), but does not delete the text
from the buffer.  It returns @code{nil}.

The command does not set @code{this-command} to @code{kill-region}, so a
subsequent kill command does not append to the same kill ring entry.

@c FIXME Why is it better?  Why isn't copy-region-as-kill obsolete then?
@c Why is it used in many places in Emacs?
In Lisp programs, it is better to use @code{kill-new} or
@code{kill-append} instead of this command.  @xref{Low-Level Kill Ring}.
@end deffn

@node Yanking
@subsection Yanking

  Yanking means inserting text from the kill ring, but it does
not insert the text blindly.  Yank commands and some other commands
use @code{insert-for-yank} to perform special processing on the
text that they copy into the buffer.

@defun insert-for-yank string
This function normally works like @code{insert} except that it doesn't
insert the text properties (@pxref{Text Properties}) in the list
variable @code{yank-excluded-properties}.  However, if any part of
@var{string} has a non-@code{nil} @code{yank-handler} text property,
that property can do various special processing on that part of the
text being inserted.
@end defun

@defun insert-buffer-substring-as-yank buf &optional start end
This function resembles @code{insert-buffer-substring} except that it
doesn't insert the text properties in the
@code{yank-excluded-properties} list.
@end defun

  You can put a @code{yank-handler} text property on all or part of
the text to control how it will be inserted if it is yanked.  The
@code{insert-for-yank} function looks for that property.  The property
value must be a list of one to four elements, with the following
format (where elements after the first may be omitted):

@example
(@var{function} @var{param} @var{noexclude} @var{undo})
@end example

  Here is what the elements do:

@table @var
@item function
When @var{function} is present and non-@code{nil}, it is called instead of
@code{insert} to insert the string.  @var{function} takes one
argument---the string to insert.

@item param
If @var{param} is present and non-@code{nil}, it replaces @var{string}
(or the part of @var{string} being processed) as the object passed to
@var{function} (or @code{insert}); for example, if @var{function} is
@code{yank-rectangle}, @var{param} should be a list of strings to
insert as a rectangle.

@item noexclude
If @var{noexclude} is present and non-@code{nil}, the normal removal of the
yank-excluded-properties is not performed; instead @var{function} is
responsible for removing those properties.  This may be necessary
if @var{function} adjusts point before or after inserting the object.

@item undo
If @var{undo} is present and non-@code{nil}, it is a function that will be
called by @code{yank-pop} to undo the insertion of the current object.
It is called with two arguments, the start and end of the current
region.  @var{function} can set @code{yank-undo-function} to override
the @var{undo} value.
@end table

@cindex yanking and text properties
@defopt yank-excluded-properties
Yanking discards certain text properties from the yanked text, as
described above.  The value of this variable is the list of properties
to discard.  Its default value contains properties that might lead to
annoying results, such as causing the text to respond to the mouse or
specifying key bindings.
@end defopt

@node Yank Commands
@comment  node-name,  next,  previous,  up
@subsection Functions for Yanking

  This section describes higher-level commands for yanking, which are
intended primarily for the user but useful also in Lisp programs.
Both @code{yank} and @code{yank-pop} honor the
@code{yank-excluded-properties} variable and @code{yank-handler} text
property (@pxref{Yanking}).

@deffn Command yank &optional arg
@cindex inserting killed text
This command inserts before point the text at the front of the kill
ring.  It sets the mark at the beginning of that text, using
@code{push-mark} (@pxref{The Mark}), and puts point at the end.

If @var{arg} is a non-@code{nil} list (which occurs interactively when
the user types @kbd{C-u} with no digits), then @code{yank} inserts the
text as described above, but puts point before the yanked text and
sets the mark after it.

If @var{arg} is a number, then @code{yank} inserts the @var{arg}th
most recently killed text---the @var{arg}th element of the kill ring
list, counted cyclically from the front, which is considered the
first element for this purpose.

@code{yank} does not alter the contents of the kill ring, unless it
used text provided by another program, in which case it pushes that text
onto the kill ring.  However if @var{arg} is an integer different from
one, it rotates the kill ring to place the yanked string at the front.

@code{yank} returns @code{nil}.
@end deffn

@deffn Command yank-pop &optional arg
This command replaces the just-yanked entry from the kill ring with a
different entry from the kill ring.

This is allowed only immediately after a @code{yank} or another
@code{yank-pop}.  At such a time, the region contains text that was just
inserted by yanking.  @code{yank-pop} deletes that text and inserts in
its place a different piece of killed text.  It does not add the deleted
text to the kill ring, since it is already in the kill ring somewhere.
It does however rotate the kill ring to place the newly yanked string at
the front.

If @var{arg} is @code{nil}, then the replacement text is the previous
element of the kill ring.  If @var{arg} is numeric, the replacement is
the @var{arg}th previous kill.  If @var{arg} is negative, a more recent
kill is the replacement.

The sequence of kills in the kill ring wraps around, so that after the
oldest one comes the newest one, and before the newest one goes the
oldest.

The return value is always @code{nil}.
@end deffn

@defvar yank-undo-function
If this variable is non-@code{nil}, the function @code{yank-pop} uses
its value instead of @code{delete-region} to delete the text
inserted by the previous @code{yank} or
@code{yank-pop} command.  The value must be a function of two
arguments, the start and end of the current region.

The function @code{insert-for-yank} automatically sets this variable
according to the @var{undo} element of the @code{yank-handler}
text property, if there is one.
@end defvar

@node Low-Level Kill Ring
@subsection Low-Level Kill Ring

  These functions and variables provide access to the kill ring at a
lower level, but are still convenient for use in Lisp programs,
because they take care of interaction with window system selections
(@pxref{Window System Selections}).

@defun current-kill n &optional do-not-move
The function @code{current-kill} rotates the yanking pointer, which
designates the ``front'' of the kill ring, by @var{n} places (from newer
kills to older ones), and returns the text at that place in the ring.

If the optional second argument @var{do-not-move} is non-@code{nil},
then @code{current-kill} doesn't alter the yanking pointer; it just
returns the @var{n}th kill, counting from the current yanking pointer.

If @var{n} is zero, indicating a request for the latest kill,
@code{current-kill} calls the value of
@code{interprogram-paste-function} (documented below) before
consulting the kill ring.  If that value is a function and calling it
returns a string or a list of several string, @code{current-kill}
pushes the strings onto the kill ring and returns the first string.
It also sets the yanking pointer to point to the kill-ring entry of
the first string returned by @code{interprogram-paste-function},
regardless of the value of @var{do-not-move}.  Otherwise,
@code{current-kill} does not treat a zero value for @var{n} specially:
it returns the entry pointed at by the yanking pointer and does not
move the yanking pointer.
@end defun

@defun kill-new string &optional replace
This function pushes the text @var{string} onto the kill ring and
makes the yanking pointer point to it.  It discards the oldest entry
if appropriate.  It also invokes the value of
@code{interprogram-cut-function} (see below).

If @var{replace} is non-@code{nil}, then @code{kill-new} replaces the
first element of the kill ring with @var{string}, rather than pushing
@var{string} onto the kill ring.
@end defun

@defun kill-append string before-p
This function appends the text @var{string} to the first entry in the
kill ring and makes the yanking pointer point to the combined entry.
Normally @var{string} goes at the end of the entry, but if
@var{before-p} is non-@code{nil}, it goes at the beginning.  This
function also invokes the value of @code{interprogram-cut-function}
(see below).
@end defun

@defvar interprogram-paste-function
This variable provides a way of transferring killed text from other
programs, when you are using a window system.  Its value should be
@code{nil} or a function of no arguments.

If the value is a function, @code{current-kill} calls it to get the
``most recent kill''.  If the function returns a non-@code{nil} value,
then that value is used as the ``most recent kill''.  If it returns
@code{nil}, then the front of the kill ring is used.

To facilitate support for window systems that support multiple
selections, this function may also return a list of strings.  In that
case, the first string is used as the ``most recent kill'', and all
the other strings are pushed onto the kill ring, for easy access by
@code{yank-pop}.

The normal use of this function is to get the window system's
clipboard as the most recent kill, even if the selection belongs to
another application.  @xref{Window System Selections}.  However, if
the clipboard contents come from the current Emacs session, this
function should return @code{nil}.
@end defvar

@defvar interprogram-cut-function
This variable provides a way of communicating killed text to other
programs, when you are using a window system.  Its value should be
@code{nil} or a function of one required argument.

If the value is a function, @code{kill-new} and @code{kill-append} call
it with the new first element of the kill ring as the argument.

The normal use of this function is to put newly killed text in the
window system's clipboard.  @xref{Window System Selections}.
@end defvar

@node Internals of Kill Ring
@comment  node-name,  next,  previous,  up
@subsection Internals of the Kill Ring

  The variable @code{kill-ring} holds the kill ring contents, in the
form of a list of strings.  The most recent kill is always at the front
of the list.

  The @code{kill-ring-yank-pointer} variable points to a link in the
kill ring list, whose @sc{car} is the text to yank next.  We say it
identifies the ``front'' of the ring.  Moving
@code{kill-ring-yank-pointer} to a different link is called
@dfn{rotating the kill ring}.  We call the kill ring a ``ring'' because
the functions that move the yank pointer wrap around from the end of the
list to the beginning, or vice-versa.  Rotation of the kill ring is
virtual; it does not change the value of @code{kill-ring}.

  Both @code{kill-ring} and @code{kill-ring-yank-pointer} are Lisp
variables whose values are normally lists.  The word ``pointer'' in the
name of the @code{kill-ring-yank-pointer} indicates that the variable's
purpose is to identify one element of the list for use by the next yank
command.

  The value of @code{kill-ring-yank-pointer} is always @code{eq} to one
of the links in the kill ring list.  The element it identifies is the
@sc{car} of that link.  Kill commands, which change the kill ring, also
set this variable to the value of @code{kill-ring}.  The effect is to
rotate the ring so that the newly killed text is at the front.

  Here is a diagram that shows the variable @code{kill-ring-yank-pointer}
pointing to the second entry in the kill ring @code{("some text" "a
different piece of text" "yet older text")}.

@example
@group
kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --> |   |   |------> |   |   |--> |   |   |--> nil
        --- ---          --- ---      --- ---
         |                |            |
         |                |            |
         |                |             -->"yet older text"
         |                |
         |                 --> "a different piece of text"
         |
          --> "some text"
@end group
@end example

@noindent
This state of affairs might occur after @kbd{C-y} (@code{yank})
immediately followed by @kbd{M-y} (@code{yank-pop}).

@defvar kill-ring
This variable holds the list of killed text sequences, most recently
killed first.
@end defvar

@defvar kill-ring-yank-pointer
This variable's value indicates which element of the kill ring is at the
``front'' of the ring for yanking.  More precisely, the value is a tail
of the value of @code{kill-ring}, and its @sc{car} is the kill string
that @kbd{C-y} should yank.
@end defvar

@defopt kill-ring-max
The value of this variable is the maximum length to which the kill
ring can grow, before elements are thrown away at the end.  The default
value for @code{kill-ring-max} is 60.
@end defopt

@node Undo
@comment  node-name,  next,  previous,  up
@section Undo
@cindex redo

  Most buffers have an @dfn{undo list}, which records all changes made
to the buffer's text so that they can be undone.  (The buffers that
don't have one are usually special-purpose buffers for which Emacs
assumes that undoing is not useful.  In particular, any buffer whose
name begins with a space has its undo recording off by default;
see @ref{Buffer Names}.)  All the primitives that modify the
text in the buffer automatically add elements to the front of the undo
list, which is in the variable @code{buffer-undo-list}.

@defvar buffer-undo-list
This buffer-local variable's value is the undo list of the current
buffer. A value of @code{t} disables the recording of undo information.
@end defvar

Here are the kinds of elements an undo list can have:

@table @code
@item @var{position}
This kind of element records a previous value of point; undoing this
element moves point to @var{position}.  Ordinary cursor motion does not
make any sort of undo record, but deletion operations use these entries
to record where point was before the command.

@item (@var{beg} . @var{end})
This kind of element indicates how to delete text that was inserted.
Upon insertion, the text occupied the range @var{beg}--@var{end} in the
buffer.

@item (@var{text} . @var{position})
This kind of element indicates how to reinsert text that was deleted.
The deleted text itself is the string @var{text}.  The place to
reinsert it is @code{(abs @var{position})}.  If @var{position} is
positive, point was at the beginning of the deleted text, otherwise it
was at the end.

@item (t @var{high} . @var{low})
This kind of element indicates that an unmodified buffer became
modified.  The elements @var{high} and @var{low} are two integers, each
recording 16 bits of the visited file's modification time as of when it
was previously visited or saved.  @code{primitive-undo} uses those
values to determine whether to mark the buffer as unmodified once again;
it does so only if the file's modification time matches those numbers.

@item (nil @var{property} @var{value} @var{beg} . @var{end})
This kind of element records a change in a text property.
Here's how you might undo the change:

@example
(put-text-property @var{beg} @var{end} @var{property} @var{value})
@end example

@item (@var{marker} . @var{adjustment})
This kind of element records the fact that the marker @var{marker} was
relocated due to deletion of surrounding text, and that it moved
@var{adjustment} character positions.  Undoing this element moves
@var{marker} @minus{} @var{adjustment} characters.

@item (apply @var{funname} . @var{args})
This is an extensible undo item, which is undone by calling
@var{funname} with arguments @var{args}.

@item (apply @var{delta} @var{beg} @var{end} @var{funname} . @var{args})
This is an extensible undo item, which records a change limited to the
range @var{beg} to @var{end}, which increased the size of the buffer
by @var{delta}.  It is undone by calling @var{funname} with arguments
@var{args}.

This kind of element enables undo limited to a region to determine
whether the element pertains to that region.

@item nil
This element is a boundary.  The elements between two boundaries are
called a @dfn{change group}; normally, each change group corresponds to
one keyboard command, and undo commands normally undo an entire group as
a unit.
@end table

@defun undo-boundary
This function places a boundary element in the undo list.  The undo
command stops at such a boundary, and successive undo commands undo
to earlier and earlier boundaries.  This function returns @code{nil}.

The editor command loop automatically calls @code{undo-boundary} just
before executing each key sequence, so that each undo normally undoes
the effects of one command.  As an exception, the command
@code{self-insert-command}, which produces self-inserting input
characters (@pxref{Commands for Insertion}), may remove the boundary
inserted by the command loop: a boundary is accepted for the first
such character, the next 19 consecutive self-inserting input
characters do not have boundaries, and then the 20th does; and so on
as long as the self-inserting characters continue.  Hence, sequences
of consecutive character insertions can be undone as a group.

All buffer modifications add a boundary whenever the previous undoable
change was made in some other buffer.  This is to ensure that
each command makes a boundary in each buffer where it makes changes.

Calling this function explicitly is useful for splitting the effects of
a command into more than one unit.  For example, @code{query-replace}
calls @code{undo-boundary} after each replacement, so that the user can
undo individual replacements one by one.
@end defun

@defvar undo-in-progress
This variable is normally @code{nil}, but the undo commands bind it to
@code{t}.  This is so that various kinds of change hooks can tell when
they're being called for the sake of undoing.
@end defvar

@defun primitive-undo count list
This is the basic function for undoing elements of an undo list.
It undoes the first @var{count} elements of @var{list}, returning
the rest of @var{list}.

@code{primitive-undo} adds elements to the buffer's undo list when it
changes the buffer.  Undo commands avoid confusion by saving the undo
list value at the beginning of a sequence of undo operations.  Then the
undo operations use and update the saved value.  The new elements added
by undoing are not part of this saved value, so they don't interfere with
continuing to undo.

This function does not bind @code{undo-in-progress}.
@end defun

@node Maintaining Undo
@section Maintaining Undo Lists

  This section describes how to enable and disable undo information for
a given buffer.  It also explains how the undo list is truncated
automatically so it doesn't get too big.

  Recording of undo information in a newly created buffer is normally
enabled to start with; but if the buffer name starts with a space, the
undo recording is initially disabled.  You can explicitly enable or
disable undo recording with the following two functions, or by setting
@code{buffer-undo-list} yourself.

@deffn Command buffer-enable-undo &optional buffer-or-name
This command enables recording undo information for buffer
@var{buffer-or-name}, so that subsequent changes can be undone.  If no
argument is supplied, then the current buffer is used.  This function
does nothing if undo recording is already enabled in the buffer.  It
returns @code{nil}.

In an interactive call, @var{buffer-or-name} is the current buffer.
You cannot specify any other buffer.
@end deffn

@deffn Command buffer-disable-undo &optional buffer-or-name
@cindex disabling undo
This function discards the undo list of @var{buffer-or-name}, and disables
further recording of undo information.  As a result, it is no longer
possible to undo either previous changes or any subsequent changes.  If
the undo list of @var{buffer-or-name} is already disabled, this function
has no effect.

This function returns @code{nil}.
@end deffn

  As editing continues, undo lists get longer and longer.  To prevent
them from using up all available memory space, garbage collection trims
them back to size limits you can set.  (For this purpose, the ``size''
of an undo list measures the cons cells that make up the list, plus the
strings of deleted text.)  Three variables control the range of acceptable
sizes: @code{undo-limit}, @code{undo-strong-limit} and
@code{undo-outer-limit}.  In these variables, size is counted as the
number of bytes occupied, which includes both saved text and other
data.

@defopt undo-limit
This is the soft limit for the acceptable size of an undo list.  The
change group at which this size is exceeded is the last one kept.
@end defopt

@defopt undo-strong-limit
This is the upper limit for the acceptable size of an undo list.  The
change group at which this size is exceeded is discarded itself (along
with all older change groups).  There is one exception: the very latest
change group is only discarded if it exceeds @code{undo-outer-limit}.
@end defopt

@defopt undo-outer-limit
If at garbage collection time the undo info for the current command
exceeds this limit, Emacs discards the info and displays a warning.
This is a last ditch limit to prevent memory overflow.
@end defopt

@defopt undo-ask-before-discard
If this variable is non-@code{nil}, when the undo info exceeds
@code{undo-outer-limit}, Emacs asks in the echo area whether to
discard the info.  The default value is @code{nil}, which means to
discard it automatically.

This option is mainly intended for debugging.  Garbage collection is
inhibited while the question is asked, which means that Emacs might
leak memory if the user waits too long before answering the question.
@end defopt

@node Filling
@comment  node-name,  next,  previous,  up
@section Filling
@cindex filling text

  @dfn{Filling} means adjusting the lengths of lines (by moving the line
breaks) so that they are nearly (but no greater than) a specified
maximum width.  Additionally, lines can be @dfn{justified}, which means
inserting spaces to make the left and/or right margins line up
precisely.  The width is controlled by the variable @code{fill-column}.
For ease of reading, lines should be no longer than 70 or so columns.

  You can use Auto Fill mode (@pxref{Auto Filling}) to fill text
automatically as you insert it, but changes to existing text may leave
it improperly filled.  Then you must fill the text explicitly.

  Most of the commands in this section return values that are not
meaningful.  All the functions that do filling take note of the current
left margin, current right margin, and current justification style
(@pxref{Margins}).  If the current justification style is
@code{none}, the filling functions don't actually do anything.

  Several of the filling functions have an argument @var{justify}.
If it is non-@code{nil}, that requests some kind of justification.  It
can be @code{left}, @code{right}, @code{full}, or @code{center}, to
request a specific style of justification.  If it is @code{t}, that
means to use the current justification style for this part of the text
(see @code{current-justification}, below).  Any other value is treated
as @code{full}.

  When you call the filling functions interactively, using a prefix
argument implies the value @code{full} for @var{justify}.

@deffn Command fill-paragraph &optional justify region
This command fills the paragraph at or after point.  If
@var{justify} is non-@code{nil}, each line is justified as well.
It uses the ordinary paragraph motion commands to find paragraph
boundaries.  @xref{Paragraphs,,, emacs, The GNU Emacs Manual}.

When @var{region} is non-@code{nil}, then if Transient Mark mode is
enabled and the mark is active, this command calls @code{fill-region}
to fill all the paragraphs in the region, instead of filling only the
current paragraph.  When this command is called interactively,
@var{region} is @code{t}.
@end deffn

@deffn Command fill-region start end &optional justify nosqueeze to-eop
This command fills each of the paragraphs in the region from @var{start}
to @var{end}.  It justifies as well if @var{justify} is
non-@code{nil}.

If @var{nosqueeze} is non-@code{nil}, that means to leave whitespace
other than line breaks untouched.  If @var{to-eop} is non-@code{nil},
that means to keep filling to the end of the paragraph---or the next hard
newline, if @code{use-hard-newlines} is enabled (see below).

The variable @code{paragraph-separate} controls how to distinguish
paragraphs.  @xref{Standard Regexps}.
@end deffn

@deffn Command fill-individual-paragraphs start end &optional justify citation-regexp
This command fills each paragraph in the region according to its
individual fill prefix.  Thus, if the lines of a paragraph were indented
with spaces, the filled paragraph will remain indented in the same
fashion.

The first two arguments, @var{start} and @var{end}, are the beginning
and end of the region to be filled.  The third and fourth arguments,
@var{justify} and @var{citation-regexp}, are optional.  If
@var{justify} is non-@code{nil}, the paragraphs are justified as
well as filled.  If @var{citation-regexp} is non-@code{nil}, it means the
function is operating on a mail message and therefore should not fill
the header lines.  If @var{citation-regexp} is a string, it is used as
a regular expression; if it matches the beginning of a line, that line
is treated as a citation marker.

Ordinarily, @code{fill-individual-paragraphs} regards each change in
indentation as starting a new paragraph.  If
@code{fill-individual-varying-indent} is non-@code{nil}, then only
separator lines separate paragraphs.  That mode can handle indented
paragraphs with additional indentation on the first line.
@end deffn

@defopt fill-individual-varying-indent
This variable alters the action of @code{fill-individual-paragraphs} as
described above.
@end defopt

@deffn Command fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
This command considers a region of text as a single paragraph and fills
it.  If the region was made up of many paragraphs, the blank lines
between paragraphs are removed.  This function justifies as well as
filling when @var{justify} is non-@code{nil}.

If @var{nosqueeze} is non-@code{nil}, that means to leave whitespace
other than line breaks untouched.  If @var{squeeze-after} is
non-@code{nil}, it specifies a position in the region, and means don't
canonicalize spaces before that position.

In Adaptive Fill mode, this command calls @code{fill-context-prefix} to
choose a fill prefix by default.  @xref{Adaptive Fill}.
@end deffn

@deffn Command justify-current-line &optional how eop nosqueeze
This command inserts spaces between the words of the current line so
that the line ends exactly at @code{fill-column}.  It returns
@code{nil}.

The argument @var{how}, if non-@code{nil} specifies explicitly the style
of justification.  It can be @code{left}, @code{right}, @code{full},
@code{center}, or @code{none}.  If it is @code{t}, that means to do
follow specified justification style (see @code{current-justification},
below).  @code{nil} means to do full justification.

If @var{eop} is non-@code{nil}, that means do only left-justification
if @code{current-justification} specifies full justification.  This is
used for the last line of a paragraph; even if the paragraph as a
whole is fully justified, the last line should not be.

If @var{nosqueeze} is non-@code{nil}, that means do not change interior
whitespace.
@end deffn

@defopt default-justification
This variable's value specifies the style of justification to use for
text that doesn't specify a style with a text property.  The possible
values are @code{left}, @code{right}, @code{full}, @code{center}, or
@code{none}.  The default value is @code{left}.
@end defopt

@defun current-justification
This function returns the proper justification style to use for filling
the text around point.

This returns the value of the @code{justification} text property at
point, or the variable @var{default-justification} if there is no such
text property.  However, it returns @code{nil} rather than @code{none}
to mean ``don't justify''.
@end defun

@defopt sentence-end-double-space
@anchor{Definition of sentence-end-double-space}
If this variable is non-@code{nil}, a period followed by just one space
does not count as the end of a sentence, and the filling functions
avoid breaking the line at such a place.
@end defopt

@defopt sentence-end-without-period
If this variable is non-@code{nil}, a sentence can end without a
period.  This is used for languages like Thai, where sentences end
with a double space but without a period.
@end defopt

@defopt sentence-end-without-space
If this variable is non-@code{nil}, it should be a string of
characters that can end a sentence without following spaces.
@end defopt

@defvar fill-paragraph-function
This variable provides a way to override the filling of paragraphs.
If its value is non-@code{nil}, @code{fill-paragraph} calls this
function to do the work.  If the function returns a non-@code{nil}
value, @code{fill-paragraph} assumes the job is done, and immediately
returns that value.

The usual use of this feature is to fill comments in programming
language modes.  If the function needs to fill a paragraph in the usual
way, it can do so as follows:

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar fill-forward-paragraph-function
This variable provides a way to override how the filling functions,
such as @code{fill-region} and @code{fill-paragraph}, move forward to
the next paragraph.  Its value should be a function, which is called
with a single argument @var{n}, the number of paragraphs to move, and
should return the difference between @var{n} and the number of
paragraphs actually moved.  The default value of this variable is
@code{forward-paragraph}.  @xref{Paragraphs,,, emacs, The GNU Emacs
Manual}.
@end defvar

@defvar use-hard-newlines
If this variable is non-@code{nil}, the filling functions do not delete
newlines that have the @code{hard} text property.  These ``hard
newlines'' act as paragraph separators.
@end defvar

@node Margins
@section Margins for Filling

@defopt fill-prefix
This buffer-local variable, if non-@code{nil}, specifies a string of
text that appears at the beginning of normal text lines and should be
disregarded when filling them.  Any line that fails to start with the
fill prefix is considered the start of a paragraph; so is any line
that starts with the fill prefix followed by additional whitespace.
Lines that start with the fill prefix but no additional whitespace are
ordinary text lines that can be filled together.  The resulting filled
lines also start with the fill prefix.

The fill prefix follows the left margin whitespace, if any.
@end defopt

@defopt fill-column
This buffer-local variable specifies the maximum width of filled lines.
Its value should be an integer, which is a number of columns.  All the
filling, justification, and centering commands are affected by this
variable, including Auto Fill mode (@pxref{Auto Filling}).

As a practical matter, if you are writing text for other people to
read, you should set @code{fill-column} to no more than 70.  Otherwise
the line will be too long for people to read comfortably, and this can
make the text seem clumsy.

The default value for @code{fill-column} is 70.
@end defopt

@deffn Command set-left-margin from to margin
This sets the @code{left-margin} property on the text from @var{from} to
@var{to} to the value @var{margin}.  If Auto Fill mode is enabled, this
command also refills the region to fit the new margin.
@end deffn

@deffn Command set-right-margin from to margin
This sets the @code{right-margin} property on the text from @var{from}
to @var{to} to the value @var{margin}.  If Auto Fill mode is enabled,
this command also refills the region to fit the new margin.
@end deffn

@defun current-left-margin
This function returns the proper left margin value to use for filling
the text around point.  The value is the sum of the @code{left-margin}
property of the character at the start of the current line (or zero if
none), and the value of the variable @code{left-margin}.
@end defun

@defun current-fill-column
This function returns the proper fill column value to use for filling
the text around point.  The value is the value of the @code{fill-column}
variable, minus the value of the @code{right-margin} property of the
character after point.
@end defun

@deffn Command move-to-left-margin &optional n force
This function moves point to the left margin of the current line.  The
column moved to is determined by calling the function
@code{current-left-margin}.  If the argument @var{n} is non-@code{nil},
@code{move-to-left-margin} moves forward @var{n}@minus{}1 lines first.

If @var{force} is non-@code{nil}, that says to fix the line's
indentation if that doesn't match the left margin value.
@end deffn

@defun delete-to-left-margin &optional from to
This function removes left margin indentation from the text between
@var{from} and @var{to}.  The amount of indentation to delete is
determined by calling @code{current-left-margin}.  In no case does this
function delete non-whitespace.  If @var{from} and @var{to} are omitted,
they default to the whole buffer.
@end defun

@defun indent-to-left-margin
This function adjusts the indentation at the beginning of the current
line to the value specified by the variable @code{left-margin}.  (That
may involve either inserting or deleting whitespace.)  This function
is value of @code{indent-line-function} in Paragraph-Indent Text mode.
@end defun

@defopt left-margin
This variable specifies the base left margin column.  In Fundamental
mode, @kbd{C-j} indents to this column.  This variable automatically
becomes buffer-local when set in any fashion.
@end defopt

@defopt fill-nobreak-predicate
This variable gives major modes a way to specify not to break a line
at certain places.  Its value should be a list of functions.  Whenever
filling considers breaking the line at a certain place in the buffer,
it calls each of these functions with no arguments and with point
located at that place.  If any of the functions returns
non-@code{nil}, then the line won't be broken there.
@end defopt

@node Adaptive Fill
@section Adaptive Fill Mode
@c @cindex Adaptive Fill mode  "adaptive-fill-mode" is adjacent.

  When @dfn{Adaptive Fill Mode} is enabled, Emacs determines the fill
prefix automatically from the text in each paragraph being filled
rather than using a predetermined value.  During filling, this fill
prefix gets inserted at the start of the second and subsequent lines
of the paragraph as described in @ref{Filling}, and in @ref{Auto
Filling}.

@defopt adaptive-fill-mode
Adaptive Fill mode is enabled when this variable is non-@code{nil}.
It is @code{t} by default.
@end defopt

@defun fill-context-prefix from to
This function implements the heart of Adaptive Fill mode; it chooses a
fill prefix based on the text between @var{from} and @var{to},
typically the start and end of a paragraph.  It does this by looking
at the first two lines of the paragraph, based on the variables
described below.
@c The optional argument first-line-regexp is not documented
@c because it exists for internal purposes and might be eliminated
@c in the future.

Usually, this function returns the fill prefix, a string.  However,
before doing this, the function makes a final check (not specially
mentioned in the following) that a line starting with this prefix
wouldn't look like the start of a paragraph.  Should this happen, the
function signals the anomaly by returning @code{nil} instead.

In detail, @code{fill-context-prefix} does this:

@enumerate
@item
It takes a candidate for the fill prefix from the first line---it
tries first the function in @code{adaptive-fill-function} (if any),
then the regular expression @code{adaptive-fill-regexp} (see below).
The first non-@code{nil} result of these, or the empty string if
they're both @code{nil}, becomes the first line's candidate.
@item
If the paragraph has as yet only one line, the function tests the
validity of the prefix candidate just found.  The function then
returns the candidate if it's valid, or a string of spaces otherwise.
(see the description of @code{adaptive-fill-first-line-regexp} below).
@item
When the paragraph already has two lines, the function next looks for
a prefix candidate on the second line, in just the same way it did for
the first line.  If it doesn't find one, it returns @code{nil}.
@item
The function now compares the two candidate prefixes heuristically: if
the non-whitespace characters in the line 2 candidate occur in the
same order in the line 1 candidate, the function returns the line 2
candidate.  Otherwise, it returns the largest initial substring which
is common to both candidates (which might be the empty string).
@end enumerate
@end defun

@defopt adaptive-fill-regexp
Adaptive Fill mode matches this regular expression against the text
starting after the left margin whitespace (if any) on a line; the
characters it matches are that line's candidate for the fill prefix.

The default value matches whitespace with certain punctuation
characters intermingled.
@end defopt

@defopt adaptive-fill-first-line-regexp
Used only in one-line paragraphs, this regular expression acts as an
additional check of the validity of the one available candidate fill
prefix: the candidate must match this regular expression, or match
@code{comment-start-skip}.  If it doesn't, @code{fill-context-prefix}
replaces the candidate with a string of spaces ``of the same width''
as it.

The default value of this variable is @w{@code{"\\`[ \t]*\\'"}}, which
matches only a string of whitespace.  The effect of this default is to
force the fill prefixes found in one-line paragraphs always to be pure
whitespace.
@end defopt

@defopt adaptive-fill-function
You can specify more complex ways of choosing a fill prefix
automatically by setting this variable to a function.  The function is
called with point after the left margin (if any) of a line, and it
must preserve point.  It should return either ``that line's'' fill
prefix or @code{nil}, meaning it has failed to determine a prefix.
@end defopt

@node Auto Filling
@comment  node-name,  next,  previous,  up
@section Auto Filling
@cindex filling, automatic
@cindex Auto Fill mode

  Auto Fill mode is a minor mode that fills lines automatically as text
is inserted.  This section describes the hook used by Auto Fill mode.
For a description of functions that you can call explicitly to fill and
justify existing text, see @ref{Filling}.

  Auto Fill mode also enables the functions that change the margins and
justification style to refill portions of the text.  @xref{Margins}.

@defvar auto-fill-function
The value of this buffer-local variable should be a function (of no
arguments) to be called after self-inserting a character from the table
@code{auto-fill-chars}.  It may be @code{nil}, in which case nothing
special is done in that case.

The value of @code{auto-fill-function} is @code{do-auto-fill} when
Auto-Fill mode is enabled.  That is a function whose sole purpose is to
implement the usual strategy for breaking a line.
@end defvar

@defvar normal-auto-fill-function
This variable specifies the function to use for
@code{auto-fill-function}, if and when Auto Fill is turned on.  Major
modes can set buffer-local values for this variable to alter how Auto
Fill works.
@end defvar

@defvar auto-fill-chars
A char table of characters which invoke @code{auto-fill-function} when
self-inserted---space and newline in most language environments.  They
have an entry @code{t} in the table.
@end defvar

@node Sorting
@section Sorting Text
@cindex sorting text

  The sorting functions described in this section all rearrange text in
a buffer.  This is in contrast to the function @code{sort}, which
rearranges the order of the elements of a list (@pxref{Rearrangement}).
The values returned by these functions are not meaningful.

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun predicate
This function is the general text-sorting routine that subdivides a
buffer into records and then sorts them.  Most of the commands in this
section use this function.

To understand how @code{sort-subr} works, consider the whole accessible
portion of the buffer as being divided into disjoint pieces called
@dfn{sort records}.  The records may or may not be contiguous, but they
must not overlap.  A portion of each sort record (perhaps all of it) is
designated as the sort key.  Sorting rearranges the records in order by
their sort keys.

Usually, the records are rearranged in order of ascending sort key.
If the first argument to the @code{sort-subr} function, @var{reverse},
is non-@code{nil}, the sort records are rearranged in order of
descending sort key.

The next four arguments to @code{sort-subr} are functions that are
called to move point across a sort record.  They are called many times
from within @code{sort-subr}.

@enumerate
@item
@var{nextrecfun} is called with point at the end of a record.  This
function moves point to the start of the next record.  The first record
is assumed to start at the position of point when @code{sort-subr} is
called.  Therefore, you should usually move point to the beginning of
the buffer before calling @code{sort-subr}.

This function can indicate there are no more sort records by leaving
point at the end of the buffer.

@item
@var{endrecfun} is called with point within a record.  It moves point to
the end of the record.

@item
@var{startkeyfun} is called to move point from the start of a record to
the start of the sort key.  This argument is optional; if it is omitted,
the whole record is the sort key.  If supplied, the function should
either return a non-@code{nil} value to be used as the sort key, or
return @code{nil} to indicate that the sort key is in the buffer
starting at point.  In the latter case, @var{endkeyfun} is called to
find the end of the sort key.

@item
@var{endkeyfun} is called to move point from the start of the sort key
to the end of the sort key.  This argument is optional.  If
@var{startkeyfun} returns @code{nil} and this argument is omitted (or
@code{nil}), then the sort key extends to the end of the record.  There
is no need for @var{endkeyfun} if @var{startkeyfun} returns a
non-@code{nil} value.
@end enumerate

The argument @var{predicate} is the function to use to compare keys.
If keys are numbers, it defaults to @code{<}; otherwise it defaults to
@code{string<}.

As an example of @code{sort-subr}, here is the complete function
definition for @code{sort-lines}:

@example
@group
;; @r{Note that the first two lines of doc string}
;; @r{are effectively one line when viewed by a user.}
(defun sort-lines (reverse beg end)
  "Sort lines in region alphabetically;\
 argument means descending order.
Called from a program, there are three arguments:
@end group
@group
REVERSE (non-nil means reverse order),\
 BEG and END (region to sort).
The variable `sort-fold-case' determines\
 whether alphabetic case affects
the sort order."
@end group
@group
  (interactive "P\nr")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (let ((inhibit-field-text-motion t))
        (sort-subr reverse 'forward-line 'end-of-line)))))
@end group
@end example

Here @code{forward-line} moves point to the start of the next record,
and @code{end-of-line} moves point to the end of record.  We do not pass
the arguments @var{startkeyfun} and @var{endkeyfun}, because the entire
record is used as the sort key.

The @code{sort-paragraphs} function is very much the same, except that
its @code{sort-subr} call looks like this:

@example
@group
(sort-subr reverse
           (function
             (lambda ()
               (while (and (not (eobp))
                      (looking-at paragraph-separate))
                 (forward-line 1))))
           'forward-paragraph)
@end group
@end example

Markers pointing into any sort records are left with no useful
position after @code{sort-subr} returns.
@end defun

@defopt sort-fold-case
If this variable is non-@code{nil}, @code{sort-subr} and the other
buffer sorting functions ignore case when comparing strings.
@end defopt

@deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
This command sorts the region between @var{start} and @var{end}
alphabetically as specified by @var{record-regexp} and @var{key-regexp}.
If @var{reverse} is a negative integer, then sorting is in reverse
order.

Alphabetical sorting means that two sort keys are compared by
comparing the first characters of each, the second characters of each,
and so on.  If a mismatch is found, it means that the sort keys are
unequal; the sort key whose character is less at the point of first
mismatch is the lesser sort key.  The individual characters are compared
according to their numerical character codes in the Emacs character set.

The value of the @var{record-regexp} argument specifies how to divide
the buffer into sort records.  At the end of each record, a search is
done for this regular expression, and the text that matches it is taken
as the next record.  For example, the regular expression @samp{^.+$},
which matches lines with at least one character besides a newline, would
make each such line into a sort record.  @xref{Regular Expressions}, for
a description of the syntax and meaning of regular expressions.

The value of the @var{key-regexp} argument specifies what part of each
record is the sort key.  The @var{key-regexp} could match the whole
record, or only a part.  In the latter case, the rest of the record has
no effect on the sorted order of records, but it is carried along when
the record moves to its new position.

The @var{key-regexp} argument can refer to the text matched by a
subexpression of @var{record-regexp}, or it can be a regular expression
on its own.

If @var{key-regexp} is:

@table @asis
@item @samp{\@var{digit}}
then the text matched by the @var{digit}th @samp{\(...\)} parenthesis
grouping in @var{record-regexp} is the sort key.

@item @samp{\&}
then the whole record is the sort key.

@item a regular expression
then @code{sort-regexp-fields} searches for a match for the regular
expression within the record.  If such a match is found, it is the sort
key.  If there is no match for @var{key-regexp} within a record then
that record is ignored, which means its position in the buffer is not
changed.  (The other records may move around it.)
@end table

For example, if you plan to sort all the lines in the region by the
first word on each line starting with the letter @samp{f}, you should
set @var{record-regexp} to @samp{^.*$} and set @var{key-regexp} to
@samp{\<f\w*\>}.  The resulting expression looks like this:

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

If you call @code{sort-regexp-fields} interactively, it prompts for
@var{record-regexp} and @var{key-regexp} in the minibuffer.
@end deffn

@deffn Command sort-lines reverse start end
This command alphabetically sorts lines in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-paragraphs reverse start end
This command alphabetically sorts paragraphs in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-pages reverse start end
This command alphabetically sorts pages in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-fields field start end
This command sorts lines in the region between @var{start} and
@var{end}, comparing them alphabetically by the @var{field}th field
of each line.  Fields are separated by whitespace and numbered starting
from 1.  If @var{field} is negative, sorting is by the
@w{@minus{}@var{field}th} field from the end of the line.  This command
is useful for sorting tables.
@end deffn

@deffn Command sort-numeric-fields field start end
This command sorts lines in the region between @var{start} and
@var{end}, comparing them numerically by the @var{field}th field of
each line.  Fields are separated by whitespace and numbered starting
from 1.  The specified field must contain a number in each line of the
region.  Numbers starting with 0 are treated as octal, and numbers
starting with @samp{0x} are treated as hexadecimal.

If @var{field} is negative, sorting is by the
@w{@minus{}@var{field}th} field from the end of the line.  This
command is useful for sorting tables.
@end deffn

@defopt sort-numeric-base
This variable specifies the default radix for
@code{sort-numeric-fields} to parse numbers.
@end defopt

@deffn Command sort-columns reverse &optional beg end
This command sorts the lines in the region between @var{beg} and
@var{end}, comparing them alphabetically by a certain range of
columns.  The column positions of @var{beg} and @var{end} bound the
range of columns to sort on.

If @var{reverse} is non-@code{nil}, the sort is in reverse order.

One unusual thing about this command is that the entire line
containing position @var{beg}, and the entire line containing position
@var{end}, are included in the region sorted.

Note that @code{sort-columns} rejects text that contains tabs, because
tabs could be split across the specified columns.  Use @kbd{M-x
untabify} to convert tabs to spaces before sorting.

When possible, this command actually works by calling the @code{sort}
utility program.
@end deffn

@node Columns
@comment  node-name,  next,  previous,  up
@section Counting Columns
@cindex columns
@cindex counting columns
@cindex horizontal position

  The column functions convert between a character position (counting
characters from the beginning of the buffer) and a column position
(counting screen characters from the beginning of a line).

  These functions count each character according to the number of
columns it occupies on the screen.  This means control characters count
as occupying 2 or 4 columns, depending upon the value of
@code{ctl-arrow}, and tabs count as occupying a number of columns that
depends on the value of @code{tab-width} and on the column where the tab
begins.  @xref{Usual Display}.

  Column number computations ignore the width of the window and the
amount of horizontal scrolling.  Consequently, a column value can be
arbitrarily high.  The first (or leftmost) column is numbered 0.  They
also ignore overlays and text properties, aside from invisibility.

@defun current-column
This function returns the horizontal position of point, measured in
columns, counting from 0 at the left margin.  The column position is the
sum of the widths of all the displayed representations of the characters
between the start of the current line and point.

For an example of using @code{current-column}, see the description of
@code{count-lines} in @ref{Text Lines}.
@end defun

@deffn Command move-to-column column &optional force
This function moves point to @var{column} in the current line.  The
calculation of @var{column} takes into account the widths of the
displayed representations of the characters between the start of the
line and point.

When called interactively, @var{column} is the value of prefix numeric
argument.  If @var{column} is not an integer, an error is signaled.

If column @var{column} is beyond the end of the line, point moves to
the end of the line.  If @var{column} is negative, point moves to the
beginning of the line.

If it is impossible to move to column @var{column} because that is in
the middle of a multicolumn character such as a tab, point moves to the
end of that character.  However, if @var{force} is non-@code{nil}, and
@var{column} is in the middle of a tab, then @code{move-to-column}
converts the tab into spaces so that it can move precisely to column
@var{column}.  Other multicolumn characters can cause anomalies despite
@var{force}, since there is no way to split them.

The argument @var{force} also has an effect if the line isn't long
enough to reach column @var{column}; if it is @code{t}, that means to
add whitespace at the end of the line to reach that column.

The return value is the column number actually moved to.
@end deffn

@node Indentation
@section Indentation
@cindex indentation

  The indentation functions are used to examine, move to, and change
whitespace that is at the beginning of a line.  Some of the functions
can also change whitespace elsewhere on a line.  Columns and indentation
count from zero at the left margin.

@menu
* Primitive Indent::      Functions used to count and insert indentation.
* Mode-Specific Indent::  Customize indentation for different modes.
* Region Indent::         Indent all the lines in a region.
* Relative Indent::       Indent the current line based on previous lines.
* Indent Tabs::           Adjustable, typewriter-like tab stops.
* Motion by Indent::      Move to first non-blank character.
@end menu

@node Primitive Indent
@subsection Indentation Primitives

  This section describes the primitive functions used to count and
insert indentation.  The functions in the following sections use these
primitives.  @xref{Width}, for related functions.

@defun current-indentation
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
This function returns the indentation of the current line, which is
the horizontal position of the first nonblank character.  If the
contents are entirely blank, then this is the horizontal position of the
end of the line.
@end defun

@deffn Command indent-to column &optional minimum
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
This function indents from point with tabs and spaces until @var{column}
is reached.  If @var{minimum} is specified and non-@code{nil}, then at
least that many spaces are inserted even if this requires going beyond
@var{column}.  Otherwise the function does nothing if point is already
beyond @var{column}.  The value is the column at which the inserted
indentation ends.

The inserted whitespace characters inherit text properties from the
surrounding text (usually, from the preceding text only).  @xref{Sticky
Properties}.
@end deffn

@defopt indent-tabs-mode
@comment !!SourceFile indent.c
If this variable is non-@code{nil}, indentation functions can insert
tabs as well as spaces.  Otherwise, they insert only spaces.  Setting
this variable automatically makes it buffer-local in the current buffer.
@end defopt

@node Mode-Specific Indent
@subsection Indentation Controlled by Major Mode

  An important function of each major mode is to customize the @key{TAB}
key to indent properly for the language being edited.  This section
describes the mechanism of the @key{TAB} key and how to control it.
The functions in this section return unpredictable values.

@deffn Command indent-for-tab-command &optional rigid
This is the command bound to @key{TAB} in most editing modes.  Its
usual action is to indent the current line, but it can alternatively
insert a tab character or indent a region.

Here is what it does:

@itemize
@item
First, it checks whether Transient Mark mode is enabled and the region
is active.  If so, it called @code{indent-region} to indent all the
text in the region (@pxref{Region Indent}).

@item
Otherwise, if the indentation function in @code{indent-line-function}
is @code{indent-to-left-margin} (a trivial command that inserts a tab
character), or if the variable @code{tab-always-indent} specifies that
a tab character ought to be inserted (see below), then it inserts a
tab character.

@item
Otherwise, it indents the current line; this is done by calling the
function in @code{indent-line-function}.  If the line is already
indented, and the value of @code{tab-always-indent} is @code{complete}
(see below), it tries completing the text at point.
@end itemize

If @var{rigid} is non-@code{nil} (interactively, with a prefix
argument), then after this command indents a line or inserts a tab, it
also rigidly indents the entire balanced expression which starts at
the beginning of the current line, in order to reflect the new
indentation.  This argument is ignored if the command indents the
region.
@end deffn

@defvar indent-line-function
This variable's value is the function to be used by
@code{indent-for-tab-command}, and various other indentation commands,
to indent the current line.  It is usually assigned by the major mode;
for instance, Lisp mode sets it to @code{lisp-indent-line}, C mode
sets it to @code{c-indent-line}, and so on.  The default value is
@code{indent-relative}.  @xref{Auto-Indentation}.
@end defvar

@deffn Command indent-according-to-mode
This command calls the function in @code{indent-line-function} to
indent the current line in a way appropriate for the current major mode.
@end deffn

@deffn Command newline-and-indent
This function inserts a newline, then indents the new line (the one
following the newline just inserted) according to the major mode.  It
does indentation by calling @code{indent-according-to-mode}.
@end deffn

@deffn Command reindent-then-newline-and-indent
This command reindents the current line, inserts a newline at point,
and then indents the new line (the one following the newline just
inserted).  It does indentation on both lines by calling
@code{indent-according-to-mode}.
@end deffn

@defopt tab-always-indent
This variable can be used to customize the behavior of the @key{TAB}
(@code{indent-for-tab-command}) command.  If the value is @code{t}
(the default), the command normally just indents the current line.  If
the value is @code{nil}, the command indents the current line only if
point is at the left margin or in the line's indentation; otherwise,
it inserts a tab character.  If the value is @code{complete}, the
command first tries to indent the current line, and if the line was
already indented, it calls @code{completion-at-point} to complete the
text at point (@pxref{Completion in Buffers}).
@end defopt

@node Region Indent
@subsection Indenting an Entire Region

  This section describes commands that indent all the lines in the
region.  They return unpredictable values.

@deffn Command indent-region start end &optional to-column
This command indents each nonblank line starting between @var{start}
(inclusive) and @var{end} (exclusive).  If @var{to-column} is
@code{nil}, @code{indent-region} indents each nonblank line by calling
the current mode's indentation function, the value of
@code{indent-line-function}.

If @var{to-column} is non-@code{nil}, it should be an integer
specifying the number of columns of indentation; then this function
gives each line exactly that much indentation, by either adding or
deleting whitespace.

If there is a fill prefix, @code{indent-region} indents each line
by making it start with the fill prefix.
@end deffn

@defvar indent-region-function
The value of this variable is a function that can be used by
@code{indent-region} as a short cut.  It should take two arguments, the
start and end of the region.  You should design the function so
that it will produce the same results as indenting the lines of the
region one by one, but presumably faster.

If the value is @code{nil}, there is no short cut, and
@code{indent-region} actually works line by line.

A short-cut function is useful in modes such as C mode and Lisp mode,
where the @code{indent-line-function} must scan from the beginning of
the function definition: applying it to each line would be quadratic in
time.  The short cut can update the scan information as it moves through
the lines indenting them; this takes linear time.  In a mode where
indenting a line individually is fast, there is no need for a short cut.

@code{indent-region} with a non-@code{nil} argument @var{to-column} has
a different meaning and does not use this variable.
@end defvar

@deffn Command indent-rigidly start end count
This command indents all lines starting between @var{start}
(inclusive) and @var{end} (exclusive) sideways by @var{count} columns.
This ``preserves the shape'' of the affected region, moving it as a
rigid unit.  Consequently, this command is useful not only for indenting
regions of unindented text, but also for indenting regions of formatted
code.

For example, if @var{count} is 3, this command adds 3 columns of
indentation to each of the lines beginning in the region specified.

In Mail mode, @kbd{C-c C-y} (@code{mail-yank-original}) uses
@code{indent-rigidly} to indent the text copied from the message being
replied to.
@end deffn

@deffn Command indent-code-rigidly start end columns &optional nochange-regexp
This is like @code{indent-rigidly}, except that it doesn't alter lines
that start within strings or comments.

In addition, it doesn't alter a line if @var{nochange-regexp} matches at
the beginning of the line (if @var{nochange-regexp} is non-@code{nil}).
@end deffn

@node Relative Indent
@subsection Indentation Relative to Previous Lines

  This section describes two commands that indent the current line
based on the contents of previous lines.

@deffn Command indent-relative &optional unindented-ok
This command inserts whitespace at point, extending to the same
column as the next @dfn{indent point} of the previous nonblank line.  An
indent point is a non-whitespace character following whitespace.  The
next indent point is the first one at a column greater than the current
column of point.  For example, if point is underneath and to the left of
the first non-blank character of a line of text, it moves to that column
by inserting whitespace.

If the previous nonblank line has no next indent point (i.e., none at a
great enough column position), @code{indent-relative} either does
nothing (if @var{unindented-ok} is non-@code{nil}) or calls
@code{tab-to-tab-stop}.  Thus, if point is underneath and to the right
of the last column of a short line of text, this command ordinarily
moves point to the next tab stop by inserting whitespace.

The return value of @code{indent-relative} is unpredictable.

In the following example, point is at the beginning of the second
line:

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

  In this next example, point is between the @samp{m} and @samp{p} of
@samp{jumped}:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@deffn Command indent-relative-maybe
@comment !!SourceFile indent.el
This command indents the current line like the previous nonblank line,
by calling @code{indent-relative} with @code{t} as the
@var{unindented-ok} argument.  The return value is unpredictable.

If the previous nonblank line has no indent points beyond the current
column, this command does nothing.
@end deffn

@node Indent Tabs
@comment  node-name,  next,  previous,  up
@subsection Adjustable ``Tab Stops''
@cindex tabs stops for indentation

  This section explains the mechanism for user-specified ``tab stops''
and the mechanisms that use and set them.  The name ``tab stops'' is
used because the feature is similar to that of the tab stops on a
typewriter.  The feature works by inserting an appropriate number of
spaces and tab characters to reach the next tab stop column; it does not
affect the display of tab characters in the buffer (@pxref{Usual
Display}).  Note that the @key{TAB} character as input uses this tab
stop feature only in a few major modes, such as Text mode.
@xref{Tab Stops,,, emacs, The GNU Emacs Manual}.

@deffn Command tab-to-tab-stop
This command inserts spaces or tabs before point, up to the next tab
stop column defined by @code{tab-stop-list}.  It searches the list for
an element greater than the current column number, and uses that element
as the column to indent to.  It does nothing if no such element is
found.
@end deffn

@defopt tab-stop-list
This variable is the list of tab stop columns used by
@code{tab-to-tab-stops}.  The elements should be integers in increasing
order.  The tab stop columns need not be evenly spaced.

Use @kbd{M-x edit-tab-stops} to edit the location of tab stops
interactively.
@end defopt

@node Motion by Indent
@subsection Indentation-Based Motion Commands

  These commands, primarily for interactive use, act based on the
indentation in the text.

@deffn Command back-to-indentation
@comment !!SourceFile simple.el
This command moves point to the first non-whitespace character in the
current line (which is the line in which point is located).  It returns
@code{nil}.
@end deffn

@deffn Command backward-to-indentation &optional arg
@comment !!SourceFile simple.el
This command moves point backward @var{arg} lines and then to the
first nonblank character on that line.  It returns @code{nil}.
If @var{arg} is omitted or @code{nil}, it defaults to 1.
@end deffn

@deffn Command forward-to-indentation &optional arg
@comment !!SourceFile simple.el
This command moves point forward @var{arg} lines and then to the first
nonblank character on that line.  It returns @code{nil}.
If @var{arg} is omitted or @code{nil}, it defaults to 1.
@end deffn

@node Case Changes
@comment  node-name,  next,  previous,  up
@section Case Changes
@cindex case conversion in buffers

  The case change commands described here work on text in the current
buffer.  @xref{Case Conversion}, for case conversion functions that work
on strings and characters.  @xref{Case Tables}, for how to customize
which characters are upper or lower case and how to convert them.

@deffn Command capitalize-region start end
This function capitalizes all words in the region defined by
@var{start} and @var{end}.  To capitalize means to convert each word's
first character to upper case and convert the rest of each word to lower
case.  The function returns @code{nil}.

If one end of the region is in the middle of a word, the part of the
word within the region is treated as an entire word.

When @code{capitalize-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 44)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command downcase-region start end
This function converts all of the letters in the region defined by
@var{start} and @var{end} to lower case.  The function returns
@code{nil}.

When @code{downcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command upcase-region start end
This function converts all of the letters in the region defined by
@var{start} and @var{end} to upper case.  The function returns
@code{nil}.

When @code{upcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command capitalize-word count
This function capitalizes @var{count} words after point, moving point
over as it does.  To capitalize means to convert each word's first
character to upper case and convert the rest of each word to lower case.
If @var{count} is negative, the function capitalizes the
@minus{}@var{count} previous words but does not move point.  The value
is @code{nil}.

If point is in the middle of a word, the part of the word before point
is ignored when moving forward.  The rest is treated as an entire word.

When @code{capitalize-word} is called interactively, @var{count} is
set to the numeric prefix argument.
@end deffn

@deffn Command downcase-word count
This function converts the @var{count} words after point to all lower
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{downcase-word} is called interactively, @var{count} is set
to the numeric prefix argument.
@end deffn

@deffn Command upcase-word count
This function converts the @var{count} words after point to all upper
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{upcase-word} is called interactively, @var{count} is set to
the numeric prefix argument.
@end deffn

@node Text Properties
@section Text Properties
@cindex text properties
@cindex attributes of text
@cindex properties of text

  Each character position in a buffer or a string can have a @dfn{text
property list}, much like the property list of a symbol (@pxref{Property
Lists}).  The properties belong to a particular character at a
particular place, such as, the letter @samp{T} at the beginning of this
sentence or the first @samp{o} in @samp{foo}---if the same character
occurs in two different places, the two occurrences in general have
different properties.

  Each property has a name and a value.  Both of these can be any Lisp
object, but the name is normally a symbol.  Typically each property
name symbol is used for a particular purpose; for instance, the text
property @code{face} specifies the faces for displaying the character
(@pxref{Special Properties}).  The usual way to access the property
list is to specify a name and ask what value corresponds to it.

  If a character has a @code{category} property, we call it the
@dfn{property category} of the character.  It should be a symbol.  The
properties of the symbol serve as defaults for the properties of the
character.

  Copying text between strings and buffers preserves the properties
along with the characters; this includes such diverse functions as
@code{substring}, @code{insert}, and @code{buffer-substring}.

@menu
* Examining Properties::   Looking at the properties of one character.
* Changing Properties::    Setting the properties of a range of text.
* Property Search::        Searching for where a property changes value.
* Special Properties::     Particular properties with special meanings.
* Format Properties::      Properties for representing formatting of text.
* Sticky Properties::      How inserted text gets properties from
                             neighboring text.
* Lazy Properties::        Computing text properties in a lazy fashion
                             only when text is examined.
* Clickable Text::         Using text properties to make regions of text
                             do something when you click on them.
* Fields::                 The @code{field} property defines
                             fields within the buffer.
* Not Intervals::          Why text properties do not use
                             Lisp-visible text intervals.
@end menu

@node Examining Properties
@subsection Examining Text Properties

  The simplest way to examine text properties is to ask for the value of
a particular property of a particular character.  For that, use
@code{get-text-property}.  Use @code{text-properties-at} to get the
entire property list of a character.  @xref{Property Search}, for
functions to examine the properties of a number of characters at once.

  These functions handle both strings and buffers.  Keep in mind that
positions in a string start from 0, whereas positions in a buffer start
from 1.

@defun get-text-property pos prop &optional object
This function returns the value of the @var{prop} property of the
character after position @var{pos} in @var{object} (a buffer or
string).  The argument @var{object} is optional and defaults to the
current buffer.

If there is no @var{prop} property strictly speaking, but the character
has a property category that is a symbol, then @code{get-text-property} returns
the @var{prop} property of that symbol.
@end defun

@defun get-char-property position prop &optional object
This function is like @code{get-text-property}, except that it checks
overlays first and then text properties.  @xref{Overlays}.

The argument @var{object} may be a string, a buffer, or a window.  If
it is a window, then the buffer displayed in that window is used for
text properties and overlays, but only the overlays active for that
window are considered.  If @var{object} is a buffer, then overlays in
that buffer are considered first, in order of decreasing priority,
followed by the text properties.  If @var{object} is a string, only
text properties are considered, since strings never have overlays.
@end defun

@defun get-char-property-and-overlay position prop &optional object
This is like @code{get-char-property}, but gives extra information
about the overlay that the property value comes from.

Its value is a cons cell whose @sc{car} is the property value, the
same value @code{get-char-property} would return with the same
arguments.  Its @sc{cdr} is the overlay in which the property was
found, or @code{nil}, if it was found as a text property or not found
at all.

If @var{position} is at the end of @var{object}, both the @sc{car} and
the @sc{cdr} of the value are @code{nil}.
@end defun

@defvar char-property-alias-alist
This variable holds an alist which maps property names to a list of
alternative property names.  If a character does not specify a direct
value for a property, the alternative property names are consulted in
order; the first non-@code{nil} value is used.  This variable takes
precedence over @code{default-text-properties}, and @code{category}
properties take precedence over this variable.
@end defvar

@defun text-properties-at position &optional object
This function returns the entire property list of the character at
@var{position} in the string or buffer @var{object}.  If @var{object} is
@code{nil}, it defaults to the current buffer.
@end defun

@defvar default-text-properties
This variable holds a property list giving default values for text
properties.  Whenever a character does not specify a value for a
property, neither directly, through a category symbol, or through
@code{char-property-alias-alist}, the value stored in this list is
used instead.  Here is an example:

@example
(setq default-text-properties '(foo 69)
      char-property-alias-alist nil)
;; @r{Make sure character 1 has no properties of its own.}
(set-text-properties 1 2 nil)
;; @r{What we get, when we ask, is the default value.}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@subsection Changing Text Properties

  The primitives for changing properties apply to a specified range of
text in a buffer or string.  The function @code{set-text-properties}
(see end of section) sets the entire property list of the text in that
range; more often, it is useful to add, change, or delete just certain
properties specified by name.

  Since text properties are considered part of the contents of the
buffer (or string), and can affect how a buffer looks on the screen,
any change in buffer text properties marks the buffer as modified.
Buffer text property changes are undoable also (@pxref{Undo}).
Positions in a string start from 0, whereas positions in a buffer
start from 1.

@defun put-text-property start end prop value &optional object
This function sets the @var{prop} property to @var{value} for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.
@end defun

@defun add-text-properties start end props &optional object
This function adds or overrides text properties for the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to add.  It should
have the form of a property list (@pxref{Property Lists}): a list whose
elements include the property names followed alternately by the
corresponding values.

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
its values agree with those in the text).

For example, here is how to set the @code{comment} and @code{face}
properties of a range of text:

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
This function deletes specified text properties from the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to delete.  It
should have the form of a property list (@pxref{Property Lists}): a list
whose elements are property names alternating with corresponding values.
But only the names matter---the values that accompany them are ignored.
For example, here's how to remove the @code{face} property.

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
if no character in the specified text had any of those properties).

To remove all text properties from certain text, use
@code{set-text-properties} and specify @code{nil} for the new property
list.
@end defun

@defun remove-list-of-text-properties start end list-of-properties &optional object
Like @code{remove-text-properties} except that
@var{list-of-properties} is a list of property names only, not an
alternating list of property names and values.
@end defun

@defun set-text-properties start end props &optional object
This function completely replaces the text property list for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} is the new property list.  It should be a list
whose elements are property names alternating with corresponding values.

After @code{set-text-properties} returns, all the characters in the
specified range have identical properties.

If @var{props} is @code{nil}, the effect is to get rid of all properties
from the specified range of text.  Here's an example:

@example
(set-text-properties @var{start} @var{end} nil)
@end example

Do not rely on the return value of this function.
@end defun

  The easiest way to make a string with text properties
is with @code{propertize}:

@defun propertize string &rest properties
This function returns a copy of @var{string} which has the text
properties @var{properties}.  These properties apply to all the
characters in the string that is returned.  Here is an example that
constructs a string with a @code{face} property and a @code{mouse-face}
property:

@smallexample
(propertize "foo" 'face 'italic
            'mouse-face 'bold-italic)
     @result{} #("foo" 0 3 (mouse-face bold-italic face italic))
@end smallexample

To put different properties on various parts of a string, you can
construct each part with @code{propertize} and then combine them with
@code{concat}:

@smallexample
(concat
 (propertize "foo" 'face 'italic
             'mouse-face 'bold-italic)
 " and "
 (propertize "bar" 'face 'italic
             'mouse-face 'bold-italic))
     @result{} #("foo and bar"
                 0 3 (face italic mouse-face bold-italic)
                 3 8 nil
                 8 11 (face italic mouse-face bold-italic))
@end smallexample
@end defun

  @xref{Buffer Contents}, for the function
@code{buffer-substring-no-properties}, which copies text from the
buffer but does not copy its properties.

@node Property Search
@subsection Text Property Search Functions

  In typical use of text properties, most of the time several or many
consecutive characters have the same value for a property.  Rather than
writing your programs to examine characters one by one, it is much
faster to process chunks of text that have the same property value.

  Here are functions you can use to do this.  They use @code{eq} for
comparing property values.  In all cases, @var{object} defaults to the
current buffer.

  For good performance, it's very important to use the @var{limit}
argument to these functions, especially the ones that search for a
single property---otherwise, they may spend a long time scanning to the
end of the buffer, if the property you are interested in does not change.

  These functions do not move point; instead, they return a position (or
@code{nil}).  Remember that a position is always between two characters;
the position returned by these functions is between two characters with
different properties.

@defun next-property-change pos &optional object limit
The function scans the text forward from position @var{pos} in the
string or buffer @var{object} until it finds a change in some text
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond @var{pos} whose
properties are not identical to those of the character just after
@var{pos}.

If @var{limit} is non-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point, this
function returns @var{limit}.

The value is @code{nil} if the properties remain unchanged all the way
to the end of @var{object} and @var{limit} is @code{nil}.  If the value
is non-@code{nil}, it is a position greater than or equal to @var{pos}.
The value equals @var{pos} only when @var{limit} equals @var{pos}.

Here is an example of how to scan the buffer by chunks of text within
which all properties are constant:

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    @r{Process text from point to @var{next-change}@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun previous-property-change pos &optional object limit
This is like @code{next-property-change}, but scans back from @var{pos}
instead of forward.  If the value is non-@code{nil}, it is a position
less than or equal to @var{pos}; it equals @var{pos} only if @var{limit}
equals @var{pos}.
@end defun

@defun next-single-property-change pos prop &optional object limit
The function scans text for a change in the @var{prop} property, then
returns the position of the change.  The scan goes forward from
position @var{pos} in the string or buffer @var{object}.  In other
words, this function returns the position of the first character
beyond @var{pos} whose @var{prop} property differs from that of the
character just after @var{pos}.

If @var{limit} is non-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point,
@code{next-single-property-change} returns @var{limit}.

The value is @code{nil} if the property remains unchanged all the way to
the end of @var{object} and @var{limit} is @code{nil}.  If the value is
non-@code{nil}, it is a position greater than or equal to @var{pos}; it
equals @var{pos} only if @var{limit} equals @var{pos}.
@end defun

@defun previous-single-property-change pos prop &optional object limit
This is like @code{next-single-property-change}, but scans back from
@var{pos} instead of forward.  If the value is non-@code{nil}, it is a
position less than or equal to @var{pos}; it equals @var{pos} only if
@var{limit} equals @var{pos}.
@end defun

@defun next-char-property-change pos &optional limit
This is like @code{next-property-change} except that it considers
overlay properties as well as text properties, and if no change is
found before the end of the buffer, it returns the maximum buffer
position rather than @code{nil} (in this sense, it resembles the
corresponding overlay function @code{next-overlay-change}, rather than
@code{next-property-change}).  There is no @var{object} operand
because this function operates only on the current buffer.  It returns
the next address at which either kind of property changes.
@end defun

@defun previous-char-property-change pos &optional limit
This is like @code{next-char-property-change}, but scans back from
@var{pos} instead of forward, and returns the minimum buffer
position if no change is found.
@end defun

@defun next-single-char-property-change pos prop &optional object limit
This is like @code{next-single-property-change} except that it
considers overlay properties as well as text properties, and if no
change is found before the end of the @var{object}, it returns the
maximum valid position in @var{object} rather than @code{nil}.  Unlike
@code{next-char-property-change}, this function @emph{does} have an
@var{object} operand; if @var{object} is not a buffer, only
text-properties are considered.
@end defun

@defun previous-single-char-property-change pos prop &optional object limit
This is like @code{next-single-char-property-change}, but scans back
from @var{pos} instead of forward, and returns the minimum valid
position in @var{object} if no change is found.
@end defun

@defun text-property-any start end prop value &optional object
This function returns non-@code{nil} if at least one character between
@var{start} and @var{end} has a property @var{prop} whose value is
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@defun text-property-not-all start end prop value &optional object
This function returns non-@code{nil} if at least one character between
@var{start} and @var{end} does not have a property @var{prop} with value
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@node Special Properties
@subsection Properties with Special Meanings

  Here is a table of text property names that have special built-in
meanings.  The following sections list a few additional special property
names that control filling and property inheritance.  All other names
have no standard meaning, and you can use them as you like.

  Note: the properties @code{composition}, @code{display},
@code{invisible} and @code{intangible} can also cause point to move to
an acceptable place, after each Emacs command.  @xref{Adjusting
Point}.

@table @code
@cindex property category of text character
@kindex category @r{(text property)}
@item category
If a character has a @code{category} property, we call it the
@dfn{property category} of the character.  It should be a symbol.  The
properties of this symbol serve as defaults for the properties of the
character.

@item face
@cindex face codes of text
@kindex face @r{(text property)}
The @code{face} property controls the appearance of the character,
such as its font and color.  @xref{Faces}.  The value of the property
can be the following:

@itemize @bullet
@item
A face name (a symbol or string).

@item
A property list of face attributes.  This has the
form (@var{keyword} @var{value} @dots{}), where each @var{keyword} is a
face attribute name and @var{value} is a meaningful value for that
attribute.  With this feature, you do not need to create a face each
time you want to specify a particular attribute for certain text.
@xref{Face Attributes}.

@item
A list, where each element uses one of the two forms listed above.
@end itemize

Font Lock mode (@pxref{Font Lock Mode}) works in most buffers by
dynamically updating the @code{face} property of characters based on
the context.

@item font-lock-face
@kindex font-lock-face @r{(text property)}
This property specifies a value for the @code{face} property that Font
Lock mode should apply to the underlying text.  It is one of the
fontification methods used by Font Lock mode, and is useful for
special modes that implement their own highlighting.
@xref{Precalculated Fontification}.  When Font Lock mode is disabled,
@code{font-lock-face} has no effect.

@item mouse-face
@kindex mouse-face @r{(text property)}
This property is used instead of @code{face} when the mouse is on or
near the character.  For this purpose, ``near'' means that all text
between the character and where the mouse is have the same
@code{mouse-face} property value.

Emacs ignores all face attributes from the @code{mouse-face} property
that alter the text size (e.g. @code{:height}, @code{:weight}, and
@code{:slant}).  Those attributes are always the same as for the
unhighlighted text.

@item fontified
@kindex fontified @r{(text property)}
This property says whether the text is ready for display.  If
@code{nil}, Emacs's redisplay routine calls the functions in
@code{fontification-functions} (@pxref{Auto Faces}) to prepare this
part of the buffer before it is displayed.  It is used internally by
the ``just in time'' font locking code.

@item display
This property activates various features that change the
way text is displayed.  For example, it can make text appear taller
or shorter, higher or lower, wider or narrow, or replaced with an image.
@xref{Display Property}.

@item help-echo
@kindex help-echo @r{(text property)}
@cindex tooltip
@anchor{Text help-echo}
If text has a string as its @code{help-echo} property, then when you
move the mouse onto that text, Emacs displays that string in the echo
area, or in the tooltip window (@pxref{Tooltips,,, emacs, The GNU Emacs
Manual}).

If the value of the @code{help-echo} property is a function, that
function is called with three arguments, @var{window}, @var{object} and
@var{pos} and should return a help string or @code{nil} for
none.  The first argument, @var{window} is the window in which
the help was found.  The second, @var{object}, is the buffer, overlay or
string which had the @code{help-echo} property.  The @var{pos}
argument is as follows:

@itemize @bullet{}
@item
If @var{object} is a buffer, @var{pos} is the position in the buffer.
@item
If @var{object} is an overlay, that overlay has a @code{help-echo}
property, and @var{pos} is the position in the overlay's buffer.
@item
If @var{object} is a string (an overlay string or a string displayed
with the @code{display} property), @var{pos} is the position in that
string.
@end itemize

If the value of the @code{help-echo} property is neither a function nor
a string, it is evaluated to obtain a help string.

You can alter the way help text is displayed by setting the variable
@code{show-help-function} (@pxref{Help display}).

This feature is used in the mode line and for other active text.

@item keymap
@cindex keymap of character
@kindex keymap @r{(text property)}
The @code{keymap} property specifies an additional keymap for
commands.  When this keymap applies, it is used for key lookup before
the minor mode keymaps and before the buffer's local map.
@xref{Active Keymaps}.  If the property value is a symbol, the
symbol's function definition is used as the keymap.

The property's value for the character before point applies if it is
non-@code{nil} and rear-sticky, and the property's value for the
character after point applies if it is non-@code{nil} and
front-sticky.  (For mouse clicks, the position of the click is used
instead of the position of point.)

@item local-map
@kindex local-map @r{(text property)}
This property works like @code{keymap} except that it specifies a
keymap to use @emph{instead of} the buffer's local map.  For most
purposes (perhaps all purposes), it is better to use the @code{keymap}
property.

@item syntax-table
The @code{syntax-table} property overrides what the syntax table says
about this particular character.  @xref{Syntax Properties}.

@item read-only
@cindex read-only character
@kindex read-only @r{(text property)}
If a character has the property @code{read-only}, then modifying that
character is not allowed.  Any command that would do so gets an error,
@code{text-read-only}.  If the property value is a string, that string
is used as the error message.

Insertion next to a read-only character is an error if inserting
ordinary text there would inherit the @code{read-only} property due to
stickiness.  Thus, you can control permission to insert next to
read-only text by controlling the stickiness.  @xref{Sticky Properties}.

Since changing properties counts as modifying the buffer, it is not
possible to remove a @code{read-only} property unless you know the
special trick: bind @code{inhibit-read-only} to a non-@code{nil} value
and then remove the property.  @xref{Read Only Buffers}.

@item invisible
@kindex invisible @r{(text property)}
A non-@code{nil} @code{invisible} property can make a character invisible
on the screen.  @xref{Invisible Text}, for details.

@item intangible
@kindex intangible @r{(text property)}
If a group of consecutive characters have equal and non-@code{nil}
@code{intangible} properties, then you cannot place point between them.
If you try to move point forward into the group, point actually moves to
the end of the group.  If you try to move point backward into the group,
point actually moves to the start of the group.

If consecutive characters have unequal non-@code{nil}
@code{intangible} properties, they belong to separate groups; each
group is separately treated as described above.

When the variable @code{inhibit-point-motion-hooks} is non-@code{nil},
the @code{intangible} property is ignored.

Beware: this property operates at a very low level, and affects a lot of code
in unexpected ways.  So use it with extreme caution.  A common misuse is to put
an intangible property on invisible text, which is actually unnecessary since
the command loop will move point outside of the invisible text at the end of
each command anyway.  @xref{Adjusting Point}.

@item field
@kindex field @r{(text property)}
Consecutive characters with the same @code{field} property constitute a
@dfn{field}.  Some motion functions including @code{forward-word} and
@code{beginning-of-line} stop moving at a field boundary.
@xref{Fields}.

@item cursor
@kindex cursor @r{(text property)}
Normally, the cursor is displayed at the beginning or the end of any
overlay and text property strings present at the current buffer
position.  You can place the cursor on any desired character of these
strings by giving that character a non-@code{nil} @code{cursor} text
property.  In addition, if the value of the @code{cursor} property is
an integer number, it specifies the number of buffer's character
positions, starting with the position where the overlay or the
@code{display} property begins, for which the cursor should be
displayed on that character.  Specifically, if the value of the
@code{cursor} property of a character is the number @var{n}, the
cursor will be displayed on this character for any buffer position in
the range @code{[@var{ovpos}..@var{ovpos}+@var{n})}, where @var{ovpos}
is the overlay's starting position given by @code{overlay-start}
(@pxref{Managing Overlays}), or the position where the @code{display}
text property begins in the buffer.

In other words, the string character with the @code{cursor} property
of any non-@code{nil} value is the character where to display the
cursor.  The value of the property says for which buffer positions to
display the cursor there.  If the value is an integer number @var{n},
the cursor is displayed there when point is anywhere between the
beginning of the overlay or @code{display} property and @var{n}
positions after that.  If the value is anything else and
non-@code{nil}, the cursor is displayed there only when point is at
the beginning of the @code{display} property or at
@code{overlay-start}.

@cindex cursor position for @code{display} properties and overlays
When the buffer has many overlay strings (e.g., @pxref{Overlay
Properties, before-string}) or @code{display} properties that are
strings, it is a good idea to use the @code{cursor} property on these
strings to cue the Emacs display about the places where to put the
cursor while traversing these strings.  This directly communicates to
the display engine where the Lisp program wants to put the cursor, or
where the user would expect the cursor.

@item pointer
@kindex pointer @r{(text property)}
This specifies a specific pointer shape when the mouse pointer is over
this text or image.  @xref{Pointer Shape}, for possible pointer
shapes.

@item line-spacing
@kindex line-spacing @r{(text property)}
A newline can have a @code{line-spacing} text or overlay property that
controls the height of the display line ending with that newline.  The
property value overrides the default frame line spacing and the buffer
local @code{line-spacing} variable.  @xref{Line Height}.

@item line-height
@kindex line-height @r{(text property)}
A newline can have a @code{line-height} text or overlay property that
controls the total height of the display line ending in that newline.
@xref{Line Height}.

@item wrap-prefix
If text has a @code{wrap-prefix} property, the prefix it defines will
be added at display time to the beginning of every continuation line
due to text wrapping (so if lines are truncated, the wrap-prefix is
never used).  It may be a string or an image (@pxref{Other Display
Specs}), or a stretch of whitespace such as specified by the
@code{:width} or @code{:align-to} display properties (@pxref{Specified
Space}).

A wrap-prefix may also be specified for an entire buffer using the
@code{wrap-prefix} buffer-local variable (however, a
@code{wrap-prefix} text-property takes precedence over the value of
the @code{wrap-prefix} variable).  @xref{Truncation}.

@item line-prefix
If text has a @code{line-prefix} property, the prefix it defines will
be added at display time to the beginning of every non-continuation
line.  It may be a string or an image (@pxref{Other Display
Specs}), or a stretch of whitespace such as specified by the
@code{:width} or @code{:align-to} display properties (@pxref{Specified
Space}).

A line-prefix may also be specified for an entire buffer using the
@code{line-prefix} buffer-local variable (however, a
@code{line-prefix} text-property takes precedence over the value of
the @code{line-prefix} variable).  @xref{Truncation}.

@item modification-hooks
@cindex change hooks for a character
@cindex hooks for changing a character
@kindex modification-hooks @r{(text property)}
If a character has the property @code{modification-hooks}, then its
value should be a list of functions; modifying that character calls
all of those functions before the actual modification.  Each function
receives two arguments: the beginning and end of the part of the
buffer being modified.  Note that if a particular modification hook
function appears on several characters being modified by a single
primitive, you can't predict how many times the function will
be called.
Furthermore, insertion will not modify any existing character, so this
hook will only be run when removing some characters, replacing them
with others, or changing their text-properties.

If these functions modify the buffer, they should bind
@code{inhibit-modification-hooks} to @code{t} around doing so, to
avoid confusing the internal mechanism that calls these hooks.

Overlays also support the @code{modification-hooks} property, but the
details are somewhat different (@pxref{Overlay Properties}).

@item insert-in-front-hooks
@itemx insert-behind-hooks
@kindex insert-in-front-hooks @r{(text property)}
@kindex insert-behind-hooks @r{(text property)}
The operation of inserting text in a buffer also calls the functions
listed in the @code{insert-in-front-hooks} property of the following
character and in the @code{insert-behind-hooks} property of the
preceding character.  These functions receive two arguments, the
beginning and end of the inserted text.  The functions are called
@emph{after} the actual insertion takes place.

See also @ref{Change Hooks}, for other hooks that are called
when you change text in a buffer.

@item point-entered
@itemx point-left
@cindex hooks for motion of point
@kindex point-entered @r{(text property)}
@kindex point-left @r{(text property)}
The special properties @code{point-entered} and @code{point-left}
record hook functions that report motion of point.  Each time point
moves, Emacs compares these two property values:

@itemize @bullet
@item
the @code{point-left} property of the character after the old location,
and
@item
the @code{point-entered} property of the character after the new
location.
@end itemize

@noindent
If these two values differ, each of them is called (if not @code{nil})
with two arguments: the old value of point, and the new one.

The same comparison is made for the characters before the old and new
locations.  The result may be to execute two @code{point-left} functions
(which may be the same function) and/or two @code{point-entered}
functions (which may be the same function).  In any case, all the
@code{point-left} functions are called first, followed by all the
@code{point-entered} functions.

It is possible to use @code{char-after} to examine characters at various
buffer positions without moving point to those positions.  Only an
actual change in the value of point runs these hook functions.

The variable @code{inhibit-point-motion-hooks} can inhibit running the
@code{point-left} and @code{point-entered} hooks, see @ref{Inhibit
point motion hooks}.

@item composition
@kindex composition @r{(text property)}
This text property is used to display a sequence of characters as a
single glyph composed from components.  But the value of the property
itself is completely internal to Emacs and should not be manipulated
directly by, for instance, @code{put-text-property}.

@end table

@defvar inhibit-point-motion-hooks
@anchor{Inhibit point motion hooks} When this variable is
non-@code{nil}, @code{point-left} and @code{point-entered} hooks are
not run, and the @code{intangible} property has no effect.  Do not set
this variable globally; bind it with @code{let}.
@end defvar

@defvar show-help-function
@anchor{Help display} If this variable is non-@code{nil}, it specifies a
function called to display help strings.  These may be @code{help-echo}
properties, menu help strings (@pxref{Simple Menu Items},
@pxref{Extended Menu Items}), or tool bar help strings (@pxref{Tool
Bar}).  The specified function is called with one argument, the help
string to display.  Tooltip mode (@pxref{Tooltips,,, emacs, The GNU Emacs
Manual}) provides an example.
@end defvar

@node Format Properties
@subsection Formatted Text Properties

  These text properties affect the behavior of the fill commands.  They
are used for representing formatted text.  @xref{Filling}, and
@ref{Margins}.

@table @code
@item hard
If a newline character has this property, it is a ``hard'' newline.
The fill commands do not alter hard newlines and do not move words
across them.  However, this property takes effect only if the
@code{use-hard-newlines} minor mode is enabled.  @xref{Hard and Soft
Newlines,, Hard and Soft Newlines, emacs, The GNU Emacs Manual}.

@item right-margin
This property specifies an extra right margin for filling this part of the
text.

@item left-margin
This property specifies an extra left margin for filling this part of the
text.

@item justification
This property specifies the style of justification for filling this part
of the text.
@end table

@node Sticky Properties
@subsection Stickiness of Text Properties
@cindex sticky text properties
@cindex inheritance of text properties

  Self-inserting characters normally take on the same properties as the
preceding character.  This is called @dfn{inheritance} of properties.

  A Lisp program can do insertion with inheritance or without,
depending on the choice of insertion primitive.  The ordinary text
insertion functions, such as @code{insert}, do not inherit any
properties.  They insert text with precisely the properties of the
string being inserted, and no others.  This is correct for programs
that copy text from one context to another---for example, into or out
of the kill ring.  To insert with inheritance, use the special
primitives described in this section.  Self-inserting characters
inherit properties because they work using these primitives.

  When you do insertion with inheritance, @emph{which} properties are
inherited, and from where, depends on which properties are @dfn{sticky}.
Insertion after a character inherits those of its properties that are
@dfn{rear-sticky}.  Insertion before a character inherits those of its
properties that are @dfn{front-sticky}.  When both sides offer different
sticky values for the same property, the previous character's value
takes precedence.

  By default, a text property is rear-sticky but not front-sticky; thus,
the default is to inherit all the properties of the preceding character,
and nothing from the following character.

  You can control the stickiness of various text properties with two
specific text properties, @code{front-sticky} and @code{rear-nonsticky},
and with the variable @code{text-property-default-nonsticky}.  You can
use the variable to specify a different default for a given property.
You can use those two text properties to make any specific properties
sticky or nonsticky in any particular part of the text.

  If a character's @code{front-sticky} property is @code{t}, then all
its properties are front-sticky.  If the @code{front-sticky} property is
a list, then the sticky properties of the character are those whose
names are in the list.  For example, if a character has a
@code{front-sticky} property whose value is @code{(face read-only)},
then insertion before the character can inherit its @code{face} property
and its @code{read-only} property, but no others.

  The @code{rear-nonsticky} property works the opposite way.  Most
properties are rear-sticky by default, so the @code{rear-nonsticky}
property says which properties are @emph{not} rear-sticky.  If a
character's @code{rear-nonsticky} property is @code{t}, then none of its
properties are rear-sticky.  If the @code{rear-nonsticky} property is a
list, properties are rear-sticky @emph{unless} their names are in the
list.

@defvar text-property-default-nonsticky
This variable holds an alist which defines the default rear-stickiness
of various text properties.  Each element has the form
@code{(@var{property} . @var{nonstickiness})}, and it defines the
stickiness of a particular text property, @var{property}.

If @var{nonstickiness} is non-@code{nil}, this means that the property
@var{property} is rear-nonsticky by default.  Since all properties are
front-nonsticky by default, this makes @var{property} nonsticky in both
directions by default.

The text properties @code{front-sticky} and @code{rear-nonsticky}, when
used, take precedence over the default @var{nonstickiness} specified in
@code{text-property-default-nonsticky}.
@end defvar

  Here are the functions that insert text with inheritance of properties:

@defun insert-and-inherit &rest strings
Insert the strings @var{strings}, just like the function @code{insert},
but inherit any sticky properties from the adjoining text.
@end defun

@defun insert-before-markers-and-inherit &rest strings
Insert the strings @var{strings}, just like the function
@code{insert-before-markers}, but inherit any sticky properties from the
adjoining text.
@end defun

  @xref{Insertion}, for the ordinary insertion functions which do not
inherit.

@node Lazy Properties
@subsection Lazy Computation of Text Properties

  Instead of computing text properties for all the text in the buffer,
you can arrange to compute the text properties for parts of the text
when and if something depends on them.

  The primitive that extracts text from the buffer along with its
properties is @code{buffer-substring}.  Before examining the properties,
this function runs the abnormal hook @code{buffer-access-fontify-functions}.

@defvar buffer-access-fontify-functions
This variable holds a list of functions for computing text properties.
Before @code{buffer-substring} copies the text and text properties for a
portion of the buffer, it calls all the functions in this list.  Each of
the functions receives two arguments that specify the range of the
buffer being accessed.  (The buffer itself is always the current
buffer.)
@end defvar

  The function @code{buffer-substring-no-properties} does not call these
functions, since it ignores text properties anyway.

  In order to prevent the hook functions from being called more than
once for the same part of the buffer, you can use the variable
@code{buffer-access-fontified-property}.

@defvar buffer-access-fontified-property
If this variable's value is non-@code{nil}, it is a symbol which is used
as a text property name.  A non-@code{nil} value for that text property
means, ``the other text properties for this character have already been
computed''.

If all the characters in the range specified for @code{buffer-substring}
have a non-@code{nil} value for this property, @code{buffer-substring}
does not call the @code{buffer-access-fontify-functions} functions.  It
assumes these characters already have the right text properties, and
just copies the properties they already have.

The normal way to use this feature is that the
@code{buffer-access-fontify-functions} functions add this property, as
well as others, to the characters they operate on.  That way, they avoid
being called over and over for the same text.
@end defvar

@node Clickable Text
@subsection Defining Clickable Text
@cindex clickable text
@cindex follow links
@cindex mouse-1

  @dfn{Clickable text} is text that can be clicked, with either the
mouse or via a keyboard command, to produce some result.  Many major
modes use clickable text to implement textual hyper-links, or
@dfn{links} for short.

  The easiest way to insert and manipulate links is to use the
@code{button} package.  @xref{Buttons}.  In this section, we will
explain how to manually set up clickable text in a buffer, using text
properties.  For simplicity, we will refer to the clickable text as a
@dfn{link}.

  Implementing a link involves three separate steps: (1) indicating
clickability when the mouse moves over the link; (2) making @key{RET}
or @kbd{Mouse-2} on that link do something; and (3) setting up a
@code{follow-link} condition so that the link obeys
@code{mouse-1-click-follows-link}.

  To indicate clickability, add the @code{mouse-face} text property to
the text of the link; then Emacs will highlight the link when the
mouse moves over it.  In addition, you should define a tooltip or echo
area message, using the @code{help-echo} text property.  @xref{Special
Properties}.  For instance, here is how Dired indicates that file
names are clickable:

@smallexample
 (if (dired-move-to-filename)
     (add-text-properties
       (point)
       (save-excursion
         (dired-move-to-end-of-filename)
         (point))
       '(mouse-face highlight
         help-echo "mouse-2: visit this file in other window")))
@end smallexample

  To make the link clickable, bind @key{RET} and @kbd{Mouse-2} to
commands that perform the desired action.  Each command should check
to see whether it was called on a link, and act accordingly.  For
instance, Dired's major mode keymap binds @kbd{Mouse-2} to the
following command:

@smallexample
(defun dired-mouse-find-file-other-window (event)
  "In Dired, visit the file or directory name you click on."
  (interactive "e")
  (let ((window (posn-window (event-end event)))
        (pos (posn-point (event-end event)))
        file)
    (if (not (windowp window))
        (error "No file chosen"))
    (with-current-buffer (window-buffer window)
      (goto-char pos)
      (setq file (dired-get-file-for-visit)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)
                 (dired-goto-subdir file))
            (progn
              (select-window window)
              (dired-other-window file)))
      (select-window window)
      (find-file-other-window (file-name-sans-versions file t)))))
@end smallexample

@noindent
This command uses the functions @code{posn-window} and
@code{posn-point} to determine where the click occurred, and
@code{dired-get-file-for-visit} to determine which file to visit.

  Instead of binding the mouse command in a major mode keymap, you can
bind it within the link text, using the @code{keymap} text property
(@pxref{Special Properties}).  For instance:

@example
(let ((map (make-sparse-keymap)))
  (define-key map [mouse-2] 'operate-this-button)
  (put-text-property link-start link-end 'keymap map))
@end example

@noindent
With this method, you can easily define different commands for
different links.  Furthermore, the global definition of @key{RET} and
@kbd{Mouse-2} remain available for the rest of the text in the buffer.

@vindex mouse-1-click-follows-link
  The basic Emacs command for clicking on links is @kbd{Mouse-2}.
However, for compatibility with other graphical applications, Emacs
also recognizes @kbd{Mouse-1} clicks on links, provided the user
clicks on the link quickly without moving the mouse.  This behavior is
controlled by the user option @code{mouse-1-click-follows-link}.
@xref{Mouse References,,, emacs, The GNU Emacs Manual}.

  To set up the link so that it obeys
@code{mouse-1-click-follows-link}, you must either (1) apply a
@code{follow-link} text or overlay property to the link text, or (2)
bind the @code{follow-link} event to a keymap (which can be a major
mode keymap or a local keymap specified via the @code{keymap} text
property).  The value of the @code{follow-link} property, or the
binding for the @code{follow-link} event, acts as a ``condition'' for
the link action.  This condition tells Emacs two things: the
circumstances under which a @kbd{Mouse-1} click should be regarded as
occurring ``inside'' the link, and how to compute an ``action code''
that says what to translate the @kbd{Mouse-1} click into.  The link
action condition can be one of the following:

@table @asis
@item @code{mouse-face}
If the condition is the symbol @code{mouse-face}, a position is inside
a link if there is a non-@code{nil} @code{mouse-face} property at that
position.  The action code is always @code{t}.

For example, here is how Info mode handles @key{Mouse-1}:

@smallexample
(define-key Info-mode-map [follow-link] 'mouse-face)
@end smallexample

@item a function
If the condition is a function, @var{func}, then a position @var{pos}
is inside a link if @code{(@var{func} @var{pos})} evaluates to
non-@code{nil}.  The value returned by @var{func} serves as the action
code.

For example, here is how pcvs enables @kbd{Mouse-1} to follow links on
file names only:

@smallexample
(define-key map [follow-link]
  (lambda (pos)
    (eq (get-char-property pos 'face) 'cvs-filename-face)))
@end smallexample

@item anything else
If the condition value is anything else, then the position is inside a
link and the condition itself is the action code.  Clearly, you should
specify this kind of condition only when applying the condition via a
text or property overlay on the link text (so that it does not apply
to the entire buffer).
@end table

@noindent
The action code tells @kbd{Mouse-1} how to follow the link:

@table @asis
@item a string or vector
If the action code is a string or vector, the @kbd{Mouse-1} event is
translated into the first element of the string or vector; i.e., the
action of the @kbd{Mouse-1} click is the local or global binding of
that character or symbol.  Thus, if the action code is @code{"foo"},
@kbd{Mouse-1} translates into @kbd{f}.  If it is @code{[foo]},
@kbd{Mouse-1} translates into @key{foo}.

@item anything else
For any other non-@code{nil} action code, the @kbd{Mouse-1} event is
translated into a @kbd{Mouse-2} event at the same position.
@end table

  To define @kbd{Mouse-1} to activate a button defined with
@code{define-button-type}, give the button a @code{follow-link}
property.  The property value should be a link action condition, as
described above.  @xref{Buttons}.  For example, here is how Help mode
handles @kbd{Mouse-1}:

@smallexample
(define-button-type 'help-xref
  'follow-link t
  'action #'help-button-action)
@end smallexample

  To define @kbd{Mouse-1} on a widget defined with
@code{define-widget}, give the widget a @code{:follow-link} property.
The property value should be a link action condition, as described
above.  For example, here is how the @code{link} widget specifies that
a @key{Mouse-1} click shall be translated to @key{RET}:

@smallexample
(define-widget 'link 'item
  "An embedded link."
  :button-prefix 'widget-link-prefix
  :button-suffix 'widget-link-suffix
  :follow-link "\C-m"
  :help-echo "Follow the link."
  :format "%[%t%]")
@end smallexample

@defun mouse-on-link-p pos
This function returns non-@code{nil} if position @var{pos} in the
current buffer is on a link.  @var{pos} can also be a mouse event
location, as returned by @code{event-start} (@pxref{Accessing Mouse}).
@end defun

@node Fields
@subsection Defining and Using Fields
@cindex fields

  A field is a range of consecutive characters in the buffer that are
identified by having the same value (comparing with @code{eq}) of the
@code{field} property (either a text-property or an overlay property).
This section describes special functions that are available for
operating on fields.

  You specify a field with a buffer position, @var{pos}.  We think of
each field as containing a range of buffer positions, so the position
you specify stands for the field containing that position.

  When the characters before and after @var{pos} are part of the same
field, there is no doubt which field contains @var{pos}: the one those
characters both belong to.  When @var{pos} is at a boundary between
fields, which field it belongs to depends on the stickiness of the
@code{field} properties of the two surrounding characters (@pxref{Sticky
Properties}).  The field whose property would be inherited by text
inserted at @var{pos} is the field that contains @var{pos}.

  There is an anomalous case where newly inserted text at @var{pos}
would not inherit the @code{field} property from either side.  This
happens if the previous character's @code{field} property is not
rear-sticky, and the following character's @code{field} property is not
front-sticky.  In this case, @var{pos} belongs to neither the preceding
field nor the following field; the field functions treat it as belonging
to an empty field whose beginning and end are both at @var{pos}.

  In all of these functions, if @var{pos} is omitted or @code{nil}, the
value of point is used by default.  If narrowing is in effect, then
@var{pos} should fall within the accessible portion.  @xref{Narrowing}.

@defun field-beginning &optional pos escape-from-edge limit
This function returns the beginning of the field specified by @var{pos}.

If @var{pos} is at the beginning of its field, and
@var{escape-from-edge} is non-@code{nil}, then the return value is
always the beginning of the preceding field that @emph{ends} at @var{pos},
regardless of the stickiness of the @code{field} properties around
@var{pos}.

If @var{limit} is non-@code{nil}, it is a buffer position; if the
beginning of the field is before @var{limit}, then @var{limit} will be
returned instead.
@end defun

@defun field-end &optional pos escape-from-edge limit
This function returns the end of the field specified by @var{pos}.

If @var{pos} is at the end of its field, and @var{escape-from-edge} is
non-@code{nil}, then the return value is always the end of the following
field that @emph{begins} at @var{pos}, regardless of the stickiness of
the @code{field} properties around @var{pos}.

If @var{limit} is non-@code{nil}, it is a buffer position; if the end
of the field is after @var{limit}, then @var{limit} will be returned
instead.
@end defun

@defun field-string &optional pos
This function returns the contents of the field specified by @var{pos},
as a string.
@end defun

@defun field-string-no-properties &optional pos
This function returns the contents of the field specified by @var{pos},
as a string, discarding text properties.
@end defun

@defun delete-field &optional pos
This function deletes the text of the field specified by @var{pos}.
@end defun

@defun constrain-to-field new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property
This function ``constrains'' @var{new-pos} to the field that
@var{old-pos} belongs to---in other words, it returns the position
closest to @var{new-pos} that is in the same field as @var{old-pos}.

If @var{new-pos} is @code{nil}, then @code{constrain-to-field} uses
the value of point instead, and moves point to the resulting position
in addition to returning that position.

If @var{old-pos} is at the boundary of two fields, then the acceptable
final positions depend on the argument @var{escape-from-edge}.  If
@var{escape-from-edge} is @code{nil}, then @var{new-pos} must be in
the field whose @code{field} property equals what new characters
inserted at @var{old-pos} would inherit.  (This depends on the
stickiness of the @code{field} property for the characters before and
after @var{old-pos}.)  If @var{escape-from-edge} is non-@code{nil},
@var{new-pos} can be anywhere in the two adjacent fields.
Additionally, if two fields are separated by another field with the
special value @code{boundary}, then any point within this special
field is also considered to be ``on the boundary''.

Commands like @kbd{C-a} with no argument, that normally move backward
to a specific kind of location and stay there once there, probably
should specify @code{nil} for @var{escape-from-edge}.  Other motion
commands that check fields should probably pass @code{t}.

If the optional argument @var{only-in-line} is non-@code{nil}, and
constraining @var{new-pos} in the usual way would move it to a different
line, @var{new-pos} is returned unconstrained.  This used in commands
that move by line, such as @code{next-line} and
@code{beginning-of-line}, so that they respect field boundaries only in
the case where they can still move to the right line.

If the optional argument @var{inhibit-capture-property} is
non-@code{nil}, and @var{old-pos} has a non-@code{nil} property of that
name, then any field boundaries are ignored.

You can cause @code{constrain-to-field} to ignore all field boundaries
(and so never constrain anything) by binding the variable
@code{inhibit-field-text-motion} to a non-@code{nil} value.
@end defun

@node Not Intervals
@subsection Why Text Properties are not Intervals
@cindex intervals

  Some editors that support adding attributes to text in the buffer do
so by letting the user specify ``intervals'' within the text, and adding
the properties to the intervals.  Those editors permit the user or the
programmer to determine where individual intervals start and end.  We
deliberately provided a different sort of interface in Emacs Lisp to
avoid certain paradoxical behavior associated with text modification.

  If the actual subdivision into intervals is meaningful, that means you
can distinguish between a buffer that is just one interval with a
certain property, and a buffer containing the same text subdivided into
two intervals, both of which have that property.

  Suppose you take the buffer with just one interval and kill part of
the text.  The text remaining in the buffer is one interval, and the
copy in the kill ring (and the undo list) becomes a separate interval.
Then if you yank back the killed text, you get two intervals with the
same properties.  Thus, editing does not preserve the distinction
between one interval and two.

  Suppose we ``fix'' this problem by coalescing the two intervals when
the text is inserted.  That works fine if the buffer originally was a
single interval.  But suppose instead that we have two adjacent
intervals with the same properties, and we kill the text of one interval
and yank it back.  The same interval-coalescence feature that rescues
the other case causes trouble in this one: after yanking, we have just
one interval.  One again, editing does not preserve the distinction
between one interval and two.

  Insertion of text at the border between intervals also raises
questions that have no satisfactory answer.

  However, it is easy to arrange for editing to behave consistently for
questions of the form, ``What are the properties of this character?''
So we have decided these are the only questions that make sense; we have
not implemented asking questions about where intervals start or end.

  In practice, you can usually use the text property search functions in
place of explicit interval boundaries.  You can think of them as finding
the boundaries of intervals, assuming that intervals are always
coalesced whenever possible.  @xref{Property Search}.

  Emacs also provides explicit intervals as a presentation feature; see
@ref{Overlays}.

@node Substitution
@section Substituting for a Character Code

  The following functions replace characters within a specified region
based on their character codes.

@defun subst-char-in-region start end old-char new-char &optional noundo
@cindex replace characters
This function replaces all occurrences of the character @var{old-char}
with the character @var{new-char} in the region of the current buffer
defined by @var{start} and @var{end}.

@cindex undo avoidance
If @var{noundo} is non-@code{nil}, then @code{subst-char-in-region} does
not record the change for undo and does not mark the buffer as modified.
This was useful for controlling the old selective display feature
(@pxref{Selective Display}).

@code{subst-char-in-region} does not move point and returns
@code{nil}.

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@deffn Command translate-region start end table
This function applies a translation table to the characters in the
buffer between positions @var{start} and @var{end}.

The translation table @var{table} is a string or a char-table;
@code{(aref @var{table} @var{ochar})} gives the translated character
corresponding to @var{ochar}.  If @var{table} is a string, any
characters with codes larger than the length of @var{table} are not
altered by the translation.

The return value of @code{translate-region} is the number of
characters that were actually changed by the translation.  This does
not count characters that were mapped into themselves in the
translation table.
@end deffn

@node Registers
@section Registers
@cindex registers

  A register is a sort of variable used in Emacs editing that can hold a
variety of different kinds of values.  Each register is named by a
single character.  All @acronym{ASCII} characters and their meta variants
(but with the exception of @kbd{C-g}) can be used to name registers.
Thus, there are 255 possible registers.  A register is designated in
Emacs Lisp by the character that is its name.

@defvar register-alist
This variable is an alist of elements of the form @code{(@var{name} .
@var{contents})}.  Normally, there is one element for each Emacs
register that has been used.

The object @var{name} is a character (an integer) identifying the
register.
@end defvar

  The @var{contents} of a register can have several possible types:

@table @asis
@item a number
A number stands for itself.  If @code{insert-register} finds a number
in the register, it converts the number to decimal.

@item a marker
A marker represents a buffer position to jump to.

@item a string
A string is text saved in the register.

@item a rectangle
A rectangle is represented by a list of strings.

@item @code{(@var{window-configuration} @var{position})}
This represents a window configuration to restore in one frame, and a
position to jump to in the current buffer.

@item @code{(@var{frame-configuration} @var{position})}
This represents a frame configuration to restore, and a position
to jump to in the current buffer.

@item (file @var{filename})
This represents a file to visit; jumping to this value visits file
@var{filename}.

@item (file-query @var{filename} @var{position})
This represents a file to visit and a position in it; jumping to this
value visits file @var{filename} and goes to buffer position
@var{position}.  Restoring this type of position asks the user for
confirmation first.
@end table

  The functions in this section return unpredictable values unless
otherwise stated.

@defun get-register reg
This function returns the contents of the register
@var{reg}, or @code{nil} if it has no contents.
@end defun

@defun set-register reg value
This function sets the contents of register @var{reg} to @var{value}.
A register can be set to any value, but the other register functions
expect only certain data types.  The return value is @var{value}.
@end defun

@deffn Command view-register reg
This command displays what is contained in register @var{reg}.
@end deffn

@deffn Command insert-register reg &optional beforep
This command inserts contents of register @var{reg} into the current
buffer.

Normally, this command puts point before the inserted text, and the
mark after it.  However, if the optional second argument @var{beforep}
is non-@code{nil}, it puts the mark before and point after.
You can pass a non-@code{nil} second argument @var{beforep} to this
function interactively by supplying any prefix argument.

If the register contains a rectangle, then the rectangle is inserted
with its upper left corner at point.  This means that text is inserted
in the current line and underneath it on successive lines.

If the register contains something other than saved text (a string) or
a rectangle (a list), currently useless things happen.  This may be
changed in the future.
@end deffn

@node Transposition
@section Transposition of Text

  This function can be used to transpose stretches of text:

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
This function exchanges two nonoverlapping portions of the buffer.
Arguments @var{start1} and @var{end1} specify the bounds of one portion
and arguments @var{start2} and @var{end2} specify the bounds of the
other portion.

Normally, @code{transpose-regions} relocates markers with the transposed
text; a marker previously positioned within one of the two transposed
portions moves along with that portion, thus remaining between the same
two characters in their new position.  However, if @var{leave-markers}
is non-@code{nil}, @code{transpose-regions} does not do this---it leaves
all markers unrelocated.
@end defun

@node Base 64
@section Base 64 Encoding
@cindex base 64 encoding

  Base 64 code is used in email to encode a sequence of 8-bit bytes as
a longer sequence of @acronym{ASCII} graphic characters.  It is defined in
Internet RFC@footnote{
An RFC, an acronym for @dfn{Request for Comments}, is a numbered
Internet informational document describing a standard.  RFCs are
usually written by technical experts acting on their own initiative,
and are traditionally written in a pragmatic, experience-driven
manner.
}2045.  This section describes the functions for
converting to and from this code.

@deffn Command base64-encode-region beg end &optional no-line-break
This function converts the region from @var{beg} to @var{end} into base
64 code.  It returns the length of the encoded text.  An error is
signaled if a character in the region is multibyte, i.e.@: in a
multibyte buffer the region must contain only characters from the
charsets @code{ascii}, @code{eight-bit-control} and
@code{eight-bit-graphic}.

Normally, this function inserts newline characters into the encoded
text, to avoid overlong lines.  However, if the optional argument
@var{no-line-break} is non-@code{nil}, these newlines are not added, so
the output is just one long line.
@end deffn

@defun base64-encode-string string &optional no-line-break
This function converts the string @var{string} into base 64 code.  It
returns a string containing the encoded text.  As for
@code{base64-encode-region}, an error is signaled if a character in the
string is multibyte.

Normally, this function inserts newline characters into the encoded
text, to avoid overlong lines.  However, if the optional argument
@var{no-line-break} is non-@code{nil}, these newlines are not added, so
the result string is just one long line.
@end defun

@deffn Command base64-decode-region beg end
This function converts the region from @var{beg} to @var{end} from base
64 code into the corresponding decoded text.  It returns the length of
the decoded text.

The decoding functions ignore newline characters in the encoded text.
@end deffn

@defun base64-decode-string string
This function converts the string @var{string} from base 64 code into
the corresponding decoded text.  It returns a unibyte string containing the
decoded text.

The decoding functions ignore newline characters in the encoded text.
@end defun

@node Checksum/Hash
@section Checksum/Hash
@cindex MD5 checksum
@cindex SHA hash
@cindex hash, cryptographic
@cindex cryptographic hash

  Emacs has built-in support for computing @dfn{cryptographic hashes}.
A cryptographic hash, or @dfn{checksum}, is a digital ``fingerprint''
of a piece of data (e.g.@: a block of text) which can be used to check
that you have an unaltered copy of that data.

@cindex message digest
  Emacs supports several common cryptographic hash algorithms: MD5,
SHA-1, SHA-2, SHA-224, SHA-256, SHA-384 and SHA-512.  MD5 is the
oldest of these algorithms, and is commonly used in @dfn{message
digests} to check the integrity of messages transmitted over a
network.  MD5 is not ``collision resistant'' (i.e.@: it is possible to
deliberately design different pieces of data which have the same MD5
hash), so you should not used it for anything security-related.  A
similar theoretical weakness also exists in SHA-1.  Therefore, for
security-related applications you should use the other hash types,
such as SHA-2.

@defun secure-hash algorithm object &optional start end binary
This function returns a hash for @var{object}.  The argument
@var{algorithm} is a symbol stating which hash to compute: one of
@code{md5}, @code{sha1}, @code{sha224}, @code{sha256}, @code{sha384}
or @code{sha512}.  The argument @var{object} should be a buffer or a
string.

The optional arguments @var{start} and @var{end} are character
positions specifying the portion of @var{object} to compute the
message digest for.  If they are @code{nil} or omitted, the hash is
computed for the whole of @var{object}.

If the argument @var{binary} is omitted or @code{nil}, the function
returns the @dfn{text form} of the hash, as an ordinary Lisp string.
If @var{binary} is non-@code{nil}, it returns the hash in @dfn{binary
form}, as a sequence of bytes stored in a unibyte string.

This function does not compute the hash directly from the internal
representation of @var{object}'s text (@pxref{Text Representations}).
Instead, it encodes the text using a coding system (@pxref{Coding
Systems}), and computes the hash from that encoded text.  If
@var{object} is a buffer, the coding system used is the one which
would be chosen by default for writing the text into a file.  If
@var{object} is a string, the user's preferred coding system is used
(@pxref{Recognize Coding,,, emacs, GNU Emacs Manual}).
@end defun

@defun md5 object &optional start end coding-system noerror
This function returns an MD5 hash.  It is semi-obsolete, since for
most purposes it is equivalent to calling @code{secure-hash} with
@code{md5} as the @var{algorithm} argument.  The @var{object},
@var{start} and @var{end} arguments have the same meanings as in
@code{secure-hash}.

If @var{coding-system} is non-@code{nil}, it specifies a coding system
to use to encode the text; if omitted or @code{nil}, the default
coding system is used, like in @code{secure-hash}.

Normally, @code{md5} signals an error if the text can't be encoded
using the specified or chosen coding system.  However, if
@var{noerror} is non-@code{nil}, it silently uses @code{raw-text}
coding instead.
@end defun

@node Parsing HTML/XML
@section Parsing HTML and XML
@cindex parsing html

When Emacs is compiled with libxml2 support, the following functions
are available to parse HTML or XML text into Lisp object trees.

@defun libxml-parse-html-region start end &optional base-url
This function parses the text between @var{start} and @var{end} as
HTML, and returns a list representing the HTML @dfn{parse tree}.  It
attempts to handle ``real world'' HTML by robustly coping with syntax
mistakes.

The optional argument @var{base-url}, if non-@code{nil}, should be a
string specifying the base URL for relative URLs occurring in links.

In the parse tree, each HTML node is represented by a list in which
the first element is a symbol representing the node name, the second
element is an alist of node attributes, and the remaining elements are
the subnodes.

The following example demonstrates this.  Given this (malformed) HTML
document:

@example
<html><head></head><body width=101><div class=thing>Foo<div>Yes
@end example

@noindent
A call to @code{libxml-parse-html-region} returns this:

@example
(html ()
  (head ())
  (body ((width . "101"))
   (div ((class . "thing"))
    "Foo"
    (div ()
      "Yes"))))
@end example
@end defun

@cindex parsing xml
@defun libxml-parse-xml-region start end &optional base-url
This function is the same as @code{libxml-parse-html-region}, except
that it parses the text as XML rather than HTML (so it is stricter
about syntax).
@end defun

@node Atomic Changes
@section Atomic Change Groups
@cindex atomic changes

  In database terminology, an @dfn{atomic} change is an indivisible
change---it can succeed entirely or it can fail entirely, but it
cannot partly succeed.  A Lisp program can make a series of changes to
one or several buffers as an @dfn{atomic change group}, meaning that
either the entire series of changes will be installed in their buffers
or, in case of an error, none of them will be.

  To do this for one buffer, the one already current, simply write a
call to @code{atomic-change-group} around the code that makes the
changes, like this:

@example
(atomic-change-group
  (insert foo)
  (delete-region x y))
@end example

@noindent
If an error (or other nonlocal exit) occurs inside the body of
@code{atomic-change-group}, it unmakes all the changes in that buffer
that were during the execution of the body.  This kind of change group
has no effect on any other buffers---any such changes remain.

  If you need something more sophisticated, such as to make changes in
various buffers constitute one atomic group, you must directly call
lower-level functions that @code{atomic-change-group} uses.

@defun prepare-change-group &optional buffer
This function sets up a change group for buffer @var{buffer}, which
defaults to the current buffer.  It returns a ``handle'' that
represents the change group.  You must use this handle to activate the
change group and subsequently to finish it.
@end defun

  To use the change group, you must @dfn{activate} it.  You must do
this before making any changes in the text of @var{buffer}.

@defun activate-change-group handle
This function activates the change group that @var{handle} designates.
@end defun

  After you activate the change group, any changes you make in that
buffer become part of it.  Once you have made all the desired changes
in the buffer, you must @dfn{finish} the change group.  There are two
ways to do this: you can either accept (and finalize) all the changes,
or cancel them all.

@defun accept-change-group handle
This function accepts all the changes in the change group specified by
@var{handle}, making them final.
@end defun

@defun cancel-change-group handle
This function cancels and undoes all the changes in the change group
specified by @var{handle}.
@end defun

  Your code should use @code{unwind-protect} to make sure the group is
always finished.  The call to @code{activate-change-group} should be
inside the @code{unwind-protect}, in case the user types @kbd{C-g}
just after it runs.  (This is one reason why
@code{prepare-change-group} and @code{activate-change-group} are
separate functions, because normally you would call
@code{prepare-change-group} before the start of that
@code{unwind-protect}.)  Once you finish the group, don't use the
handle again---in particular, don't try to finish the same group
twice.

  To make a multibuffer change group, call @code{prepare-change-group}
once for each buffer you want to cover, then use @code{nconc} to
combine the returned values, like this:

@example
(nconc (prepare-change-group buffer-1)
       (prepare-change-group buffer-2))
@end example

You can then activate the multibuffer change group with a single call
to @code{activate-change-group}, and finish it with a single call to
@code{accept-change-group} or @code{cancel-change-group}.

  Nested use of several change groups for the same buffer works as you
would expect.  Non-nested use of change groups for the same buffer
will get Emacs confused, so don't let it happen; the first change
group you start for any given buffer should be the last one finished.

@node Change Hooks
@section Change Hooks
@cindex change hooks
@cindex hooks for text changes

  These hook variables let you arrange to take notice of all changes in
all buffers (or in a particular buffer, if you make them buffer-local).
See also @ref{Special Properties}, for how to detect changes to specific
parts of the text.

  The functions you use in these hooks should save and restore the match
data if they do anything that uses regular expressions; otherwise, they
will interfere in bizarre ways with the editing operations that call
them.

@defvar before-change-functions
This variable holds a list of functions to call before any buffer
modification.  Each function gets two arguments, the beginning and end
of the region that is about to change, represented as integers.  The
buffer that is about to change is always the current buffer.
@end defvar

@defvar after-change-functions
This variable holds a list of functions to call after any buffer
modification.  Each function receives three arguments: the beginning
and end of the region just changed, and the length of the text that
existed before the change.  All three arguments are integers.  The
buffer has been changed is always the current buffer.

The length of the old text is the difference between the buffer
positions before and after that text as it was before the change.  As
for the changed text, its length is simply the difference between the
first two arguments.
@end defvar

  Output of messages into the @file{*Messages*} buffer does not
call these functions.

@defmac combine-after-change-calls body@dots{}
The macro executes @var{body} normally, but arranges to call the
after-change functions just once for a series of several changes---if
that seems safe.

If a program makes several text changes in the same area of the buffer,
using the macro @code{combine-after-change-calls} around that part of
the program can make it run considerably faster when after-change hooks
are in use.  When the after-change hooks are ultimately called, the
arguments specify a portion of the buffer including all of the changes
made within the @code{combine-after-change-calls} body.

@strong{Warning:} You must not alter the values of
@code{after-change-functions} within
the body of a @code{combine-after-change-calls} form.

@strong{Warning:} if the changes you combine occur in widely scattered
parts of the buffer, this will still work, but it is not advisable,
because it may lead to inefficient behavior for some change hook
functions.
@end defmac

@defvar first-change-hook
This variable is a normal hook that is run whenever a buffer is changed
that was previously in the unmodified state.
@end defvar

@defvar inhibit-modification-hooks
If this variable is non-@code{nil}, all of the change hooks are
disabled; none of them run.  This affects all the hook variables
described above in this section, as well as the hooks attached to
certain special text properties (@pxref{Special Properties}) and overlay
properties (@pxref{Overlay Properties}).

Also, this variable is bound to non-@code{nil} while running those
same hook variables, so that by default modifying the buffer from
a modification hook does not cause other modification hooks to be run.
If you do want modification hooks to be run in a particular piece of
code that is itself run from a modification hook, then rebind locally
@code{inhibit-modification-hooks} to @code{nil}.
@end defvar
