@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2012
@c   Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@setfilename ../../info/buffers
@node Buffers, Windows, Backups and Auto-Saving, Top
@chapter Buffers
@cindex buffer

  A @dfn{buffer} is a Lisp object containing text to be edited.  Buffers
are used to hold the contents of files that are being visited; there may
also be buffers that are not visiting files.  While several buffers may
exist at one time, only one buffer is designated the @dfn{current
buffer} at any time.  Most editing commands act on the contents of the
current buffer.  Each buffer, including the current buffer, may or may
not be displayed in any windows.

@menu
* Buffer Basics::       What is a buffer?
* Current Buffer::      Designating a buffer as current
                          so that primitives will access its contents.
* Buffer Names::        Accessing and changing buffer names.
* Buffer File Name::    The buffer file name indicates which file is visited.
* Buffer Modification:: A buffer is @dfn{modified} if it needs to be saved.
* Modification Time::   Determining whether the visited file was changed
                         "behind Emacs's back".
* Read Only Buffers::   Modifying text is not allowed in a read-only buffer.
* The Buffer List::     How to look at all the existing buffers.
* Creating Buffers::    Functions that create buffers.
* Killing Buffers::     Buffers exist until explicitly killed.
* Indirect Buffers::    An indirect buffer shares text with some other buffer.
* Swapping Text::       Swapping text between two buffers.
* Buffer Gap::          The gap in the buffer.
@end menu

@node Buffer Basics
@comment  node-name,  next,  previous,  up
@section Buffer Basics

@ifnottex
  A @dfn{buffer} is a Lisp object containing text to be edited.  Buffers
are used to hold the contents of files that are being visited; there may
also be buffers that are not visiting files.  Although several buffers
normally exist, only one buffer is designated the @dfn{current
buffer} at any time.  Most editing commands act on the contents of the
current buffer.  Each buffer, including the current buffer, may or may
not be displayed in any windows.
@end ifnottex

  Buffers in Emacs editing are objects that have distinct names and hold
text that can be edited.  Buffers appear to Lisp programs as a special
data type.  You can think of the contents of a buffer as a string that
you can extend; insertions and deletions may occur in any part of the
buffer.  @xref{Text}.

  A Lisp buffer object contains numerous pieces of information.  Some of
this information is directly accessible to the programmer through
variables, while other information is accessible only through
special-purpose functions.  For example, the visited file name is
directly accessible through a variable, while the value of point is
accessible only through a primitive function.

  Buffer-specific information that is directly accessible is stored in
@dfn{buffer-local} variable bindings, which are variable values that are
effective only in a particular buffer.  This feature allows each buffer
to override the values of certain variables.  Most major modes override
variables such as @code{fill-column} or @code{comment-column} in this
way.  For more information about buffer-local variables and functions
related to them, see @ref{Buffer-Local Variables}.

  For functions and variables related to visiting files in buffers, see
@ref{Visiting Files} and @ref{Saving Buffers}.  For functions and
variables related to the display of buffers in windows, see
@ref{Buffers and Windows}.

@defun bufferp object
This function returns @code{t} if @var{object} is a buffer,
@code{nil} otherwise.
@end defun

@node Current Buffer
@section The Current Buffer
@cindex selecting a buffer
@cindex changing to another buffer
@cindex current buffer

  There are, in general, many buffers in an Emacs session.  At any
time, one of them is designated the @dfn{current buffer}---the buffer
in which most editing takes place.  Most of the primitives for
examining or changing text operate implicitly on the current buffer
(@pxref{Text}).

  Normally, the buffer displayed in the selected window is the current
buffer, but this is not always so: a Lisp program can temporarily
designate any buffer as current in order to operate on its contents,
without changing what is displayed on the screen.  The most basic
function for designating a current buffer is @code{set-buffer}.

@defun current-buffer
This function returns the current buffer.

@example
@group
(current-buffer)
     @result{} #<buffer buffers.texi>
@end group
@end example
@end defun

@defun set-buffer buffer-or-name
This function makes @var{buffer-or-name} the current buffer.
@var{buffer-or-name} must be an existing buffer or the name of an
existing buffer.  The return value is the buffer made current.

This function does not display the buffer in any window, so the user
cannot necessarily see the buffer.  But Lisp programs will now operate
on it.
@end defun

  When an editing command returns to the editor command loop, Emacs
automatically calls @code{set-buffer} on the buffer shown in the
selected window.  This is to prevent confusion: it ensures that the
buffer that the cursor is in, when Emacs reads a command, is the
buffer to which that command applies (@pxref{Command Loop}).  Thus,
you should not use @code{set-buffer} to switch visibly to a different
buffer; for that, use the functions described in @ref{Switching
Buffers}.

  When writing a Lisp function, do @emph{not} rely on this behavior of
the command loop to restore the current buffer after an operation.
Editing commands can also be called as Lisp functions by other
programs, not just from the command loop; it is convenient for the
caller if the subroutine does not change which buffer is current
(unless, of course, that is the subroutine's purpose).

  To operate temporarily on another buffer, put the @code{set-buffer}
within a @code{save-current-buffer} form.  Here, as an example, is a
simplified version of the command @code{append-to-buffer}:

@example
@group
(defun append-to-buffer (buffer start end)
  "Append the text of the region to BUFFER."
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (save-current-buffer
      (set-buffer (get-buffer-create buffer))
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

@noindent
Here, we bind a local variable to record the current buffer, and then
@code{save-current-buffer} arranges to make it current again later.
Next, @code{set-buffer} makes the specified buffer current, and
@code{insert-buffer-substring} copies the string from the original
buffer to the specified (and now current) buffer.

  Alternatively, we can use the @code{with-current-buffer} macro:

@example
@group
(defun append-to-buffer (buffer start end)
  "Append the text of the region to BUFFER."
  (interactive "BAppend to buffer: \nr")
  (let ((oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (insert-buffer-substring oldbuf start end))))
@end group
@end example

  In either case, if the buffer appended to happens to be displayed in
some window, the next redisplay will show how its text has changed.
If it is not displayed in any window, you will not see the change
immediately on the screen.  The command causes the buffer to become
current temporarily, but does not cause it to be displayed.

  If you make local bindings (with @code{let} or function arguments)
for a variable that may also have buffer-local bindings, make sure
that the same buffer is current at the beginning and at the end of the
local binding's scope.  Otherwise you might bind it in one buffer and
unbind it in another!

  Do not rely on using @code{set-buffer} to change the current buffer
back, because that won't do the job if a quit happens while the wrong
buffer is current.  For instance, in the previous example, it would
have been wrong to do this:

@example
@group
  (let ((oldbuf (current-buffer)))
    (set-buffer (get-buffer-create buffer))
    (insert-buffer-substring oldbuf start end)
    (set-buffer oldbuf))
@end group
@end example

@noindent
Using @code{save-current-buffer} or @code{with-current-buffer}, as we
did, correctly handles quitting, errors, and @code{throw}, as well as
ordinary evaluation.

@defspec save-current-buffer body@dots{}
The @code{save-current-buffer} special form saves the identity of the
current buffer, evaluates the @var{body} forms, and finally restores
that buffer as current.  The return value is the value of the last
form in @var{body}.  The current buffer is restored even in case of an
abnormal exit via @code{throw} or error (@pxref{Nonlocal Exits}).

If the buffer that used to be current has been killed by the time of
exit from @code{save-current-buffer}, then it is not made current again,
of course.  Instead, whichever buffer was current just before exit
remains current.
@end defspec

@defmac with-current-buffer buffer-or-name body@dots{}
The @code{with-current-buffer} macro saves the identity of the current
buffer, makes @var{buffer-or-name} current, evaluates the @var{body}
forms, and finally restores the current buffer.  @var{buffer-or-name}
must specify an existing buffer or the name of an existing buffer.

The return value is the value of the last form in @var{body}.  The
current buffer is restored even in case of an abnormal exit via
@code{throw} or error (@pxref{Nonlocal Exits}).
@end defmac

@defmac with-temp-buffer body@dots{}
@anchor{Definition of with-temp-buffer}
The @code{with-temp-buffer} macro evaluates the @var{body} forms
with a temporary buffer as the current buffer.  It saves the identity of
the current buffer, creates a temporary buffer and makes it current,
evaluates the @var{body} forms, and finally restores the previous
current buffer while killing the temporary buffer.  By default, undo
information (@pxref{Undo}) is not recorded in the buffer created by
this macro (but @var{body} can enable that, if needed).

The return value is the value of the last form in @var{body}.  You can
return the contents of the temporary buffer by using
@code{(buffer-string)} as the last form.

The current buffer is restored even in case of an abnormal exit via
@code{throw} or error (@pxref{Nonlocal Exits}).

See also @code{with-temp-file} in @ref{Definition of with-temp-file,,
Writing to Files}.
@end defmac

@node Buffer Names
@section Buffer Names
@cindex buffer names

  Each buffer has a unique name, which is a string.  Many of the
functions that work on buffers accept either a buffer or a buffer name
as an argument.  Any argument called @var{buffer-or-name} is of this
sort, and an error is signaled if it is neither a string nor a buffer.
Any argument called @var{buffer} must be an actual buffer
object, not a name.

@cindex hidden buffers
@cindex buffers without undo information
  Buffers that are ephemeral and generally uninteresting to the user
have names starting with a space, so that the @code{list-buffers} and
@code{buffer-menu} commands don't mention them (but if such a buffer
visits a file, it @strong{is} mentioned).  A name starting with
space also initially disables recording undo information; see
@ref{Undo}.

@defun buffer-name &optional buffer
This function returns the name of @var{buffer} as a string.
@var{buffer} defaults to the current buffer.

If @code{buffer-name} returns @code{nil}, it means that @var{buffer}
has been killed.  @xref{Killing Buffers}.

@example
@group
(buffer-name)
     @result{} "buffers.texi"
@end group

@group
(setq foo (get-buffer "temp"))
     @result{} #<buffer temp>
@end group
@group
(kill-buffer foo)
     @result{} nil
@end group
@group
(buffer-name foo)
     @result{} nil
@end group
@group
foo
     @result{} #<killed buffer>
@end group
@end example
@end defun

@deffn Command rename-buffer newname &optional unique
This function renames the current buffer to @var{newname}.  An error
is signaled if @var{newname} is not a string.

@c Emacs 19 feature
Ordinarily, @code{rename-buffer} signals an error if @var{newname} is
already in use.  However, if @var{unique} is non-@code{nil}, it modifies
@var{newname} to make a name that is not in use.  Interactively, you can
make @var{unique} non-@code{nil} with a numeric prefix argument.
(This is how the command @code{rename-uniquely} is implemented.)

This function returns the name actually given to the buffer.
@end deffn

@defun get-buffer buffer-or-name
This function returns the buffer specified by @var{buffer-or-name}.
If @var{buffer-or-name} is a string and there is no buffer with that
name, the value is @code{nil}.  If @var{buffer-or-name} is a buffer, it
is returned as given; that is not very useful, so the argument is usually
a name.  For example:

@example
@group
(setq b (get-buffer "lewis"))
     @result{} #<buffer lewis>
@end group
@group
(get-buffer b)
     @result{} #<buffer lewis>
@end group
@group
(get-buffer "Frazzle-nots")
     @result{} nil
@end group
@end example

See also the function @code{get-buffer-create} in @ref{Creating Buffers}.
@end defun

@c Emacs 19 feature
@defun generate-new-buffer-name starting-name &optional ignore
This function returns a name that would be unique for a new buffer---but
does not create the buffer.  It starts with @var{starting-name}, and
produces a name not currently in use for any buffer by appending a
number inside of @samp{<@dots{}>}.  It starts at 2 and keeps
incrementing the number until it is not the name of an existing buffer.

If the optional second argument @var{ignore} is non-@code{nil}, it
should be a string, a potential buffer name.  It means to consider
that potential buffer acceptable, if it is tried, even it is the name
of an existing buffer (which would normally be rejected).  Thus, if
buffers named @samp{foo}, @samp{foo<2>}, @samp{foo<3>} and
@samp{foo<4>} exist,

@example
(generate-new-buffer-name "foo")
     @result{} "foo<5>"
(generate-new-buffer-name "foo" "foo<3>")
     @result{} "foo<3>"
(generate-new-buffer-name "foo" "foo<6>")
     @result{} "foo<5>"
@end example

See the related function @code{generate-new-buffer} in @ref{Creating
Buffers}.
@end defun

@node Buffer File Name
@section Buffer File Name
@cindex visited file
@cindex buffer file name
@cindex file name of buffer

  The @dfn{buffer file name} is the name of the file that is visited in
that buffer.  When a buffer is not visiting a file, its buffer file name
is @code{nil}.  Most of the time, the buffer name is the same as the
nondirectory part of the buffer file name, but the buffer file name and
the buffer name are distinct and can be set independently.
@xref{Visiting Files}.

@defun buffer-file-name &optional buffer
This function returns the absolute file name of the file that
@var{buffer} is visiting.  If @var{buffer} is not visiting any file,
@code{buffer-file-name} returns @code{nil}.  If @var{buffer} is not
supplied, it defaults to the current buffer.

@example
@group
(buffer-file-name (other-buffer))
     @result{} "/usr/user/lewis/manual/files.texi"
@end group
@end example
@end defun

@defvar buffer-file-name
This buffer-local variable contains the name of the file being visited
in the current buffer, or @code{nil} if it is not visiting a file.  It
is a permanent local variable, unaffected by
@code{kill-all-local-variables}.

@example
@group
buffer-file-name
     @result{} "/usr/user/lewis/manual/buffers.texi"
@end group
@end example

It is risky to change this variable's value without doing various other
things.  Normally it is better to use @code{set-visited-file-name} (see
below); some of the things done there, such as changing the buffer name,
are not strictly necessary, but others are essential to avoid confusing
Emacs.
@end defvar

@defvar buffer-file-truename
This buffer-local variable holds the abbreviated truename of the file
visited in the current buffer, or @code{nil} if no file is visited.
It is a permanent local, unaffected by
@code{kill-all-local-variables}.  @xref{Truenames}, and
@ref{abbreviate-file-name}.
@end defvar

@defvar buffer-file-number
This buffer-local variable holds the file number and directory device
number of the file visited in the current buffer, or @code{nil} if no
file or a nonexistent file is visited.  It is a permanent local,
unaffected by @code{kill-all-local-variables}.

The value is normally a list of the form @code{(@var{filenum}
@var{devnum})}.  This pair of numbers uniquely identifies the file among
all files accessible on the system.  See the function
@code{file-attributes}, in @ref{File Attributes}, for more information
about them.

If @code{buffer-file-name} is the name of a symbolic link, then both
numbers refer to the recursive target.
@end defvar

@defun get-file-buffer filename
This function returns the buffer visiting file @var{filename}.  If
there is no such buffer, it returns @code{nil}.  The argument
@var{filename}, which must be a string, is expanded (@pxref{File Name
Expansion}), then compared against the visited file names of all live
buffers.  Note that the buffer's @code{buffer-file-name} must match
the expansion of @var{filename} exactly.  This function will not
recognize other names for the same file.

@example
@group
(get-file-buffer "buffers.texi")
    @result{} #<buffer buffers.texi>
@end group
@end example

In unusual circumstances, there can be more than one buffer visiting
the same file name.  In such cases, this function returns the first
such buffer in the buffer list.
@end defun

@defun find-buffer-visiting filename &optional predicate
This is like @code{get-file-buffer}, except that it can return any
buffer visiting the file @emph{possibly under a different name}.  That
is, the buffer's @code{buffer-file-name} does not need to match the
expansion of @var{filename} exactly, it only needs to refer to the
same file.  If @var{predicate} is non-@code{nil}, it should be a
function of one argument, a buffer visiting @var{filename}.  The
buffer is only considered a suitable return value if @var{predicate}
returns non-@code{nil}.  If it can not find a suitable buffer to
return, @code{find-buffer-visiting} returns @code{nil}.
@end defun

@deffn Command set-visited-file-name filename &optional no-query along-with-file
If @var{filename} is a non-empty string, this function changes the
name of the file visited in the current buffer to @var{filename}.  (If the
buffer had no visited file, this gives it one.)  The @emph{next time}
the buffer is saved it will go in the newly-specified file.

This command marks the buffer as modified, since it does not (as far
as Emacs knows) match the contents of @var{filename}, even if it
matched the former visited file.  It also renames the buffer to
correspond to the new file name, unless the new name is already in
use.

If @var{filename} is @code{nil} or the empty string, that stands for
``no visited file''.  In this case, @code{set-visited-file-name} marks
the buffer as having no visited file, without changing the buffer's
modified flag.

Normally, this function asks the user for confirmation if there
already is a buffer visiting @var{filename}.  If @var{no-query} is
non-@code{nil}, that prevents asking this question.  If there already
is a buffer visiting @var{filename}, and the user confirms or
@var{query} is non-@code{nil}, this function makes the new buffer name
unique by appending a number inside of @samp{<@dots{}>} to @var{filename}.

If @var{along-with-file} is non-@code{nil}, that means to assume that
the former visited file has been renamed to @var{filename}.  In this
case, the command does not change the buffer's modified flag, nor the
buffer's recorded last file modification time as reported by
@code{visited-file-modtime} (@pxref{Modification Time}).  If
@var{along-with-file} is @code{nil}, this function clears the recorded
last file modification time, after which @code{visited-file-modtime}
returns zero.

When the function @code{set-visited-file-name} is called
interactively, it prompts for @var{filename} in the minibuffer.
@end deffn

@defvar list-buffers-directory
This buffer-local variable specifies a string to display in a buffer
listing where the visited file name would go, for buffers that don't
have a visited file name.  Dired buffers use this variable.
@end defvar

@node Buffer Modification
@section Buffer Modification
@cindex buffer modification
@cindex modification flag (of buffer)

  Emacs keeps a flag called the @dfn{modified flag} for each buffer, to
record whether you have changed the text of the buffer.  This flag is
set to @code{t} whenever you alter the contents of the buffer, and
cleared to @code{nil} when you save it.  Thus, the flag shows whether
there are unsaved changes.  The flag value is normally shown in the mode
line (@pxref{Mode Line Variables}), and controls saving (@pxref{Saving
Buffers}) and auto-saving (@pxref{Auto-Saving}).

  Some Lisp programs set the flag explicitly.  For example, the function
@code{set-visited-file-name} sets the flag to @code{t}, because the text
does not match the newly-visited file, even if it is unchanged from the
file formerly visited.

  The functions that modify the contents of buffers are described in
@ref{Text}.

@defun buffer-modified-p &optional buffer
This function returns @code{t} if the buffer @var{buffer} has been modified
since it was last read in from a file or saved, or @code{nil}
otherwise.  If @var{buffer} is not supplied, the current buffer
is tested.
@end defun

@defun set-buffer-modified-p flag
This function marks the current buffer as modified if @var{flag} is
non-@code{nil}, or as unmodified if the flag is @code{nil}.

Another effect of calling this function is to cause unconditional
redisplay of the mode line for the current buffer.  In fact, the
function @code{force-mode-line-update} works by doing this:

@example
@group
(set-buffer-modified-p (buffer-modified-p))
@end group
@end example
@end defun

@defun restore-buffer-modified-p flag
Like @code{set-buffer-modified-p}, but does not force redisplay
of mode lines.
@end defun

@deffn Command not-modified &optional arg
This command marks the current buffer as unmodified, and not needing
to be saved.  If @var{arg} is non-@code{nil}, it marks the buffer as
modified, so that it will be saved at the next suitable occasion.
Interactively, @var{arg} is the prefix argument.

Don't use this function in programs, since it prints a message in the
echo area; use @code{set-buffer-modified-p} (above) instead.
@end deffn

@defun buffer-modified-tick &optional buffer
This function returns @var{buffer}'s modification-count.  This is a
counter that increments every time the buffer is modified.  If
@var{buffer} is @code{nil} (or omitted), the current buffer is used.
The counter can wrap around occasionally.
@end defun

@defun buffer-chars-modified-tick &optional buffer
This function returns @var{buffer}'s character-change modification-count.
Changes to text properties leave this counter unchanged; however, each
time text is inserted or removed from the buffer, the counter is reset
to the value that would be returned by @code{buffer-modified-tick}.
By comparing the values returned by two @code{buffer-chars-modified-tick}
calls, you can tell whether a character change occurred in that buffer
in between the calls.  If @var{buffer} is @code{nil} (or omitted), the
current buffer is used.
@end defun

@node Modification Time
@comment  node-name,  next,  previous,  up
@section Buffer Modification Time
@cindex comparing file modification time
@cindex modification time of buffer

  Suppose that you visit a file and make changes in its buffer, and
meanwhile the file itself is changed on disk.  At this point, saving the
buffer would overwrite the changes in the file.  Occasionally this may
be what you want, but usually it would lose valuable information.  Emacs
therefore checks the file's modification time using the functions
described below before saving the file.  (@xref{File Attributes},
for how to examine a file's modification time.)

@defun verify-visited-file-modtime &optional buffer
This function compares what @var{buffer} (by default, the
current-buffer) has recorded for the modification time of its visited
file against the actual modification time of the file as recorded by the
operating system.  The two should be the same unless some other process
has written the file since Emacs visited or saved it.

The function returns @code{t} if the last actual modification time and
Emacs's recorded modification time are the same, @code{nil} otherwise.
It also returns @code{t} if the buffer has no recorded last
modification time, that is if @code{visited-file-modtime} would return
zero.

It always returns @code{t} for buffers that are not visiting a file,
even if @code{visited-file-modtime} returns a non-zero value.  For
instance, it always returns @code{t} for dired buffers.  It returns
@code{t} for buffers that are visiting a file that does not exist and
never existed, but @code{nil} for file-visiting buffers whose file has
been deleted.
@end defun

@defun clear-visited-file-modtime
This function clears out the record of the last modification time of
the file being visited by the current buffer.  As a result, the next
attempt to save this buffer will not complain of a discrepancy in
file modification times.

This function is called in @code{set-visited-file-name} and other
exceptional places where the usual test to avoid overwriting a changed
file should not be done.
@end defun

@c Emacs 19 feature
@defun visited-file-modtime
This function returns the current buffer's recorded last file
modification time, as a list of the form @code{(@var{high} @var{low})}.
(This is the same format that @code{file-attributes} uses to return
time values; see @ref{File Attributes}.)

If the buffer has no recorded last modification time, this function
returns zero.  This case occurs, for instance, if the buffer is not
visiting a file or if the time has been explicitly cleared by
@code{clear-visited-file-modtime}.  Note, however, that
@code{visited-file-modtime} returns a list for some non-file buffers
too.  For instance, in a Dired buffer listing a directory, it returns
the last modification time of that directory, as recorded by Dired.

For a new buffer visiting a not yet existing file, @var{high} is
@minus{}1 and @var{low} is 65535, that is,
@ifnottex
@w{2**16 - 1.}
@end ifnottex
@tex
@math{2^{16}-1}.
@end tex
@end defun

@c Emacs 19 feature
@defun set-visited-file-modtime &optional time
This function updates the buffer's record of the last modification time
of the visited file, to the value specified by @var{time} if @var{time}
is not @code{nil}, and otherwise to the last modification time of the
visited file.

If @var{time} is neither @code{nil} nor zero, it should have the form
@code{(@var{high} . @var{low})} or @code{(@var{high} @var{low})}, in
either case containing two integers, each of which holds 16 bits of the
time.

This function is useful if the buffer was not read from the file
normally, or if the file itself has been changed for some known benign
reason.
@end defun

@defun ask-user-about-supersession-threat filename
This function is used to ask a user how to proceed after an attempt to
modify an buffer visiting file @var{filename} when the file is newer
than the buffer text.  Emacs detects this because the modification
time of the file on disk is newer than the last save-time of the
buffer.  This means some other program has probably altered the file.

@kindex file-supersession
Depending on the user's answer, the function may return normally, in
which case the modification of the buffer proceeds, or it may signal a
@code{file-supersession} error with data @code{(@var{filename})}, in which
case the proposed buffer modification is not allowed.

This function is called automatically by Emacs on the proper
occasions.  It exists so you can customize Emacs by redefining it.
See the file @file{userlock.el} for the standard definition.

See also the file locking mechanism in @ref{File Locks}.
@end defun

@node Read Only Buffers
@section Read-Only Buffers
@cindex read-only buffer
@cindex buffer, read-only

  If a buffer is @dfn{read-only}, then you cannot change its contents,
although you may change your view of the contents by scrolling and
narrowing.

  Read-only buffers are used in two kinds of situations:

@itemize @bullet
@item
A buffer visiting a write-protected file is normally read-only.

Here, the purpose is to inform the user that editing the buffer with the
aim of saving it in the file may be futile or undesirable.  The user who
wants to change the buffer text despite this can do so after clearing
the read-only flag with @kbd{C-x C-q}.

@item
Modes such as Dired and Rmail make buffers read-only when altering the
contents with the usual editing commands would probably be a mistake.

The special commands of these modes bind @code{buffer-read-only} to
@code{nil} (with @code{let}) or bind @code{inhibit-read-only} to
@code{t} around the places where they themselves change the text.
@end itemize

@defvar buffer-read-only
This buffer-local variable specifies whether the buffer is read-only.
The buffer is read-only if this variable is non-@code{nil}.
@end defvar

@defvar inhibit-read-only
If this variable is non-@code{nil}, then read-only buffers and,
depending on the actual value, some or all read-only characters may be
modified.  Read-only characters in a buffer are those that have
non-@code{nil} @code{read-only} properties (either text properties or
overlay properties).  @xref{Special Properties}, for more information
about text properties.  @xref{Overlays}, for more information about
overlays and their properties.

If @code{inhibit-read-only} is @code{t}, all @code{read-only} character
properties have no effect.  If @code{inhibit-read-only} is a list, then
@code{read-only} character properties have no effect if they are members
of the list (comparison is done with @code{eq}).
@end defvar

@deffn Command toggle-read-only &optional arg
This command toggles whether the current buffer is read-only.  It is
intended for interactive use; do not use it in programs (it may have
side-effects, such as enabling View mode, and does not affect
read-only text properties).  To change the read-only state of a buffer in
a program, explicitly set @code{buffer-read-only} to the proper value.
To temporarily ignore a read-only state, bind @code{inhibit-read-only}.

If @var{arg} is non-@code{nil}, it should be a raw prefix argument.
@code{toggle-read-only} sets @code{buffer-read-only} to @code{t} if
the numeric value of that prefix argument is positive and to
@code{nil} otherwise.  @xref{Prefix Command Arguments}.
@end deffn

@defun barf-if-buffer-read-only
This function signals a @code{buffer-read-only} error if the current
buffer is read-only.  @xref{Using Interactive}, for another way to
signal an error if the current buffer is read-only.
@end defun

@node The Buffer List
@section The Buffer List
@cindex buffer list

  The @dfn{buffer list} is a list of all live buffers.  The order of the
buffers in this list is based primarily on how recently each buffer has
been displayed in a window.  Several functions, notably
@code{other-buffer}, use this ordering.  A buffer list displayed for the
user also follows this order.

  Creating a buffer adds it to the end of the buffer list, and killing
a buffer removes it from that list.  A buffer moves to the front of
this list whenever it is chosen for display in a window
(@pxref{Switching Buffers}) or a window displaying it is selected
(@pxref{Selecting Windows}).  A buffer moves to the end of the list
when it is buried (see @code{bury-buffer}, below).  There are no
functions available to the Lisp programmer which directly manipulate
the buffer list.

  In addition to the fundamental buffer list just described, Emacs
maintains a local buffer list for each frame, in which the buffers that
have been displayed (or had their windows selected) in that frame come
first.  (This order is recorded in the frame's @code{buffer-list} frame
parameter; see @ref{Buffer Parameters}.)  Buffers never displayed in
that frame come afterward, ordered according to the fundamental buffer
list.

@defun buffer-list &optional frame
This function returns the buffer list, including all buffers, even those
whose names begin with a space.  The elements are actual buffers, not
their names.

If @var{frame} is a frame, this returns @var{frame}'s local buffer list.
If @var{frame} is @code{nil} or omitted, the fundamental buffer list is
used: the buffers appear in order of most recent display or selection,
regardless of which frames they were displayed on.

@example
@group
(buffer-list)
     @result{} (#<buffer buffers.texi>
         #<buffer  *Minibuf-1*> #<buffer buffer.c>
         #<buffer *Help*> #<buffer TAGS>)
@end group

@group
;; @r{Note that the name of the minibuffer}
;;   @r{begins with a space!}
(mapcar (function buffer-name) (buffer-list))
    @result{} ("buffers.texi" " *Minibuf-1*"
        "buffer.c" "*Help*" "TAGS")
@end group
@end example
@end defun

  The list returned by @code{buffer-list} is constructed specifically;
it is not an internal Emacs data structure, and modifying it has no
effect on the order of buffers.  If you want to change the order of
buffers in the fundamental buffer list, here is an easy way:

@example
(defun reorder-buffer-list (new-list)
  (while new-list
    (bury-buffer (car new-list))
    (setq new-list (cdr new-list))))
@end example

  With this method, you can specify any order for the list, but there is
no danger of losing a buffer or adding something that is not a valid
live buffer.

  To change the order or value of a specific frame's buffer list, set
that frame's @code{buffer-list} parameter with
@code{modify-frame-parameters} (@pxref{Parameter Access}).

@defun other-buffer &optional buffer visible-ok frame
This function returns the first buffer in the buffer list other than
@var{buffer}.  Usually, this is the buffer appearing in the most
recently selected window (in frame @var{frame} or else the selected
frame, @pxref{Input Focus}), aside from @var{buffer}.  Buffers whose
names start with a space are not considered at all.

If @var{buffer} is not supplied (or if it is not a live buffer), then
@code{other-buffer} returns the first buffer in the selected frame's
local buffer list. (If @var{frame} is non-@code{nil}, it returns the
first buffer in @var{frame}'s local buffer list instead.)

If @var{frame} has a non-@code{nil} @code{buffer-predicate} parameter,
then @code{other-buffer} uses that predicate to decide which buffers to
consider.  It calls the predicate once for each buffer, and if the value
is @code{nil}, that buffer is ignored.  @xref{Buffer Parameters}.

@c Emacs 19 feature
If @var{visible-ok} is @code{nil}, @code{other-buffer} avoids returning
a buffer visible in any window on any visible frame, except as a last
resort.  If @var{visible-ok} is non-@code{nil}, then it does not matter
whether a buffer is displayed somewhere or not.

If no suitable buffer exists, the buffer @file{*scratch*} is returned
(and created, if necessary).
@end defun

@defun last-buffer &optional buffer visible-ok frame
This function returns the last buffer in @var{frame}'s buffer list other
than @var{BUFFER}.  If @var{frame} is omitted or @code{nil}, it uses the
selected frame's buffer list.

The argument @var{visible-ok} is handled as with @code{other-buffer},
see above.  If no suitable buffer can be found, the buffer
@file{*scratch*} is returned.
@end defun

@deffn Command bury-buffer &optional buffer-or-name
This command puts @var{buffer-or-name} at the end of the buffer list,
without changing the order of any of the other buffers on the list.
This buffer therefore becomes the least desirable candidate for
@code{other-buffer} to return.  The argument can be either a buffer
itself or the name of one.

This functions operates on each frame's @code{buffer-list} parameter as
well as the fundamental buffer list; therefore, the buffer that you bury
will come last in the value of @code{(buffer-list @var{frame})} and in
the value of @code{(buffer-list)}.  In addition, it also puts the buffer
at the end of the list of buffer of the selected window (@pxref{Window
History}) provided it is shown in that window.

If @var{buffer-or-name} is @code{nil} or omitted, this means to bury the
current buffer.  In addition, if the current buffer is displayed in the
selected window, this makes sure that the window is either deleted or
another buffer is shown in it.  More precisely, if the window is
dedicated (@pxref{Dedicated Windows}) and there are other windows on its
frame, the window is deleted.  If the window is both dedicated and the
only window on its frame's terminal, the function specified by
@code{frame-auto-hide-function} (@pxref{Quitting Windows}) will deal
with the window.  If the window is not dedicated to its buffer, it calls
@code{switch-to-prev-buffer} (@pxref{Window History}) to show another
buffer in that window.  If @var{buffer-or-name} is displayed in some
other window, it remains displayed there.

To replace a buffer in all the windows that display it, use
@code{replace-buffer-in-windows}, @xref{Buffers and Windows}.
@end deffn

@deffn Command unbury-buffer
This command switches to the last buffer in the local buffer list of
the selected frame.  More precisely, it calls the function
@code{switch-to-buffer} (@pxref{Switching Buffers}), to display the
buffer returned by @code{last-buffer} (see above), in the selected
window.
@end deffn


@node Creating Buffers
@section Creating Buffers
@cindex creating buffers
@cindex buffers, creating

  This section describes the two primitives for creating buffers.
@code{get-buffer-create} creates a buffer if it finds no existing buffer
with the specified name; @code{generate-new-buffer} always creates a new
buffer and gives it a unique name.

  Other functions you can use to create buffers include
@code{with-output-to-temp-buffer} (@pxref{Temporary Displays}) and
@code{create-file-buffer} (@pxref{Visiting Files}).  Starting a
subprocess can also create a buffer (@pxref{Processes}).

@defun get-buffer-create buffer-or-name
This function returns a buffer named @var{buffer-or-name}.  The buffer
returned does not become the current buffer---this function does not
change which buffer is current.

@var{buffer-or-name} must be either a string or an existing buffer.  If
it is a string and a live buffer with that name already exists,
@code{get-buffer-create} returns that buffer.  If no such buffer exists,
it creates a new buffer.  If @var{buffer-or-name} is a buffer instead of
a string, it is returned as given, even if it is dead.

@example
@group
(get-buffer-create "foo")
     @result{} #<buffer foo>
@end group
@end example

The major mode for a newly created buffer is set to Fundamental mode.
(The default value of the variable @code{major-mode} is handled at a higher
level; see @ref{Auto Major Mode}.)  If the name begins with a space, the
buffer initially disables undo information recording (@pxref{Undo}).
@end defun

@defun generate-new-buffer name
This function returns a newly created, empty buffer, but does not make
it current.  The name of the buffer is generated by passing @var{name}
to the function @code{generate-new-buffer-name} (@pxref{Buffer
Names}).  Thus, if there is no buffer named @var{name}, then that is
the name of the new buffer; if that name is in use, a suffix of the
form @samp{<@var{n}>}, where @var{n} is an integer, is appended to
@var{name}.

An error is signaled if @var{name} is not a string.

@example
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<2>>
@end group
@group
(generate-new-buffer "bar")
     @result{} #<buffer bar<3>>
@end group
@end example

The major mode for the new buffer is set to Fundamental mode.  The default
value of the variable @code{major-mode} is handled at a higher level.
@xref{Auto Major Mode}.
@end defun

@node Killing Buffers
@section Killing Buffers
@cindex killing buffers
@cindex buffers, killing

  @dfn{Killing a buffer} makes its name unknown to Emacs and makes the
memory space it occupied available for other use.

  The buffer object for the buffer that has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; if you kill two distinct buffers, they remain
distinct according to @code{eq} although both are dead.

  If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This
means that killing a buffer can change the current buffer.  Therefore,
when you kill a buffer, you should also take the precautions
associated with changing the current buffer (unless you happen to know
that the buffer being killed isn't current).  @xref{Current Buffer}.

  If you kill a buffer that is the base buffer of one or more indirect
@iftex
buffers,
@end iftex
@ifnottex
buffers (@pxref{Indirect Buffers}),
@end ifnottex
the indirect buffers are automatically killed as well.

@cindex live buffer
  The @code{buffer-name} of a buffer is @code{nil} if, and only if,
the buffer is killed.  A buffer that has not been killed is called a
@dfn{live} buffer.  To test whether a buffer is live or killed, use
the function @code{buffer-live-p} (see below).

@deffn Command kill-buffer &optional buffer-or-name
This function kills the buffer @var{buffer-or-name}, freeing all its
memory for other uses or to be returned to the operating system.  If
@var{buffer-or-name} is @code{nil} or omitted, it kills the current
buffer.

Any processes that have this buffer as the @code{process-buffer} are
sent the @code{SIGHUP} (``hangup'') signal, which normally causes them
to terminate.  @xref{Signals to Processes}.

If the buffer is visiting a file and contains unsaved changes,
@code{kill-buffer} asks the user to confirm before the buffer is killed.
It does this even if not called interactively.  To prevent the request
for confirmation, clear the modified flag before calling
@code{kill-buffer}.  @xref{Buffer Modification}.

This function calls @code{replace-buffer-in-windows} for cleaning up
all windows currently displaying the buffer to be killed.

Killing a buffer that is already dead has no effect.

This function returns @code{t} if it actually killed the buffer.  It
returns @code{nil} if the user refuses to confirm or if
@var{buffer-or-name} was already dead.

@smallexample
(kill-buffer "foo.unchanged")
     @result{} t
(kill-buffer "foo.changed")

---------- Buffer: Minibuffer ----------
Buffer foo.changed modified; kill anyway? (yes or no) @kbd{yes}
---------- Buffer: Minibuffer ----------

     @result{} t
@end smallexample
@end deffn

@defvar kill-buffer-query-functions
After confirming unsaved changes, @code{kill-buffer} calls the functions
in the list @code{kill-buffer-query-functions}, in order of appearance,
with no arguments.  The buffer being killed is the current buffer when
they are called.  The idea of this feature is that these functions will
ask for confirmation from the user.  If any of them returns @code{nil},
@code{kill-buffer} spares the buffer's life.
@end defvar

@defvar kill-buffer-hook
This is a normal hook run by @code{kill-buffer} after asking all the
questions it is going to ask, just before actually killing the buffer.
The buffer to be killed is current when the hook functions run.
@xref{Hooks}.  This variable is a permanent local, so its local binding
is not cleared by changing major modes.
@end defvar

@defopt buffer-offer-save
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} (if the
second optional argument to that function is @code{t}) to offer to
save that buffer, just as they offer to save file-visiting buffers.
@xref{Definition of save-some-buffers}.  The variable
@code{buffer-offer-save} automatically becomes buffer-local when set
for any reason.  @xref{Buffer-Local Variables}.
@end defopt

@defvar buffer-save-without-query
This variable, if non-@code{nil} in a particular buffer, tells
@code{save-buffers-kill-emacs} and @code{save-some-buffers} to save
this buffer (if it's modified) without asking the user.  The variable
automatically becomes buffer-local when set for any reason.
@end defvar

@defun buffer-live-p object
This function returns @code{t} if @var{object} is a live buffer (a
buffer which has not been killed), @code{nil} otherwise.
@end defun

@node Indirect Buffers
@section Indirect Buffers
@cindex indirect buffers
@cindex base buffer

  An @dfn{indirect buffer} shares the text of some other buffer, which
is called the @dfn{base buffer} of the indirect buffer.  In some ways it
is the analogue, for buffers, of a symbolic link among files.  The base
buffer may not itself be an indirect buffer.

  The text of the indirect buffer is always identical to the text of its
base buffer; changes made by editing either one are visible immediately
in the other.  This includes the text properties as well as the characters
themselves.

  In all other respects, the indirect buffer and its base buffer are
completely separate.  They have different names, independent values of
point, independent narrowing, independent markers and overlays (though
inserting or deleting text in either buffer relocates the markers and
overlays for both), independent major modes, and independent
buffer-local variable bindings.

  An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually saves the base
buffer.

  Killing an indirect buffer has no effect on its base buffer.  Killing
the base buffer effectively kills the indirect buffer in that it cannot
ever again be the current buffer.

@deffn Command make-indirect-buffer base-buffer name &optional clone
This creates and returns an indirect buffer named @var{name} whose
base buffer is @var{base-buffer}.  The argument @var{base-buffer} may
be a live buffer or the name (a string) of an existing buffer.  If
@var{name} is the name of an existing buffer, an error is signaled.

If @var{clone} is non-@code{nil}, then the indirect buffer originally
shares the ``state'' of @var{base-buffer} such as major mode, minor
modes, buffer local variables and so on.  If @var{clone} is omitted
or @code{nil} the indirect buffer's state is set to the default state
for new buffers.

If @var{base-buffer} is an indirect buffer, its base buffer is used as
the base for the new buffer.  If, in addition, @var{clone} is
non-@code{nil}, the initial state is copied from the actual base
buffer, not from @var{base-buffer}.
@end deffn

@deffn Command clone-indirect-buffer newname display-flag &optional norecord
This function creates and returns a new indirect buffer that shares
the current buffer's base buffer and copies the rest of the current
buffer's attributes.  (If the current buffer is not indirect, it is
used as the base buffer.)

If @var{display-flag} is non-@code{nil}, that means to display the new
buffer by calling @code{pop-to-buffer}.  If @var{norecord} is
non-@code{nil}, that means not to put the new buffer to the front of
the buffer list.
@end deffn

@defun buffer-base-buffer &optional buffer
This function returns the base buffer of @var{buffer}, which defaults
to the current buffer.  If @var{buffer} is not indirect, the value is
@code{nil}.  Otherwise, the value is another buffer, which is never an
indirect buffer.
@end defun

@node Swapping Text
@section Swapping Text Between Two Buffers
@cindex swap text between buffers
@cindex virtual buffers

  Specialized modes sometimes need to let the user access from the
same buffer several vastly different types of text.  For example, you
may need to display a summary of the buffer text, in addition to
letting the user access the text itself.

  This could be implemented with multiple buffers (kept in sync when
the user edits the text), or with narrowing (@pxref{Narrowing}).  But
these alternatives might sometimes become tedious or prohibitively
expensive, especially if each type of text requires expensive
buffer-global operations in order to provide correct display and
editing commands.

  Emacs provides another facility for such modes: you can quickly swap
buffer text between two buffers with @code{buffer-swap-text}.  This
function is very fast because it doesn't move any text, it only
changes the internal data structures of the buffer object to point to
a different chunk of text.  Using it, you can pretend that a group of
two or more buffers are actually a single virtual buffer that holds
the contents of all the individual buffers together.

@defun buffer-swap-text buffer
This function swaps the text of the current buffer and that of its
argument @var{buffer}.  It signals an error if one of the two buffers
is an indirect buffer (@pxref{Indirect Buffers}) or is a base buffer
of an indirect buffer.

All the buffer properties that are related to the buffer text are
swapped as well: the positions of point and mark, all the markers, the
overlays, the text properties, the undo list, the value of the
@code{enable-multibyte-characters} flag (@pxref{Text Representations,
enable-multibyte-characters}), etc.
@end defun

  If you use @code{buffer-swap-text} on a file-visiting buffer, you
should set up a hook to save the buffer's original text rather than
what it was swapped with.  @code{write-region-annotate-functions}
works for this purpose.  You should probably set
@code{buffer-saved-size} to @minus{}2 in the buffer, so that changes
in the text it is swapped with will not interfere with auto-saving.

@node Buffer Gap
@section The Buffer Gap

  Emacs buffers are implemented using an invisible @dfn{gap} to make
insertion and deletion faster.  Insertion works by filling in part of
the gap, and deletion adds to the gap.  Of course, this means that the
gap must first be moved to the locus of the insertion or deletion.
Emacs moves the gap only when you try to insert or delete.  This is why
your first editing command in one part of a large buffer, after
previously editing in another far-away part, sometimes involves a
noticeable delay.

  This mechanism works invisibly, and Lisp code should never be affected
by the gap's current location, but these functions are available for
getting information about the gap status.

@defun gap-position
This function returns the current gap position in the current buffer.
@end defun

@defun gap-size
This function returns the current gap size of the current buffer.
@end defun

