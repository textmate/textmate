This is ../../info/viper, produced by makeinfo version 4.13 from
viper.texi.

Copyright (C) 1995-1997, 2001-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual", and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License".

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs misc features
START-INFO-DIR-ENTRY
* VIPER: (viper).               A VI-emulation mode for Emacs.
END-INFO-DIR-ENTRY


File: viper,  Node: Top,  Next: Overview,  Up: (DIR)

Viper
*****

We believe that one or more of the following statements are adequate
descriptions of Viper:

     Viper Is a Package for Emacs Rebels;
     it is a VI Plan for Emacs Rescue
     and/or a venomous VI PERil.

   Technically speaking, Viper is a Vi emulation package for Emacs.  It
implements all Vi and Ex commands, occasionally improving on them and
adding many new features.  It gives the user the best of both worlds: Vi
keystrokes for editing combined with the power of the Emacs environment.

   Viper emulates Vi at several levels, from the one that closely
follows Vi conventions to the one that departs from many of them.  It
has many customizable options, which can be used to tailor Viper to the
work habits of various users.  This manual describes Viper,
concentrating on the differences from Vi and new features of Viper.

   Viper, formerly known as VIP-19, was written by Michael Kifer.  It
is based on VIP version 3.5 by Masahiko Sato and VIP version 4.4 by
Aamod Sane.  About 15% of the code still comes from those older
packages.

   Viper is intended to be usable without reading this manual -- the
defaults are set to make Viper as close to Vi as possible.  At startup,
Viper will try to set the most appropriate default environment for you,
based on your familiarity with Emacs.  It will also tell you the basic
GNU Emacs window management commands to help you start immediately.

   Although this manual explains how to customize Viper, some basic
familiarity with Emacs Lisp is a plus.

   It is recommended that you read the Overview node.  The other nodes
may be visited as needed.

   Comments and bug reports are welcome.  `kifer@cs.stonybrook.edu' is
the current address for Viper bug reports.  Please use the Ex command
`:submitReport' for this purpose.

   Copyright (C) 1995-1997, 2001-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual", and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License".

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

* Menu:

* Overview::                    Read for a smoother start
* Improvements over Vi::        New features, Improvements
* Customization::               How to customize Viper
* Commands::                    Vi and Ex Commands

* Key Index::                   Index of Vi and Ex Commands
* Function Index::              Index of Viper Functions
* Variable Index::              Index of Viper Variables
* Package Index::               Index of Packages Mentioned in this Document
* Concept Index::               Vi, Ex and Emacs concepts

* Acknowledgments::
* GNU Free Documentation License:: The license for this documentation.


File: viper,  Node: Overview,  Next: Improvements over Vi,  Prev: Top,  Up: Top

1 Overview of Viper
*******************

Viper is a Vi emulation on top of Emacs.  At the same time, Viper
provides a virtually unrestricted access to Emacs facilities.  Perfect
compatibility with Vi is possible but not desirable.  This chapter
tells you about the Emacs ideas that you should know about, how to use
Viper within Emacs and some incompatibilities.

   This manual is written with the assumption that you are an
experienced Vi user who wants to switch to Emacs while retaining the
ability to edit files Vi style. Incredible as it might seem, there are
experienced Emacs users who use Viper as a backdoor into the superior
(as every Vi user already knows) world of Vi! These users are well
familiar with Emacs bindings and prefer them in some cases, especially
in the Vi Insert state. John Hawkins <jshawkin@eecs.umich.edu> has
provided a set of customizations, which enables additional Emacs
bindings under Viper.  These customizations can be included in your
`~/.viper' file and are found at the following URL:
`http://traeki.freeshell.org/files/viper-sample'.

* Menu:

* Emacs Preliminaries::         Basic concepts in Emacs.
* Loading Viper::               Loading and Preliminary Configuration.
* States in Viper::             Viper has four states orthogonal to Emacs
                                modes.
* The Minibuffer::              Command line in Emacs.
* Multiple Files in Viper::     True multiple file handling.
* Unimplemented Features::      That are unlikely to be implemented.


File: viper,  Node: Emacs Preliminaries,  Next: Loading Viper,  Prev: Overview,  Up: Overview

1.1 Emacs Preliminaries
=======================

Emacs can edit several files at once.  A file in Emacs is placed in a
"buffer" that usually has the same name as the file.  Buffers are also
used for other purposes, such as shell interfaces, directory editing,
etc.  *Note Directory Editor: (emacs)Dired, for an example.

   A buffer has a distinguished position called the "point".  A "point"
is always between 2 characters, and is "looking at" the right hand
character.  The cursor is positioned on the right hand character.
Thus, when the "point" is looking at the end-of-line, the cursor is on
the end-of-line character, i.e. beyond the last character on the line.
This is the default Emacs behavior.

   The default settings of Viper try to mimic the behavior of Vi,
preventing the cursor from going beyond the last character on the line.
By using Emacs commands directly (such as those bound to arrow keys),
it is possible to get the cursor beyond the end-of-line.  However, this
won't (or shouldn't) happen if you restrict yourself to standard Vi
keys, unless you modify the default editing style.  *Note
Customization::.

   In addition to the "point", there is another distinguished buffer
position called the "mark".  *Note Mark: (emacs)Mark, for more info on
the mark.  The text between the "point" and the "mark" is called the
"region" of the buffer.  For the Viper user, this simply means that in
addition to the Vi textmarkers a-z, there is another marker called
"mark".  This is similar to the unnamed Vi marker used by the jump
commands ```' and `''', which move the cursor to the position of the
last absolute jump.  Viper provides access to the region in most text
manipulation commands as `r' and `R' suffix to commands that operate on
text regions, e.g., `dr' to delete region, etc.

   Furthermore, Viper lets Ex-style commands to work on the current
region.  This is done by typing a digit argument before `:'.  For
instance, typing `1:' will prompt you with something like _:123,135_,
assuming that the current region starts at line 123 and ends at line
135.  There is no need to type the line numbers, since Viper inserts
them automatically in front of the Ex command.

   *Note Basics::, for more info.

   Emacs divides the screen into tiled "windows".  You can see the
contents of a buffer through the window associated with the buffer.  The
cursor of the screen is positioned on the character after "point".
Every window has a "mode line" that displays information about the
buffer.  You can change the format of the mode line, but normally if
you see `**' at the beginning of a mode line it means that the buffer
is "modified".  If you write out the contents of a buffer to a file,
then the buffer will become not modified.  Also if you see `%%' at the
beginning of the mode line, it means that the file associated with the
buffer is write protected.  The mode line will also show the buffer
name and current major and minor modes (see below).  A special buffer
called "Minibuffer" is displayed as the last line in a minibuffer
window.  The minibuffer window is used for command input output.  Viper
uses minibuffer window for `/' and `:' commands.

   An Emacs buffer can have a "major mode" that customizes Emacs for
editing text of a particular sort by changing the functionality of the
keys.  Keys are defined using a "keymap" that records the bindings
between keystrokes and functions.  The "global keymap" is common to all
the buffers.  Additionally, each buffer has its "local keymap" that
determines the "mode" of the buffer.  If a function is bound to some
key in the local keymap then that function will be executed when you
type the key.  If no function is bound to a key in the local map,
however, the function bound to the key in the global map will be
executed.  *Note Major Modes: (emacs)Major Modes, for more information.

   A buffer can also have a "minor mode".  Minor modes are options that
you can use or not.  A buffer in `text-mode' can have `auto-fill-mode'
as minor mode, which can be turned off or on at any time.  In Emacs, a
minor mode may have it own keymap, which overrides the local keymap
when the minor mode is turned on.  For more information, *note Minor
Modes: (emacs)Minor Modes.

   Viper is implemented as a collection of minor modes.  Different
minor modes are involved when Viper emulates Vi command mode, Vi insert
mode, etc.  You can also turn Viper on and off at any time while in Vi
command mode.  *Note States in Viper::, for more information.

   Emacs uses Control and Meta modifiers.  These are denoted as C and M,
e.g. `^Z' as `C-z' and `Meta-x' as `M-x'.  The Meta key is usually
located on each side of the Space bar; it is used in a manner similar
to the Control key, e.g., `M-x' means typing `x' while holding the Meta
key down.  For keyboards that do not have a Meta key, <ESC> is used as
Meta.  Thus `M-x' is typed as `<ESC> x'.  Viper uses <ESC> to switch
from Insert state to Vi state.  Therefore Viper defines `C-\' as its
Meta key in Vi state.  *Note Vi State::, for more info.

   Emacs is structured as a Lisp interpreter around a C core.  Emacs
keys cause Lisp functions to be called.  It is possible to call these
functions directly, by typing `M-x function-name'.


File: viper,  Node: Loading Viper,  Next: States in Viper,  Prev: Emacs Preliminaries,  Up: Overview

1.2 Loading Viper
=================

The most common way to load it automatically is to include the following
lines (in the given order!):

     (setq viper-mode t)
     (require 'viper)

in your `~/.emacs' file.  The `.emacs' file is placed in your home
directory and it is be executed every time you invoke Emacs.  This is
the place where all general Emacs customization takes place.  Beginning
with version 20.0, Emacsen have an interactive interface, which
simplifies the job of customization significantly.

   Viper also uses the file `~/.viper' for Viper-specific customization.
The location of Viper customization file can be changed by setting the
variable `viper-custom-file-name' in `.emacs' _prior_ to loading Viper.

   The latest versions of Emacs have an interactive customization
facility, which allows you to (mostly) bypass the use of the `.emacs'
and `.viper' files. You can reach this customization facility from
within Viper's VI state by executing the Ex command `:customize'.

   Once invoked, Viper will arrange to bring up Emacs buffers in Vi
state whenever this makes sense.  *Note Packages that Change Keymaps::,
to find out when forcing Vi command state on a buffer may be
counter-productive.

   Even if your `.emacs' file does not invoke Viper automatically, you
can still load Viper and enter the Vi command state by typing the
following from within Emacs:

     M-x viper-mode

   When Emacs first comes up, if you have not specified a file on the
command line, it will show the `*scratch*' buffer, in the `Lisp
Interaction' mode.  After you invoke Viper, you can start editing files
by using `:e', `:vi', or `v' commands.  (*Note File and Buffer
Handling::, for more information on `v' and other new commands that, in
many cases, are more convenient than `:e', `:vi', and similar old-style
Vi commands.)

   Finally, if at some point you would want to de-Viperize your running
copy of Emacs after Viper has been loaded, the command `M-x
viper-go-away' will do it for you.  The function `toggle-viper-mode'
toggles Viperization of Emacs on and off.


File: viper,  Node: States in Viper,  Next: The Minibuffer,  Prev: Loading Viper,  Up: Overview

1.3 States in Viper
===================

Viper has four states, Emacs, Vi, Insert, and Replace.

`Emacs state'
     This is the state plain vanilla Emacs is normally in.  After you
     have loaded Viper, `C-z' will normally take you to Vi command
     state.  Another `C-z' will take you back to Emacs state.  This
     toggle key can be changed, *note Customization:: You can also type
     `M-x viper-mode' to change to Vi state.

     For users who chose to set their user level to 1 at Viper setup
     time, switching to Emacs state is deliberately made harder in
     order to not confuse the novice user.  In this case, `C-z' will
     either iconify Emacs (if Emacs runs as an application under X) or
     it will stop Emacs (if Emacs runs on a dumb terminal or in an
     Xterm window).

`Vi state'
     This is the Vi command mode.  Any of the Vi commands, such as `i,
     o, a', ..., will take you to Insert state.  All Vi commands may be
     used in this mode.  Most Ex commands can also be used.  For a full
     list of Ex commands supported by Viper, type `:' and then <TAB>.
     To get help on any issue, including the Ex commands, type `:help'.
     This will invoke Viper Info (if it is installed).  Then typing `i'
     will prompt you for a topic to search in the index.  Note: to
     search for Ex commands in the index, you should start them with a
     `:', e.g., `:WW'.

     In Viper, Ex commands can be made to work on the current Emacs
     region.  This is done by typing a digit argument before `:'.  For
     instance, typing `1:' will prompt you with something like
     _:123,135_, assuming that the current region starts at line 123 and
     ends at line 135.  There is no need to type the line numbers,
     since Viper inserts them automatically in front of the Ex command.

`Insert state'
     Insert state is the Vi insertion mode.  <ESC> will take you back to
     Vi state.  Insert state editing can be done, including
     auto-indentation.  By default, Viper disables Emacs key bindings
     in Insert state.

`Replace state'
     Commands like `cw' invoke the Replace state.  When you cross the
     boundary of a replacement region (usually designated via a `$'
     sign), it will automatically change to Insert state.  You do not
     have to worry about it.  The key bindings remain practically the
     same as in Insert state.  If you type <ESC>, Viper will switch to
     Vi command mode, terminating the replacement state.

   The modes are indicated on the "mode line" as <E>, <I>, <V>, and <R>,
so that the multiple modes do not confuse you.  Most of your editing
can be done in Vi and Insert states.  Viper will try to make all new
buffers be in Vi state, but sometimes they may come up in Emacs state.
`C-z' will take you to Vi state in such a case.  In some major modes,
like Dired, Info, Gnus, etc., you should not switch to Vi state (and
Viper will not attempt to do so) because these modes are not intended
for text editing and many of the Vi keys have special meaning there.
If you plan to read news, browse directories, read mail, etc., from
Emacs (which you should start doing soon!), you should learn about the
meaning of the various keys in those special modes (typing `C-h m' in a
buffer provides help with key bindings for the major mode of that
buffer).

   If you switch to Vi in Dired or similar modes--no harm is done.  It
is just that the special key bindings provided by those modes will be
temporarily overshadowed by Viper's bindings.  Switching back to
Viper's Emacs state will revive the environment provided by the current
major mode.

   States in Viper are orthogonal to Emacs major modes, such as C mode
or Dired mode.  You can turn Viper on and off for any Emacs state.
When Viper is turned on, Vi state can be used to move around.  In
Insert state, the bindings for these modes can be accessed.  For
beginners (users at Viper levels 1 and 2), these bindings are
suppressed in Insert state, so that new users are not confused by the
Emacs states.  Note that unless you allow Emacs bindings in Insert
state, you cannot do many interesting things, like language sensitive
editing.  For the novice user (at Viper level 1), all major mode
bindings are turned off in Vi state as well.  This includes the
bindings for key sequences that start with `C-c', which practically
means that all major mode bindings are unsupported.  *Note
Customization::, to find out how to allow Emacs keys in Insert state.

* Menu:

* Emacs State::         This is the state you should learn more about when
                        you get up to speed with Viper.
* Vi State::            Vi commands are executed in this state.
* Insert State::        You can enter text, and also can do sophisticated
                        editing if you know enough Emacs commands.
* Replace State::       Like Insert mode, but it is invoked via the
                        replacement commands, such as cw, C, R, etc.


File: viper,  Node: Emacs State,  Next: Vi State,  Prev: States in Viper,  Up: States in Viper

1.3.1 Emacs State
-----------------

You will be in this mode only by accident (hopefully).  This is the
state Emacs is normally in (imagine!!).  Now leave it as soon as
possible by typing `C-z'.  Then you will be in Vi state (sigh of
relief) :-).

   Emacs state is actually a Viperism to denote all the major and minor
modes (*note Emacs Preliminaries::) other than Viper that Emacs can be
in.  Emacs can have several modes, such as C mode for editing C
programs, LaTeX mode for editing LaTeX documents, Dired for directory
editing, etc.  These are major modes, each with a different set of
key-bindings.  Viper states are orthogonal to these Emacs major modes.
The presence of these language sensitive and other modes is a major win
over Vi.  *Note Improvements over Vi::, for more.

   The bindings for these modes can be made available in the Viper
Insert state as well as in Emacs state.  Unless you specify your user
level as 1 (a novice), all major mode key sequences that start with
`C-x' and `C-c' are also available in Vi state.  This is important
because major modes designed for editing files, such as cc-mode or
latex-mode, use key sequences that begin with `C-x' and `C-c'.

   There is also a key that lets you temporarily escape to Vi command
state from the Insert state: typing `C-z' will let you execute a single
Vi command while staying in Viper's Insert state.


File: viper,  Node: Vi State,  Next: Insert State,  Prev: Emacs State,  Up: States in Viper

1.3.2 Vi State
--------------

This is the Vi command mode.  When Viper is in Vi state, you will see
the sign <V> in the mode line.  Most keys will work as in Vi.  The
notable exceptions are:

`C-x'
     `C-x' is used to invoke Emacs commands, mainly those that do window
     management.  `C-x 2' will split a window, `C-x 0' will close a
     window.  `C-x 1' will close all other windows.  `C-xb' is used to
     switch buffers in a window, and `C-xo' to move through windows.
     These are about the only necessary keystrokes.  For the rest, see
     the GNU Emacs Manual.

`C-c'
     For user levels 2 and higher, this key serves as a prefix key for
     the key sequences used by various major modes.  For users at Viper
     level 1, `C-c' simply beeps.

`C-g and C-]'
     These are the Emacs `quit' keys.  There will be cases where you
     will have to use `C-g' to quit.  Similarly, `C-]' is used to exit
     `Recursive Edits' in Emacs for which there is no comparable Vi
     functionality and no key-binding.  Recursive edits are indicated by
     `[]' brackets framing the modes on the mode line.  *Note Recursive
     Edit: (emacs)Recursive Edit.  At user level 1, `C-g' is bound to
     `viper-info-on-file' function instead.

`C-\'
     Viper uses <ESC> as a switch between Insert and Vi states.  Emacs
     uses <ESC> for Meta.  The Meta key is very important in Emacs
     since many functions are accessible only via that key as `M-x
     function-name'.  Therefore, we need to simulate it somehow.  In
     Viper's Vi, Insert, and Replace states, the meta key is set to be
     `C-\'.  Thus, to get `M-x', you should type `C-\ x' (if the
     keyboard has no Meta key, which is rare these days).  This works
     both in the Vi command state and in the Insert and Replace states.
     In Vi command state, you can also use `\ <ESC>' as the meta key.

     Note: Emacs binds `C-\' to a function that offers to change the
     keyboard input method in the multilingual environment.  Viper
     overrides this binding.  However, it is still possible to switch
     the input method by typing `\ C-\' in the Vi command state and
     `C-z \ C-\' in the Insert state.  Or you can use the MULE menu in
     the menubar.
   Other differences are mostly improvements.  The ones you should know
about are:

`Undo'
     `u' will undo.  Undo can be repeated by the `.' key.  Undo itself
     can be undone.  Another `u' will change the direction.  The
     presence of repeatable undo means that `U', undoing lines, is not
     very important.  Therefore, `U' also calls `viper-undo'.  

`Counts'
     Most commands, `~', `[[', `p', `/', ..., etc., take counts.

`Regexps'
     Viper uses Emacs Regular Expressions for searches.  These are a
     superset of Vi regular expressions, excepting the change-of-case
     escapes `\u', `\L', ..., etc.  *Note Syntax of Regular
     Expressions: (emacs)Regexps, for details.  Files specified to `:e'
     use `csh' regular expressions (globbing, wildcards, what have you).
     However, the function `viper-toggle-search-style', bound to `C-c
     /', lets the user switch from search with regular expressions to
     plain vanilla search and vice versa.  It also lets one switch from
     case-sensitive search to case-insensitive and back.  *Note Viper
     Specials::, for more details.  

`Ex commands'
     The current working directory of a buffer is automatically
     inserted in the minibuffer if you type `:e' then space.  Absolute
     filenames are required less often in Viper.  For file names, Emacs
     uses a convention that is slightly different from other programs.
     It is designed to minimize the need for deleting file names that
     Emacs provides in its prompts.  (This is usually convenient, but
     occasionally the prompt may suggest a wrong file name for you.)
     If you see a prompt `/usr/foo/' and you wish to edit the file
     `~/.viper', you don't have to erase the prompt.  Instead, simply
     continue typing what you need.  Emacs will interpret
     `/usr/foo/~/.viper' correctly.  Similarly, if the prompt is
     `~/foo/' and you need to get to `/bar/file', keep typing.  Emacs
     interprets `~/foo//bar/' as `/bar/file', since when it sees `//',
     it understands that `~/foo/' is to be discarded.

     The command `:cd' will change the default directory for the
     current buffer.  The command `:e' will interpret the filename
     argument in `csh'.  *Note Customization::, if you want to change
     the default shell.  The command `:next' takes counts from `:args',
     so that `:rew' is obsolete.  Also, `:args' will show only the
     invisible files (i.e., those that are not currently seen in Emacs
     windows).

     When applicable, Ex commands support file completion and history.
     This means that by typing a partial file name and then <TAB>,
     Emacs will try to complete the name or it will offer a menu of
     possible completions.  This works similarly to Tcsh and extends
     the behavior of Csh.  While Emacs is waiting for a file name, you
     can type `M-p' to get the previous file name you typed.
     Repeatedly typing `M-p' and `M-n' will let you browse through the
     file history.

     Like file names, partially typed Ex commands can be completed by
     typing <TAB>, and Viper keeps the history of Ex commands.  After
     typing `:', you can browse through the previously entered Ex
     commands by typing `M-p' and `M-n'.  Viper tries to rationalize
     when it puts Ex commands on the history list.  For instance, if
     you typed `:w! foo', only `:w!' will be placed on the history
     list.  This is because the last history element is the default
     that can be invoked simply by typing `: <RET>'.  If `:w! foo' were
     placed on the list, it would be all to easy to override valuable
     data in another file.  Reconstructing the full command, `:w! foo',
     from the history is still not that hard, since Viper has a
     separate history for file names.  By typing `: M-p', you will get
     `:w!' in the minibuffer.  Then, repeated `M-p' will get you through
     the file history, inserting one file name after another.

     In contrast to `:w! foo', if the command were `:r foo', the entire
     command will appear in the history list.  This is because having
     `:r' alone as a default is meaningless, since this command
     requires a file argument.

   As in Vi, Viper's destructive commands can be re-executed by typing
``.''.  However, in addition, Viper keeps track of the history of such
commands.  This history can be perused by typing `C-c M-p' and `C-c
M-n'.  Having found the appropriate command, it can be then executed by
typing ``.''.  *Note Improvements over Vi::, for more information.


File: viper,  Node: Insert State,  Next: Replace State,  Prev: Vi State,  Up: States in Viper

1.3.3 Insert State
------------------

To avoid confusing the beginner (at Viper level 1 and 2), Viper makes
only the standard Vi keys available in Insert state.  The implication
is that Emacs major modes cannot be used in Insert state.  It is
strongly recommended that as soon as you are comfortable, make the
Emacs state bindings visible (by changing your user level to 3 or
higher).  *Note Customization::, to see how to do this.

   Once this is done, it is possible to do quite a bit of editing in
Insert state.  For instance, Emacs has a "yank" command, `C-y', which
is similar to Vi's `p'.  However, unlike `p', `C-y' can be used in
Insert state of Viper.  Emacs also has a kill ring where it keeps
pieces of text you deleted while editing buffers.  The command `M-y' is
used to delete the text previously put back by Emacs's `C-y' or by Vi's
`p' command and reinsert text that was placed on the kill-ring earlier.

   This works both in Vi and Insert states.  In Vi state, `M-y' is a
much better alternative to the usual Vi's way of recovering the 10
previously deleted chunks of text.  In Insert state, you can use this
as follows.  Suppose you deleted a piece of text and now you need to
re-insert it while editing in Insert mode.  The key `C-y' will put back
the most recently deleted chunk.  If this is not what you want, type
`M-y' repeatedly and, hopefully, you will find the chunk you want.

   Finally, in Insert and Replace states, Viper provides the history of
pieces of text inserted in previous insert or replace commands.  These
strings of text can be recovered by repeatedly typing `C-c M-p' or `C-c
M-n' while in Insert or Replace state.  (This feature is disabled in
the minibuffer: the above keys are usually bound to other histories,
which are more appropriate in the minibuffer.)

   You can call Meta functions from Insert state.  As in Vi state, the
Meta key is `C-\'.  Thus `M-x' is typed as `C-\ x'.

   Other Emacs commands that are useful in Insert state are `C-e' and
`C-a', which move the cursor to the end and the beginning of the
current line, respectively.  You can also use `M-f' and `M-b', which
move the cursor forward (or backward) one word.  If your display has a
Meta key, these functions are invoked by holding the Meta key and then
typing `f' and `b', respectively.  On displays without the Meta key,
these functions are invoked by typing `C-\ f' and `C-\ b' (`C-\'
simulates the Meta key in Insert state, as explained above).

   The key `C-z' is sometimes also useful in Insert state: it allows you
to execute a single command in Vi state without leaving the Insert
state!  For instance, `C-z d2w' will delete the next two words without
leaving the Insert state.

   When Viper is in Insert state, you will see <I> in the mode line.


File: viper,  Node: Replace State,  Prev: Insert State,  Up: States in Viper

1.3.4 Replace State
-------------------

This state is entered through Vi replacement commands, such as `C',
`cw', etc., or by typing `R'.  In Replace state, Viper puts <R> in the
mode line to let you know which state is in effect.  If Replace state is
entered through `R', Viper stays in that state until the user hits
<ESC>.  If this state is entered via the other replacement commands,
then Replace state is in effect until you hit <ESC> or until you cross
the rightmost boundary of the replacement region.  In the latter case,
Viper changes its state from Replace to Insert (which you will notice
by the change in the mode line).

   Since Viper runs under Emacs, it is possible to switch between
buffers while in Replace state.  You can also move the cursor using the
arrow keys (even on dumb terminals!) and the mouse.  Because of this
freedom (which is unattainable in regular Vi), it is possible to take
the cursor outside the replacement region.  (This may be necessary for
several reasons, including the need to enable text selection and
region-setting with the mouse.)

   The issue then arises as to what to do when the user hits the <ESC>
key.  In Vi, this would cause the text between cursor and the end of
the replacement region to be deleted.  But what if, as is possible in
Viper, the cursor is not inside the replacement region?

   To solve the problem, Viper keeps track of the last cursor position
while it was still inside the replacement region.  So, in the above
situation, Viper would delete text between this position and the end of
the replacement region.


File: viper,  Node: The Minibuffer,  Next: Multiple Files in Viper,  Prev: States in Viper,  Up: Overview

1.4 The Minibuffer
==================

The minibuffer is where commands are entered in.  Editing can be done
by commands from Insert state, namely:

`C-h'
     Backspace

`C-w'
     Delete Word

`C-u'
     Erase line

`C-v'
     Quote the following character

`<RET>'
     Execute command

`C-g and C-]'
     Emacs quit and abort keys.  These may be necessary.  *Note Vi
     State::, for an explanation.

`M-p and M-n'
     These keys are bound to functions that peruse minibuffer history.
     The precise history to be perused depends on the context.  It may
     be the history of search strings, Ex commands, file names, etc.

`C-s'
     If the minibuffer is entered via the Viper search commands `/' or
     `?', then this key inserts the last search string used by the
     Emacs incremental search command (which is bound to `C-s'
     everywhere except in this case).

   Most of the Emacs keys are functional in the minibuffer.  While in
the minibuffer, Viper tries to make editing resemble Vi's behavior when
the latter is waiting for the user to type an Ex command.  In
particular, you can use the regular Vi commands to edit the minibuffer.
You can switch between the Vi state and Insert state at will, and even
use the replace mode.  Initially, the minibuffer comes up in Insert
state.

   Some users prefer plain Emacs bindings in the minibuffer.  To this
end, set `viper-vi-style-in-minibuffer' to `nil' in `.viper'.  *Note
Customization::, to learn how to do this.

   When the minibuffer changes Viper states, you will notice that the
appearance of the text there changes as well.  This is useful because
the minibuffer has no mode line to tell which Vi state it is in.  The
appearance of the text in the minibuffer can be changed.  *Note Viper
Specials::, for more details.


File: viper,  Node: Multiple Files in Viper,  Next: Unimplemented Features,  Prev: The Minibuffer,  Up: Overview

1.5 Multiple Files in Viper
===========================

Viper can edit multiple files.  This means, for example that you never
need to suffer through `No write since last change' errors.  Some Viper
elements are common over all the files.

`Textmarkers'
     Textmarkers remember _files and positions_.  If you set marker `a'
     in file `foo', start editing file `bar' and type `'a', then _YOU
     WILL SWITCH TO FILE `foo'_.  You can see the contents of a
     textmarker using the Viper command `[<a-z>' where <a-z> are the
     textmarkers, e.g., `[a' to view marker `a' .

`Repeated Commands'
     Command repetitions are common over files.  Typing `!!' will
     repeat the last `!' command whichever file it was issued from.
     Typing `.' will repeat the last command from any file, and
     searches will repeat the last search.  Ex commands can be repeated
     by typing `: <RET>'.  Note: in some rare cases, that `: <RET>' may
     do something dangerous.  However, usually its effect can be undone
     by typing `u'.

`Registers'
     Registers are common to files.  Also, text yanked with `y' can be
     put back (`p') into any file.  The Viper command `]<a-z>', where
     <a-z> are the registers, can be used to look at the contents of a
     register, e.g., type `]a' to view register `a'.

     There is one difference in text deletion that you should be aware
     of.  This difference comes from Emacs and was adopted in Viper
     because we find it very useful.  In Vi, if you delete a line, say,
     and then another line, these two deletions are separated and are
     put back separately if you use the `p' command.  In Emacs (and
     Viper), successive series of deletions that are _not interrupted_
     by other commands are lumped together, so the deleted text gets
     accumulated and can be put back as one chunk.  If you want to
     break a sequence of deletions so that the newly deleted text could
     be put back separately from the previously deleted text, you
     should perform a non-deleting action, e.g., move the cursor one
     character in any direction.

`Absolute Filenames'
     The current directory name for a file is automatically prepended
     to the file name in any `:e', `:r', `:w', etc., command (in Emacs,
     each buffer has a current directory).  This directory is inserted
     in the minibuffer once you type space after `:e, r', etc.  Viper
     also supports completion of file names and Ex commands (<TAB>),
     and it keeps track of command and file history (`M-p', `M-n').
     Absolute filenames are required less often in Viper.

     You should be aware that Emacs interprets `/foo/bar//bla' as
     `/bla' and `/foo/~/bar' as `~/bar'.  This is designed to minimize
     the need for erasing file names that Emacs suggests in its
     prompts, if a suggested file name is not what you wanted.

     The command `:cd' will change the default directory for the
     current Emacs buffer.  The Ex command `:e' will interpret the
     filename argument in `csh', by default.  *Note Customization::, if
     you want to change this.

Currently undisplayed files can be listed using the `:ar' command.  The
command `:n' can be given counts from the `:ar' list to switch to other
files. For example, use `:n3' to move to the third file in that list.


File: viper,  Node: Unimplemented Features,  Prev: Multiple Files in Viper,  Up: Overview

1.6 Unimplemented Features
==========================

Unimplemented features include:

   * `:ab' and `:una' are not implemented, since `:ab' is considered
     obsolete, since Emacs has much more powerful facilities for
     defining abbreviations.

   * `:set option?' is not implemented.  The current `:set' can also be
     used to set Emacs variables.

   * `:se list' requires modification of the display code for Emacs, so
     it is not implemented.  A useful alternative is `cat -t -e file'.
     Unfortunately, it cannot be used directly inside Emacs, since
     Emacs will obdurately change `^I' back to normal tabs.


File: viper,  Node: Improvements over Vi,  Next: Customization,  Prev: Overview,  Up: Top

2 Improvements over Vi
**********************

Some common problems with Vi and Ex have been solved in Viper.  This
includes better implementation of existing commands, new commands, and
the facilities provided by Emacs.

* Menu:

* Basics::                  Basic Viper differences, Multi-file effects.
* Undo and Backups::        Multiple undo, auto-save, backups and changes
* History::                 History for Ex and Vi commands.
* Macros and Registers::    Keyboard Macros (extended ".") @reg execution.
* Completion::              Filename and Command Completion for Ex.
* Improved Search::         Incremental Search and Buffer Content Search.
* Abbreviation Facilities:: Normal Abbrevs, Templates, and Dynamic Abbrevs.
* Movement and Markers::    Screen Editor movements, viewing textmarkers.
* New Commands::            Commands that do not exist in Vi.
* Useful Packages::         A Sampling of some Emacs packages, and things
                            you should know about.


File: viper,  Node: Basics,  Next: Undo and Backups,  Prev: Improvements over Vi,  Up: Improvements over Vi

2.1 Basics
==========

The Vi command set is based on the idea of combining motion commands
with other commands.  The motion command is used as a text region
specifier for other commands.  We classify motion commands into "point
commands" and "line commands".

   The point commands are:

     `h', `l', `0',  `$', `w', `W', `b', `B', `e', `E', `(', `)', `/',
     `?', ``', `f', `F', `t', `T', `%', `;', `,', `^'

   The line commands are:

     `j', `k', `+', `-', `H', `M', `L', `{', `}', `G', `'',  `[[',
     `]]', `[]'

If a point command is given as an argument to a modifying command, the
region determined by the point command will be affected by the modifying
command.  On the other hand, if a line command is given as an argument
to a modifying command, the region determined by the line command will
be enlarged so that it will become the smallest region properly
containing the region and consisting of whole lines (we call this
process "expanding the region"), and then the enlarged region will be
affected by the modifying command.  Text Deletion Commands (*note
Deleting Text::), Change commands (*note Changing Text::), even Shell
Commands (*note Shell Commands::) use these commands to describe a
region of text to operate on.  Thus, type `dw' to delete a word, `>}'
to shift a paragraph, or `!'afmt' to format a region from `point' to
textmarker `a'.

   Viper adds the region specifiers `r' and `R'.  Emacs has a special
marker called "mark".  The text-area between the current cursor
position "point" and the "mark" is called the "region".  `r' specifies
the raw region and `R' is the expanded region (i.e., the minimal
contiguous chunk of full lines that contains the raw region).  `dr'
will now delete the region, `>r' will shift it, etc.  `r,R' are not
motion commands, however.  The special mark is set by `m.' and other
commands.  *Note Marking::, for more info.

   Viper also adds counts to most commands for which it would make
sense.

   In the Overview chapter, some Multiple File issues were discussed
(*note Multiple Files in Viper::).  In addition to the files, Emacs has
buffers.  These can be seen in the `:args' list and switched using
`:next' if you type `:set ex-cycle-through-non-files t', or specify
`(setq ex-cycle-through-non-files t)' in your `.viper' file.  *Note
Customization::, for details.


File: viper,  Node: Undo and Backups,  Next: History,  Prev: Basics,  Up: Improvements over Vi

2.2 Undo and Backups
====================

Viper provides multiple undo.  The number of undo's and the size is
limited by the machine.  The Viper command `u' does an undo.  Undo can
be repeated by typing `.' (a period).  Another `u' will undo the undo,
and further `.' will repeat it.  Typing `u' does the first undo, and
changes the direction.

   Since the undo size is limited, Viper can create backup files and
auto-save files.  It will normally do this automatically.  It is
possible to have numbered backups, etc.  For details, *note Backup and
Auto-Save: (emacs)Backup.

   The results of the 9 previous changes are available in the 9 numeric
registers, as in Vi.  The extra goody is the ability to _view_ these
registers, in addition to being able to access them through `p' and
`M-y' (*Note Insert State::, for details.)  The Viper command `]
register' will display the contents of any register, numeric or
alphabetical.  The related command `[ textmarker' will show the text
around the textmarker.  `register' and `textmarker' can be any letters
from a through z.


File: viper,  Node: History,  Next: Macros and Registers,  Prev: Undo and Backups,  Up: Improvements over Vi

2.3 History
===========

History is provided for Ex commands, Vi searches, file names, pieces of
text inserted in earlier commands that use Insert or Replace state, and
for destructive commands in Vi state.  These are useful for fixing
those small typos that screw up searches and `:s', and for eliminating
routine associated with repeated typing of file names or pieces of text
that need to be inserted frequently.  At the `:' or `/' prompts in the
minibuffer, you can do the following:

`M-p and M-n'
     To move to previous and next history items.  This causes the
     history items to appear on the command line, where you can edit
     them, or simply type Return to execute.

`M-r and M-s'
     To search backward and forward through the history.

`<RET>'
     Type <RET> to accept a default (which is displayed in the prompt).

   The history of insertions  can be perused by typing `C-c M-p' and
`C-c M-n' while in Insert or Replace state.  The history of destructive
Vi commands can be perused via the same keys when Viper is in Vi state.
*Note Viper Specials::, for details.

   All Ex commands have a file history.  For instance, typing `:e',
space and then `M-p' will bring up the name of the previously typed file
name.  Repeatedly typing `M-p', `M-n', etc., will let you browse
through the file history.

   Similarly, commands that have to do with switching buffers have a
buffer history, and commands that expect strings or regular expressions
keep a history on those items.


File: viper,  Node: Macros and Registers,  Next: Completion,  Prev: History,  Up: Improvements over Vi

2.4 Macros and Registers
========================

Viper facilitates the use of Emacs-style keyboard macros.  `@#' will
start a macro definition.  As you type, the commands will be executed,
and remembered (This is called "learn mode" in some editors.)
`@register' will complete the macro, putting it into `register', where
`register' is any character from `a' through `z'.  Then you can execute
this macro using `@register'.  It is, of course, possible to yank some
text into a register and execute it using `@register'.  Typing `@@',
`@RET', or `@C-j' will execute the last macro that was executed using
`@register'.

   Viper will automatically lowercase the register, so that pressing the
`SHIFT' key for `@' will not create problems.  This is for `@' macros
and `"p' _only_.  In the case of `y', `"Ayy' will append to _register
a_.  For `[,],',`', it is an error to use a Uppercase register name.

   The contents of a register can be seen by `]register'.
(`[textmarker' will show the contents of a textmarker).

   The last keyboard macro can also be executed using `*', and it can
be yanked into a register using `@!register'.  This is useful for Emacs
style keyboard macros defined using `C-x(' and `C-x)'.  Emacs keyboard
macros have more capabilities.  *Note Keyboard Macros: (emacs)Keyboard
Macros, for details.

   Keyboard Macros allow an interesting form of Query-Replace:
`/pattern' or `n' to go to the next pattern (the query), followed by a
Keyboard Macro execution `@@' (the replace).

   Viper also provides Vi-style macros.  *Note Vi Macros::, for details.


File: viper,  Node: Completion,  Next: Improved Search,  Prev: Macros and Registers,  Up: Improvements over Vi

2.5 Completion
==============

Completion is done when you type <TAB>.  The Emacs completer does not
grok wildcards in file names.  Once you type a wildcard, the completer
will no longer work for that file name.  Remember that Emacs interprets
a file name of the form `/foo//bar' as `/bar' and `/foo/~/bar' as
`~/bar'.


File: viper,  Node: Improved Search,  Next: Abbreviation Facilities,  Prev: Completion,  Up: Improvements over Vi

2.6 Improved Search
===================

Viper provides buffer search, the ability to search the buffer for a
region under the cursor.  You have to turn this on in `.viper' either
by calling

     (viper-buffer-search-enable)

or by setting `viper-buffer-search-char' to, say, `f3':
     (setq viper-buffer-search-char ?g)

If the user calls `viper-buffer-search-enable' explicitly (the first
method), then `viper-buffer-search-char' will be set to `g'.
Regardless of how this feature is enabled, the key
`viper-buffer-search-char' will take movement commands, like `w,/,e',
to find a region and then search for the contents of that region.  This
command is very useful for searching for variable names, etc., in a
program.  The search can be repeated by `n' or reversed by `N'.

   Emacs provides incremental search.  As you type the string in, the
cursor will move to the next match.  You can snarf words from the buffer
as you go along.  Incremental Search is normally bound to `C-s' and
`C-r'.  *Note Customization::, to find out how to change the bindings
of `C-r or C-s'.  For details, *note Incremental Search:
(emacs)Incremental Search.

   Viper also provides a query replace function that prompts through the
minibuffer.  It is invoked by the `Q' key in Vi state.

   On a window display, Viper supports mouse search, i.e., you can
search for a word by clicking on it.  *Note Viper Specials::, for
details.

   Finally, on a window display, Viper highlights search patterns as it
finds them.  This is done through what is known as _faces_ in Emacs.
The variable that controls how search patterns are highlighted is
`viper-search-face'.  If you don't want any highlighting at all, put
     (copy-face 'default 'viper-search-face)
   in `~/.viper'.  If you want to change how patterns are highlighted,
you will have to change `viper-search-face' to your liking.  The easiest
way to do this is to use Emacs customization widget, which is accessible
from the menubar.  Viper customization group is located under the
_Emulations_ customization group, which in turn is under the _Editing_
group (or simply by typing `:customize').  All Viper faces are grouped
together under Viper's _Highlighting_ group.

   Try it: it is really simple!


File: viper,  Node: Abbreviation Facilities,  Next: Movement and Markers,  Prev: Improved Search,  Up: Improvements over Vi

2.7 Abbreviation Facilities
===========================

It is possible in Emacs to define abbrevs based on the contents of the
buffer.  Sophisticated templates can be defined using the Emacs
abbreviation facilities.  *Note Abbreviations: (emacs)Abbrevs, for
details.

   Emacs also provides Dynamic Abbreviations.  Given a partial word,
Emacs will search the buffer to find an extension for this word.  For
instance, one can type `Abbreviations' by typing `A', followed by a
keystroke that completed the `A' to `Abbreviations'.  Repeated typing
will search further back in the buffer, so that one could get `Abbrevs'
by repeating the keystroke, which appears earlier in the text.  Emacs
binds this to `<ESC> /', so you will have to find a key and bind the
function `dabbrev-expand' to that key.  Facilities like this make Vi's
`:ab' command obsolete.


File: viper,  Node: Movement and Markers,  Next: New Commands,  Prev: Abbreviation Facilities,  Up: Improvements over Vi

2.8 Movement and Markers
========================

Viper can be set free from the line-limited movements in Vi, such as `l'
refusing to move beyond the line, <ESC> moving one character back, etc.
These derive from Ex, which is a line editor.  If your `.viper' contains

     `(setq viper-ex-style-motion nil)'

the motion will be a true screen editor motion.  One thing you must then
watch out for is that it is possible to be on the end-of-line character.
The keys `x' and `%' will still work correctly, i.e., as if they were
on the last character.

   The word-movement commands `w', `e', etc., and the associated
deletion/yanking commands, `dw', `yw', etc., can be made to understand
Emacs syntax tables.  If the variable `viper-syntax-preference' is set
to `strict-vi' then the meaning of _word_ is the same as in Vi.
However, if the value is `reformed-vi' (the default) then the
alphanumeric symbols will be those specified by the current Emacs syntax
table (which may be different for different major modes) plus the
underscore symbol `_', minus some non-word symbols, like '.;,|, etc.
Both `strict-vi' and `reformed-vi' work close to Vi in traditional
cases, but `reformed-vi' does a better job when editing text in
non-Latin alphabets.

   The user can also specify the value `emacs', which would make Viper
use exactly the Emacs notion of word.  In particular, the underscore
may not be part of a word.  Finally, if `viper-syntax-preference' is
set to `extended', Viper words would consist of characters that are
classified as alphanumeric _or_ as parts of symbols.  This is
convenient for writing programs and in many other situations.

   `viper-syntax-preference' is a local variable, so it can have
different values for different major modes.  For instance, in
programming modes it can have the value `extended'.  In text modes
where words contain special characters, such as European (non-English)
letters, Cyrillic letters, etc., the value can be `reformed-vi' or
`emacs'.

   Changes to `viper-syntax-preference' should be done in the hooks to
various major modes by executing `viper-set-syntax-preference' as in
the following example:

     (viper-set-syntax-preference nil "emacs")

   The above discussion of the meaning of Viper's words concerns only
Viper's movement commands.  In regular expressions, words remain the
same as in Emacs.  That is, the expressions `\w', `\>', `\<', etc., use
Emacs's idea of what is a word, and they don't look into the value of
variable `viper-syntax-preference'.  This is because Viper doesn't
change syntax tables in fear of upsetting the various major modes that
set these tables.

   Textmarkers in Viper remember the file and the position, so that you
can switch files by simply doing `'a'.  If you set up a regimen for
using Textmarkers, this is very useful.  Contents of textmarkers can be
viewed by `[marker'.  (Contents of registers can be viewed by
`]register').


File: viper,  Node: New Commands,  Next: Useful Packages,  Prev: Movement and Markers,  Up: Improvements over Vi

2.9 New Commands
================

These commands have no Vi analogs.

`C-x, C-c'
     These two keys invoke many important Emacs functions.  For
     example, if you hit `C-x' followed by `2', then the current window
     will be split into 2.  Except for novice users, `C-c' is also set
     to execute an Emacs command from the current major mode.  <ESC>
     will do the same, if you configure <ESC> as Meta by setting
     `viper-no-multiple-ESC' to `nil' in `.viper'.  *Note
     Customization::.  `C-\' in Insert, Replace, or Vi states will make
     Emacs think `Meta' has been hit.

`\'
     Escape to Emacs to execute a single Emacs command.  For instance,
     `\ <ESC>' will act like a Meta key.

`Q'
     `Q' is for query replace.  By default, each string to be replaced
     is treated as a regular expression.  You can use `(setq
     viper-re-query-replace nil)' in your `.emacs' file to turn this
     off.  (For normal searches, `:se nomagic' will work.  Note that
     `:se nomagic' turns Regexps off completely, unlike Vi).

`v'
`V'
`C-v'
     These keys are used to visit files.  `v' will switch to a buffer
     visiting file whose name can be entered in the minibuffer.  `V' is
     similar, but will use a window different from the current window.
     `C-v' is like `V', except that a new frame (X window) will be used
     instead of a new Emacs window.

`#'
     If followed by a certain character CH, it becomes an operator whose
     argument is the region determined by the motion command that
     follows (indicated as <move>).  Currently, CH can be one of `c',
     `C', `g', `q', and `s'.  For instance, `#qr' will prompt you for a
     string and then prepend this string to each line in the buffer.

`# c'
     Change upper-case characters in the region to lower-case
     (`downcase-region').  Emacs command `M-l' does the same for words.

`# C'
     Change lower-case characters in the region to upper-case.  For
     instance, `# C 3 w' will capitalize 3 words from the current point
     (`upcase-region').  Emacs command `M-u' does the same for words.

`# g'
     Execute last keyboard macro for each line in the region
     (`viper-global-execute').

`# q'
     Insert specified string at the beginning of each line in the region
     (`viper-quote-region').  The default string is composed of the
     comment character(s) appropriate for the current major mode.

`# s'
     Check spelling of words in the region (`spell-region').  The
     function used for spelling is determined from the variable
     `viper-spell-function'.  

`*'
     Call last keyboard macro.

`m .'
     Set mark at point and push old mark off the ring

`m<'

`m>'
     Set mark at beginning and end of buffer, respectively.

`m,'
     Jump to mark and pop mark off the ring.  *Note Mark: (emacs)Mark,
     for more info.

`] register'
     View contents of register

`[ textmarker'
     View filename and position of textmarker

`@#'

`@register'

`@!'
     Begin/end keyboard macro.  @register has a different meaning when
     used after a `@#'.  *Note Macros and Registers::, for details

`[]'
     Go to end of heading.

`g <_movement command_>'
     Search buffer for text delimited by movement command.  The
     canonical example is `gw' to search for the word under the cursor.
     *Note Improved Search::, for details.

`C-g and C-]'
     Quit and Abort Recursive edit.  These may be necessary on occasion.
     *Note Vi State::, for a reason.

`C-c C-g'
     Hitting `C-c' followed by `C-g' will display the information on the
     current buffer.  This is the same as hitting `C-g' in Vi, but, as
     explained above, `C-g' is needed for other purposes in Emacs.

`C-c /'
     Without a prefix argument, this command toggles
     case-sensitive/case-insensitive search modes and plain
     vanilla/regular expression search.  With the prefix argument 1,
     i.e., `1 C-c /', this toggles case-sensitivity; with the prefix
     argument 2, toggles plain vanilla search and search using regular
     expressions.  *Note Viper Specials::, for alternative ways to
     invoke this function.  

`M-p and M-n'
     In the minibuffer, these commands navigate through the minibuffer
     histories, such as the history of search strings, Ex commands, etc.

`C-s'
     If the minibuffer is entered via a Viper search commands `/' or
     `?', then typing this key inserts the last search string used by
     the Emacs incremental search command (that is bound to `C-s'
     everywhere except in this case).

`C-c M-p and C-c M-n'
     In Insert or Replace state, these commands let  the user peruse
     the history of insertion strings used in previous insert or replace
     commands.  Try to hit `C-c M-p' or `C-c M-n' repeatedly and see
     what happens.  *Note Viper Specials::, for more.

     In Vi state, these commands let the user peruse the history of
     Vi-style destructive commands, such as `dw', `J', `a', etc.  By
     repeatedly typing `C-c M-p' or `C-c M-n' you will cycle Viper
     through the recent history of Vi commands, displaying the commands
     one by one.  Once an appropriate command is found, it can be
     executed by typing ``.''.

     Since typing `C-c M-p' is tedious, it is more convenient to bind an
     appropriate function to a function key on the keyboard and use
     that key.  *Note Viper Specials::, for details.

`Ex commands'
     The commands `:args', `:next', `:pre' behave differently.  `:pwd'
     exists to get current directory.  The commands `:b' and `:B'
     switch buffers around.  *Note File and Buffer Handling::, for
     details.  There are also the new commands `:RelatedFile' and
     `PreviousRelatedFile' (which abbreviate to `R' and `P',
     respectively.  *Note Viper Specials::, for details.  

   Apart from the new commands, many old commands have been enhanced.
Most notably, Vi style macros are much more powerful in Viper than in
Vi.  *Note Vi Macros::, for details.


File: viper,  Node: Useful Packages,  Prev: New Commands,  Up: Improvements over Vi

2.10 Useful Packages
====================

Some Emacs packages are mentioned here as an aid to the new Viper user,
to indicate what Viper is capable of.  A vast number comes with the
standard Emacs distribution, and many more exist on the net and on the
archives.

   This manual also mentions some Emacs features a new user should know
about.  The details of these are found in the GNU Emacs Manual.

   The features first.  For details, look up the Emacs Manual.

`Make'
     Makes and Compiles can be done from the editor.  Error messages
     will be parsed and you can move to the error lines.

`Shell'
     You can talk to Shells from inside the editor.  Your entire shell
     session can be treated as a file.

`Mail'
     Mail can be read from and sent within the editor.  Several
     sophisticated packages exist.

`Language Sensitive Editing'
     Editing modes are written for most computer languages in
     existence.  By controlling indentation, they catch punctuation
     errors.

   The packages, below, represents a drop in the sea of special-purpose
packages that come with standard distribution of Emacs.

`Transparent FTP'
     `ange-ftp.el' can ftp from the editor to files on other machines
     transparent to the user.

`RCS Interfaces'
     `vc.el' for doing RCS commands from inside the editor

`Directory Editor'
     `dired.el' for editing contents of directories and for navigating
     in the file system.

`Syntactic Highlighting'
     `font-lock.el' for automatic highlighting various parts of a buffer
     using different fonts and colors.

`Saving Emacs Configuration'
     `desktop.el' for saving/restoring configuration on Emacs
     exit/startup.

`Spell Checker'
     `ispell.el' for spell checking the buffer, words, regions, etc.

`File and Buffer Comparison'
     `ediff.el' for finding differences between files and for applying
     patches.

Emacs Lisp archives exist on `archive.cis.ohio-state.edu' and
`wuarchive.wustl.edu'


File: viper,  Node: Customization,  Next: Commands,  Prev: Improvements over Vi,  Up: Top

3 Customization
***************

Customization can be done in 2 ways.

   * Elisp code in a `.viper' file in your home directory.  Viper loads
     `.viper' just before it does the binding for mode hooks.  This is
     recommended for experts only.

   * Elisp code in your `.emacs' file before and after the `(require
     'viper)' line.  This method is _not_ recommended, unless you know
     what you are doing.  Only two variables, `viper-mode' and
     `viper-custom-file-name', are supposed to be customized in
     `.emacs', prior to loading Viper (i.e., prior to `(require
     'viper)' command.

   * By executing the `:customize' Ex command. This takes you to the
     Emacs customization widget, which lets you change the values of
     Viper customizable variables easily. This method is good for
     novice and experts alike. The customization code in the form of
     Lisp commands will be placed in `~/.emacs' or some other
     customization file depending on the version of Emacs that you use.
     Still, it is recommended to separate Viper-related customization
     produced by the Emacs customization widget and keep it in the
     `.viper' file.

     Some advanced customization cannot be accomplished this way,
     however, and has to be done in Emacs Lisp in the `.viper' file.
     For the common cases, examples are provided that you can use
     directly.

* Menu:

* Rudimentary Changes::          Simple constant definitions.
* Key Bindings::                 Enabling Emacs Keys, Rebinding keys, etc.
* Packages that Change Keymaps:: How to deal with such beasts.
* Viper Specials::               Special Viper commands.
* Vi Macros::                    How to do Vi style macros.


File: viper,  Node: Rudimentary Changes,  Next: Key Bindings,  Prev: Customization,  Up: Customization

3.1 Rudimentary Changes
=======================

An easy way to customize Viper is to change the values of constants
used in Viper.  Here is the list of the constants used in Viper and
their default values.  The corresponding :se command is also indicated.
(The symbols `t' and `nil' represent "true" and "false" in Lisp).

   Viper supports both the abbreviated Vi variable names and their full
names.  Variable completion is done on full names only.  <TAB> and
<SPC> complete variable names.  Typing `=' will complete the name and
then will prompt for a value, if applicable.  For instance, `:se au
<SPC>' will complete the command to `:set autoindent'; `:se ta <SPC>'
will complete the command and prompt further like this: `:set tabstop =
'.  However, typing `:se ts <SPC>' will produce a "No match" message
because `ts' is an abbreviation for `tabstop' and Viper supports
completion on full names only.  However, you can still hit <RET> or
`=', which will complete the command like this: `:set ts = ' and Viper
will be waiting for you to type a value for the tabstop variable.  To
get the full list of Vi variables, type `:se <SPC> <TAB>'.

`viper-auto-indent nil'
`:se ai (:se autoindent)'
`:se ai-g (:se autoindent-global)'
     If `t', enable auto indentation.  by <RET>, `o' or `O' command.

     `viper-auto-indent' is a local variable.  To change the value
     globally, use `setq-default'.  It may be useful for certain major
     modes to have their own values of `viper-auto-indent'.  This can
     be achieved by using `setq' to change the local value of this
     variable in the hooks to the appropriate major modes.

     `:se ai' changes the value of `viper-auto-indent' in the current
     buffer only; `:se ai-g' does the same globally.

`viper-electric-mode t'
     If not `nil', auto-indentation becomes electric, which means that
     <RET>, `O', and `o' indent cursor according to the current major
     mode.  In the future, this variable may control additional electric
     features.

     This is a local variable: `setq' changes the value of this variable
     in the current buffer only.  Use `setq-default' to change the
     value in all buffers.

`viper-case-fold-search nil'
`:se ic (:se ignorecase)'
     If not `nil', search ignores cases.  This can also be toggled by
     quickly hitting `/' twice.

`viper-re-search nil'
`:se magic'
     If not `nil', search will use regular expressions; if `nil' then
     use vanilla search.  This behavior can also be toggled by quickly
     hitting `/' trice.

`buffer-read-only'
`:se ro (:se readonly)'
     Set current buffer to read only.  To change globally put
     `(setq-default buffer-read-only t)' in your `.emacs' file.

`blink-matching-paren t'
`:se sm (:se showmatch)'
     Show matching parens by blinking cursor.

`tab-width t (default setting via `setq-default')'
`:se ts=value (:se tabstop=value)'
`:se ts-g=value (:se tabstop-global=value)'
     `tab-width' is a local variable that controls the width of the tab
     stops.  To change the value globally, use `setq-default'; for
     local settings, use `setq'.

     The command `:se ts' sets the tab width in the current buffer
     only; it has no effect on other buffers.

     The command `:se ts-g' sets tab width globally, for all buffers
     where the tab is not yet set locally, including the new buffers.

     Note that typing <TAB> normally doesn't insert the tab, since this
     key is usually bound to a text-formatting function,
     `indent-for-tab-command' (which facilitates programming and
     document writing).  Instead, the tab is inserted via the command
     `viper-insert-tab', which is bound to `S-tab' (shift + tab).

     On some non-windowing terminals, Shift doesn't modify the <TAB>
     key, so `S-tab' behaves as if it were <TAB>.  In such a case, you
     will have to bind `viper-insert-tab' to some other convenient key.

`viper-shift-width 8'
`:se sw=value  (:se shiftwidth=value)'
     The number of columns shifted by `>' and `<' commands.

`viper-search-wrap-around t'
`:se ws (:se wrapscan)'
     If not `nil', search wraps around the end/beginning of buffer.

`viper-search-scroll-threshold 2'
     If search lands within this many lines of the window top or
     bottom, the window will be scrolled up or down by about 1/7-th of
     its size, to reveal the context.  If the value is negative--don't
     scroll.

`viper-tags-file-name "TAGS"'
     The name of the file used as the tag table.

`viper-re-query-replace nil'
     If not `nil', use reg-exp replace in query replace.

`viper-want-ctl-h-help nil'
     If not `nil', `C-h' is bound to `help-command'; otherwise, `C-h'
     is bound as usual in Vi.

`viper-vi-style-in-minibuffer t'
     If not `nil', Viper provides a high degree of compatibility with Vi
     insert mode when you type text in the minibuffer; if `nil', typing
     in the minibuffer feels like plain Emacs.

`viper-no-multiple-ESC t'
     If you set this to `nil', you can use <ESC> as Meta in Vi state.
     Normally, this is not necessary, since graphical displays have
     separate Meta keys (usually on each side of the space bar).  On a
     dumb terminal, Viper sets this variable to `twice', which is
     almost like `nil', except that double <ESC> beeps.  This, too,
     lets <ESC> to be used as a Meta.

`viper-fast-keyseq-timeout 200'
     Key sequences separated by this many milliseconds are treated as
     Vi-style keyboard macros.  If the key sequence is defined as such
     a macro, it will be executed.  Otherwise, it is processed as an
     ordinary sequence of typed keys.

     Setting this variable too high may slow down your typing.  Setting
     it too low may make it hard to type macros quickly enough.

`viper-ex-style-motion t'
     Set this to `nil', if you want `l,h' to cross lines, etc.  *Note
     Movement and Markers::, for more info.

`viper-ex-style-editing t'
     Set this to `nil', if you want `C-h' and <DEL> to not stop at the
     beginning of a line in Insert state, <X> and <x> to delete
     characters across lines in Vi command state, etc.

`viper-ESC-moves-cursor-back t'
     It `t', cursor moves back 1 character when switching from insert
     state to vi state.  If `nil', the cursor stays where it was before
     the switch.

`viper-always t'
     `t' means: leave it to Viper to decide when a buffer must be
     brought up in Vi state, Insert state, or Emacs state.  This
     heuristics works well in virtually all cases.  `nil' means you
     either has to invoke `viper-mode' manually for each buffer (or you
     can add `viper-mode' to the appropriate major mode hooks using
     `viper-load-hook').

     This option must be set in the file `~/.viper'.

`viper-custom-file-name "~/.viper"'
     File used for Viper-specific customization.  Change this setting,
     if you want.  Must be set in `.emacs' (not `.viper'!)  before
     Viper is loaded.  Note that you have to set it as a string inside
     double quotes.

`viper-spell-function 'ispell-region'
     Function used by the command `#c<move>' to spell.

`viper-glob-function'
     The value of this variable is the function symbol used to expand
     wildcard symbols. This is platform-dependent. The default tries to
     set this variable to work with most shells, MS Windows, OS/2, etc.
     However, if it doesn't work the way you expect, you should write
     your own.  Use `viper-glob-unix-files' and
     `viper-glob-mswindows-files' in `viper-util.el' as examples.

     This feature is used to expand wildcards in the Ex command `:e'.
     Note that Viper doesn't support wildcards in the `:r' and `:w'
     commands, because file completion is a better mechanism.  

`ex-cycle-other-window t'
     If not `nil', `:n' and `:b' will cycle through files in another
     window, if one exists.

`ex-cycle-through-non-files nil'
     `:n' does not normally cycle through buffers.  Set this to get
     buffers also.

`viper-want-emacs-keys-in-insert'
     This is set to `nil' for user levels 1 and 2 and to `t' for user
     levels 3 and 4.  Users who specify level 5 are allowed to set this
     variable as they please (the default for this level is `t').  If
     set to `nil', complete Vi compatibility is provided in Insert
     state.  This is really not recommended, as this precludes you from
     using language-specific features provided by the major modes.

`viper-want-emacs-keys-in-vi'
     This is set to `nil' for user level 1 and to `t' for user levels
     2-4.  At level 5, users are allowed to set this variable as they
     please (the default for this level is `t').  If set to `nil',
     complete Vi compatibility is provided in Vi command state.
     Setting this to `nil' is really a bad idea, unless you are a
     novice, as this precludes the use of language-specific features
     provided by the major modes.

`viper-keep-point-on-repeat t'
     If not `nil', point is not moved when the user repeats the previous
     command by typing `.'  This is very useful for doing repeated
     changes with the `.' key.

`viper-repeat-from-history-key 'f12'
     Prefix key used to invoke the macros `f12 1' and `f12 2' that
     repeat the second-last and the third-last destructive command.
     Both these macros are bound (as Viper macros) to
     `viper-repeat-from-history', which checks the second key by which
     it is invoked to see which of the previous commands to invoke.
     Viper binds `f12 1' and `f12 2' only, but the user can bind more
     in `~/.viper'.  *Note Vi Macros::, for how to do this.

`viper-keep-point-on-undo nil'
     If not `nil', Viper tries to not move point when undoing commands.
     Instead, it will briefly move the cursor to the place where change
     has taken place.  However, if the undone piece of text is not seen
     in window, then point will be moved to the place where the change
     took place.  Set it to `t' and see if you like it better.

`viper-delete-backwards-in-replace nil'
     If not `nil', <DEL> key will delete characters while moving the
     cursor backwards.  If `nil', the cursor will move backwards
     without deleting anything.

`viper-replace-overlay-face 'viper-replace-overlay-face'
     On a graphical display, Viper highlights replacement regions
     instead of putting a `$' at the end.  This variable controls the
     so called "face" used to highlight the region.

     By default, `viper-replace-overlay-face' underlines the
     replacement on monochrome displays and also lays a stipple over
     them.  On color displays, replacement regions are highlighted with
     color.

     If you know something about Emacs faces and don't like how Viper
     highlights replacement regions, you can change
     `viper-replace-overlay-face' by specifying a new face.  (Emacs
     faces are described in the Emacs Lisp reference.)  On a color
     display, the following customization method is usually most
     effective:
          (set-face-foreground viper-replace-overlay-face "DarkSlateBlue")
          (set-face-background viper-replace-overlay-face "yellow")
     For a complete list of colors available to you, evaluate the
     expression `(x-defined-colors)'.  (Type it in the buffer
     `*scratch*' and then hit the `C-j' key.

`viper-replace-overlay-cursor-color  "Red"'
     Cursor color when it is inside the replacement region.  This has
     effect only on color displays and only when Emacs runs as an X
     application.

`viper-insert-state-cursor-color nil'
     If set to a valid color, this will be the cursor color when Viper
     is in insert state.

`viper-emacs-state-cursor-color nil'
     If set to a valid color, this will be the cursor color when Viper
     is in emacs state.

`viper-replace-region-end-delimiter "$"'
     A string used to mark the end of replacement regions.  It is used
     only on TTYs or if `viper-use-replace-region-delimiters' is
     non-`nil'.

`viper-replace-region-start-delimiter  ""'
     A string used to mark the beginning of replacement regions.  It is
     used only on TTYs or if `viper-use-replace-region-delimiters' is
     non-`nil'.

`viper-use-replace-region-delimiters'
     If non-`nil', Viper will always use
     `viper-replace-region-end-delimiter' and
     `viper-replace-region-start-delimiter' to delimit replacement
     regions, even on color displays (where this is unnecessary).  By
     default, this variable is non-`nil' only on TTYs or monochrome
     displays.

`viper-allow-multiline-replace-regions t'
     If non-`nil', multi-line text replacement regions, such as those
     produced by commands `c55w', `3C', etc., will stay around until
     the user exits the replacement mode.  In this variable is set to
     `nil', Viper will emulate the standard Vi behavior, which supports
     only intra-line replacement regions (and multi-line replacement
     regions are deleted).

`viper-toggle-key "\C-z"'
     Specifies the key used to switch from Emacs to Vi and back.  Must
     be set in `.viper'.  This variable can't be changed interactively
     after Viper is loaded.

     In Insert state, this key acts as a temporary escape to Vi state,
     i.e., it will set Viper up so that the very next command will be
     executed as if it were typed in Vi state.

`viper-buffer-search-char nil'
     Key used for buffer search.  *Note Viper Specials::, for details.

`viper-surrounding-word-function 'viper-surrounding-word'
     The value of this variable is a function name that is used to
     determine what constitutes a word clicked upon by the mouse.  This
     is used by mouse search and insert.

`viper-search-face 'viper-search-face'
     Variable that controls how search patterns are highlighted when
     they are found.

`viper-vi-state-hook nil'
     List of parameterless functions to be run just after entering the
     Vi command state.

`viper-insert-state-hook nil'
     Same for Insert state.  This hook is also run after entering
     Replace state.

`viper-replace-state-hook  nil'
     List of (parameterless) functions called just after entering
     Replace state (and after all `viper-insert-state-hook').

`viper-emacs-state-hook nil'
     List of (parameterless) functions called just after switching from
     Vi state to Emacs state.

`viper-load-hook nil'
     List of (parameterless) functions called just after loading Viper.
     This is the last chance to do customization before Viper is up and
     running.
   You can reset some of these constants in Viper with the Ex command
`:set' (when so indicated in the table).  Or you can include a line
like this in your `.viper' file:
     (setq viper-case-fold-search t)
   

File: viper,  Node: Key Bindings,  Next: Packages that Change Keymaps,  Prev: Rudimentary Changes,  Up: Customization

3.2 Key Bindings
================

Viper lets you define hot keys, i.e., you can associate keyboard keys
such as F1, Help, PgDn, etc., with Emacs Lisp functions (that may
already exist or that you will write).  Each key has a "preferred form"
in Emacs.  For instance, the Up key's preferred form is [up], the Help
key's preferred form is [help], and the Undo key has the preferred form
[f14].  You can find out the preferred form of a key by typing `M-x
describe-key-briefly' and then typing the key you want to know about.

   Under the X Window System, every keyboard key emits its preferred
form, so you can just type

     (global-set-key [f11] 'calendar)                        ; L1, Stop
     (global-set-key [f14] 'undo)                            ; L4, Undo

to bind L1 (a key that exists on some SUN workstations) so it will
invoke the Emacs Calendar and to bind L4 so it will undo changes.
However, on a dumb terminal or in an Xterm window, even the standard
arrow keys may not emit the right signals for Emacs to understand.  To
let Emacs know about those keys, you will have to find out which key
sequences they emit by typing `C-q' and then the key (you should switch
to Emacs state first).  Then you can bind those sequences to their
preferred forms using `input-decode-map' as follows:

     (cond ((string= (getenv "TERM") "xterm")
     (define-key input-decode-map "\e[192z" [f11])    ; L1
     (define-key input-decode-map "\e[195z" [f14])    ; L4, Undo

   The above illustrates how to do this for Xterm.  On VT100, you would
have to replace "xterm" with "vt100" and also change the key sequences
(the same key may emit different sequences on different types of
terminals).

   The above keys are global, so they are overwritten by the local maps
defined by the major modes and by Viper itself.  Therefore, if you wish
to change a binding set by a major mode or by Viper, read this.

   Viper users who wish to specify their own key bindings should be
concerned only with the following three keymaps:
`viper-vi-global-user-map' for Vi state commands,
`viper-insert-global-user-map' for Insert state commands, and
`viper-emacs-global-user-map' for Emacs state commands (note:
customized bindings for Emacs state made to
`viper-emacs-global-user-map' are _not_ inherited by Insert state).

   For more information on Viper keymaps, see the header of the file
`viper.el'.  If you wish to change a Viper binding, you can use the
`define-key' command, to modify `viper-vi-global-user-map',
`viper-insert-global-user-map', and `viper-emacs-global-user-map', as
explained below.  Each of these key maps affects the corresponding
Viper state.  The keymap `viper-insert-global-user-map' also affects
Viper's Replace state.

If you want to bind a key, say `C-v', to the function that scrolls page
down and to make `0' display information on the current buffer, putting
this in `.viper' will do the trick in Vi state:
     (define-key viper-vi-global-user-map "\C-v" 'scroll-down)
   To set a key globally,
     (define-key viper-emacs-global-user-map "\C-c m" 'smail)
     (define-key viper-vi-global-user-map "0" 'viper-info-on-file)
   Note, however, that this binding may be overwritten by other
keymaps, since the global keymap has the lowest priority.  To make sure
that nothing will override a binding in Emacs state, you can write this:
     (define-key viper-emacs-global-user-map "\C-c m" 'smail)
   To customize the binding for `C-h' in Insert state:
     (define-key viper-insert-global-user-map "\C-h" 'my-del-backwards-function)
   Each Emacs command key calls some Lisp function.  If you have
enabled the Help, (*note Rudimentary Changes::) `C-h k' will show you
the function for each specific key; `C-h b' will show all bindings, and
`C-h m' will provide information on the major mode in effect.  If Help
is not enabled, you can still get help in Vi state by prefixing the
above commands with `\', e.g., `\ C-h k' (or you can use the Help menu
in the menu bar, if Emacs runs under X).

   Viper users can also change bindings on a per major mode basis.  As
with global bindings, this can be done separately for each of the three
main Viper states.  To this end, Viper provides the function
`viper-modify-major-mode'.  

   To modify keys in Emacs state for `my-favorite-major-mode', the user
needs to create a sparse keymap, say, `my-fancy-map', bind whatever
keys necessary in that keymap, and put

     (viper-modify-major-mode 'dired-mode 'emacs-state my-fancy-map)

in `~/.viper'.  To do the same in Vi and Insert states, you should use
`vi-state' and `insert-state'.  Changes in Insert state are also in
effect in Replace state.  For instance, suppose that the user wants to
use `dd' in Vi state under Dired mode to delete files, `u' to unmark
files, etc.  The following code in `~/.viper' will then do the job:

     (setq my-dired-modifier-map (make-sparse-keymap))
     (define-key my-dired-modifier-map "dd" 'dired-flag-file-deletion)
     (define-key my-dired-modifier-map "u" 'dired-unmark)
     (viper-modify-major-mode 'dired-mode 'vi-state my-dired-modifier-map)

   A Vi purist may want to modify Emacs state under Dired mode so that
`k', `l', etc., will move around in directory buffers, as in Vi.
Although this is not recommended, as these keys are bound to useful
Dired functions, the trick can be accomplished via the following code:

     (setq my-dired-vi-purist-map (make-sparse-keymap))
     (define-key my-dired-vi-purist-map "k" 'viper-previous-line)
     (define-key my-dired-vi-purist-map "l" 'viper-forward-char)
     (viper-modify-major-mode 'dired-mode 'emacs-state my-dired-vi-purist-map)

   Yet another way to customize key bindings in a major mode is to edit
the list `viper-major-mode-modifier-list' using the customization
widget.  (This variable is in the Viper-misc customization group.)  The
elements of this list are triples of the form: (major-mode viper-state
keymap), where the keymap contains bindings that are supposed to be
active in the given major mode and the given viper-state.

   Effects similar to key binding changes can be achieved by defining Vi
keyboard macros using the Ex commands `:map' and `:map!'.  The
difference is that multi-key Vi macros do not override the keys they are
bound to, unless these keys are typed in quick succession.  So, with
macros, one can use the normal keys alongside with the macros.  If
per-mode modifications are needed, the user can try both ways and see
which one is more convenient.  *Note Vi Macros::, for details.

   Note: in major modes that come up in _Emacs state_ by default, the
aforesaid modifications may not take place immediately (but only after
the buffer switches to some other Viper state and then back to Emacs
state).  To avoid this, one should add `viper-change-state-to-emacs' to
an appropriate hook of that major mode.  (Check the function
`viper-set-hooks' in `viper.el' for examples.)  However, if you did not
set `viper-always' to `nil', chances are that you won't need to perform
the above procedure, because Viper will take care of most useful
defaults.

   Finally, Viper has a facility that lets the user define per-buffer
bindings, i.e., bindings that are in effect in some specific buffers
only.  Unlike per-mode bindings described above, per-buffer bindings
can be defined based on considerations other than the major mode.  This
is done via the function `viper-add-local-keys', which lets one specify
bindings that should be in effect in the current buffer only and for a
specific Viper state.  For instance,
     (viper-add-local-keys 'vi-state '(("ZZ" . TeX-command-master)
                                      ("ZQ" . viper-save-kill-buffer)))
   redefines `ZZ' to invoke `TeX-command-master' in `vi-state' and `ZQ'
to save-then-kill the current buffer.  These bindings take effect only
in the buffer where this command is executed.  The typical use of this
function is to execute the above expression from within a function that
is included in a hook to some major mode.  For instance, the above
expression could be called from a function, `my-tex-init', which may be
added to `tex-mode-hook' as follows:
     (add-hook 'tex-mode-hook 'my-tex-init)
   When TeX mode starts, the hook is executed and the above Lisp
expression is evaluated.  Then, the bindings for `ZZ' and `ZQ' are
changed in Vi command mode for all buffers in TeX mode.

   Another useful application is to bind `ZZ' to `send-mail' in the
Mail mode buffers (the specifics of this depend on which mail package
you are using, `rmail', `mh-e', `vm', etc.  For instance, here is how
to do this for `mh-e', the Emacs interface to MH:
     (defun mh-add-vi-keys ()
       "Set up ZZ for MH-e and XMH."
       (viper-add-local-keys 'vi-state '(("ZZ" . mh-send-letter))))
     (add-hook 'mh-letter-mode-hook 'mh-add-vi-keys)

   You can also use `viper-add-local-keys' to set per buffer bindings
in Insert state and Emacs state by passing as a parameter the symbols
`insert-state' and `emacs-state', respectively.  As with global
bindings, customized local bindings done to Emacs state are not
inherited by Insert state.

   On rare occasions, local keys may be added by mistake.  Usually this
is done indirectly, by invoking a major mode that adds local keys (e.g.,
`shell-mode' redefines <RET>).  In such a case, exiting the wrong major
mode won't rid you from unwanted local keys, since these keys are local
to Viper state and the current buffer, not to the major mode.  In such
situations, the remedy is to type `M-x viper-zap-local-keys'.

   So much about Viper-specific bindings.  *Note Customization:
(emacs)Customization, and the Emacs quick reference card for the
general info on key bindings in Emacs.


File: viper,  Node: Packages that Change Keymaps,  Next: Viper Specials,  Prev: Key Bindings,  Up: Customization

3.2.1 Packages that Change Keymaps
----------------------------------

Viper is designed to coexist with all major and minor modes of Emacs.
This means that bindings set by those modes are generally available
with Viper (unless you explicitly prohibit them by setting
`viper-want-emacs-keys-in-vi' and `viper-want-emacs-keys-in-insert' to
`nil').  If `viper-always' is set to `t' (which is the default), Viper
will try to bring each buffer in the Viper state that is most
appropriate for that buffer.  Usually, this would be the Vi state, but
sometimes it could be the Insert state or the Emacs state.

   Some major mode bindings will necessarily be overwritten by Viper.
Indeed, in Vi state, most of the 1-character keys are used for Vi-style
editing.  This usually causes no problems because most packages
designed for editing files typically do not bind such keys.  Instead,
they use key sequences that start with `C-x' and `C-c'.  This is why it
was so important for us to free up `C-x' and `C-c'.  It is common for
language-specific major modes to bind <TAB> and `C-j' (the line feed)
keys to various formatting functions.  This is extremely useful, but
may require some getting used to for a Vi user.  If you decide that
this feature is not for you, you can re-bind these keys as explained
earlier (*note Customization::).

   Binding for <TAB> is one of the most unusual aspects of Viper for
many novice users.  In Emacs, <TAB> is used to format text and
programs, and is extremely useful.  For instance, hitting <TAB> causes
the current line to be re-indented in accordance with the context.  In
programming, this is very important, since improper automatic
indentation would immediately alert the programmer to a possible error.
For instance, if a `)' or a `"' is missing somewhere above the current
line, <TAB> is likely to mis-indent the line.

   For this reason, Viper doesn't change the standard Emacs binding of
<TAB>, thereby sacrificing Vi compatibility (except for users at level
1).  Instead, in Viper, the key `S-tab' (shift+ tab) is chosen to
emulate Vi's <TAB>.

   We should note that on some non-windowing terminals, Shift doesn't
modify the <TAB> key, so `S-tab' behaves as if it were <TAB>.  In such
a case, you will have to bind `viper-insert-tab' to some other
convenient key.

   Some packages, notably Dired, Gnus, Info, etc., attach special
meaning to common keys like <SPC>, `x', `d', `v', and others.  This
means that Vi command state is inappropriate for working with these
packages.  Fortunately, these modes operate on read-only buffers and are
designed not for editing files, but for special-purpose browsing,
reading news, mail, etc., and Vi commands are meaningless in these
situations.  For this reason, Viper doesn't force Vi state on such
major modes--it brings them in Emacs state.  You can switch to Vi state
by typing `C-z' if, for instance, you want to do Vi-style search in a
buffer (although, usually, incremental search, which is bound to `C-s',
is sufficient in these situations).  But you should then switch back to
Emacs state if you plan to continue using these major modes
productively.  You can also switch to Vi temporarily, to execute just
one command.  This is done by typing `C-c \'.  (In some of these modes,
`/' and `:' are bound Vi-style, unless these keys perform essential
duties.)

   If you would like certain major modes to come up in Emacs state
rather than Vi state (but Viper thinks otherwise), you should put these
major modes on the `viper-emacs-state-mode-list' list and delete them
from `viper-vi-state-mode-list'.  Likewise, you can force Viper's
Insert state on a major mode by putting it in
`viper-insert-state-mode-list'.  

   It is also possible to impose Vi on some major modes, even though
they may bind common keys to specialized commands.  This might make
sense for modes that bind only a small number of common keys.  For
instance, Viper subverts the Shell mode by changing the bindings for
`C-m' and `C-d' using `viper-add-local-keys' described in the section
on customization (*note Customization::).

   In some cases, some _minor_ modes might override certain essential
bindings in Vi command state.  This is not a big problem because this
can happen only in the beginning, when the minor mode kicks in.  Typing
`M-x viper-mode' will correct the situation.  Viper knows about several
such minor modes and takes care of them, so the above trick is usually
not necessary.  If you find that some minor mode, e.g., `nasty-mode'
interferes with Viper, putting the following in `.viper' should fix the
problem:
     (viper-harness-minor-mode "nasty-mode")
   The argument to `viper-harness-minor-mode' is the name of the file
for the offending minor mode with the suffixes `.el' and `.elc' removed.

   It may not be always obvious which minor mode is at fault.  The only
guidance here is to look into the file that defines the minor mode you
are suspecting, say `nasty-mode.el', and see if it has a variable called
`nasty-mode-map'.  Then check if there is a statement of the form
     (define-key nasty-mode-map key function)
   that binds the misbehaving keys.  If so, use the above line to
harness `nasty-mode'.  If your suspicion is wrong, no harm is done if
you harness a minor mode that doesn't need to be harnessed.

   It is recommended to harness even those minor modes that don't
override Viper keys, but still have their own keymaps. A general way to
make a minor mode, `my-mode', compatible with Viper is to have the file
`my-mode.el' include the following code:

     (when (fboundp 'viper-harness-minor-mode)
       (let ((lib (file-name-sans-extension
                    (file-name-nondirectory load-file-name))))
         (viper-harness-minor-mode lib)))


File: viper,  Node: Viper Specials,  Next: Vi Macros,  Prev: Packages that Change Keymaps,  Up: Customization

3.3 Viper Specials
==================

Viper extends Vi with a number of useful features.  This includes
various search functions, histories of search strings, Ex commands,
insertions, and Vi's destructive commands.  In addition, Viper supports
file name completion and history, completion of Ex commands and
variables, and many other features.  Some of these features are
explained in detail elsewhere in this document.  Other features are
explained here.

`(viper-buffer-search-enable)'

`viper-buffer-search-char nil'
     Enable buffer search.  Explicit call to
     `viper-buffer-search-enable' sets `viper-buffer-search-char' to
     `g'.  Alternatively, the user can set `viper-buffer-search-char'
     in `.viper' to a key sequence to be used for buffer search.  There
     is no need to call `viper-buffer-search-enable' in that case.  

`viper-toggle-search-style'
     This function, bound to `C-c /', lets one toggle case-sensitive and
     case-insensitive search, and also switch between plain vanilla
     search and search via regular expressions.  Without the prefix
     argument, the user is asked which mode to toggle.  With prefix
     argument 1, this toggles case-sensitivity.  With prefix argument
     2, regular expression/vanilla search will be toggled.

     However, we found that the most convenient way to toggle these
     options is to bind a Vi macro to bind `//' to toggles case
     sensitivity and to `///' to toggles vanilla search.  Thus, quickly
     hitting `/' twice will switch Viper from case sensitive search to
     case-insensitive.  Repeating this once again will restore the
     original state.  Likewise, quickly hitting `/' three times will
     switch you from vanilla-style search to search via regular
     expressions.  If you hit something other than `/' after the first
     `/' or if the second `/' doesn't follow quickly enough, then Viper
     will issue the usual prompt `/' and will wait for input, as usual
     in Vi.  If you don't like this behavior, you can "unrecord" these
     macros in your `~/.viper' file.  For instance, if you don't like
     the above feature, put this in `~/.viper':
          (viper-set-searchstyle-toggling-macros 'undefine)
     
     If you don't like this feature as a default, but would still like
     to have it in some major modes, you can do so by first unsetting
     it globally, as shown above, and then setting it in the desired
     major modes as follows:
          (viper-set-searchstyle-toggling-macros nil 'c-mode)
          (viper-set-searchstyle-toggling-macros nil 'lisp-mode)

`Vi-isms in Emacs state'
     Some people find it useful to use the Vi-style search key, `/', to
     invoke search in modes which Viper leaves in emacs-state.  These
     modes are: `dired-mode', `mh-folder-mode', `Info-mode', and
     `Buffer-menu-mode' (more may be added in the future).  So, in the
     above modes, Viper binds `/' so that it will behave Vi-style.
     Furthermore, in those major modes, Viper binds `:' to invoke
     ex-style commands, like in vi-state.  And, as described above,
     `//' and `///' get bound to Vi-style macros that toggle
     case-insensitivity and regexp-search.

     If you don't like these features--which I don't really
     understand--you can unbind `/' and `:' in
     `viper-dired-modifier-map' (for Dired) or in
     `viper-slash-and-colon-map', for other modes.  

     To unbind the macros `//' and `///' for a major mode where you
     feel they are undesirable, execute
     `viper-set-emacs-state-searchstyle-macros' with a non-`nil'
     argument.  This can be done either interactively, by supplying a
     prefix argument, or by placing
          (viper-set-emacs-state-searchstyle-macros 'undefine)
     in the hook to the major mode (e.g., `dired-mode-hook').  *Note Vi
     Macros::, for more information on Vi macros.

`viper-heading-start'

`viper-heading-end'
     Regular Expressions for `[[' and `]]'.  Note that Emacs defines
     Regexps for paragraphs and sentences.  *Note Paragraphs and
     Sentences: (emacs)Paragraphs, for details.

`M-x viper-set-expert-level'
     Change your user level interactively.

`viper-smart-suffix-list  '("" "tex" "c" "cc" "el" "p")'
     Viper supports Emacs-style file completion when it prompts the
     user for a file name.  However, in many cases, the same directory
     may contain files with identical prefix but different suffixes,
     e.g., prog.c, prog.o, paper.tex, paper.dvi.  In such cases,
     completion will stop at the `.'.  If the above variable is a list
     of strings representing suffixes, Viper will try these suffixes in
     the order listed and will check if the corresponding file exists.

     For instance, if completion stopped at `paper.' and the user typed
     <RET>, then Viper will check if the files `paper.', `paper.tex',
     `paper.c', etc., exist.  It will take the first such file.  If no
     file exists, Viper will give a chance to complete the file name by
     typing the appropriate suffix.  If `paper.' was the intended file
     name, hitting return will accept it.

     To turn this feature off, set the above variable to `nil'.

`viper-insertion-ring-size  14'
     Viper remembers what was previously inserted in Insert and Replace
     states.  Several such recent insertions are kept in a special ring
     of strings of size `viper-insertion-ring-size'.  If you enter
     Insert or Replace state you can reinsert strings from this ring by
     typing `C-c M-p' or `C-c M-n'.  The former will search the ring in
     the direction of older insertions, and the latter will search in
     the direction of newer insertions.  Hitting `C-c M-p' or `C-c M-n'
     in succession will undo the previous insertion from the ring and
     insert the next item on the ring.  If a larger ring size is
     needed, change the value of the above variable in the `~/.viper'
     file.

     Since typing these sequences of keys may be tedious, it is
     suggested that the user should bind a function key, such as `f31',
     as follows:
          (define-key viper-insert-global-user-map [f31]
                      'viper-insert-prev-from-insertion-ring)
     This binds `f31' (which is usually `R11' on a Sun workstation) to
     the function that inserts the previous string in the insertion
     history.  To rotate the history in the opposite direction, you can
     either bind an unused key to
     `viper-insert-next-from-insertion-ring' or hit any digit (1 to 9)
     then `f31'.

     One should not bind the above functions to `M-p' or `M-n', since
     this will interfere with the minibuffer histories and, possibly,
     other major modes.

`viper-command-ring-size  14'
     Viper keeps track of the recent history of destructive commands,
     such as `dw', `i', etc.  In Vi state, the most recent command can
     be re-executed by hitting ``.'', as in Vi.  However, repeated
     typing `C-c M-p' will cause Viper to show the previous destructive
     commands in the minibuffer.  Subsequent hitting ``.'' will execute
     the command that was displayed last.  The key `C-c M-n' will cycle
     through the command history in the opposite direction.  Since
     typing `C-c M-p' may be tedious, it is more convenient to bind an
     appropriate function to an unused function key on the keyboard and
     use that key.  For instance, the following
          (define-key viper-vi-global-user-map [f31]
                      'viper-prev-destructive-command)
     binds the key `f31' (which is usually `R11' on a Sun workstation)
     to the function that searches the command history in the direction
     of older commands.  To search in the opposite direction, you can
     either bind an unused key to `viper-next-destructive-command' or
     hit any digit (1 to 9) then `f31'.

     One should not bind the above functions to `M-p' or `M-n', since
     this will interfere with the minibuffer histories and, possibly,
     other major modes.

`viper-minibuffer-vi-face  'viper-minibuffer-vi-face'

`viper-minibuffer-insert-face  'viper-minibuffer-insert-face'

`viper-minibuffer-emacs-face  'viper-minibuffer-emacs-face'
     These faces control the appearance of the minibuffer text in the
     corresponding Viper states.  You can change the appearance of
     these faces through Emacs's customization widget, which is
     accessible through the menubar.

     Viper is located in this widget under the _Emulations_
     customization subgroup of the _Editing_ group.  All Viper faces
     are grouped together in Viper's _Highlighting_ customization
     subgroup.

     Note that only the text you type in is affected by the above faces.
     Prompts and minibuffer messages are not affected.

     Purists who do not like adornments in the minibuffer can always
     zap them by putting
          (copy-face 'default 'viper-minibuffer-vi-face)
          (copy-face 'default 'viper-minibuffer-insert-face)
          (copy-face 'default 'viper-minibuffer-emacs-face)
     in the `~/.viper' file or through the customization widget, as
     described above.  However, in that case, the user will not have any
     indication of the current Viper state in the minibuffer.  (This is
     important if the user accidentally switches to another Viper state
     by typing <ESC> or `C-z').

`M-x viper-go-away'
     Make Viper disappear from the face of your running Emacs instance.
     If your fingers start aching again, `M-x viper-mode' might save
     your day.

`M-x toggle-viper-mode'
     Toggle Viperization of Emacs on and off.

   Viper provides some support for multi-file documents and programs.
If a document consists of several files we can designate one of them as
a master and put the following at the end of that file:
     ;; Local Variables:
     ;; eval: (viper-setup-master-buffer "file1" "file2" "file3" "file4")
     ;; End:
   where `file1' to `file4' are names of files related to the master
file.  Next time, when the master file is visited, the command
`viper-setup-master-buffer' will be evaluated and the above files will
be associated with the master file.  Then, the new Ex command
`:RelatedFile' (abbr. `:R') will display files 1 to 4 one after
another, so you can edit them.  If a file is not in any Emacs buffer, it
will be visited.  The command `PreviousRelatedFile' (abbr., `:P') goes
through the file list in the opposite direction.  

   These commands are akin to `:n' and `:N', but they allow the user to
focus on relevant files only.

   Note that only the master file needs to have the aforementioned
block of commands.  Also, ";;" above can be replaced by some other
markers.  Semicolon is good for Lisp programs, since it is considered a
comment designator there.  For LaTeX, this could be "%%%", and for C the
above block should be commented out.

   Even though these commands are sometimes useful, they are no
substitute for the powerful _tag table_ facility of Emacs.  Viper's
`:tag' command in a primitive interface to Emacs tags.  *Note Tags:
(emacs)Tags, for more information on tags.

   The following two commands are normally bound to a mouse click and
are part of Viper.  They work only if Emacs runs as an application
under X Windows (or under some other window system for which a port of
GNU Emacs 20 is available).  Clicking the mouse when Emacs is invoked
in an Xterm window (using `emacs -nw') will do no good.

`viper-mouse-search-key  (meta shift 1)'
     This variable controls the _mouse-search_ feature of Viper.  The
     default value states that holding Meta and Shift keys while
     clicking mouse button 1 should initiate search for a region under
     the mouse pointer (defined below).  This command can take a prefix
     argument, which indicates the occurrence of the pattern to search
     for.

     Note: while loading initially, Viper binds this mouse action only
     if it is not already bound to something else.  If you want to use
     the mouse-search feature, and the `Meta-Shift-Mouse-1' mouse
     action is already bound to something else, you can rebind the
     mouse-search feature by setting `viper-mouse-search-key' to
     something else in your `~/.viper' file:
          (setq viper-mouse-search-key '(meta 1))
     This would bind mouse search to the action invoked by pressing the
     Meta key and clicking mouse button 1.  The allowed values of
     `viper-mouse-search-key' are lists that contain a mouse-button
     number (1,2, or 3) and any combination of the words `control',
     `meta', and `shift'.

     If the requested mouse action (e.g., (meta 1)) is already taken
     for other purposes then you have to confirm your intention by
     placing the following command in `~/.viper' after setting
     `viper-mouse-search-key':
          (viper-bind-mouse-search-key 'force)

     You can also change this setting interactively, through the
     customization widget of Emacs (type `:customize').

     The region that is chosen as a pattern to search for is determined
     as follows.  If search is invoked via a single click, Viper
     chooses the region that lies between the beginning of the "word"
     under the pointer ("word" is understood in Vi sense) and the end
     of that word.  The only difference with Vi's words is that in Lisp
     major modes `-' is considered an alphanumeric symbol.  This is
     done for the convenience of working with Lisp symbols, which often
     have an `-' in them.  Also, if you click on a non-alphanumeric
     character that is not a word separator (in Vi sense) then this
     character will also be considered alphanumeric, provided that it is
     adjacent (from either side) to an alphanumeric character.  This
     useful feature gives added control over the patterns selected by
     the mouse click.

     On a double-click, the region is determined by the beginning of
     the current Vi's "Word" (i.e., the largest non-separator chunk of
     text) and the End of that "Word" (as determined by the `E'
     command).

     On a triple-click, the region consists of the entire line where
     the click occurred with all leading and trailing spaces and tabs
     removed.

`viper-mouse-insert-key (meta shift 2)'
     This variable controls the _mouse-insert_ feature of Viper.  The
     above default value states that holding Meta and Shift keys while
     clicking mouse button 2 should insert the region surrounding the
     mouse pointer.  The rules defining this region are the same as for
     mouse-search.  This command takes an optional prefix argument,
     which indicates how many such regions to snarf from the buffer and
     insert.  (In case of a triple-click, the prefix argument is
     ignored.)

     Note: while loading initially, Viper binds this mouse action only
     if it not already bound to something else.  If you want to use
     this feature and the default mouse action is already bound, you
     can rebind mouse-insert by placing this command in `~/.viper':
          (setq viper-mouse-insert-key '(meta 2))
     If you want to bind mouse-insert to an action even if this action
     is already taken for other purposes in Emacs, then you should add
     this command to `~/.viper', after setting `viper-mouse-insert-key':
          (viper-bind-mouse-insert-key 'force)

     This value can also be changed via the Emacs customization widget
     at the menubar.

`viper-multiclick-timeout'
     This variable controls the rate at which double-clicking must
     occur for the purpose of mouse search and mouse insert.  By
     default, this is set to `double-click-time' in Emacs and to
     `mouse-track-multi-click-time' milliseconds in XEmacs.
   
   Note: The above functions search and insert in the selected window of
the latest active frame.  This means that you can click in another
window or another frame and have search or insertion done in the frame
and window you just left.  This lets one use these functions in a
multi-frame configuration.  However, this may require some getting used
to.  For instance, if you are typing in a frame, A, and then move the
mouse to frame B and click to invoke mouse search, search (or
insertion) will be performed in frame A.  To perform search/insertion
in frame B, you will first have to shift focus there, which doesn't
happen until you type a character or perform some other action in frame
B--mouse search doesn't shift focus.

   If you decide that you don't like the above feature and always want
search/insertion be performed in the frame where the click occurs, don't
bind (and unbind, if necessary) `viper-mouse-catch-frame-switch' from
the mouse event it is bound to.

   Mouse search is integrated with Vi-style search, so you can repeat
it with `n' and `N'.  It should be also noted that, while
case-sensitivity of search in Viper is controlled by the variable
`viper-case-fold-search', the case of mouse search is controlled by the
Emacs variable `case-fold-search', which may be set differently from
`viper-case-fold-search'.  Therefore, case-sensitivity of mouse search
may be different from that of the usual Vi-style search.

   Finally, if the way Viper determines the word to be searched for or
to be inserted is not what you want, there is a variable,
`viper-surrounding-word-function', which can be changed to indicate
another function for snarfing words out of the buffer.  The catch is
that you will then have to write such a function and make it known to
your Emacs.  The function `viper-surrounding-word' in `viper.el' can be
used as a guiding example.


File: viper,  Node: Vi Macros,  Prev: Viper Specials,  Up: Customization

3.4 Vi Macros
=============

Viper supports much enhanced Vi-style macros and also facilitates the
use of Emacs-style macros.  To define a temporary macro, it is
generally more convenient to use Emacs keyboard macro facility.  Emacs
keyboard macros are usually defined anonymously, and the latest macro
can be executed by typing `C-x e' (or `*', if Viper is in Vi state).
If you need to use several temporary macros, Viper lets you save them
to a register (a lowercase letter); such macros can then be executed by
typing `@a' in Vi state (if a macro was previously saved in register
`a').  *Note Macros and Registers::, for details.

   If, however, you need to use a macro regularly, it must be given a
permanent name and saved.  Emacs manual explains how to do this, but
invocation of named Emacs macros is quite different from Vi's.  First,
invocation of permanent Emacs macros takes time because it requires
typing too many keys (to  a Vi user's taste, anyway).  Second, binding
such macros to function keys, for fast access, hogs valuable real
estate on the keyboard.

   Vi-style macros are better in that respect, since Vi lets the user
overload the meaning of key sequences: keys typed in fast succession
are treated specially, if this key sequence is bound to a macro.

   Viper provides Vi-style keyboard macros through the usual Ex
commands, `:map' and `:map!'.  These macros are much more powerful in
Viper than they are in the original Vi and in other emulators.  This is
because Viper implements an enhanced vi-style interface to the powerful
Emacs keyboard macro facility.

   First, any Emacs command can be executed while defining a macro, not
just the Vi commands.  In particular, the user can invoke Emacs
commands via `M-x command-name' or by pressing various function keys on
the keyboard.  One can even use the mouse, although this is usually not
useful and is not recommended (and macros defined with the use of the
mouse cannot be saved in command history and in the startup file, for
future use).

   Macros defined by mixing Vi and Emacs commands are represented as
vectors.  So, don't be confused when you see one (usually through the
history of Ex commands).  For instance, if `gg' is defined by typing
`l', the up-arrow key and `M-x next-line', its definition will look as
follows in Emacs:

     [l up (meta x) n e x t - l i n e return]

   Second, Viper macros are defined in a WYSIWYG style.  This means that
commands are executed as you type them, so you can see precisely what is
being defined.  Third, macros can be bound to arbitrary sequences of
keys, not just to printable keys.  For instance, one can define a macro
that will be invoked by hitting `f3' then `f2' function keys.  (The keys
`delete' and `backspace' are excluded; also, a macro invocation
sequence can't start with <ESC>.  Some other keys, such as `f1' and
`help', can't be bound to macros under Emacs, since they are bound in
`key-translation-map', which overrides any other binding the user gives
to keys.  In general, keys that have a binding in `key-translation-map'
can't be bound to a macro.)

   Fourth, in Viper, one can define macros that are specific to a given
buffer, a given major mode, or macros that are defined for all buffers.
In fact, the same macro name can have several different definitions: one
global, several definitions for various major modes, and definitions
for various specific buffers.  Buffer-specific definitions override
mode-specific definitions, which, in turn, override global definitions.

   As if all that is not enough, Viper (through its interface to Emacs
macros) lets the user define keyboard macros that ask for confirmation
or even prompt the user for input and then continue.  To do this, one
should type `C-x q' (for confirmation) or `C-u C-x q' (for prompt).
For details, *note Customization: (emacs)Keyboard Macro Query.

   When the user finishes defining a macro (which is done by typing
`C-x)' -- a departure from Vi), you will be asked whether you want this
macro to be global, mode-specific, or buffer-specific.  You will also be
given a chance to save the macro in your `~/.viper' file.  This is the
easiest way to save a macro and make it permanently available.  If you
work your startup files with bare hands, here is how Viper saves the
above macro so that it will be available in Viper's Insert state (and
Replace state) in buffer `my-buf' only:

     (viper-record-kbd-macro "gg" 'insert-state
            [l up (meta x) n e x t - l i n e return]
            "my-buf")

To do the same for Vi state and all buffers with the major mode
`cc-mode', use:

     (viper-record-kbd-macro "gg" 'vi-state
            [l up (meta x) n e x t - l i n e return]
            'cc-mode)

Both macro names and macro definitions are vectors of symbols that
denote keys on the keyboard.  Some keys, like `\', ` ', or digit-keys
must be escaped with a backslash.  Modified keys are represented as
lists.  For instance, holding Meta and Control and pressing `f4' is
represented as `(control meta f4)'.  If all members of a vectors are
printable characters (or sequences, such as `\e', `\t', for <ESC> and
<TAB>), then they can also be represented as strings:

     (viper-record-kbd-macro "aa" 'vi-state  "aaa\e"  "my-buffer")

Thus, typing `aa' fast in Vi state will switch Viper to Insert state
(due to the first `a'), insert `aa', and then it will switch back to Vi
state.  All this will take effect only in the buffer named `my-buffer'.

   Note that the last argument to `viper-record-kbd-macro' must be
either a string (a buffer name), a symbol representing a major mode, or
`t'; the latter says that the macro is to be defined for all buffers
(which is how macros are defined in original Vi).

   For convenience, Viper also lets you define Vi-style macros in its
Emacs state.  There is no Ex command, like `:map' and `:map!' for doing
this, but the user can include such a macro in the `~/.viper' file.  The
only thing is that the `viper-record-kbd-macro' command should specify
`emacs-state' instead of `vi-state' or `insert-state'.

   The user can get rid of a macro either by using the Ex commands
`:unmap' and `:unmap!' or by issuing a call to
`viper-unrecord-kbd-macro'.  The latter is more powerful, since it can
delete macros even in `emacs-state'.  However,
`viper-unrecord-kbd-macro' is usually needed only when the user needs
to get rid of the macros that are already predefined in Viper.  The
syntax is: 
     (viper-unrecord-kbd-macro macro state)
   The second argument must be `vi-state', `insert-state', or
`emacs-state'.  The first argument is a name of a macro.  To avoid
mistakes in specifying names of existing macros, type `M-x
viper-describe-kbd-macros' and use a name from the list displayed by
this command.

   If an error occurs during macro definition, Emacs aborts the
process, and it must be repeated.  This is analogous to Vi, except that
in Vi the user doesn't know there is an error until the macro is
actually run.  All that means that in order for a definition to be
successful, the user must do some simple planning of the process in
advance, to avoid errors.  For instance, if you want to map `gg' to
`llll' in Vi state, you must make sure that there is enough room on the
current line.  Since `l' moves the cursor forward, it may signal an
error on reaching the end of line, which will abort the definition.

   These precautions are necessary only when defining macros; they will
help avoid the need to redo the job.  When macros are actually run, an
error during the execution will simply terminate the current execution
(but the macro will remain mapped).

   A macro name can be a string of characters or a vector of keys.  The
latter makes it possible to define macros bound to, say, double-hits on
a function key, such as `up' or `f13'.  This is very useful if you run
out of function keys on your keyboard; it makes Viper macro facility a
_keyboard doubler_, so to speak.

   Elsewhere (*Note Key Bindings::, for details), we review the
standard Emacs mechanism for binding function keys to commands.  For
instance,

     (global-set-key [f13] 'repeat-complex-command)

binds the key f13 to the Emacs function that repeats the last minibuffer
command.  Under Viper, however, you may still use this key for
additional purposes, if you bind, say, a double-hitting action for that
key to some other function.  Emacs doesn't allow the user to do that,
but Viper does this through its keyboard macro facility.  To do this,
type `:map ' first.  When you are asked to enter a macro name, hit f13
twice, followed by <RET> or <SPC>.

   Emacs will now start the mapping process by actually executing Vi
and Emacs commands, so that you could see what will happen each time the
macro is executed.  Suppose now we wanted to bind the key sequence `f13
f13' to the command `eval-last-sexp'.  To accomplish this, we can type
`M-x eval-last-sexp' followed by `C-x )'.  If you answer positively to
Viper's offer to save this macro in `~/.viper' for future uses, the
following will be inserted in that file:

     (viper-record-kbd-macro [f16 f16] 'vi-state
              [(meta x) e v a l - l a s t - s e x p]
              'lisp-interaction-mode)

   To illustrate the above point, Viper provides two canned macros,
which, by default, are bound to `[f12 \1]' and `[f12 \2]' (invoked by
typing `f12' then `1' and `2', respectively).  These macros are useful
shortcuts to Viper's command ring history.  The first macro will
execute the second-last destructive command (the last one is executed
by `.', as usual).  The second macro executes the third-last command.

   If you need to go deeper into the command history, you will have to
use other commands, as described earlier in this section; or you can
bind, say, `f12 \3' like this:

     (viper-record-kbd-macro [f12 \3] 'vi-state
                           [(meta x) r e p e a t - f r o m - h i s t o r y]
                           t)

   Note that even though the macro uses the function key `f12', the key
is actually free and can still be bound to some Emacs function via
`define-key' or `global-set-key'.

   Viper allows the user to define macro names that are prefixes of
other macros.  For instance, one can define `[[' and `[[[[' to be
macros.  If you type the exact sequence of such keys and then pause,
Viper will execute the right macro.  However, if you don't pause and,
say, type `[[[[text' then the conflict is resolved as follows.  If only
one of the key sequences, `[[' or `[[[[' has a definition applicable to
the current buffer, then, in fact, there is no conflict and the right
macro will be chosen.  If both have applicable definitions, then the
first one found will be executed.  Usually this is the macro with a
shorter name.  So, in our case, `[[[[text' will cause the macro `[[' to
be executed twice and then the remaining keys, `t e x t', will be
processed.

   When defining macros using `:map' or `:map!', the user enters the
actually keys to be used to invoke the macro.  For instance, you should
hit the actual key `f6' if it is to be part of a macro name; you do
_not_ write `f 6'.  When entering keys, Viper displays them as strings
or vectors (e.g., `"abc"' or `[f6 f7 a]').  The same holds for
unmapping.  Hitting <TAB> while typing a macro name in the `:unmap' or
`:unmap!' command will cause name completion.  Completions are
displayed as strings or vectors.  However, as before, you don't
actually type `"', `[', or `]' that appear in the completions.  These
are meta-symbols that indicate whether the corresponding macro name is a
vector or a string.

   One last difference from Vi: Vi-style keyboard macros cannot be
defined in terms of other Vi-style keyboard macros (but named Emacs
macros are OK).  More precisely, while defining or executing a macro,
the special meaning of key sequences (as Vi macros) is ignored.  This
is because it is all too easy to create an infinite loop in this way.
Since Viper macros are much more powerful than Vi's it is impossible to
detect such loops.  In practice, this is not really a limitation but,
rather, a feature.

   We should also note that Vi macros are disabled in the minibuffer,
which helps keep some potential troubles away.

   The rate at which the user must type keys in order for them to be
recognized as a timeout macro is controlled by the variable
`viper-fast-keyseq-timeout', which defaults to 200 milliseconds.

   For the most part, Viper macros defined in `~/.viper' can be shared
between X and TTY modes.  The problem with TTY may be that the function
keys there generate sequences of events instead of a single event (as
under a window system).  Emacs maps some of these sequences back to the
logical keys (e.g., the sequences generated by the arrow keys are
mapped to `up', `left', etc.).  However, not all function keys are
mapped in this way.  Macros that are bound to key sequences that
contain such unmapped function keys have to be redefined for TTY's (and
possibly for every type of TTY you may be using).  To do this, start
Emacs on an appropriate TTY device and define the macro using `:map',
as usual.

   Finally, Viper provides a function that conveniently displays all
macros currently defined.  To see all macros along with their
definitions, type `M-x viper-describe-kbd-macros'.


File: viper,  Node: Commands,  Prev: Customization,  Up: Top

4 Commands
**********

This section is a semi-automatically bowdlerized version of the Vi
reference created by
`maart@cs.vu.nl' and others.  It can be found on the Vi archives.  This
reference has been adapted for Viper.

* Menu:

* Groundwork::                  Textual Conventions and Viper basics
* Text Handling::               Moving, Editing, Undoing.
* Display::                     Scrolling.
* File and Buffer Handling::    Editing, Writing and Quitting.
* Mapping::                     Mapping Keys, Keyboard Macros
* Shell Commands::              Accessing Shell Commands, Processing Text
* Options::                     Ex options, the :set commands
* Emacs Related Commands::      Meta Keys, Windows
* Mouse-bound Commands::        Search and insertion of text


File: viper,  Node: Groundwork,  Next: Text Handling,  Prev: Commands,  Up: Commands

4.1 Groundwork
==============

The VI command set is based on the idea of combining motion commands
with other commands.  The motion command is used as a text region
specifier for other commands.  We classify motion commands into "point
commands" and "line commands".

   The point commands are:

     `h', `l', `0',  `$', `w', `W', `b', `B', `e', `E', `(', `)', `/',
     `?', ``', `f', `F', `t', `T', `%', `;', `,', `^'

   The line commands are:

     `j', `k', `+', `-', `H', `M', `L', `{', `}', `G', `'',  `[[',
     `]]', `[]'
   Text Deletion Commands (*note Deleting Text::), Change commands
(*note Changing Text::), even Shell Commands (*note Shell Commands::)
use these commands to describe a region of text to operate on.

   Viper adds two region descriptors, `r' and `R'.  These describe the
Emacs regions (*note Basics::), but they are not movement commands.

   The command description uses angle brackets `<>' to indicate
metasyntactic variables, since the normal conventions of using simple
text can be confusing with Viper where the commands themselves are
characters.  Watch out where `<' shift commands and `<count>' are
mentioned together!!!

   `<move>' refers to the above movement commands, and `<a-z>' refers
to registers or textmarkers from `a' to `z'.  Note that the `<move>'
is described by full move commands, that is to say they will take
counts, and otherwise behave like normal move commands.  `<address>'
refers to Ex line addresses, which include

`. <No address>'
     Current line

`.+n .-n'
     Add or subtract for current line

`number'
     Actual line number, use `.=' to get the line number

`'<a-z>'
     Textmarker

`$'
     Last line

`x,y'
     Where x and y are one of the above

`%'
     For the whole file, same as (1,$).

`/<pat>/'
`?<pat>?'
     Next or previous line with pattern <pat>.

     Note that the pattern is allowed to contain newline character
     (inserted as `C-qC-j').  Therefore, one can search for patterns
     that span several lines.

   Note that `%' is used in Ex commands `:e' and `:r <shell-cmd>' to
mean current file.  If you want a `%' in your command, it must be
escaped as `\%'. Note that `:w' and the regular `:r <file>' command
doesn't support the meta symbols `%' and `#', because file history is a
better mechanism.  Similarly, `#' expands to the previous file.  The
previous file is the first file in `:args' listing.  This defaults to
previous window in the VI sense if you have one window only.

Others like `<args> -- arguments', `<cmd> -- command' etc.  should be
fairly obvious.

Common characters referred to include:

`<sp>'
     Space

`<ht>'
     Tab

`<lf>'
     Linefeed

`<esc>'
     Escape

`<cr>'
     Return, Enter
   
   We also use `word' for alphanumeric/non-alphanumeric words, and
`WORD' for whitespace delimited words.  `char' refers to any ASCII
character, `CHAR' to non-whitespace character.  Brackets `[]' indicate
optional parameters; `<count>' also optional, usually defaulting to 1.
Brackets are elided for `<count>' to eschew obfuscation.

   Viper's idea of Vi's words is slightly different from Vi.  First,
Viper words understand Emacs symbol tables.  Therefore, all symbols
declared to be alphanumeric in a symbol table can automatically be made
part of the Viper word.  This is useful when, for instance, editing
text containing European, Cyrillic, Japanese, etc., texts.

   Second, Viper lets you depart from Vi's idea of a word by changing
the a syntax preference via the customization widget (the variable
`viper-syntax-preference') or by executing
`viper-set-syntax-preference' interactively.

   By default, Viper syntax preference is `reformed-vi', which means
that Viper considers only those symbols to be part of a word that are
specified as word-symbols by the current Emacs syntax table (which may
be different for different major modes) plus the underscore symbol `_',
minus the symbols that are not considered words in Vi (e.g., `,',;,
etc.), but may be considered as word-symbols by various Emacs major
modes.  Reformed-Vi works very close to Vi, and it also recognizes
words in other alphabets.  Therefore, this is the most appropriate mode
for editing text and is likely to fit all your needs.

   You can also set Viper syntax preference to `strict-vi', which would
cause Viper to view all non-English letters as non-word-symbols.

   You can also specify `emacs' as your preference, which would make
Viper use exactly the same notion of a word as Emacs does.  In
particular, the underscore may not be part of a word in some major
modes.

   Finally, if `viper-syntax-preference' is set to `extended', Viper
words would consist of characters that are classified as alphanumeric
_or_ as parts of symbols.  This is convenient for editing programs.

   `viper-syntax-preference' is a local variable, so it can have
different values for different major modes.  For instance, in
programming modes it can have the value `extended'.  In text modes
where words contain special characters, such as European (non-English)
letters, Cyrillic letters, etc., the value can be `reformed-vi' or
`emacs'.  If you consider using different syntactic preferences for
different major modes, you should execute, for example,

     (viper-set-syntax-preference nil "extended")

   in the appropriate major mode hooks.

   The above discussion concerns only the movement commands.  In regular
expressions, words remain the same as in Emacs.  That is, the
expressions `\w', `\>', `\<', etc., use Emacs's idea of what is a word,
and they don't look into the value of variable
`viper-syntax-preference'.  This is because Viper avoids changing
syntax tables in order to not thwart the various major modes that set
these tables.

   The usual Emacs convention is used to indicate Control Characters,
i.e C-h for Control-h.  _Do not confuse this with a sequence of separate
characters C, -, h!!!_ The `^' is itself, never used to indicate a
Control character.

   Finally, we note that Viper's Ex-style commands can be made to work
on the current Emacs region.  This is done by typing a digit argument
before `:'.  For instance, typing `1:' will prompt you with something
like _:123,135_, assuming that the current region starts at line 123 and
ends at line 135.  There is no need to type the line numbers, since
Viper inserts them automatically in front of the Ex command.  


File: viper,  Node: Text Handling,  Next: Display,  Prev: Groundwork,  Up: Commands

4.2 Text Handling
=================

* Menu:

* Move Commands::               Moving, Searching
* Marking::                     Textmarkers in Viper and the Emacs Mark.
* Appending Text::              Text insertion, Shifting, Putting
* Editing in Insert State::     Autoindent, Quoting etc.
* Deleting Text::               Deleting
* Changing Text::               Changing, Replacement, Joining
* Search and Replace::          Searches, Query Replace, Pattern Commands
* Yanking::                     Yanking, Viewing Registers
* Undoing::                     Multiple Undo, Backups


File: viper,  Node: Move Commands,  Next: Marking,  Up: Text Handling

4.2.1 Move Commands
-------------------

`<count>  h  C-h'
     <count> chars to the left.

`<count>  j  <lf> C-n'
     <count> lines downward.

`<count>  l  <sp>'
     <count> chars to the right.

`<count>  k  C-p'
     <count> lines upward.

`<count>  $'
     To the end of line <count> from the cursor.

`<count>  ^'
     To the first CHAR <count> - 1 lines lower.

`<count>  -'
     To the first CHAR <count> lines higher.

`<count>  +  <cr>'
     To the first CHAR <count> lines lower.

`0'
     To the first char of the line.

`<count> |'
     To column <count>

`<count>  f<char>'
     <count> <char>s to the right (find).

`<count>  t<char>'
     Till before <count> <char>s to the right.

`<count>  F<char>'
     <count> <char>s to the left.

`<count>  T<char>'
     Till after <count> <char>s to the left.

`<count>  ;'
     Repeat latest `f t F T' <count> times.

`<count>  ,'
     Repeat latest `f t F T' <count> times in opposite direction.

`<count>  w'
     <count> words forward.

`<count>  W'
     <count> WORDS forward.

`<count>  b'
     <count> words backward.

`<count>  B'
     <count> WORDS backward.

`<count>  e'
     To the end of word <count> forward.

`<count>  E'
     To the end of WORD <count> forward.

`<count>  G'
     Go to line <count> (default end-of-file).

`<count>  H'
     To line <count> from top of the screen (home).

`<count>  L'
     To line <count> from bottom of the screen (last).

`M'
     To the middle line of the screen.

`<count>  )'
     <count> sentences forward.

`<count>  ('
     <count> sentences backward.

`<count>  }'
     <count> paragraphs forward.

`<count>  {'
     <count> paragraphs backward.

`<count>  ]]'
     To the <count>th heading.

`<count>  [['
     To the <count>th previous heading.

`<count>  []'
     To the end of <count>th heading.

`m<a-z>'
     Mark the cursor position with a letter.

``<a-z>'
     To the mark.

`'<a-z>'
     To the first CHAR of the line with the mark.

`[<a-z>'
     Show contents of textmarker.

`]<a-z>'
     Show contents of register.

```'
     To the cursor position before the latest absolute jump (of which
     are examples `/' and `G').

`'''
     To the first CHAR of the line on which the cursor was placed
     before the latest absolute jump.

`<count>  /<string>'
     To the <count>th occurrence of <string>.

`<count>  /<cr>'
     To the <count>th occurrence of <string> from previous `/ or ?'.

`<count>  ?<string>'
     To the <count>th previous occurrence of <string>.

`<count>  ?<cr>'
     To the <count>th previous occurrence of <string> from previous `?
     or /'.

`n'
     Repeat latest `/' `?' (next).

`N'
     Repeat latest search in opposite direction.

`C-c /'
     Without a prefix argument, this command toggles
     case-sensitive/case-insensitive search modes and plain
     vanilla/regular expression search.  With the prefix argument 1,
     i.e., `1 C-c /', this toggles case-sensitivity; with the prefix
     argument 2, toggles plain vanilla search and search using regular
     expressions.  *Note Viper Specials::, for alternative ways to
     invoke this function.  

`%'
     Find the next bracket/parenthesis/brace and go to its match.  By
     default, Viper ignores brackets/parentheses/braces that occur
     inside parentheses.  You can change this by setting
     `viper-parse-sexp-ignore-comments' to `nil' in your `.viper' file.
     This option can also be toggled interactively if you quickly hit
     `%%%'.

     This latter feature is implemented as a vi-style keyboard macro.
     If you don't want this macro, put

          (viper-set-parsing-style-toggling-macro 'undefine)
     
     in your `~/.viper' file.



File: viper,  Node: Marking,  Next: Appending Text,  Prev: Move Commands,  Up: Text Handling

4.2.2 Marking
-------------

Emacs mark is referred to in the region specifiers `r' and `R'.  *Note
Emacs Preliminaries::, and *Note Basics::, for explanation.  Also see
*note Mark: (emacs)Mark, for an explanation of the Emacs mark ring.

`m<a-z>'
     Mark the current file and position with the specified letter.

`m .'
     Set the Emacs mark (*note Emacs Preliminaries::) at point.

`m ^'
     Set the Emacs mark (*note Emacs Preliminaries::) back to where it
     was last set with the `m.' command. This is useful when you set
     the mark with `m.', but then some other command (such as `L' or
     `G') changes it in a way that you didn't like.

`m <'
     Set the Emacs mark at beginning of buffer.

`m >'
     Set the Emacs mark at end of buffer.

`m ,'
     Jump to the Emacs mark.

`:mark <char>'
     Mark position with text marker named <char>.  This is an Ex
     command.

`:k <char>'
     Same as `:mark'.

```'
     Exchange point and mark.

`'''
     Exchange point and mark and go to the first CHAR on line.

`'<a-z>'
     Go to specified Viper mark.

`'
     Go to specified Viper mark and go to the first CHAR on line.
   

File: viper,  Node: Appending Text,  Next: Editing in Insert State,  Prev: Marking,  Up: Text Handling

4.2.3 Appending Text
--------------------

*Note Options::, to see how to change tab and shiftwidth size.  See the
GNU Emacs manual, or try `C-ha tabs' (If you have turned Emacs help on).
Check out the variable `indent-tabs-mode' to put in just spaces.  Also
see options for word-wrap.

`<count>  a'
     <count> times after the cursor.

`<count>  A'
     <count> times at the end of line.

`<count>  i'
     <count> times before the cursor (insert).

`<count>  I'
     <count> times before the first CHAR of the line

`<count>  o'
     On a new line below the current (open).  The count is only useful
     on a slow terminal.

`<count>  O'
     On a new line above the current.  The count is only useful on a
     slow terminal.

`<count>  ><move>'
     Shift the lines described by <count><move> one shiftwidth to the
     right (layout!).

`<count>  >>'
     Shift <count> lines one shiftwidth to the right.

`<count>  ["<a-z1-9>]p'
     Put the contents of the (default undo) buffer <count> times after
     the cursor.  The register will be automatically down-cased.

`<count>  ["<a-z1-9>]P'
     Put the contents of the (default undo) buffer <count> times before
     the cursor.  The register will

`[<a-z>'
     Show contents of textmarker.

`]<a-z>'
     Show contents of register.

`<count>  .'
     Repeat previous command <count> times.  For destructive commands
     as well as undo.

`f1 1 and f1 2'
     While `.' repeats the last destructive command, these two macros
     repeat the second-last and the third-last destructive commands.
     *Note Vi Macros::, for more information on Vi macros.

`C-c M-p and C-c M-n'
     In Vi state, these commands help peruse the history of Vi's
     destructive commands.  Successive typing of `C-c M-p' causes Viper
     to search the history in the direction of older commands, while
     hitting `C-c M-n' does so in reverse order.  Each command in the
     history is displayed in the minibuffer.  The displayed command can
     then be executed by typing ``.''.

     Since typing the above sequences of keys may be tedious, the
     functions doing the perusing can be bound to unused keyboard keys
     in the `~/.viper' file.  *Note Viper Specials::, for details.
   

File: viper,  Node: Editing in Insert State,  Next: Deleting Text,  Prev: Appending Text,  Up: Text Handling

4.2.4 Editing in Insert State
-----------------------------

Minibuffer can be edited similarly to Insert state, and you can switch
between Insert/Replace/Vi states at will.  Some users prefer plain
Emacs feel in the minibuffer.  To this end, set
VIPER-VI-STYLE-IN-MINIBUFFER to `nil'.

`C-v'
     Deprive the next char of its special meaning (quoting).

`C-h'
     One char back.

`C-w'
     One word back.

`C-u'
     Back to the begin of the change on the current line.

   

File: viper,  Node: Deleting Text,  Next: Changing Text,  Prev: Editing in Insert State,  Up: Text Handling

4.2.5 Deleting Text
-------------------

There is one difference in text deletion that you should be aware of.
This difference comes from Emacs and was adopted in Viper because we
find it very useful.  In Vi, if you delete a line, say, and then
another line, these two deletions are separated and are put back
separately if you use the `p' command.  In Emacs (and Viper), successive
series of deletions that are _not interrupted_ by other commands are
lumped together, so the deleted text gets accumulated and can be put
back as one chunk.  If you want to break a sequence of deletions so
that the newly deleted text could be put back separately from the
previously deleted text, you should perform a non-deleting action,
e.g., move the cursor one character in any direction.

`<count>  x'
     Delete <count> chars under and after the cursor.

`<count>  X'
     Delete <count> chars before the cursor.

`<count>  d<move>'
     Delete from point to endpoint of <count><move>.

`<count>  dd'
     Delete <count> lines.

`D'
     The rest of the line.

`<count>  <<move>'
     Shift the lines described by <count><move> one shiftwidth to the
     left (layout!).

`<count>  <<'
     Shift <count> lines one shiftwidth to the left.
   

File: viper,  Node: Changing Text,  Next: Search and Replace,  Prev: Deleting Text,  Up: Text Handling

4.2.6 Changing Text
-------------------

`<count>  r<char>'
     Replace <count> chars by <char> - no <esc>.

`<count>  R'
     Overwrite the rest of the line, appending change COUNT - 1 times.

`<count>  s'
     Substitute <count> chars.

`<count>  S'
     Change <count> lines.

`<count>  c<move>'
     Change from begin to endpoint of <count><move>.

`<count>  cc'
     Change <count> lines.

`<count>  C'
     The rest of the line and <count> - 1 next lines.

`<count>  =<move>'
     Reindent the region described by move.

`<count>  ~'
     Switch lower and upper cases.

`<count>  J'
     Join <count> lines (default 2).

`:[x,y]s/<pat>/<repl>/<f>'
     Substitute (on lines x through y) the pattern <pat> (default the
     last pattern) with <repl>.  Useful flags <f> are `g' for `global'
     (i.e. change every non-overlapping occurrence of <pat>) and `c' for
     `confirm' (type `y' to confirm a particular substitution, else `n'
     ).  Instead of `/' any punctuation CHAR unequal to <space> <tab>
     and <lf> can be used as delimiter.

     In Emacs, `\&' stands for the last matched expression, so
     `s/[ab]+/\&\&/' will double the string matched by `[ab]'.  Viper
     doesn't treat `&' specially, unlike Vi: use `\&' instead.

     Viper does not parse search patterns and does not expand special
     symbols found there (e.g., `~' is not expanded to the result of
     the previous substitution).

     Note: _The newline character (inserted as `C-qC-j') can be used in
     <repl>_.

`:[x,y]copy [z]'
     Copy text between `x' and `y' to the position after `z'.

`:[x,y]t [z]'
     Same as `:copy'.

`:[x,y]move [z]'
     Move text between `x' and `y' to the position after `z'.

`&'
     Repeat latest Ex substitute command, e.g.  `:s/wrong/right'.

`:x,yp'
`:g/Pat/p'
`:v/Pat/p'
     The above commands display certain buffer lines in a temporary
     buffer. The first form above displays the buffer lines between `x'
     and `y'. The second displays the lines of the buffer, which match
     a given pattern. The third form displays the lines that do _not_
     match the given pattern.

`#c<move>'
     Change upper-case characters in the region to lower-case.

`#C<move>'
     Change lower-case characters in the region to upper-case.

`#q<move>'
     Insert specified string at the beginning of each line in the region

`C-c M-p and C-c M-n'
     In Insert and Replace states, these keys are bound to commands
     that peruse the history of the text previously inserted in other
     insert or replace commands.  By repeatedly typing `C-c M-p' or
     `C-c M-n', you will cause Viper to insert these previously used
     strings one by one.  When a new string is inserted, the previous
     one is deleted.

     In Vi state, these keys are bound to functions that peruse the
     history of destructive Vi commands.  *Note Viper Specials::, for
     details.


File: viper,  Node: Search and Replace,  Next: Yanking,  Prev: Changing Text,  Up: Text Handling

4.2.7 Search and Replace
------------------------

*Note Groundwork::, for Ex address syntax.  *Note Options::, to see how
to get literal (non-regular-expression) search and how to stop search
from wrapping around.

`C-c /'
     Toggle case-sensitive search.  With prefix argument, toggle
     vanilla/regular expression search.

`<count>  /<string>'
     To the <count>th occurrence of <string>.

     Viper does not parse search patterns and does not expand special
     symbols found there (e.g., `~' is not expanded to the result of
     the previous substitution).

     After typing `/' or `?' all the usual Emacs minibuffer commands,
     such as `M-p' and `M-n' are available. In addition, typing `C-s'
     will insert the last search string used by the Emacs incremental
     search command (which is bound to `C-s' everywhere except in this
     case).

`<count>  ?<string>'
     To the <count>th previous occurrence of <string>.

`<count>  g<move>'
     Search for the text described by move.  (off by default)

`n'
     Repeat latest `/' `?' (next).

`N'
     Idem in opposite direction.

`%'
     Find the next bracket and go to its match

`:[x,y]g/<string>/<cmd>'
     Search globally [from line x to y] for <string> and execute the Ex
     <cmd> on each occurrence.

`:[x,y]v/<string>/<cmd>'
     Execute <cmd> on the lines that don't match.

`#g<move>'
     Execute the last keyboard macro for each line in the region.
     *Note Macros and Registers::, for more info.

`Q'
     Query Replace.

`:ta <name>'
     Search in the tags file where <name> is defined (file, line), and
     go to it.

`:[x,y]s/<pat>/<repl>/<f>'
     Substitute (on lines x through y) the pattern <pat> (default the
     last pattern) with <repl>.  Useful flags <f> are `g' for `global'
     (i.e. change every non-overlapping occurrence of <pat>) and `c' for
     `confirm' (type `y' to confirm a particular substitution, else
     `n').  Instead of `/' any punctuation character other than <space>
     <tab> and <lf> can be used as delimiter.

     Note: _The newline character (inserted as `C-qC-j') can be used in
     <repl>_.

`&'
     Repeat latest Ex substitute command, e.g. `:s/wrong/right'.

`:global /<pattern>/<ex-command>'
`:g /<pattern>/<ex-command>'
     Execute <ex-command> on all lines that match <pattern>.

`:vglobal /<pattern>/<ex-command>'
`:v /<pattern>/<ex-command>'
     Execute <ex-command> on all lines that do not match <pattern>.
   

File: viper,  Node: Yanking,  Next: Undoing,  Prev: Search and Replace,  Up: Text Handling

4.2.8 Yanking
-------------

`<count>  y<move>'
     Yank from begin to endpoint of <count><move>.

`<count>  "<a-z>y<move>'
     Yank from begin to endpoint of <count><move> to register.

`<count>  "<A-Z>y<move>'
     Yank from begin to endpoint of <count><move> and append to
     register.

`<count>  yy'
     <count> lines.

`<count>  Y'
     Idem (should be equivalent to `y$' though).

`m<a-z>'
     Mark the cursor position with a letter.

`[<a-z>'
     Show contents of textmarker.

`]<a-z>'
     Show contents of register.

`<count>  ["<a-z1-9>]p'
     Put the contents of the (default undo) buffer <count> times after
     the cursor.  The register will be automatically down-cased.

`<count>  ["<a-z1-9>]P'
     Put the contents of the (default undo) buffer <count> times before
     the cursor.  The register will


File: viper,  Node: Undoing,  Prev: Yanking,  Up: Text Handling

4.2.9 Undoing
-------------

`u U'
     Undo the latest change.

`.'
     Repeat undo.

`:q!'
     Quit Vi without writing.

`:e!'
     Re-edit a messed-up file.

`:rec'
     Recover file from autosave.  Viper also creates backup files that
     have a `~' appended to them.


File: viper,  Node: Display,  Next: File and Buffer Handling,  Prev: Text Handling,  Up: Commands

4.3 Display
===========

`C-g'
     At user level 1, give file name, status, current line number and
     relative position.
     At user levels 2 and higher, abort the current command.

`C-c g'
     Give file name, status, current line number and relative position
     - all user levels.

`C-l'
     Refresh the screen.

`<count> C-e'
     Expose <count> more lines at bottom, cursor stays put (if
     possible).

`<count> C-y'
     Expose <count> more lines at top, cursor stays put (if possible).

`<count> C-d'
     Scroll <count> lines downward (default the number of the previous
     scroll; initialization: half a page).

`<count> C-u'
     Scroll <count> lines upward (default the number of the previous
     scroll; initialization: half a page).

`<count> C-f'
     <count> pages forward.

`<count> C-b'
     <count> pages backward (in older versions `C-b' only works without
     count).

`<count> z<cr>'

`zH'
     Put line <count> at the top of the window (default the current
     line).

`<count> z-'

`zL'
     Put line <count> at the bottom of the window (default the current
     line).

`<count> z.'

`zM'
     Put line <count> in the center of the window (default the current
     line).


File: viper,  Node: File and Buffer Handling,  Next: Mapping,  Prev: Display,  Up: Commands

4.4 File and Buffer Handling
============================

In all file handling commands, space should be typed before entering
the file name.  If you need to type a modifier, such as `>>' or `!',
don't put any space between the command and the modifier.

   Note that many Ex commands, e.g., `:w', accept command arguments. The
effect is that the command would start acting on the current region. For
instance, if the current region spans the lines 11 through 22, then if
you type `1:w' you would see `:11,22w' in the minibuffer.

`:q'
     Quit buffer except if modified.

`:q!'
     Quit buffer without checking.  In Viper, these two commands are
     identical.  Confirmation is required if exiting modified buffers
     that visit files.

`:suspend'

`:stop'
     Suspend Viper

`:[x,y] w'
     Write the file.  Viper makes sure that a final newline is always
     added to any file where this newline is missing.  This is done by
     setting Emacs variable `require-final-newline' to `t'.  If you
     don't like this feature, use `setq-default' to set
     `require-final-newline' to `nil'.  This must be done in `.viper'
     file.

`:[x,y] w <name>'
     Write to the file <name>.

`:[x,y] w>> <name>'
     Append the buffer to the file <name>.  There should be no space
     between `w' and `>>'.  Type space after the `>>' and see what
     happens.

`:w! <name>'
     Overwrite the file <name>.  In Viper, `:w' and `:w!' are identical.
     Confirmation is required for writing to an existing file (if this
     is not the file the buffer is visiting) or to a read-only file.

`:x,y w <name>'
     Write lines x through y to the file <name>.

`:wq'
     Write the file and kill buffer.

`:r <file> [<file> ...]'
     Read file into a buffer, inserting its contents after the current
     line.

`:xit'
     Same as `:wq'.

`:Write'
`:W'
     Save all unsaved buffers, asking for confirmation.

`:WWrite'
`:WW'
     Like `W', but without asking for confirmation.

`ZZ'
     Save current buffer and kill it.  If user level is 1, then save
     all files and kill Emacs.  Killing Emacs is the wrong way to use
     it, so you should switch to higher user levels as soon as possible.

`:x [<file>]'
     Save and kill buffer.

`:x! [<file>]'
     `:w![<file>]' and `:q'.

`:pre'
     Preserve the file - autosave buffers.

`:rec'
     Recover file from autosave.

`:f [<file>]'
     without the argument, prints file name and character/line
     information afout the currently visited file. With an argument,
     sets the currently visited filename to `file'.

`:cd [<dir>]'
     Set the working directory to <dir> (default home directory).

`:pwd'
     Print present working directory.

`:e [+<cmd>] <files>'
     Edit files.  If no filename is given, edit the file visited by the
     current buffer.  If buffer was modified or the file changed on
     disk, ask for confirmation.  Unlike Vi, Viper allows `:e' to take
     multiple arguments.  The first file is edited the same way as in
     Vi.  The rest are visited in the usual Emacs way.

`:e! [+<cmd>] <files>'
     Re-edit file.  If no filename, re-edit current file.  In Viper,
     unlike Vi, `e!' is identical to `:e'.  In both cases, the user is
     asked to confirm if there is a danger of discarding changes to a
     buffer.

`:q!'
     Quit Vi without writing.

`C-^'
     Edit the alternate (normally the previous) file.

`:rew'
     Obsolete

`:args'
     List files not shown anywhere with counts for next

`:n [count]  [+<cmd>] [<files>]'
     Edit <count> file, or edit files.  The count comes from `:args'.

`:N [count] [+<cmd>] [<files>]'
     Like `:n', but the meaning of the variable EX-CYCLE-OTHER-WINDOW
     is reversed.

`:b'
     Switch to another buffer.  If EX-CYCLE-OTHER-WINDOW is `t', switch
     in another window.  Buffer completion is supported.  The variable
     VIPER-READ-BUFFER-FUNCTION controls which function is actually
     used to read the buffer name. The default is `read-buffer', but
     better alternatives are also available in Emacs (e.g.,
     `iswitchb-read-buffer').  

`:B'
     Like `:b', but the meaning of EX-CYCLE-OTHER-WINDOW is reversed.

`:<address>r <name>'
     Read the file <name> into the buffer after the line <address>.

`v, V, C-v'
     Edit a file in current or another window, or in another frame.
     File name is typed in minibuffer.  File completion and history are
     supported.
   

File: viper,  Node: Mapping,  Next: Shell Commands,  Prev: File and Buffer Handling,  Up: Commands

4.5 Mapping
===========

`:map <string>'
     Start defining a Vi-style keyboard macro.  For instance, typing
     `:map www' followed by `:!wc %' and then typing `C-x )' will cause
     `www' to run wc on current file (Vi replaces `%' with the current
     file name).

`C-x )'
     Finish defining a keyboard macro.  In Viper, this command
     completes the process of defining all keyboard macros, whether
     they are Emacs-style or Vi-style.  This is a departure from Vi,
     needed to allow WYSIWYG mapping of keyboard macros and to permit
     the use of function keys and arbitrary Emacs functions in the
     macros.

`:unmap <string>'
     Deprive <string> of its mappings in Vi state.

`:map! <string>'
     Map a macro for Insert state.

`:unmap! <string>'
     Deprive <string> of its mapping in Insert state (see `:unmap').

`@<a-z>'
     In Vi state, execute the contents of register as a command.

`@@'
     In Vi state, repeat last register command.

`@#'
     In Vi state, begin keyboard macro.  End with @<a-z>.  This will
     put the macro in the proper register.  Register will be
     automatically down-cased.  *Note Macros and Registers::, for more
     info.

`@!<a-z>'
     In Vi state, yank anonymous macro to register

`*'
     In Vi state, execute anonymous macro (defined by C-x( and C-x )).

`C-x e'
     Like `*', but works in all Viper states.

`#g<move>'
     Execute the last keyboard macro for each line in the region.
     *Note Macros and Registers::, for more info.

`[<a-z>'
     Show contents of textmarker.

`]<a-z>'
     Show contents of register.


File: viper,  Node: Shell Commands,  Next: Options,  Prev: Mapping,  Up: Commands

4.6 Shell Commands
==================

The symbol `%' is used in Ex shell commands to mean current file.  If
you want a `%' in your command, it must be escaped as `\%'.  However if
`%' is the first character, it stands as the address for the whole file.  Similarly,
`#' expands to the previous file.  The previous file is the first file
in `:args' listing.  This defaults to the previous file in the VI sense
if you have one window.

   Symbols `%' and `#' are also used in the Ex commands `:e' and `:r
<shell-cmd>'.  The commands `:w' and the regular `:r <file>' command
don't support these meta symbols, because file history is a better
mechanism.

`:sh'
     Execute a subshell in another window

`:[x,y]!<cmd>'
     Execute a shell <cmd> [on lines x through y; % is replace by
     current file, \% is changed to %

`:[x,y]!! [<args>]'
     Repeat last shell command [and append <args>].

`:!<cmd>'
     Just execute command and display result in a buffer.

`:!! <args>'
     Repeat last shell command and append <args>

`<count> !<move><cmd>'
     The shell executes <cmd>, with standard input the lines described
     by <count><move>, next the standard output replaces those lines
     (think of `cb', `sort', `nroff', etc.).

`<count> !!<cmd>'
     Give <count> lines as standard input to the shell <cmd>, next let
     the standard output replace those lines.

`:[x,y] w !<cmd>'
     Let lines x to y be standard input for <cmd> (notice the <sp>
     between `w' and `!').

`:<address>r !<cmd>'
     Put the output of <cmd> after the line <address> (default current).

`:<address>r <name>'
     Read the file <name> into the buffer after the line <address>
     (default current).

`:make'
     Run the make command in the current directory.
   

File: viper,  Node: Options,  Next: Emacs Related Commands,  Prev: Shell Commands,  Up: Commands

4.7 Options
===========

`autoindent'
`ai'
     autoindent - In append mode after a <cr> the cursor will move
     directly below the first character on the previous line.  This
     setting affects the current buffer only.

`autoindent-global'
`ai-global'
     Same as `autoindent', but affects all buffers.

`noautoindent'
`noai'
     Cancel autoindent.

`noautoindent-global'
`noai-g'
     Cancel autoindent-global.

`ignorecase'
`ic'
     ignorecase - No distinction between upper and lower cases when
     searching.

`noignorecase'
`noic'
     Cancel ignorecase.

`magic'
`ma'
     Regular expressions used in searches; nomagic means no regexps.

`nomagic'

`noma'
     Cancel magic.

`readonly'
`ro'
     readonly - The file is not to be changed.  If the user attempts to
     write to this file, confirmation will be requested.

`noreadonly'
`noro'
     Cancel readonly.

`shell=<string>'
`sh=<string>'
     shell - The program to be used for shell escapes (default `$SHELL'
     (default `/bin/sh')).

`shiftwidth=<count>'
`sw=<count>'
     shiftwidth - Gives the shiftwidth (default 8 positions).

`showmatch'
`sm'
     showmatch - Whenever you append a `)', Vi shows its match if it's
     on the same page; also with `{' and `}'.  If there's no match, Vi
     will beep.

`noshowmatch'
`nosm'
     Cancel showmatch.

`tabstop=<count>'
`ts=<count>'
     tabstop - The length of a <ht>; warning: this is only IN the
     editor, outside of it <ht>s have their normal length (default 8
     positions).  This setting affects the current buffer only.

`tabstop-global'
`ts-g'
     Same as `tabstop', but affects all buffers.

`wrapmargin=<count>'
`wm=<count>'
     wrapmargin - In append mode Vi automatically puts a <lf> whenever
     there is a <sp> or <ht> within <wm> columns from the right margin.

`wrapscan'
`ws'
     wrapscan - When searching, the end is considered `stuck' to the
     begin of the file.

`nowrapscan'
`nows'
     Cancel wrapscan.

`:set <option>'
     Turn <option> on.

`:set no<option>'
     Turn <option> off.

`:set <option>=<value>'
     Set <option> to <value>.


File: viper,  Node: Emacs Related Commands,  Prev: Options,  Up: Commands

4.8 Emacs Related Commands
==========================

`C-\'
     Begin Meta command in Vi or Insert states.  Most often used as C-\
     x (M-x).

     Note: Emacs binds `C-\' to a function that offers to change the
     keyboard input method in the multilingual environment.  Viper
     overrides this binding.  However, it is still possible to switch
     the input method by typing `\ C-\' in the Vi command state and
     `C-z \ C-\' in the Insert state.  Or you can use the MULE menu on
     the menubar.

`C-z'
     In Insert and Replace states, prepare Viper to accept the next
     command and execute it as if Viper was in Vi state.  Then return
     to Insert state.

     In Vi state, switch to Emacs state; in Emacs state, switch to Vi
     state.

`C-c \'
     Switches to Vi state for the duration of a single command.  Then
     goes back to the original Viper state.  Works from Vi, Insert,
     Replace, and Emacs states.

`C-x0'
     Close Window

`C-x1'
     Close Other Windows

`C-x2'
     Split Window

`C-xo'
     Move among windows

`C-xC-f'
     Emacs find-file, useful in Insert state

`C-y'
     Put back the last killed text.  Similar to Vi's `p', but also
     works in Insert and Replace state.  This command doesn't work in
     Vi command state, since this binding is taken for something else.

`M-y'
     Undoes the last `C-y' and puts another kill from the kill ring.
     Using this command, you can try may different kills until you find
     the one you need.


File: viper,  Node: Mouse-bound Commands,  Up: Commands

4.9 Mouse-bound Commands
========================

The following two mouse actions are normally bound to special search and
insert commands in of Viper:

`S-Mouse-1'
     Holding Shift and clicking mouse button 1 will initiate search for
     a region under the mouse pointer.  This command can take a prefix
     argument.  Note: Viper sets this binding only if this mouse action
     is not already bound to something else.  *Note Viper Specials::,
     for more information.

`S-Mouse-2'
     Holding Shift and clicking button 2 of the mouse will insert a
     region surrounding the mouse pointer.  This command can also take
     a prefix argument.  Note: Viper sets this binding only if this
     mouse action is not already bound to something else.  *Note Viper
     Specials::, for more details.
   

File: viper,  Node: Acknowledgments,  Up: Top

Acknowledgments
***************

Viper, formerly known as VIP-19, was written by Michael Kifer.  Viper is
based on the original VIP package by Masahiko Sato and on its
enhancement, VIP 4.4, by Aamod Sane.  This manual is an adaptation of
the manual for VIP 4.4, which, in turn, was based on Sato's manual for
VIP 3.5.

   Many contributors on the Net pointed out bugs and suggested a number
of useful features. Scott Bronson and Samuel Padgett contributed
patches that were incorporated in this code.  Here is a hopefully
complete list of contributors:

     aaronl@vitelus.com (Aaron Lehmann),
     ahg@panix.com (Al Gelders),
     amade@diagram.fr (Paul-Bernard Amade),
     ascott@fws214.intel.com (Andy Scott),
     bronson@trestle.com (Scott Bronson),
     cook@biostat.wisc.edu (Tom Cook),
     csdayton@midway.uchicago.edu (Soren Dayton),
     dave@hellgate.utah.edu,
     dm@scs.cs.nyu.edu (David Mazieres),
     dominik@strw.LeidenUniv.nl (Carsten Dominik),
     dwallach@cs.princeton.edu (Dan Wallach),
     dwight@toolucky.llnl.gov (Dwight Shih),
     dxc@xprt.net (David X Callaway),
     edmonds@edmonds.home.cs.ubc.ca (Brian Edmonds),
     gin@mo.msk.ru (Golubev I.N.),
     gviswana@cs.wisc.edu (Guhan Viswanathan),
     gvr@halcyon.com (George V. Reilly),
     hatazaki@bach.convex.com (Takao Hatazaki),
     hpz@ibmhpz.aug.ipp-garching.mpg.de (Hans-Peter Zehrfeld),
     irie@t.email.ne.jp (Irie Tetsuya),
     jackr@dblues.engr.sgi.com (Jack Repenning),
     jamesm@bga.com (D.J. Miller II),
     jjm@hplb.hpl.hp.com (Jean-Jacques Moreau),
     jl@cse.ogi.edu (John Launchbury),
     jobrien@hchp.org (John O'Brien),
     johnw@borland.com (John Wiegley),
     kanze@gabi-soft.fr (James Kanze),
     kin@isi.com (Kin Cho),
     kwzh@gnu.org (Karl Heuer),
     lindstro@biostat.wisc.edu (Mary Lindstrom),
     lektu@terra.es (Juanma Barranquero),
     lennart.borgman.073@student.lu.se (Lennart Borgman),
     minakaji@osaka.email.ne.jp (Mikio Nakajima),
     Mark.Bordas@East.Sun.COM (Mark Bordas),
     meyering@comco.com (Jim Meyering),
     martin@xemacs.org (Martin Buchholz),
     mbutler@redfernnetworks.com (Malcolm Butler),
     mveiga@dit.upm.es (Marcelino Veiga Tuimil),
     paulk@summit.esg.apertus.com (Paul Keusemann),
     pfister@cs.stonybrook.edu (Hanspeter Pfister),
     phil_brooks@MENTORG.COM (Phil Brooks),
     pogrell@informatik.hu-berlin.de (Lutz Pogrell),
     pradyut@cs.uchicago.edu (Pradyut Shah),
     roderick@argon.org (Roderick Schertler),
     rxga@ulysses.att.com,
     sawdey@lcse.umn.edu (Aaron Sawdey),
     simonb@prl.philips.co.uk (Simon Blanchard),
     spadgett1@nc.rr.com (Samuel Padgett),
     stephen@farrell.org (Stephen Farrell),
     storm@cua.dk (Kim F. Storm),
     sudish@MindSpring.COM (Sudish Joseph),
     schwab@issan.informatik.uni-dortmund.de (Andreas Schwab)
     terra@diku.dk (Morten Welinder),
     thanh@informatics.muni.cz (Han The Thanh),
     toma@convex.convex.com,
     vrenjak@sun1.racal.com (Milan Vrenjak),
     whicken@dragon.parasoft.com (Wendell Hicken),
     zapman@cc.gatech.edu (Jason Zapman II),


File: viper,  Node: GNU Free Documentation License,  Up: Top

Appendix A GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
     `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, receipt of a copy of some or all of
     the same material does not give you any rights to use it.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.  If the Document specifies that a proxy
     can decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

 11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: viper,  Node: Key Index,  Next: Function Index,  Up: Top

Key Index
*********

 [index ]
* Menu:

* "<a-z1-9>P:                            Yanking.             (line  38)
* "<a-z1-9>p:                            Yanking.             (line  38)
* "<a-z1-9>P:                            Appending Text.      (line  72)
* "<a-z1-9>p:                            Appending Text.      (line  72)
* "<a-z>y<move>:                         Yanking.             (line  38)
* "<A-Z>y<move>:                         Yanking.             (line  38)
* #:                                     New Commands.        (line  39)
* #c<move>:                              Changing Text.       (line  96)
* #C<move> <1>:                          Changing Text.       (line  96)
* #C<move>:                              New Commands.        (line  50)
* #c<move>:                              New Commands.        (line  46)
* #g<move> <1>:                          Mapping.             (line  59)
* #g<move> <2>:                          Search and Replace.  (line  81)
* #g<move>:                              New Commands.        (line  55)
* #q<move>:                              New Commands.        (line  59)
* #q<move> :                             Changing Text.       (line  96)
* #s<move>:                              New Commands.        (line  64)
* $:                                     Move Commands.       (line 171)
* % <1>:                                 Search and Replace.  (line  81)
* %:                                     Move Commands.       (line 171)
* & <1>:                                 Search and Replace.  (line  81)
* &:                                     Changing Text.       (line  96)
* '' <1>:                                Marking.             (line  49)
* '':                                    Move Commands.       (line 171)
* '<a-z> <1>:                            Marking.             (line  49)
* '<a-z>:                                Move Commands.       (line 171)
* (:                                     Move Commands.       (line 171)
* ):                                     Move Commands.       (line 171)
* * <1>:                                 Mapping.             (line  59)
* *:                                     New Commands.        (line  69)
* +:                                     Move Commands.       (line 171)
* ,:                                     Move Commands.       (line 171)
* -:                                     Move Commands.       (line 171)
* . <1>:                                 Undoing.             (line  21)
* .:                                     Appending Text.      (line  72)
* /<cr>:                                 Move Commands.       (line 171)
* /<string> <1>:                         Search and Replace.  (line  81)
* /<string>:                             Move Commands.       (line 171)
* 0:                                     Move Commands.       (line 171)
* ;:                                     Move Commands.       (line 171)
* <<:                                    Deleting Text.       (line  39)
* <<move>:                               Deleting Text.       (line  39)
* <a-z>:                                 Groundwork.          (line  33)
* <address>:                             Groundwork.          (line  33)
* <args>:                                Groundwork.          (line  76)
* <cmd>:                                 Groundwork.          (line  76)
* <cr>:                                  Move Commands.       (line 171)
* <ESC>:                                 States in Viper.     (line   6)
* <lf>:                                  Move Commands.       (line 171)
* <move>:                                Groundwork.          (line  33)
* <sp>:                                  Move Commands.       (line 171)
* =<move>:                               Changing Text.       (line  96)
* ><move>:                               Appending Text.      (line  72)
* >>:                                    Appending Text.      (line  72)
* ?<cr>:                                 Move Commands.       (line 171)
* ?<string> <1>:                         Search and Replace.  (line  81)
* ?<string>:                             Move Commands.       (line 171)
* @!:                                    New Commands.        (line  94)
* @!<a-z>:                               Mapping.             (line  59)
* @# <1>:                                Mapping.             (line  59)
* @#:                                    New Commands.        (line  94)
* @<a-z> <1>:                            Mapping.             (line  59)
* @<a-z>:                                New Commands.        (line  94)
* @@:                                    Mapping.             (line  59)
* [<a-z> <1>:                            Mapping.             (line  59)
* [<a-z> <2>:                            Yanking.             (line  38)
* [<a-z> <3>:                            Appending Text.      (line  72)
* [<a-z> <4>:                            Move Commands.       (line 171)
* [<a-z>:                                New Commands.        (line  87)
* [[:                                    Move Commands.       (line 171)
* [] <1>:                                Move Commands.       (line 171)
* []:                                    New Commands.        (line  98)
* \:                                     New Commands.        (line  19)
* \&:                                    Changing Text.       (line  96)
* ]<a-z> <1>:                            Mapping.             (line  59)
* ]<a-z> <2>:                            Yanking.             (line  38)
* ]<a-z> <3>:                            Appending Text.      (line  72)
* ]<a-z> <4>:                            Move Commands.       (line 171)
* ]<a-z>:                                New Commands.        (line  84)
* ]]:                                    Move Commands.       (line 171)
* ^:                                     Move Commands.       (line 171)
* `<a-z> <1>:                            Marking.             (line  49)
* `<a-z>:                                Move Commands.       (line 171)
* `` <1>:                                Marking.             (line  49)
* ``:                                    Move Commands.       (line 171)
* a:                                     Appending Text.      (line  72)
* A:                                     Appending Text.      (line  72)
* b:                                     Move Commands.       (line 171)
* B:                                     Move Commands.       (line 171)
* C:                                     Changing Text.       (line  96)
* C-\ <1>:                               Emacs Related Commands.
                                                              (line  54)
* C-\:                                   Vi State.            (line  33)
* C-] <1>:                               New Commands.        (line 106)
* C-]:                                   Vi State.            (line  24)
* C-^:                                   File and Buffer Handling.
                                                              (line 148)
* C-b:                                   Display.             (line  57)
* C-c <1>:                               New Commands.        (line   9)
* C-c:                                   Vi State.            (line  19)
* C-c / <1>:                             Move Commands.       (line 171)
* C-c / <2>:                             New Commands.        (line 115)
* C-c /:                                 Vi State.            (line  71)
* C-c C-g:                               New Commands.        (line 110)
* C-c M-n <1>:                           Changing Text.       (line  96)
* C-c M-n <2>:                           Appending Text.      (line  72)
* C-c M-n:                               New Commands.        (line 134)
* C-c M-p <1>:                           Changing Text.       (line  96)
* C-c M-p <2>:                           Appending Text.      (line  72)
* C-c M-p:                               New Commands.        (line 134)
* C-c\:                                  Emacs Related Commands.
                                                              (line  54)
* C-d:                                   Display.             (line  57)
* C-e:                                   Display.             (line  57)
* C-f:                                   Display.             (line  57)
* C-g <1>:                               Display.             (line  57)
* C-g <2>:                               New Commands.        (line 106)
* C-g:                                   Vi State.            (line  24)
* C-h:                                   Move Commands.       (line 171)
* C-l:                                   Display.             (line  57)
* C-n:                                   Move Commands.       (line 171)
* C-p:                                   Move Commands.       (line 171)
* C-s:                                   New Commands.        (line 128)
* C-u <1>:                               Display.             (line  57)
* C-u:                                   Editing in Insert State.
                                                              (line  23)
* C-v <1>:                               Editing in Insert State.
                                                              (line  23)
* C-v:                                   New Commands.        (line  32)
* C-w:                                   Editing in Insert State.
                                                              (line  23)
* C-x <1>:                               New Commands.        (line   9)
* C-x:                                   Vi State.            (line  11)
* C-x0:                                  Emacs Related Commands.
                                                              (line  54)
* C-x1:                                  Emacs Related Commands.
                                                              (line  54)
* C-x2:                                  Emacs Related Commands.
                                                              (line  54)
* C-xC-f:                                Emacs Related Commands.
                                                              (line  54)
* C-xo:                                  Emacs Related Commands.
                                                              (line  54)
* C-y <1>:                               Emacs Related Commands.
                                                              (line  54)
* C-y:                                   Display.             (line  57)
* C-z <1>:                               Emacs Related Commands.
                                                              (line  54)
* C-z <2>:                               Emacs State.         (line   6)
* C-z:                                   States in Viper.     (line   6)
* c<move>:                               Changing Text.       (line  96)
* cc:                                    Changing Text.       (line  96)
* D:                                     Deleting Text.       (line  39)
* d<move>:                               Deleting Text.       (line  39)
* dd:                                    Deleting Text.       (line  39)
* e:                                     Move Commands.       (line 171)
* E:                                     Move Commands.       (line 171)
* f<char>:                               Move Commands.       (line 171)
* F<char>:                               Move Commands.       (line 171)
* G:                                     Move Commands.       (line 171)
* g<move>:                               Search and Replace.  (line  81)
* h:                                     Move Commands.       (line 171)
* H:                                     Move Commands.       (line 171)
* i <1>:                                 Appending Text.      (line  72)
* i:                                     States in Viper.     (line   6)
* J:                                     Changing Text.       (line  96)
* j:                                     Move Commands.       (line 171)
* k:                                     Move Commands.       (line 171)
* l:                                     Move Commands.       (line 171)
* L:                                     Move Commands.       (line 171)
* M:                                     Move Commands.       (line 171)
* m,:                                    Marking.             (line  49)
* M-n:                                   New Commands.        (line 124)
* M-p:                                   New Commands.        (line 124)
* M-y:                                   Emacs Related Commands.
                                                              (line  54)
* m.:                                    Marking.             (line  49)
* m<:                                    Marking.             (line  49)
* m<a-z> <1>:                            Yanking.             (line  38)
* m<a-z> <2>:                            Marking.             (line  49)
* m<a-z>:                                Move Commands.       (line 171)
* m>:                                    Marking.             (line  49)
* m^:                                    Marking.             (line  49)
* meta button1up:                        Mouse-bound Commands.
                                                              (line  22)
* meta button2up:                        Mouse-bound Commands.
                                                              (line  22)
* meta shift button1up:                  Viper Specials.      (line 311)
* meta shift button2up:                  Viper Specials.      (line 311)
* n:                                     Search and Replace.  (line  81)
* N:                                     Search and Replace.  (line  81)
* n:                                     Move Commands.       (line 171)
* N:                                     Move Commands.       (line 171)
* o:                                     Appending Text.      (line  72)
* O:                                     Appending Text.      (line  72)
* p:                                     Yanking.             (line  38)
* P:                                     Yanking.             (line  38)
* p:                                     Appending Text.      (line  72)
* P:                                     Appending Text.      (line  72)
* Q <1>:                                 Search and Replace.  (line  81)
* Q:                                     New Commands.        (line  23)
* R:                                     Changing Text.       (line  96)
* r<char>:                               Changing Text.       (line  96)
* s:                                     Changing Text.       (line  96)
* S:                                     Changing Text.       (line  96)
* S-Mouse-1 <1>:                         Mouse-bound Commands.
                                                              (line  22)
* S-Mouse-1:                             Viper Specials.      (line 311)
* S-Mouse-2 <1>:                         Mouse-bound Commands.
                                                              (line  22)
* S-Mouse-2:                             Viper Specials.      (line 311)
* t<char>:                               Move Commands.       (line 171)
* T<char>:                               Move Commands.       (line 171)
* u:                                     Undoing.             (line  21)
* U:                                     Undoing.             (line  21)
* u:                                     Vi State.            (line  53)
* V:                                     File and Buffer Handling.
                                                              (line 148)
* v:                                     File and Buffer Handling.
                                                              (line 148)
* V:                                     New Commands.        (line  32)
* v:                                     New Commands.        (line  32)
* w:                                     Move Commands.       (line 171)
* W:                                     Move Commands.       (line 171)
* x:                                     Deleting Text.       (line  39)
* X:                                     Deleting Text.       (line  39)
* Y:                                     Yanking.             (line  38)
* y<move>:                               Yanking.             (line  38)
* yank:                                  Yanking.             (line  38)
* yy:                                    Yanking.             (line  38)
* z-:                                    Display.             (line  57)
* z.:                                    Display.             (line  57)
* z<cr>:                                 Display.             (line  57)
* zH:                                    Display.             (line  57)
* zL:                                    Display.             (line  57)
* zM:                                    Display.             (line  57)
* ZZ:                                    File and Buffer Handling.
                                                              (line 148)
* {:                                     Move Commands.       (line 171)
* |:                                     Move Commands.       (line 171)
* }:                                     Move Commands.       (line 171)
* ~:                                     Changing Text.       (line  96)


File: viper,  Node: Function Index,  Next: Variable Index,  Prev: Key Index,  Up: Top

Function Index
**************

 [index ]
* Menu:

* !!<cmd>:                               Shell Commands.      (line  56)
* !<cmd>:                                Shell Commands.      (line  56)
* !<move><cmd>:                          Shell Commands.      (line  56)
* :!! <args>:                            Shell Commands.      (line  56)
* :!<cmd>:                               Shell Commands.      (line  56)
* :<address>r !<cmd>:                    Shell Commands.      (line  56)
* :<address>r <name>:                    Shell Commands.      (line  56)
* :args <1>:                             File and Buffer Handling.
                                                              (line 148)
* :args:                                 New Commands.        (line 151)
* :cd [<dir>]:                           File and Buffer Handling.
                                                              (line 148)
* :copy [z]:                             Changing Text.       (line  96)
* :e [<files>]:                          File and Buffer Handling.
                                                              (line 148)
* :e!:                                   Undoing.             (line  21)
* :e! [<files>]:                         File and Buffer Handling.
                                                              (line 148)
* :edit [<files>]:                       File and Buffer Handling.
                                                              (line 148)
* :edit! [<files>]:                      File and Buffer Handling.
                                                              (line 148)
* :f:                                    File and Buffer Handling.
                                                              (line 148)
* :g:                                    Search and Replace.  (line  81)
* :global:                               Search and Replace.  (line  81)
* :k:                                    Marking.             (line  49)
* :make:                                 Shell Commands.      (line  56)
* :map:                                  Key Bindings.        (line 124)
* :map <char> <seq>:                     Mapping.             (line  59)
* :map! <char> <seq>:                    Mapping.             (line  59)
* :mark:                                 Marking.             (line  49)
* :move [z]:                             Changing Text.       (line  96)
* :n:                                    New Commands.        (line 151)
* :n [<count> | <file>]:                 File and Buffer Handling.
                                                              (line 148)
* :pre <1>:                              File and Buffer Handling.
                                                              (line 148)
* :pre:                                  New Commands.        (line 151)
* :PreviousRelatedFile <1>:              Viper Specials.      (line 208)
* :PreviousRelatedFile:                  New Commands.        (line 156)
* :pwd <1>:                              File and Buffer Handling.
                                                              (line 148)
* :pwd:                                  New Commands.        (line 151)
* :q:                                    File and Buffer Handling.
                                                              (line 148)
* :q! <1>:                               File and Buffer Handling.
                                                              (line 148)
* :q!:                                   Undoing.             (line  21)
* :quit:                                 File and Buffer Handling.
                                                              (line 148)
* :quit!:                                File and Buffer Handling.
                                                              (line 148)
* :r:                                    File and Buffer Handling.
                                                              (line 148)
* :read:                                 File and Buffer Handling.
                                                              (line 148)
* :rec <1>:                              File and Buffer Handling.
                                                              (line 148)
* :rec:                                  Undoing.             (line  21)
* :RelatedFile <1>:                      Viper Specials.      (line 208)
* :RelatedFile:                          New Commands.        (line 156)
* :rew:                                  File and Buffer Handling.
                                                              (line 148)
* :s/<pat>/<repl>/<f>:                   Changing Text.       (line  96)
* :set:                                  Rudimentary Changes. (line   6)
* :set <option>:                         Options.             (line 102)
* :set <option>=<value>:                 Options.             (line 102)
* :set ai:                               Options.             (line 102)
* :set autoindent:                       Options.             (line 102)
* :set ic:                               Options.             (line 102)
* :set ignorecase:                       Options.             (line 102)
* :set magic:                            Options.             (line 102)
* :set no<option>:                       Options.             (line 102)
* :set readonly:                         Options.             (line 102)
* :set ro:                               Options.             (line 102)
* :set sh=<string>:                      Options.             (line 102)
* :set shell=<string>:                   Options.             (line 102)
* :set shiftwidth=<count>:               Options.             (line 102)
* :set showmatch:                        Options.             (line 102)
* :set sm:                               Options.             (line 102)
* :set sw=<count>:                       Options.             (line 102)
* :set tab-stop-local=<count>:           Options.             (line 102)
* :set tabstop=<count>:                  Options.             (line 102)
* :set ts=<count>:                       Options.             (line 102)
* :set wm=<count>:                       Options.             (line 102)
* :set wrapmargin=<count>:               Options.             (line 102)
* :set wrapscan:                         Options.             (line 102)
* :set ws:                               Options.             (line 102)
* :sh:                                   Shell Commands.      (line  56)
* :stop:                                 File and Buffer Handling.
                                                              (line 148)
* :substitute/<pat>/<repl>/<f> <1>:      Search and Replace.  (line  81)
* :substitute/<pat>/<repl>/<f>:          Changing Text.       (line  96)
* :suspend:                              File and Buffer Handling.
                                                              (line 148)
* :t [z]:                                Changing Text.       (line  96)
* :tag <name>:                           Search and Replace.  (line  81)
* :unmap <char>:                         Mapping.             (line  59)
* :unmap! <char>:                        Mapping.             (line  59)
* :v:                                    Search and Replace.  (line  81)
* :vglobal:                              Search and Replace.  (line  81)
* :W:                                    File and Buffer Handling.
                                                              (line 148)
* :w !<cmd>:                             Shell Commands.      (line  56)
* :w <file>:                             File and Buffer Handling.
                                                              (line 148)
* :w >> <file>:                          File and Buffer Handling.
                                                              (line 148)
* :w! <file>:                            File and Buffer Handling.
                                                              (line 148)
* :wq:                                   File and Buffer Handling.
                                                              (line 148)
* :Write:                                File and Buffer Handling.
                                                              (line 148)
* :write <file>:                         File and Buffer Handling.
                                                              (line 148)
* :write >> <file>:                      File and Buffer Handling.
                                                              (line 148)
* :write! <file>:                        File and Buffer Handling.
                                                              (line 148)
* :WW:                                   File and Buffer Handling.
                                                              (line 148)
* :WWrite:                               File and Buffer Handling.
                                                              (line 148)
* :x:                                    File and Buffer Handling.
                                                              (line 148)
* :x!:                                   File and Buffer Handling.
                                                              (line 148)
* :x,y w !<cmd>:                         Shell Commands.      (line  56)
* :yank:                                 Yanking.             (line  38)
* add-hook:                              Packages that Change Keymaps.
                                                              (line 108)
* remove-hook:                           Packages that Change Keymaps.
                                                              (line 108)
* toggle-viper-mode <1>:                 Viper Specials.      (line 193)
* toggle-viper-mode:                     States in Viper.     (line   6)
* viper-add-local-keys:                  Key Bindings.        (line 183)
* viper-buffer-search-enable:            Viper Specials.      (line  21)
* viper-describe-kbd-macros:             Vi Macros.           (line 253)
* viper-glob-function:                   Rudimentary Changes. (line 180)
* viper-go-away <1>:                     Viper Specials.      (line 188)
* viper-go-away:                         States in Viper.     (line   6)
* viper-harness-minor-mode:              Packages that Change Keymaps.
                                                              (line 108)
* viper-mode:                            Packages that Change Keymaps.
                                                              (line 108)
* viper-modify-major-mode:               Key Bindings.        (line  82)
* viper-mouse-click-insert-word:         Viper Specials.      (line 311)
* viper-mouse-click-search-word:         Viper Specials.      (line 311)
* viper-set-emacs-state-searchstyle-macros: Viper Specials.   (line  75)
* viper-set-expert-level:                Viper Specials.      (line  86)
* viper-set-hooks:                       Packages that Change Keymaps.
                                                              (line 108)
* viper-set-parsing-style-toggling-macro: Move Commands.      (line 168)
* viper-set-searchstyle-toggling-macros: Viper Specials.      (line  45)
* viper-set-syntax-preference <1>:       Groundwork.          (line 147)
* viper-set-syntax-preference:           Movement and Markers.
                                                              (line  49)
* viper-unrecord-kbd-macro:              Vi Macros.           (line 126)
* viper-zap-local-keys:                  Key Bindings.        (line 183)


File: viper,  Node: Variable Index,  Next: Package Index,  Prev: Function Index,  Up: Top

Variable Index
**************

 [index ]
* Menu:

* buffer-read-only:                      Rudimentary Changes. (line 339)
* ex-cycle-other-window:                 Rudimentary Changes. (line 339)
* ex-cycle-through-non-files:            Rudimentary Changes. (line 339)
* function-key-map:                      Key Bindings.        (line 183)
* input-decode-map:                      Key Bindings.        (line 183)
* viper-allow-multiline-replace-regions: Rudimentary Changes. (line 339)
* viper-always <1>:                      Packages that Change Keymaps.
                                                              (line 108)
* viper-always:                          Rudimentary Changes. (line 339)
* viper-auto-indent:                     Rudimentary Changes. (line 339)
* viper-buffer-search-char <1>:          Viper Specials.      (line  21)
* viper-buffer-search-char:              Rudimentary Changes. (line 339)
* viper-case-fold-search:                Rudimentary Changes. (line 339)
* viper-command-ring-size:               Viper Specials.      (line 136)
* viper-custom-file-name:                Rudimentary Changes. (line 339)
* viper-delete-backwards-in-replace:     Rudimentary Changes. (line 339)
* viper-dired-modifier-map:              Viper Specials.      (line  67)
* viper-electric-mode:                   Rudimentary Changes. (line 339)
* viper-emacs-global-user-map:           Key Bindings.        (line 183)
* viper-emacs-state-cursor-color:        Rudimentary Changes. (line 265)
* viper-emacs-state-hook:                Rudimentary Changes. (line 339)
* viper-emacs-state-mode-list:           Packages that Change Keymaps.
                                                              (line  68)
* viper-ESC-moves-cursor-back:           Rudimentary Changes. (line 339)
* viper-ex-style-editing:                Rudimentary Changes. (line 339)
* viper-ex-style-motion:                 Rudimentary Changes. (line 339)
* viper-fast-keyseq-timeout:             Rudimentary Changes. (line 339)
* viper-insert-global-user-map:          Key Bindings.        (line 183)
* viper-insert-state-cursor-color:       Rudimentary Changes. (line 261)
* viper-insert-state-hook:               Rudimentary Changes. (line 339)
* viper-insert-state-mode-list:          Packages that Change Keymaps.
                                                              (line  68)
* viper-insertion-ring-size:             Viper Specials.      (line 107)
* viper-keep-point-on-repeat:            Rudimentary Changes. (line 339)
* viper-keep-point-on-undo:              Rudimentary Changes. (line 339)
* viper-major-mode-modifier-list:        Key Bindings.        (line 113)
* viper-mouse-insert-key:                Viper Specials.      (line 231)
* viper-multiclick-timeout:              Viper Specials.      (line 311)
* viper-no-multiple-ESC:                 Rudimentary Changes. (line 339)
* viper-parse-sexp-ignore-comments:      Move Commands.       (line 171)
* viper-re-query-replace:                Rudimentary Changes. (line 339)
* viper-re-search:                       Rudimentary Changes. (line 339)
* VIPER-READ-BUFFER-FUNCTION:            File and Buffer Handling.
                                                              (line 136)
* viper-replace-overlay-cursor-color:    Rudimentary Changes. (line 256)
* viper-replace-overlay-face:            Rudimentary Changes. (line 339)
* viper-replace-region-end-symbol:       Rudimentary Changes. (line 339)
* viper-replace-region-start-symbol:     Rudimentary Changes. (line 339)
* viper-replace-state-hook:              Rudimentary Changes. (line 339)
* viper-search-face <1>:                 Rudimentary Changes. (line 339)
* viper-search-face:                     Improved Search.     (line  42)
* viper-search-scroll-threshold:         Rudimentary Changes. (line 339)
* viper-search-wrap-around:              Rudimentary Changes. (line 339)
* viper-shift-width:                     Rudimentary Changes. (line 339)
* viper-slash-and-colon-map:             Viper Specials.      (line  67)
* viper-smart-suffix-list:               Viper Specials.      (line  89)
* viper-spell-function <1>:              Rudimentary Changes. (line 339)
* viper-spell-function:                  New Commands.        (line  66)
* viper-surrounding-word-function:       Rudimentary Changes. (line 339)
* viper-syntax-preference <1>:           Groundwork.          (line 147)
* viper-syntax-preference:               Movement and Markers.
                                                              (line  17)
* viper-tags-file-name:                  Rudimentary Changes. (line 339)
* viper-toggle-key:                      Rudimentary Changes. (line 339)
* viper-vi-global-user-map:              Key Bindings.        (line 183)
* viper-vi-state-hook:                   Rudimentary Changes. (line 339)
* viper-vi-state-mode-list:              Packages that Change Keymaps.
                                                              (line  68)
* viper-vi-style-in-minibuffer:          Rudimentary Changes. (line 339)
* viper-want-ctl-h-help:                 Rudimentary Changes. (line 339)
* viper-want-emacs-keys-in-insert <1>:   Packages that Change Keymaps.
                                                              (line 108)
* viper-want-emacs-keys-in-insert:       Rudimentary Changes. (line 339)
* viper-want-emacs-keys-in-vi <1>:       Packages that Change Keymaps.
                                                              (line 108)
* viper-want-emacs-keys-in-vi:           Rudimentary Changes. (line 339)


File: viper,  Node: Package Index,  Next: Concept Index,  Prev: Variable Index,  Up: Top

Package Index
*************

 [index ]
* Menu:

* ange-ftp.el:                           Useful Packages.      (line 37)
* desktop.el:                            Useful Packages.      (line 52)
* dired.el:                              Useful Packages.      (line 44)
* ediff.el:                              Useful Packages.      (line 59)
* font-lock.el:                          Useful Packages.      (line 48)
* ispell.el:                             Useful Packages.      (line 56)
* vc.el:                                 Useful Packages.      (line 41)


File: viper,  Node: Concept Index,  Prev: Package Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* # (Previous file) <1>:                 Shell Commands.      (line   8)
* # (Previous file):                     Groundwork.          (line  72)
* % (Current file) <1>:                  Shell Commands.      (line   6)
* % (Current file):                      Groundwork.          (line  68)
* % (Ex address) <1>:                    Shell Commands.      (line   7)
* % (Ex address):                        Groundwork.          (line  58)
* .emacs:                                Customization.       (line  12)
* .viper:                                Customization.       (line   8)
* :customize:                            Customization.       (line  19)
* <a-z>:                                 Groundwork.          (line  33)
* <address>:                             Groundwork.          (line  33)
* <args>:                                Groundwork.          (line  76)
* <cmd>:                                 Groundwork.          (line  76)
* <cr>:                                  Groundwork.          (line  95)
* <esc>:                                 Groundwork.          (line  95)
* <ht>:                                  Groundwork.          (line  95)
* <lf>:                                  Groundwork.          (line  95)
* <move>:                                Groundwork.          (line  33)
* <sp>:                                  Groundwork.          (line  95)
* abbrevs:                               Abbreviation Facilities.
                                                              (line   6)
* absolute file names:                   Multiple Files in Viper.
                                                              (line  46)
* appending:                             Appending Text.      (line  11)
* auto fill:                             Options.             (line  82)
* auto save:                             Undo and Backups.    (line  12)
* autoindent:                            Options.             (line   8)
* backup files <1>:                      Undoing.             (line   6)
* backup files:                          Undo and Backups.    (line  12)
* buffer:                                Emacs Preliminaries. (line   6)
* buffer (modified):                     Emacs Preliminaries. (line  46)
* buffer information:                    Emacs Preliminaries. (line  46)
* buffer search:                         Improved Search.     (line   6)
* C-c and Viper:                         Packages that Change Keymaps.
                                                              (line   6)
* case and searching:                    Options.             (line  26)
* case-insensitive search <1>:           Move Commands.       (line 154)
* case-insensitive search <2>:           New Commands.        (line 121)
* case-insensitive search:               Vi State.            (line  71)
* case-sensitive search <1>:             Move Commands.       (line 154)
* case-sensitive search <2>:             New Commands.        (line 121)
* case-sensitive search:                 Vi State.            (line  71)
* changing case <1>:                     Changing Text.       (line   6)
* changing case:                         New Commands.        (line  46)
* changing tab width:                    Options.             (line  72)
* CHAR:                                  Groundwork.          (line  96)
* char:                                  Groundwork.          (line  96)
* column movement:                       Move Commands.       (line   6)
* Command history:                       New Commands.        (line 134)
* command line:                          Emacs Preliminaries. (line  46)
* Command ring:                          New Commands.        (line 134)
* compiling:                             Useful Packages.     (line  17)
* completion:                            Completion.          (line   6)
* Control keys:                          Emacs Preliminaries. (line  79)
* customization:                         Customization.       (line   6)
* cut and paste:                         Yanking.             (line   6)
* describing regions:                    Basics.              (line  21)
* desktop:                               Useful Packages.     (line  52)
* Destructive command history:           Viper Specials.      (line 136)
* Destructive command ring:              Viper Specials.      (line 136)
* dired:                                 Useful Packages.     (line  44)
* dynamic abbrevs:                       Abbreviation Facilities.
                                                              (line  11)
* ediff:                                 Useful Packages.     (line  59)
* Emacs state <1>:                       Emacs State.         (line   6)
* Emacs state:                           States in Viper.     (line   6)
* email:                                 Useful Packages.     (line  25)
* end (of buffer):                       Emacs Preliminaries. (line   6)
* end (of line):                         Emacs Preliminaries. (line   6)
* Ex addresses:                          Groundwork.          (line  36)
* Ex commands <1>:                       Groundwork.          (line 165)
* Ex commands <2>:                       Vi State.            (line  74)
* Ex commands:                           States in Viper.     (line   6)
* Ex style motion:                       Movement and Markers.
                                                              (line   6)
* expanding (region):                    Basics.              (line  21)
* font-lock:                             Useful Packages.     (line  48)
* global keymap:                         Emacs Preliminaries. (line  61)
* headings <1>:                          Move Commands.       (line   6)
* headings:                              Viper Specials.      (line  81)
* history:                               History.             (line   6)
* incremental search:                    Improved Search.     (line  23)
* initialization:                        Customization.       (line   8)
* Insert state <1>:                      Editing in Insert State.
                                                              (line  11)
* Insert state <2>:                      Insert State.        (line   6)
* Insert state:                          States in Viper.     (line   6)
* inserting:                             Appending Text.      (line  11)
* Insertion history:                     New Commands.        (line 134)
* Insertion ring <1>:                    Viper Specials.      (line 107)
* Insertion ring:                        New Commands.        (line 134)
* interactive shell:                     Useful Packages.     (line  21)
* ispell:                                Useful Packages.     (line  56)
* joining lines:                         Changing Text.       (line   6)
* key bindings <1>:                      Mapping.             (line   6)
* key bindings:                          Key Bindings.        (line   6)
* key mapping:                           Mapping.             (line   6)
* keyboard macros <1>:                   New Commands.        (line  94)
* keyboard macros:                       Macros and Registers.
                                                              (line   6)
* keymap:                                Emacs Preliminaries. (line  61)
* keymaps:                               Key Bindings.        (line   6)
* last keyboard macro:                   Macros and Registers.
                                                              (line  24)
* layout:                                Options.             (line  58)
* line commands <1>:                     Groundwork.          (line  16)
* line commands:                         Basics.              (line  16)
* line editor motion:                    Movement and Markers.
                                                              (line   6)
* literal searching:                     Options.             (line  35)
* local keymap:                          Emacs Preliminaries. (line  61)
* looking at:                            Emacs Preliminaries. (line   6)
* macros:                                Macros and Registers.
                                                              (line   6)
* mail:                                  Useful Packages.     (line  25)
* major mode:                            Emacs Preliminaries. (line  61)
* make:                                  Useful Packages.     (line  17)
* managing multiple files:               Multiple Files in Viper.
                                                              (line   6)
* mark:                                  Emacs Preliminaries. (line   6)
* markers <1>:                           Move Commands.       (line   6)
* markers <2>:                           Undo and Backups.    (line  17)
* markers:                               Multiple Files in Viper.
                                                              (line  11)
* marking:                               Marking.             (line  10)
* matching parens <1>:                   Options.             (line  62)
* matching parens:                       Move Commands.       (line   6)
* Meta key <1>:                          Insert State.        (line  36)
* Meta key <2>:                          Vi State.            (line  33)
* Meta key:                              Emacs Preliminaries. (line  79)
* Minibuffer <1>:                        History.             (line   6)
* Minibuffer <2>:                        The Minibuffer.      (line   6)
* Minibuffer:                            Emacs Preliminaries. (line  46)
* minor mode:                            Emacs Preliminaries. (line  61)
* mode:                                  Emacs Preliminaries. (line  61)
* mode line <1>:                         States in Viper.     (line  54)
* mode line:                             Emacs Preliminaries. (line  46)
* mouse:                                 Viper Specials.      (line 230)
* mouse search:                          Improved Search.     (line  33)
* mouse-insert:                          Viper Specials.      (line 283)
* mouse-search:                          Viper Specials.      (line 230)
* movement commands <1>:                 Move Commands.       (line   6)
* movement commands:                     Basics.              (line  21)
* movements:                             Groundwork.          (line  33)
* Multifile documents and programs:      Viper Specials.      (line 195)
* multiple files <1>:                    File and Buffer Handling.
                                                              (line   6)
* multiple files:                        Multiple Files in Viper.
                                                              (line   6)
* multiple undo:                         Vi State.            (line  56)
* paragraphs <1>:                        Move Commands.       (line   6)
* paragraphs:                            Viper Specials.      (line  81)
* paren matching <1>:                    Options.             (line  62)
* paren matching:                        Move Commands.       (line   6)
* paste <1>:                             Yanking.             (line   6)
* paste:                                 Appending Text.      (line  11)
* point:                                 Emacs Preliminaries. (line   6)
* point commands <1>:                    Groundwork.          (line  11)
* point commands:                        Basics.              (line  11)
* put:                                   Appending Text.      (line  11)
* query replace <1>:                     New Commands.        (line  23)
* query replace:                         Improved Search.     (line  30)
* quoting regions:                       Changing Text.       (line   6)
* r and R region specifiers <1>:         Groundwork.          (line  24)
* r and R region specifiers:             Basics.              (line  35)
* RCS:                                   Useful Packages.     (line  41)
* readonly files:                        Options.             (line  44)
* region <1>:                            Basics.              (line  21)
* region:                                Emacs Preliminaries. (line   6)
* region specification:                  Basics.              (line  21)
* register execution <1>:                New Commands.        (line  94)
* register execution:                    Macros and Registers.
                                                              (line   6)
* registers <1>:                         Macros and Registers.
                                                              (line   6)
* registers <2>:                         Undo and Backups.    (line  17)
* registers:                             Multiple Files in Viper.
                                                              (line  27)
* regular expressions:                   Vi State.            (line  71)
* Replace state <1>:                     Replace State.       (line   6)
* Replace state:                         States in Viper.     (line   6)
* scrolling:                             Display.             (line   6)
* searching <1>:                         Options.             (line  87)
* searching:                             Move Commands.       (line   6)
* sections <1>:                          Move Commands.       (line   6)
* sections:                              Viper Specials.      (line  81)
* sentences <1>:                         Move Commands.       (line   6)
* sentences:                             Viper Specials.      (line  81)
* setting variables:                     Rudimentary Changes. (line   6)
* shell <1>:                             Options.             (line  53)
* shell:                                 Useful Packages.     (line  21)
* shell commands:                        Shell Commands.      (line  18)
* shifting text <1>:                     Options.             (line  58)
* shifting text:                         Deleting Text.       (line  18)
* substitution:                          Changing Text.       (line   6)
* syntax table <1>:                      Groundwork.          (line 147)
* syntax table:                          Movement and Markers.
                                                              (line  17)
* tabbing:                               Options.             (line  72)
* text:                                  Emacs Preliminaries. (line   6)
* text processing:                       Search and Replace.  (line  43)
* textmarkers <1>:                       Move Commands.       (line   6)
* textmarkers <2>:                       Movement and Markers.
                                                              (line  57)
* textmarkers <3>:                       Undo and Backups.    (line  17)
* textmarkers:                           Multiple Files in Viper.
                                                              (line  11)
* transparent ftp:                       Useful Packages.     (line  37)
* undo <1>:                              Undoing.             (line   6)
* undo <2>:                              Undo and Backups.    (line   6)
* undo:                                  Vi State.            (line  56)
* vanilla search <1>:                    Move Commands.       (line 154)
* vanilla search <2>:                    New Commands.        (line 121)
* vanilla search:                        Vi State.            (line  71)
* variables for customization:           Rudimentary Changes. (line   6)
* version maintenance:                   Useful Packages.     (line  41)
* Vi macros:                             Vi Macros.           (line   6)
* Vi options:                            Options.             (line   6)
* Vi state <1>:                          Vi State.            (line   6)
* Vi state:                              States in Viper.     (line   6)
* viewing registers and markers <1>:     Macros and Registers.
                                                              (line  21)
* viewing registers and markers:         Undo and Backups.    (line  17)
* Viper and C-c:                         Packages that Change Keymaps.
                                                              (line   6)
* Viper as minor mode:                   Emacs Preliminaries. (line  79)
* window:                                Emacs Preliminaries. (line  46)
* word search:                           Improved Search.     (line   6)
* word wrap:                             Options.             (line  82)
* WORDS:                                 Groundwork.          (line  96)
* words:                                 Groundwork.          (line  96)



Tag Table:
Node: Top939
Node: Overview4147
Node: Emacs Preliminaries5743
Node: Loading Viper11098
Node: States in Viper13284
Node: Emacs State18348
Node: Vi State19829
Node: Insert State26708
Node: Replace State29587
Node: The Minibuffer31251
Node: Multiple Files in Viper33154
Node: Unimplemented Features36596
Node: Improvements over Vi37319
Node: Basics38405
Node: Undo and Backups40856
Node: History42029
Node: Macros and Registers43635
Node: Completion45319
Node: Improved Search45753
Node: Abbreviation Facilities48113
Node: Movement and Markers49093
Node: New Commands52145
Node: Useful Packages58233
Node: Customization60295
Node: Rudimentary Changes62102
Node: Key Bindings76919
Node: Packages that Change Keymaps86764
Node: Viper Specials92638
Node: Vi Macros110353
Node: Commands123757
Node: Groundwork124596
Node: Text Handling131065
Node: Move Commands131737
Node: Marking135490
Node: Appending Text136732
Node: Editing in Insert State139070
Node: Deleting Text139660
Node: Changing Text141004
Node: Search and Replace144006
Node: Yanking146564
Node: Undoing147485
Node: Display147828
Node: File and Buffer Handling149140
Node: Mapping153666
Node: Shell Commands155364
Node: Options157204
Node: Emacs Related Commands159407
Node: Mouse-bound Commands160983
Node: Acknowledgments161850
Node: GNU Free Documentation License164991
Node: Key Index190122
Node: Function Index207732
Node: Variable Index219409
Node: Package Index225075
Node: Concept Index225729

End Tag Table
