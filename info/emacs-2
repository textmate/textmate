This is /home/cyd/emacs/doc/emacs/../../info/emacs, produced by
makeinfo version 4.13 from /home/cyd/emacs/doc/emacs/emacs.texi.

This is the `GNU Emacs Manual', updated for Emacs version 24.1.

Copyright (C) 1985-1987, 1993-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).       The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


File: emacs,  Node: Basic Isearch,  Next: Repeat Isearch,  Up: Incremental Search

15.1.1 Basics of Incremental Search
-----------------------------------

`C-s'
     Begin incremental search (`isearch-forward').

`C-r'
     Begin reverse incremental search (`isearch-backward').

   `C-s' (`isearch-forward') starts a forward incremental search.  It
reads characters from the keyboard, and moves point just past the end
of the next occurrence of those characters in the buffer.

   For instance, if you type `C-s' and then `F', that puts the cursor
after the first `F' that occurs in the buffer after the starting point.
Then if you then type `O', the cursor moves to just after the first
`FO'; the `F' in that `FO' might not be the first `F' previously found.
After another `O', the cursor moves to just after the first `FOO'.

   At each step, Emacs highlights the "current match"--the buffer text
that matches the search string--using the `isearch' face (*note
Faces::).  The current search string is also displayed in the echo area.

   If you make a mistake typing the search string, type <DEL>.  Each
<DEL> cancels the last character of the search string.

   When you are satisfied with the place you have reached, type <RET>.
This stops searching, leaving the cursor where the search brought it.
Also, any command not specially meaningful in searches stops the
searching and is then executed.  Thus, typing `C-a' exits the search
and then moves to the beginning of the line.  <RET> is necessary only
if the next command you want to type is a printing character, <DEL>,
<RET>, or another character that is special within searches (`C-q',
`C-w', `C-r', `C-s', `C-y', `M-y', `M-r', `M-c', `M-e', and some others
described below).

   As a special exception, entering <RET> when the search string is
empty launches nonincremental search (*note Nonincremental Search::).

   When you exit the incremental search, it adds the original value of
point to the mark ring, without activating the mark; you can thus use
`C-u C-<SPC>' to return to where you were before beginning the search.
*Note Mark Ring::.  It only does this if the mark was not already
active.

   To search backwards, use `C-r' (`isearch-backward') instead of `C-s'
to start the search.  A backward search finds matches that end before
the starting point, just as a forward search finds matches that begin
after it.


File: emacs,  Node: Repeat Isearch,  Next: Error in Isearch,  Prev: Basic Isearch,  Up: Incremental Search

15.1.2 Repeating Incremental Search
-----------------------------------

Suppose you search forward for `FOO' and find a match, but not the one
you expected to find: the `FOO' you were aiming for occurs later in the
buffer.  In this event, type another `C-s' to move to the next
occurrence of the search string.  You can repeat this any number of
times.  If you overshoot, you can cancel some `C-s' characters with
<DEL>.  Similarly, each `C-r' in a backward incremental search repeats
the backward search.

   If you pause for a little while during incremental search, Emacs
highlights all the other possible matches for the search string that
are present on the screen.  This helps you anticipate where you can get
to by typing `C-s' or `C-r' to repeat the search.  The other matches
are highlighted differently from the current match, using the
customizable face `lazy-highlight' (*note Faces::).  If you don't like
this feature, you can disable it by setting `isearch-lazy-highlight' to
`nil'.

   After exiting a search, you can search for the same string again by
typing just `C-s C-s'.  The first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again".
Similarly, `C-r C-r' searches backward for the last search string.  In
determining the last search string, it doesn't matter whether the
string was searched for with `C-s' or `C-r'.

   If you are searching forward but you realize you were looking for
something before the starting point, type `C-r' to switch to a backward
search, leaving the search string unchanged.  Similarly, `C-s' in a
backward search switches to a forward search.

   If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating a
failing reverse search with `C-r' starts again from the end.  This is
called "wrapping around", and `Wrapped' appears in the search prompt
once this has happened.  If you keep on going past the original
starting point of the search, it changes to `Overwrapped', which means
that you are revisiting matches that you have already seen.

   To reuse earlier search strings, use the "search ring".  The
commands `M-p' and `M-n' move through the ring to pick a search string
to reuse.  These commands leave the selected search ring element in the
minibuffer, where you can edit it.

   To edit the current search string in the minibuffer without
replacing it with items from the search ring, type `M-e'.  Type `C-s'
or `C-r' to finish editing the string and search for it.


File: emacs,  Node: Error in Isearch,  Next: Special Isearch,  Prev: Repeat Isearch,  Up: Incremental Search

15.1.3 Errors in Incremental Search
-----------------------------------

If your string is not found at all, the echo area says `Failing
I-Search', and the cursor moves past the place where Emacs found as
much of your string as it could.  Thus, if you search for `FOOT', and
there is no `FOOT', you might see the cursor after the `FOO' in `FOOL'.
In the echo area, the part of the search string that failed to match is
highlighted using the face `isearch-fail'.

   At this point, there are several things you can do.  If your string
was mistyped, you can use <DEL> to erase some of it and correct it.  If
you like the place you have found, you can type <RET> to remain there.
Or you can type `C-g', which removes from the search string the
characters that could not be found (the `T' in `FOOT'), leaving those
that were found (the `FOO' in `FOOT').  A second `C-g' at that point
cancels the search entirely, returning point to where it was when the
search started.

   The quit command, `C-g', does special things during searches; just
what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, `C-g' cancels the
entire search, moving the cursor back to where you started the search.
If `C-g' is typed when there are characters in the search string that
have not been found--because Emacs is still searching for them, or
because it has failed to find them--then the search string characters
which have not been found are discarded from the search string.  With
them gone, the search is now successful and waiting for more input, so
a second `C-g' will cancel the entire search.


File: emacs,  Node: Special Isearch,  Next: Isearch Yank,  Prev: Error in Isearch,  Up: Incremental Search

15.1.4 Special Input for Incremental Search
-------------------------------------------

Some of the characters you type during incremental search have special
effects.

   If the search string you entered contains only lower-case letters,
the search is case-insensitive; as long as an upper-case letter exists
in the search string, the search becomes case-sensitive.  If you delete
the upper-case character from the search string, it ceases to have this
effect.  *Note Search Case::.

   To search for a newline character, type `C-j'.

   To search for other control characters, such as <control-S>, quote
it by typing `C-q' first (*note Inserting Text::).  To search for
non-ASCII characters, you can either use `C-q' and enter its octal
code, or use an input method (*note Input Methods::).  If an input
method is enabled in the current buffer when you start the search, you
can use it in the search string also.  While typing the search string,
you can toggle the input method with the command `C-\'
(`isearch-toggle-input-method').  You can also turn on a non-default
input method with `C-^' (`isearch-toggle-specified-input-method'),
which prompts for the name of the input method.  When an input method
is active during incremental search, the search prompt includes the
input method mnemonic, like this:

     I-search [IM]:

where IM is the mnemonic of the active input method.  Any input method
you enable during incremental search remains enabled in the current
buffer afterwards.

   Typing `M-%' in incremental search invokes `query-replace' or
`query-replace-regexp' (depending on search mode) with the current
search string used as the string to replace.  *Note Query Replace::.

   Typing `M-<TAB>' in incremental search invokes `isearch-complete',
which attempts to complete the search string using the search ring as a
list of completion alternatives.  *Note Completion::.  In many
operating systems, the `M-<TAB>' key sequence is captured by the window
manager; you then need to rebind `isearch-complete' to another key
sequence if you want to use it (*note Rebinding::).

   When incremental search is active, you can type `C-h C-h' to access
interactive help options, including a list of special key bindings.
These key bindings are part of the keymap `isearch-mode-map' (*note
Keymaps::).


File: emacs,  Node: Isearch Yank,  Next: Isearch Scroll,  Prev: Special Isearch,  Up: Incremental Search

15.1.5 Isearch Yanking
----------------------

Within incremental search, `C-y' (`isearch-yank-kill') appends the
current kill to the search string.  `M-y' (`isearch-yank-pop'), if
called after `C-y', replaces that appended text with an earlier kill,
similar to the usual `M-y' (`yank-pop') command (*note Yanking::).
`Mouse-2' appends the current X selection (*note Primary Selection::).

   `C-w' (`isearch-yank-word-or-char') appends the next character or
word at point to the search string.  This is an easy way to search for
another occurrence of the text at point.  (The decision of whether to
copy a character or a word is heuristic.)

   Similarly, `M-s C-e' (`isearch-yank-line') appends the rest of the
current line to the search string.  If point is already at the end of a
line, it appends the next line.

   If the search is currently case-insensitive, both `C-w' and `M-s
C-e' convert the text they copy to lower case, so that the search
remains case-insensitive.

   `C-M-w' (`isearch-del-char') deletes the last character from the
search string, and `C-M-y' (`isearch-yank-char') appends the character
after point to the search string.  An alternative method to add the
character after point is to enter the minibuffer with `M-e' (*note
Repeat Isearch::) and type `C-f' at the end of the search string in the
minibuffer.


File: emacs,  Node: Isearch Scroll,  Next: Isearch Minibuffer,  Prev: Isearch Yank,  Up: Incremental Search

15.1.6 Scrolling During Incremental Search
------------------------------------------

Normally, scrolling commands exit incremental search.  If you change
the variable `isearch-allow-scroll' to a non-`nil' value, that enables
the use of the scroll-bar, as well as keyboard scrolling commands like
`C-v', `M-v', and `C-l' (*note Scrolling::).  This applies only to
calling these commands via their bound key sequences--typing `M-x' will
still exit the search.  You can give prefix arguments to these commands
in the usual way.  This feature won't let you scroll the current match
out of visibility, however.

   The `isearch-allow-scroll' feature also affects some other commands,
such as `C-x 2' (`split-window-below') and `C-x ^' (`enlarge-window'),
which don't exactly scroll but do affect where the text appears on the
screen.  It applies to any command whose name has a non-`nil'
`isearch-scroll' property.  So you can control which commands are
affected by changing these properties.

   For example, to make `C-h l' usable within an incremental search in
all future Emacs sessions, use `C-h c' to find what command it runs
(*note Key Help::), which is `view-lossage'.  Then you can put the
following line in your init file (*note Init File::):

     (put 'view-lossage 'isearch-scroll t)

This feature can be applied to any command that doesn't permanently
change point, the buffer contents, the match data, the current buffer,
or the selected window and frame.  The command must not itself attempt
an incremental search.


File: emacs,  Node: Isearch Minibuffer,  Prev: Isearch Scroll,  Up: Incremental Search

15.1.7 Searching the Minibuffer
-------------------------------

If you start an incremental search while the minibuffer is active,
Emacs searches the contents of the minibuffer.  Unlike searching an
ordinary buffer, the search string is not shown in the echo area,
because that is used to display the minibuffer.

   If an incremental search fails in the minibuffer, it tries searching
the minibuffer history.  *Note Minibuffer History::.  You can visualize
the minibuffer and its history as a series of "pages", with the
earliest history element on the first page and the current minibuffer
on the last page.  A forward search, `C-s', searches forward to later
pages; a reverse search, `C-r', searches backwards to earlier pages.
Like in ordinary buffer search, a failing search can wrap around, going
from the last page to the first page or vice versa.

   When the current match is on a history element, that history element
is pulled into the minibuffer.  If you exit the incremental search
normally (e.g. by typing <RET>), it remains in the minibuffer
afterwards.  Canceling the search, with `C-g', restores the contents of
the minibuffer when you began the search.


File: emacs,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

15.2 Nonincremental Search
==========================

Emacs also has conventional nonincremental search commands, which
require you to type the entire search string before searching begins.

`C-s <RET> STRING <RET>'
     Search for STRING.

`C-r <RET> STRING <RET>'
     Search backward for STRING.

   To start a nonincremental search, first type `C-s <RET>'.  This
enters the minibuffer to read the search string; terminate the string
with <RET>, and then the search takes place.  If the string is not
found, the search command signals an error.

   When you type `C-s <RET>', the `C-s' invokes incremental search as
usual.  That command is specially programmed to invoke the command for
nonincremental search, `search-forward', if the string you specify is
empty.  (Such an empty argument would otherwise be useless.)  `C-r
<RET>' does likewise, invoking the command `search-backward'.


File: emacs,  Node: Word Search,  Next: Regexp Search,  Prev: Nonincremental Search,  Up: Search

15.3 Word Search
================

A "word search" finds a sequence of words without regard to the type of
punctuation between them.  For instance, if you enter a search string
that consists of two words separated by a single space, the search
matches any sequence of those two words separated by one or more
spaces, newlines, or other punctuation characters.  This is
particularly useful for searching text documents, because you don't
have to worry whether the words you are looking for are separated by
newlines or spaces.

`M-s w'
     If incremental search is active, toggle word search mode
     (`isearch-toggle-word'); otherwise, begin an incremental forward
     word search (`isearch-forward-word').

`M-s w <RET> WORDS <RET>'
     Search for WORDS, using a forward nonincremental word search.

`M-s w C-r <RET> WORDS <RET>'
     Search backward for WORDS, using a nonincremental word search.

   To begin a forward incremental word search, type `M-s w'.  If
incremental search is not already active, this runs the command
`isearch-forward-word'.  If incremental search is already active
(whether a forward or backward search), `M-s w' switches to a word
search while keeping the direction of the search and the current search
string unchanged.  You can toggle word search back off by typing `M-s
w' again.

   To begin a nonincremental word search, type `M-s w <RET>' for a
forward search, or `M-s w C-r <RET>' for a backward search.  These run
the commands `word-search-forward' and `word-search-backward'
respectively.

   Incremental and nonincremental word searches differ slightly in the
way they find a match.  In a nonincremental word search, the last word
in the search string must exactly match a whole word.  In an
incremental word search, the matching is more lax: the last word in the
search string can match part of a word, so that the matching proceeds
incrementally as you type.  This additional laxity does not apply to
the lazy highlight, which always matches whole words.


File: emacs,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

15.4 Regular Expression Search
==============================

A "regular expression" (or "regexp" for short) is a pattern that
denotes a class of alternative strings to match.  Emacs provides both
incremental and nonincremental ways to search for a match for a regexp.
The syntax of regular expressions is explained in the next section.

`C-M-s'
     Begin incremental regexp search (`isearch-forward-regexp').

`C-M-r'
     Begin reverse incremental regexp search
     (`isearch-backward-regexp').

   Incremental search for a regexp is done by typing `C-M-s'
(`isearch-forward-regexp'), by invoking `C-s' with a prefix argument
(whose value does not matter), or by typing `M-r' within a forward
incremental search.  This command reads a search string incrementally
just like `C-s', but it treats the search string as a regexp rather
than looking for an exact match against the text in the buffer.  Each
time you add text to the search string, you make the regexp longer, and
the new regexp is searched for.  To search backward for a regexp, use
`C-M-r' (`isearch-backward-regexp'), `C-r' with a prefix argument, or
`M-r' within a backward incremental search.

   All of the special key sequences in an ordinary incremental search
do similar things in an incremental regexp search.  For instance,
typing `C-s' immediately after starting the search retrieves the last
incremental search regexp used and searches forward for it.
Incremental regexp and non-regexp searches have independent defaults.
They also have separate search rings, which you can access with `M-p'
and `M-n'.

   If you type <SPC> in incremental regexp search, it matches any
sequence of whitespace characters, including newlines.  If you want to
match just a space, type `C-q <SPC>'.  You can control what a bare
space matches by setting the variable `search-whitespace-regexp' to the
desired regexp.

   In some cases, adding characters to the regexp in an incremental
regexp search can make the cursor move back and start again.  For
example, if you have searched for `foo' and you add `\|bar', the cursor
backs up in case the first `bar' precedes the first `foo'.  *Note
Regexps::.

   Forward and backward regexp search are not symmetrical, because
regexp matching in Emacs always operates forward, starting with the
beginning of the regexp.  Thus, forward regexp search scans forward,
trying a forward match at each possible starting position.  Backward
regexp search scans backward, trying a forward match at each possible
starting position.  These search methods are not mirror images.

   Nonincremental search for a regexp is done with the commands
`re-search-forward' and `re-search-backward'.  You can invoke these
with `M-x', or by way of incremental regexp search with `C-M-s <RET>'
and `C-M-r <RET>'.

   If you use the incremental regexp search commands with a prefix
argument, they perform ordinary string search, like `isearch-forward'
and `isearch-backward'.  *Note Incremental Search::.


File: emacs,  Node: Regexps,  Next: Regexp Backslash,  Prev: Regexp Search,  Up: Search

15.5 Syntax of Regular Expressions
==================================

This manual describes regular expression features that users typically
use.  *Note Regular Expressions: (elisp)Regular Expressions, for
additional features used mainly in Lisp programs.

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
matches that same character and nothing else.  The special characters
are `$^.*+?[\'.  The character `]' is special if it ends a character
alternative (see later).  The character `-' is special inside a
character alternative.  Any other character appearing in a regular
expression is ordinary, unless a `\' precedes it.  (When you use
regular expressions in a Lisp program, each `\' must be doubled, see
the example near the end of this section.)

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does _not_ match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.  (When case distinctions
are being ignored, these regexps also match `F' and `O', but we
consider this a generalization of "the same string", rather than an
exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.
For example, concatenating the regular expressions `f' and `o' gives
the regular expression `fo', which matches only the string `fo'.  Still
trivial.  To do something nontrivial, you need to use one of the special
characters.  Here is a list of them.

`.' (Period)
     is a special character that matches any single character except a
     newline.  For example, the regular expressions `a.b' matches any
     three-character string that begins with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a postfix operator that means
     to match the preceding regular expression repetitively any number
     of times, as many times as possible.  Thus, `o*' matches any number
     of `o's, including no `o's.

     `*' always applies to the _smallest_ possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.  It matches `f', `fo', `foo', and so on.

     The matcher processes a `*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the `*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     in matching `ca*ar' against the string `caaar', the `a*' first
     tries to match all three `a's; but the rest of the pattern is `ar'
     and there is only `r' left to match, so this try fails.  The next
     alternative is for `a*' to match only two `a's.  With this choice,
     the rest of the regexp matches successfully.

`+'
     is a postfix operator, similar to `*' except that it must match
     the preceding expression at least once.  Thus, `ca+r' matches the
     strings `car' and `caaaar' but not the string `cr', whereas `ca*r'
     matches all three strings.

`?'
     is a postfix operator, similar to `*' except that it can match the
     preceding expression either once or not at all.  Thus, `ca?r'
     matches `car' or `cr', and nothing else.

`*?', `+?', `??'
     are non-"greedy" variants of the operators above.  The normal
     operators `*', `+', `?' match as much as they can, as long as the
     overall regexp can still match.  With a following `?', they will
     match as little as possible.

     Thus, both `ab*' and `ab*?' can match the string `a' and the
     string `abbbb'; but if you try to match them both against the text
     `abbb', `ab*' will match it all (the longest valid match), while
     `ab*?'  will match just `a' (the shortest valid match).

     Non-greedy operators match the shortest possible string starting
     at a given starting point; in a forward search, though, the
     earliest possible starting point for match is always the one
     chosen.  Thus, if you search for `a.*?$' against the text `abbab'
     followed by a newline, it matches the whole string.  Since it
     _can_ match starting at the first `a', it does.

`\{N\}'
     is a postfix operator specifying N repetitions--that is, the
     preceding regular expression must match exactly N times in a row.
     For example, `x\{4\}' matches the string `xxxx' and nothing else.

`\{N,M\}'
     is a postfix operator specifying between N and M repetitions--that
     is, the preceding regular expression must match at least N times,
     but no more than M times.  If M is omitted, then there is no upper
     limit, but the preceding regular expression must match at least N
     times.
     `\{0,1\}' is equivalent to `?'.
     `\{0,\}' is equivalent to `*'.
     `\{1,\}' is equivalent to `+'.

`[ ... ]'
     is a "character set", beginning with `[' and terminated by `]'.

     In the simplest case, the characters between the two brackets are
     what this set can match.  Thus, `[ad]' matches either one `a' or
     one `d', and `[ad]*' matches any string composed of just `a's and
     `d's (including the empty string).  It follows that `c[ad]*r'
     matches `cr', `car', `cdr', `caddaar', etc.

     You can also include character ranges in a character set, by
     writing the starting and ending characters with a `-' between
     them.  Thus, `[a-z]' matches any lower-case ASCII letter.  Ranges
     may be intermixed freely with individual characters, as in
     `[a-z$%.]', which matches any lower-case ASCII letter or `$', `%'
     or period.

     You can also include certain special "character classes" in a
     character set.  A `[:' and balancing `:]' enclose a character
     class inside a character alternative.  For instance, `[[:alnum:]]'
     matches any letter or digit.  *Note Char Classes: (elisp)Char
     Classes, for a list of character classes.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `-' as the first or last character of the set, or put
     it after a range.  Thus, `[]-]' matches both `]' and `-'.

     To include `^' in a set, put it anywhere but at the beginning of
     the set.  (At the beginning, it complements the set--see below.)

     When you use a range in case-insensitive search, you should write
     both ends of the range in upper case, or both in lower case, or
     both should be non-letters.  The behavior of a mixed-case range
     such as `A-z' is somewhat ill-defined, and it may change in future
     Emacs versions.

`[^ ... ]'
     `[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters _except_ ASCII letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (in other words, `-' and `]' are not special there).

     A complemented character set can match a newline, unless newline is
     mentioned as one of the characters not to match.  This is in
     contrast to the handling of regexps in programs such as `grep'.

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' that occurs
     at the beginning of a line.

     For historical compatibility reasons, `^' can be used with this
     meaning only at the beginning of the regular expression, or after
     `\(' or `\|'.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `x+$' matches a string of one `x' or more at the end of a line.

     For historical compatibility reasons, `$' can be used with this
     meaning only at the end of the regular expression, or before `\)'
     or `\|'.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression that matches only `$', and `\[' is a regular expression
     that matches only `[', and so on.

     See the following section for the special constructs that begin
     with `\'.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, `*foo' treats `*' as ordinary since there is no
preceding expression on which the `*' can act.  It is poor practice to
depend on this behavior; it is better to quote the special character
anyway, regardless of where it appears.

   As a `\' is not special inside a character alternative, it can never
remove the special meaning of `-' or `]'.  So you should not quote
these characters when they have no special meaning either.  This would
not clarify anything, since backslashes can legitimately precede these
characters where they _have_ special meaning, as in `[^\]' (`"[^\\]"'
for Lisp string syntax), which matches any single character except a
backslash.


File: emacs,  Node: Regexp Backslash,  Next: Regexp Example,  Prev: Regexps,  Up: Search

15.6 Backslash in Regular Expressions
=====================================

For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with `\' that have special meanings.  The second
character in the sequence is always an ordinary character when used on
its own.  Here is a table of `\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches some text if
     either A matches it or B matches it.  It works by trying to match
     A, and if that fails, by trying to match B.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix operators
          `*', `+' and `?' to operate on.  Thus, `ba\(na\)*' matches
          `bananana', etc., with any (zero or more) number of `na'
          strings.

       3. To record a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that is assigned
     as a second meaning to the same `\( ... \)' construct.  In practice
     there is usually no conflict between the two meanings; when there
     is a conflict, you can use a "shy" group.

`\(?: ... \)'
     specifies a "shy" group that does not record the matched substring;
     you can't refer back to it with `\D'.  This is useful in
     mechanically combining regular expressions, so that you can add
     groups for syntactic purposes without interfering with the
     numbering of the groups that are meant to be referred to.

`\D'
     matches the same text that matched the Dth occurrence of a `\( ...
     \)' construct.  This is called a "back reference".

     After the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use `\' followed by the
     digit D to mean "match the same text matched the Dth time by the
     `\( ... \)' construct".

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in the order that the open-parentheses appear in the regular
     expression.  So you can use `\1' through `\9' to refer to the text
     matched by the corresponding `\( ... \)' constructs.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

     If a particular `\( ... \)' construct matches more than once
     (which can easily happen if it is followed by `*'), only the last
     match is recorded.

`\`'
     matches the empty string, but only at the beginning of the string
     or buffer (or its accessible portion) being matched against.

`\''
     matches the empty string, but only at the end of the string or
     buffer (or its accessible portion) being matched against.

`\='
     matches the empty string, but only at point.

`\b'
     matches the empty string, but only at the beginning or end of a
     word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

     `\b' matches at the beginning or end of the buffer regardless of
     what text appears next to it.

`\B'
     matches the empty string, but _not_ at the beginning or end of a
     word.

`\<'
     matches the empty string, but only at the beginning of a word.
     `\<' matches at the beginning of the buffer only if a
     word-constituent character follows.

`\>'
     matches the empty string, but only at the end of a word.  `\>'
     matches at the end of the buffer only if the contents end with a
     word-constituent character.

`\w'
     matches any word-constituent character.  The syntax table
     determines which characters these are.  *Note Syntax Tables:
     (elisp)Syntax Tables.

`\W'
     matches any character that is not a word-constituent.

`\_<'
     matches the empty string, but only at the beginning of a symbol.
     A symbol is a sequence of one or more symbol-constituent
     characters.  A symbol-constituent character is a character whose
     syntax is either `w' or `_'.  `\_<' matches at the beginning of the
     buffer only if a symbol-constituent character follows.

`\_>'
     matches the empty string, but only at the end of a symbol.  `\_>'
     matches at the end of the buffer only if the contents end with a
     symbol-constituent character.

`\sC'
     matches any character whose syntax is C.  Here C is a character
     that designates a particular syntax class: thus, `w' for word
     constituent, `-' or ` ' for whitespace, `.' for ordinary
     punctuation, etc.  *Note Syntax Tables: (elisp)Syntax Tables.

`\SC'
     matches any character whose syntax is not C.

`\cC'
     matches any character that belongs to the category C.  For
     example, `\cc' matches Chinese characters, `\cg' matches Greek
     characters, etc.  For the description of the known categories,
     type `M-x describe-categories <RET>'.

`\CC'
     matches any character that does _not_ belong to category C.

   The constructs that pertain to words and syntax are controlled by
the setting of the syntax table.  *Note Syntax Tables: (elisp)Syntax
Tables.


File: emacs,  Node: Regexp Example,  Next: Search Case,  Prev: Regexp Backslash,  Up: Search

15.7 Regular Expression Example
===============================

Here is an example of a regexp--similar to the regexp that Emacs uses,
by default, to recognize the end of a sentence, not including the
following space (i.e., the variable `sentence-end-base'):

     [.?!][]\"')}]*

This contains two parts in succession: a character set matching period,
`?', or `!', and a character set matching close-brackets, quotes, or
parentheses, repeated zero or more times.


File: emacs,  Node: Search Case,  Next: Replace,  Prev: Regexp Example,  Up: Search

15.8 Searching and Case
=======================

Searches in Emacs normally ignore the case of the text they are
searching through, if you specify the text in lower case.  Thus, if you
specify searching for `foo', then `Foo' and `foo' also match.  Regexps,
and in particular character sets, behave likewise: `[ab]' matches `a'
or `A' or `b' or `B'.

   An upper-case letter anywhere in the incremental search string makes
the search case-sensitive.  Thus, searching for `Foo' does not find
`foo' or `FOO'.  This applies to regular expression search as well as
to string search.  The effect ceases if you delete the upper-case
letter from the search string.

   Typing `M-c' within an incremental search toggles the case
sensitivity of that search.  The effect does not extend beyond the
current incremental search to the next one, but it does override the
effect of adding or removing an upper-case letter in the current search.

   If you set the variable `case-fold-search' to `nil', then all
letters must match exactly, including case.  This is a per-buffer
variable; altering the variable normally affects only the current
buffer, unless you change its default value.  *Note Locals::.  This
variable applies to nonincremental searches also, including those
performed by the replace commands (*note Replace::) and the minibuffer
history matching commands (*note Minibuffer History::).

   Several related variables control case-sensitivity of searching and
matching for specific commands or activities.  For instance,
`tags-case-fold-search' controls case sensitivity for `find-tag'.  To
find these variables, do `M-x apropos-variable <RET> case-fold-search
<RET>'.


File: emacs,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

15.9 Replacement Commands
=========================

Emacs provides several commands for performing search-and-replace
operations.  In addition to the simple `M-x replace-string' command,
there is `M-%' (`query-replace'), which presents each occurrence of the
pattern and asks you whether to replace it.

   The replace commands normally operate on the text from point to the
end of the buffer.  When the region is active, they operate on it
instead (*note Mark::).  The basic replace commands replace one "search
string" (or regexp) with one "replacement string".  It is possible to
perform several replacements in parallel, using the command
`expand-region-abbrevs' (*note Expanding Abbrevs::).

* Menu:

* Unconditional Replace::   Replacing all matches for a string.
* Regexp Replace::          Replacing all matches for a regexp.
* Replacement and Case::    How replacements preserve case of letters.
* Query Replace::           How to use querying.


File: emacs,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

15.9.1 Unconditional Replacement
--------------------------------

`M-x replace-string <RET> STRING <RET> NEWSTRING <RET>'
     Replace every occurrence of STRING with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement happens only in the text after point, so if you want to
cover the whole buffer you must go to the beginning first.  All
occurrences up to the end of the buffer are replaced; to limit
replacement to part of the buffer, activate the region around that
part.  When the region is active, replacement is limited to the region
(*note Mark::).

   When `replace-string' exits, it leaves point at the last occurrence
replaced.  It adds the prior position of point (where the
`replace-string' command was issued) to the mark ring, without
activating the mark; use `C-u C-<SPC>' to move back there.  *Note Mark
Ring::.

   A prefix argument restricts replacement to matches that are
surrounded by word boundaries.

   *Note Replacement and Case::, for details about case-sensitivity in
replace commands.


File: emacs,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

15.9.2 Regexp Replacement
-------------------------

The `M-x replace-string' command replaces exact matches for a single
string.  The similar command `M-x replace-regexp' replaces any match
for a specified pattern.

`M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace every match for REGEXP with NEWSTRING.

   In `replace-regexp', the NEWSTRING need not be constant: it can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire match being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the Dth
parenthesized grouping in REGEXP.  (This is called a "back reference".)
`\#' refers to the count of replacements already made in this command,
as a decimal number.  In the first replacement, `\#' stands for `0'; in
the second, for `1'; and so on.  For example,

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

replaces (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

performs the inverse transformation.  To include a `\' in the text to
replace with, you must enter `\\'.

   If you want to enter part of the replacement string by hand each
time, use `\?' in the replacement string.  Each replacement will ask
you to edit the replacement string in the minibuffer, putting point
where the `\?' was.

   The remainder of this subsection is intended for specialized tasks
and requires knowledge of Lisp.  Most readers can skip it.

   You can use Lisp expressions to calculate parts of the replacement
string.  To do this, write `\,' followed by the expression in the
replacement string.  Each replacement calculates the value of the
expression and converts it to text without quoting (if it's a string,
this means using the string's contents), and uses it in the replacement
string in place of the expression itself.  If the expression is a
symbol, one space in the replacement string after the symbol name goes
with the symbol name, so the value replaces them both.

   Inside such an expression, you can use some special sequences.  `\&'
and `\N' refer here, as usual, to the entire match as a string, and to
a submatch as a string.  N may be multiple digits, and the value of
`\N' is `nil' if subexpression N did not match.  You can also use `\#&'
and `\#N' to refer to those matches as numbers (this is valid when the
match or submatch has the form of a numeral).  `\#' here too stands for
the number of already-completed replacements.

   Repeating our example to exchange `x' and `y', we can thus do it
also this way:

     M-x replace-regexp <RET> \(x\)\|y <RET>
     \,(if \1 "y" "x") <RET>

   For computing replacement strings for `\,', the `format' function is
often useful (*note Formatting Strings: (elisp)Formatting Strings.).
For example, to add consecutively numbered strings like `ABC00042' to
columns 73 to 80 (unless they are already occupied), you can use

     M-x replace-regexp <RET> ^.\{0,72\}$ <RET>
     \,(format "%-72sABC%05d" \& \#) <RET>


File: emacs,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

15.9.3 Replace Commands and Case
--------------------------------

If the first argument of a replace command is all lower case, the
command ignores case while searching for occurrences to
replace--provided `case-fold-search' is non-`nil'.  If
`case-fold-search' is set to `nil', case is always significant in all
searches.

   In addition, when the NEWSTRING argument is all or partly lower
case, replacement commands try to preserve the case pattern of each
occurrence.  Thus, the command

     M-x replace-string <RET> foo <RET> bar <RET>

replaces a lower case `foo' with a lower case `bar', an all-caps `FOO'
with `BAR', and a capitalized `Foo' with `Bar'.  (These three
alternatives--lower case, all caps, and capitalized, are the only ones
that `replace-string' can distinguish.)

   If upper-case letters are used in the replacement string, they remain
upper case every time that text is inserted.  If upper-case letters are
used in the first argument, the second argument is always substituted
exactly as given, with no case conversion.  Likewise, if either
`case-replace' or `case-fold-search' is set to `nil', replacement is
done without case conversion.


File: emacs,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

15.9.4 Query Replace
--------------------

`M-% STRING <RET> NEWSTRING <RET>'
     Replace some occurrences of STRING with NEWSTRING.

`C-M-% REGEXP <RET> NEWSTRING <RET>'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, use `M-%' (`query-replace').  This command
finds occurrences of `foo' one by one, displays each occurrence and
asks you whether to replace it.  Aside from querying, `query-replace'
works just like `replace-string' (*note Unconditional Replace::).  In
particular, it preserves case provided `case-replace' is non-`nil', as
it normally is (*note Replacement and Case::).  A numeric argument
means to consider only occurrences that are bounded by word-delimiter
characters.

   `C-M-%' performs regexp search and replace (`query-replace-regexp').
It works like `replace-regexp' except that it queries like
`query-replace'.

   These commands highlight the current match using the face
`query-replace'.  They highlight other matches using `lazy-highlight'
just like incremental search (*note Incremental Search::).  By default,
`query-replace-regexp' will show the substituted replacement string for
the current match in the minibuffer.  If you want to keep special
sequences `\&' and `\N' unexpanded, customize
`query-replace-show-replacement' variable.

   The characters you can type when you are shown a match for the string
or regexp are:

`<SPC>'
     to replace the occurrence with NEWSTRING.

`<DEL>'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character to say what to do next.  Since
     the replacement has already been made, <DEL> and <SPC> are
     equivalent in this situation; both move to the next occurrence.

     You can type `C-r' at this point (see below) to alter the replaced
     text.  You can also type `C-x u' to undo the replacement; this
     exits the `query-replace', so if you want to do further
     replacement you must use `C-x <ESC> <ESC> <RET>' to restart (*note
     Repetition::).

`<RET>'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit without searching for more
     occurrences.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the position of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake or
     want to reexamine it.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' to proceed
     to the next occurrence.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in `C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with `C-M-c' to proceed to the next occurrence.

`e'
     to edit the replacement string in the minibuffer.  When you exit
     the minibuffer by typing <RET>, the minibuffer contents replace the
     current occurrence of the pattern.  They also become the new
     replacement string for any further occurrences.

`C-l'
     to redisplay the screen.  Then you must type another character to
     specify what to do with this occurrence.

`C-h'
     to display a message summarizing these options.  Then you must type
     another character to specify what to do with this occurrence.

   Some other characters are aliases for the ones listed above: `y',
`n' and `q' are equivalent to <SPC>, <DEL> and <RET>.

   Aside from this, any other character exits the `query-replace', and
is then reread as part of a key sequence.  Thus, if you type `C-k', it
exits the `query-replace' and then kills to end of line.

   To restart a `query-replace' once it is exited, use `C-x <ESC>
<ESC>', which repeats the `query-replace' because it used the
minibuffer to read its arguments.  *Note C-x ESC ESC: Repetition.

   *Note Operating on Files::, for the Dired `Q' command which performs
query replace on selected files.  See also *note Transforming File
Names::, for Dired commands to rename, copy, or link files by replacing
regexp matches in file names.


File: emacs,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

15.10 Other Search-and-Loop Commands
====================================

Here are some other commands that find matches for a regular
expression.  They all ignore case in matching, if the pattern contains
no upper-case letters and `case-fold-search' is non-`nil'.  Aside from
`occur' and its variants, all operate on the text from point to the end
of the buffer, or on the region if it is active.

`M-x multi-isearch-buffers'
     Prompt for one or more buffer names, ending with <RET>; then,
     begin a multi-buffer incremental search in those buffers.  (If the
     search fails in one buffer, the next `C-s' tries searching the
     next specified buffer, and so forth.)  With a prefix argument,
     prompt for a regexp and begin a multi-buffer incremental search in
     buffers matching that regexp.

`M-x multi-isearch-buffers-regexp'
     This command is just like `multi-isearch-buffers', except it
     performs an incremental regexp search.

`M-x occur'
     Prompt for a regexp, and display a list showing each line in the
     buffer that contains a match for it.  To limit the search to part
     of the buffer, narrow to that part (*note Narrowing::).  A numeric
     argument N specifies that N lines of context are to be displayed
     before and after each matching line.

     In the `*Occur*' buffer, you can click on each entry, or move
     point there and type <RET>, to visit the corresponding position in
     the buffer that was searched.  `o' and `C-o' display the match in
     another window; `C-o' does not select it.  Alternatively, you can
     use the `C-x `' (`next-error') command to visit the occurrences
     one by one (*note Compilation Mode::).

     Typing `e' in the `*Occur*' buffer switches to Occur Edit mode, in
     which edits made to the entries are also applied to the text in
     the originating buffer.  Type `C-c C-c' to return to Occur mode.

     The command `M-x list-matching-lines' is a synonym for `M-x occur'.

`M-s o'
     Run `occur' using the search string of the last incremental string
     search.  You can also run `M-s o' when an incremental search is
     active; this uses the current search string.

`M-x multi-occur'
     This command is just like `occur', except it is able to search
     through multiple buffers.  It asks you to specify the buffer names
     one by one.

`M-x multi-occur-in-matching-buffers'
     This command is similar to `multi-occur', except the buffers to
     search are specified by a regular expression that matches visited
     file names.  With a prefix argument, it uses the regular
     expression to match buffer names instead.

`M-x how-many'
     Prompt for a regexp, and print the number of matches for it in the
     buffer after point.  If the region is active, this operates on the
     region instead.

`M-x flush-lines'
     Prompt for a regexp, and delete each line that contains a match for
     it, operating on the text after point.  This command deletes the
     current line if it contains a match starting after point.  If the
     region is active, it operates on the region instead; if a line
     partially contained in the region contains a match entirely
     contained in the region, it is deleted.

     If a match is split across lines, `flush-lines' deletes all those
     lines.  It deletes the lines before starting to look for the next
     match; hence, it ignores a match starting on the same line at which
     another match ended.

`M-x keep-lines'
     Prompt for a regexp, and delete each line that _does not_ contain
     a match for it, operating on the text after point.  If point is
     not at the beginning of a line, this command always keeps the
     current line.  If the region is active, the command operates on
     the region instead; it never deletes lines that are only partially
     contained in the region (a newline that ends a line counts as part
     of that line).

     If a match is split across lines, this command keeps all those
     lines.


File: emacs,  Node: Fixit,  Next: Keyboard Macros,  Prev: Search,  Up: Top

16 Commands for Fixing Typos
****************************

In this chapter we describe commands that are useful when you catch a
mistake while editing.  The most fundamental of these commands is the
undo command `C-/' (also bound to `C-x u' and `C-_').  This undoes a
single command, or a part of a command (as in the case of
`query-replace'), or several consecutive character insertions.
Consecutive repetitions of `C-/' undo earlier and earlier changes, back
to the limit of the undo information available.

   Aside from the commands described here, you can erase text using
deletion commands such as <DEL> (`delete-backward-char').  These were
described earlier in this manual.  *Note Erasing::.

* Menu:

* Undo::        The Undo commands.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: emacs,  Node: Undo,  Next: Transpose,  Up: Fixit

16.1 Undo
=========

The "undo" command reverses recent changes in the buffer's text.  Each
buffer records changes individually, and the undo command always
applies to the current buffer.  You can undo all the changes in a
buffer for as far as back its records go.  Usually, each editing
command makes a separate entry in the undo records, but some commands
such as `query-replace' divide their changes into multiple entries for
flexibility in undoing.  Consecutive character insertion commands are
usually grouped together into a single undo record, to make undoing
less tedious.

`C-/'
`C-x u'
`C-_'
     Undo one entry in the current buffer's undo records (`undo').

   To begin to undo, type `C-/' (or its aliases, `C-_' or `C-x u')(1).
This undoes the most recent change in the buffer, and moves point back
to where it was before that change.    Consecutive repetitions of `C-/'
(or its aliases) undo earlier and earlier changes in the current
buffer.  If all the recorded changes have already been undone, the undo
command signals an error.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting from that moment, the entire sequence of undo
commands that you have just performed are themselves placed into the
undo record, as a single set of changes.  Therefore, to re-apply
changes you have undone, type `C-f' or any other command that
harmlessly breaks the sequence of undoing; then type `C-/' to undo the
undo command.

   Alternatively, if you want to resume undoing, without redoing
previous undo commands, use `M-x undo-only'.  This is like `undo', but
will not redo changes you have just undone.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-/' repeatedly until the stars
disappear from the front of the mode line (*note Mode Line::).
Whenever an undo command makes the stars disappear from the mode line,
it means that the buffer contents are the same as they were when the
file was last read in or saved.  If you do not remember whether you
changed the buffer deliberately, type `C-/' once.  When you see the
last change you made undone, you will see whether it was an intentional
change.  If it was an accident, leave it undone.  If it was deliberate,
redo the change as described above.

   When there is an active region, any use of `undo' performs
"selective undo": it undoes the most recent change within the region,
instead of the entire buffer.  However, when Transient Mark mode is off
(*note Disabled Transient Mark::), `C-/' always operates on the entire
buffer, ignoring the region.  In this case, you can perform selective
undo by supplying a prefix argument to the `undo' command: `C-u C-/'.
To undo further changes in the same region, repeat the `undo' command
(no prefix argument is needed).

   Some specialized buffers do not make undo records.  Buffers whose
names start with spaces never do; these buffers are used internally by
Emacs to hold text that users don't normally look at or edit.

   When the undo records for a buffer becomes too large, Emacs discards
the oldest undo records from time to time (during "garbage
collection").  You can specify how much undo records to keep by setting
the variables `undo-limit', `undo-strong-limit', and
`undo-outer-limit'.  Their values are expressed in bytes.

   The variable `undo-limit' sets a soft limit: Emacs keeps undo data
for enough commands to reach this size, and perhaps exceed it, but does
not keep data for any earlier commands beyond that.  Its default value
is 80000.  The variable `undo-strong-limit' sets a stricter limit: any
previous command (though not the most recent one) that pushes the size
past this amount is forgotten.  The default value of
`undo-strong-limit' is 120000.

   Regardless of the values of those variables, the most recent change
is never discarded unless it gets bigger than `undo-outer-limit'
(normally 12,000,000).  At that point, Emacs discards the undo data and
warns you about it.  This is the only situation in which you cannot
undo the last command.  If this happens, you can increase the value of
`undo-outer-limit' to make it even less likely to happen in the future.
But if you didn't expect the command to create such large undo data,
then it is probably a bug and you should report it.  *Note Reporting
Bugs: Bugs.

   ---------- Footnotes ----------

   (1) Aside from `C-/', the `undo' command is also bound to `C-x u'
because that is more straightforward for beginners to remember: `u'
stands for "undo".  It is also bound to `C-_' because typing `C-/' on
some text terminals actually enters `C-_'.


File: emacs,  Node: Transpose,  Next: Fixing Case,  Prev: Undo,  Up: Fixit

16.2 Transposing Text
=====================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two characters can be fixed, when
they are adjacent, with the `C-t' command (`transpose-chars').
Normally, `C-t' transposes the two characters on either side of point.
When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, `C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a `C-t'.  If
you don't catch it so fast, you must move the cursor back between the
two transposed characters before you type `C-t'.  If you transposed a
space with the last character of the word before it, the word motion
commands are a good way of getting there.  Otherwise, a reverse search
(`C-r') is often the best way.  *Note Search::.

   `M-t' transposes the word before point with the word after point
(`transpose-words').  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, `FOO, BAR'
transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing two
expressions (*note Expressions::), and `C-x C-t' (`transpose-lines')
exchanges lines.  They work like `M-t' except as regards what units of
text they transpose.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, expression,
line) before or containing point across several other characters (words,
expressions, lines).  For example, `C-u 3 C-t' moves the character
before point forward across three other characters.  It would change
`f-!-oobar' into `oobf-!-ar'.  This is equivalent to repeating `C-t'
three times.  `C-u - 4 M-t' moves the word before point backward across
four words.  `C-u - C-M-t' would cancel the effect of plain `C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (word, expression, line) ending after point
with the one ending after the mark.


File: emacs,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

16.3 Case Conversion
====================

`M-- M-l'
     Convert last word to lower case.  Note `Meta--' is Meta-minus.

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands `M-l', `M-u' and `M-c' have a
special feature when used with a negative argument: they do not move the
cursor.  As soon as you see you have mistyped the last word, you can
simply case-convert it and go on typing.  *Note Case::.


File: emacs,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

16.4 Checking and Correcting Spelling
=====================================

This section describes the commands to check the spelling of a single
word or of a portion of a buffer.  These commands only work if the
spelling checker program Aspell, Ispell or Hunspell is installed.
These programs are not part of Emacs, but one of them is usually
installed in GNU/Linux and other free operating systems.  *Note Aspell:
(aspell)Top.

`M-$'
     Check and correct spelling of the word at point (`ispell-word').
     If the region is active, do it for all words in the region instead.

`M-x ispell'
     Check and correct spelling of all words in the buffer.  If the
     region is active, do it for all words in the region instead.

`M-x ispell-buffer'
     Check and correct spelling in the buffer.

`M-x ispell-region'
     Check and correct spelling in the region.

`M-x ispell-message'
     Check and correct spelling in a draft mail message, excluding cited
     material.

`M-x ispell-change-dictionary <RET> DICT <RET>'
     Restart the Aspell/Ispell/Hunspell process, using DICT as the
     dictionary.

`M-x ispell-kill-ispell'
     Kill the Aspell/Ispell/Hunspell subprocess.

`M-<TAB>'
`<ESC> <TAB>'
     Complete the word before point based on the spelling dictionary
     (`ispell-complete-word').

`M-x flyspell-mode'
     Enable Flyspell mode, which highlights all misspelled words.

`M-x flyspell-prog-mode'
     Enable Flyspell mode for comments and strings only.

   To check the spelling of the word around or before point, and
optionally correct it as well, type `M-$' (`ispell-word').  If a region
is active, `M-$' checks the spelling of all words within the region.
*Note Mark::.  (When Transient Mark mode is off, `M-$' always acts on
the word around or before point, ignoring the region; *note Disabled
Transient Mark::.)

   Similarly, the command `M-x ispell' performs spell-checking in the
region if one is active, or in the entire buffer otherwise.  The
commands `M-x ispell-buffer' and `M-x ispell-region' explicitly perform
spell-checking on the entire buffer or the region respectively.  To
check spelling in an email message you are writing, use `M-x
ispell-message'; that command checks the whole buffer, except for
material that is indented or appears to be cited from other messages.
*Note Sending Mail::.

   When one of these commands encounters what appears to be an
incorrect word, it asks you what to do.  It usually displays a list of
numbered "near-misses"--words that are close to the incorrect word.
Then you must type a single-character response.  Here are the valid
responses:

`DIGIT'
     Replace the word, just this time, with one of the displayed
     near-misses.  Each near-miss is listed with a digit; type that
     digit to select it.

`<SPC>'
     Skip this word--continue to consider it incorrect, but don't
     change it here.

`r NEW <RET>'
     Replace the word, just this time, with NEW.  (The replacement
     string will be rescanned for more spelling errors.)

`R NEW <RET>'
     Replace the word with NEW, and do a `query-replace' so you can
     replace it elsewhere in the buffer if you wish.  (The replacements
     will be rescanned for more spelling errors.)

`a'
     Accept the incorrect word--treat it as correct, but only in this
     editing session.

`A'
     Accept the incorrect word--treat it as correct, but only in this
     editing session and for this buffer.

`i'
     Insert this word in your private dictionary file so that Aspell or
     Ispell or Hunspell will consider it correct from now on, even in
     future sessions.

`m'
     Like `i', but you can also specify dictionary completion
     information.

`u'
     Insert the lower-case version of this word in your private
     dictionary file.

`l WORD <RET>'
     Look in the dictionary for words that match WORD.  These words
     become the new list of "near-misses"; you can select one of them as
     the replacement by typing a digit.  You can use `*' in WORD as a
     wildcard.

`C-g'
`X'
     Quit interactive spell checking, leaving point at the word that was
     being checked.  You can restart checking again afterward with `C-u
     M-$'.

`x'
     Quit interactive spell checking and move point back to where it was
     when you started spell checking.

`q'
     Quit interactive spell checking and kill the spell-checker
     subprocess.

`?'
     Show the list of options.

   In Text mode and related modes, `M-<TAB>' (`ispell-complete-word')
performs in-buffer completion based on spelling correction.  Insert the
beginning of a word, and then type `M-<TAB>'; this shows a list of
completions.  (If your window manager intercepts `M-<TAB>', type `<ESC>
<TAB>' or `C-M-i'.)  Each completion is listed with a digit or
character; type that digit or character to choose it.

   Once started, the Aspell or Ispell or Hunspell subprocess continues
to run, waiting for something to do, so that subsequent spell checking
commands complete more quickly.  If you want to get rid of the process,
use `M-x ispell-kill-ispell'.  This is not usually necessary, since the
process uses no processor time except when you do spelling correction.

   Ispell, Aspell and Hunspell look up spelling in two dictionaries:
the standard dictionary and your personal dictionary.  The standard
dictionary is specified by the variable `ispell-local-dictionary' or,
if that is `nil', by the variable `ispell-dictionary'.  If both are
`nil', the spelling program's default dictionary is used.  The command
`M-x ispell-change-dictionary' sets the standard dictionary for the
buffer and then restarts the subprocess, so that it will use a
different standard dictionary.  Your personal dictionary is specified
by the variable `ispell-personal-dictionary'.  If that is `nil', the
spelling program looks for a personal dictionary in a default location.

   A separate dictionary is used for word completion.  The variable
`ispell-complete-word-dict' specifies the file name of this dictionary.
The completion dictionary must be different because it cannot use root
and affix information.  For some languages, there is a spell checking
dictionary but no word completion dictionary.

   Flyspell mode is a minor mode that performs automatic spell checking
as you type.  When it finds a word that it does not recognize, it
highlights that word.  Type `M-x flyspell-mode' to toggle Flyspell mode
in the current buffer.  To enable Flyspell mode in all text mode
buffers, add `flyspell-mode' to `text-mode-hook'.  *Note Hooks::.

   When Flyspell mode highlights a word as misspelled, you can click on
it with `Mouse-2' to display a menu of possible corrections and
actions.  You can also correct the word by editing it manually in any
way you like.

   Flyspell Prog mode works just like ordinary Flyspell mode, except
that it only checks words in comments and string constants.  This
feature is useful for editing programs.  Type `M-x flyspell-prog-mode'
to enable or disable this mode in the current buffer.  To enable this
mode in all programming mode buffers, add `flyspell-prog-mode' to
`prog-mode-hook' (*note Hooks::).


File: emacs,  Node: Keyboard Macros,  Next: Files,  Prev: Fixit,  Up: Top

17 Keyboard Macros
******************

In this chapter we describe how to record a sequence of editing
commands so you can repeat it conveniently later.

   A "keyboard macro" is a command defined by an Emacs user to stand for
another sequence of keys.  For example, if you discover that you are
about to type `C-n M-d C-d' forty times, you can speed your work by
defining a keyboard macro to do `C-n M-d C-d', and then executing it 39
more times.

   You define a keyboard macro by executing and recording the commands
which are its definition.  Put differently, as you define a keyboard
macro, the definition is being executed for the first time.  This way,
you can see the effects of your commands, so that you don't have to
figure them out in your head.  When you close the definition, the
keyboard macro is defined and also has been, in effect, executed once.
You can then do the whole thing over again by invoking the macro.

   Keyboard macros differ from ordinary Emacs commands in that they are
written in the Emacs command language rather than in Lisp.  This makes
it easier for the novice to write them, and makes them more convenient
as temporary hacks.  However, the Emacs command language is not powerful
enough as a programming language to be useful for writing anything
intelligent or general.  For such things, Lisp must be used.

* Menu:

* Basic Keyboard Macro::     Defining and running keyboard macros.
* Keyboard Macro Ring::      Where previous keyboard macros are saved.
* Keyboard Macro Counter::   Inserting incrementing numbers in macros.
* Keyboard Macro Query::     Making keyboard macros do different things each
                               time.
* Save Keyboard Macro::      Giving keyboard macros names; saving them in
                               files.
* Edit Keyboard Macro::      Editing keyboard macros.
* Keyboard Macro Step-Edit:: Interactively executing and editing a keyboard
                               macro.


File: emacs,  Node: Basic Keyboard Macro,  Next: Keyboard Macro Ring,  Up: Keyboard Macros

17.1 Basic Use
==============

`<F3>'
     Start defining a keyboard macro
     (`kmacro-start-macro-or-insert-counter').

`<F4>'
     If a keyboard macro is being defined, end the definition;
     otherwise, execute the most recent keyboard macro
     (`kmacro-end-or-call-macro').

`C-u <F3>'
     Re-execute last keyboard macro, then append keys to its definition.

`C-u C-u <F3>'
     Append keys to the last keyboard macro without re-executing it.

`C-x C-k r'
     Run the last keyboard macro on each line that begins in the region
     (`apply-macro-to-region-lines').

   To start defining a keyboard macro, type <F3>.  From then on, your
keys continue to be executed, but also become part of the definition of
the macro.  `Def' appears in the mode line to remind you of what is
going on.  When you are finished, type <F4>
(`kmacro-end-or-call-macro') to terminate the definition.  For example,

     <F3> M-f foo <F4>

defines a macro to move forward a word and then insert `foo'.  Note
that <F3> and <F4> do not become part of the macro.

   After defining the macro, you can call it with <F4>.  For the above
example, this has the same effect as typing `M-f foo' again.  (Note the
two roles of the <F4> command: it ends the macro if you are in the
process of defining one, or calls the last macro otherwise.)  You can
also supply <F4> with a numeric prefix argument `n', which means to
invoke the macro `n' times.  An argument of zero repeats the macro
indefinitely, until it gets an error or you type `C-g' (or, on MS-DOS,
`C-<BREAK>').

   The above example demonstrates a handy trick that you can employ
with keyboard macros: if you wish to repeat an operation at regularly
spaced places in the text, include a motion command as part of the
macro.  In this case, repeating the macro inserts the string `foo'
after each successive word.

   After terminating the definition of a keyboard macro, you can append
more keystrokes to its definition by typing `C-u <F3>'.  This is
equivalent to plain <F3> followed by retyping the whole definition so
far.  As a consequence, it re-executes the macro as previously defined.
If you change the variable `kmacro-execute-before-append' to `nil', the
existing macro will not be re-executed before appending to it (the
default is `t').  You can also add to the end of the definition of the
last keyboard macro without re-executing it by typing `C-u C-u <F3>'.

   When a command reads an argument with the minibuffer, your
minibuffer input becomes part of the macro along with the command.  So
when you replay the macro, the command gets the same argument as when
you entered the macro.  For example,

     <F3> C-a C-k C-x b foo <RET> C-y C-x b <RET> <F4>

defines a macro that kills the current line, yanks it into the buffer
`foo', then returns to the original buffer.

   Most keyboard commands work as usual in a keyboard macro definition,
with some exceptions.  Typing `C-g' (`keyboard-quit') quits the
keyboard macro definition.  Typing `C-M-c' (`exit-recursive-edit') can
be unreliable: it works as you'd expect if exiting a recursive edit
that started within the macro, but if it exits a recursive edit that
started before you invoked the keyboard macro, it also necessarily
exits the keyboard macro too.  Mouse events are also unreliable, even
though you can use them in a keyboard macro: when the macro replays the
mouse event, it uses the original mouse position of that event, the
position that the mouse had while you were defining the macro.  The
effect of this may be hard to predict.

   The command `C-x C-k r' (`apply-macro-to-region-lines') repeats the
last defined keyboard macro on each line that begins in the region.  It
does this line by line, by moving point to the beginning of the line
and then executing the macro.

   In addition to the <F3> and <F4> commands described above, Emacs
also supports an older set of key bindings for defining and executing
keyboard macros.  To begin a macro definition, type `C-x ('
(`kmacro-start-macro'); as with <F3>, a prefix argument appends this
definition to the last keyboard macro.  To end a macro definition, type
`C-x )' (`kmacro-end-macro').  To execute the most recent macro, type
`C-x e' (`kmacro-end-and-call-macro').  If you enter `C-x e' while
defining a macro, the macro is terminated and executed immediately.
Immediately after typing `C-x e', you can type <e> repeatedly to
immediately repeat the macro one or more times.  You can also give `C-x
e' a repeat argument, just like <F4>.

   `C-x )' can be given a repeat count as an argument.  This means to
repeat the macro right after defining it.  The macro definition itself
counts as the first repetition, since it is executed as you define it,
so `C-u 4 C-x )' executes the macro immediately 3 additional times.


File: emacs,  Node: Keyboard Macro Ring,  Next: Keyboard Macro Counter,  Prev: Basic Keyboard Macro,  Up: Keyboard Macros

17.2 The Keyboard Macro Ring
============================

All defined keyboard macros are recorded in the "keyboard macro ring".
There is only one keyboard macro ring, shared by all buffers.

`C-x C-k C-k'
     Execute the keyboard macro at the head of the ring
     (`kmacro-end-or-call-macro-repeat').

`C-x C-k C-n'
     Rotate the keyboard macro ring to the next macro (defined earlier)
     (`kmacro-cycle-ring-next').

`C-x C-k C-p'
     Rotate the keyboard macro ring to the previous macro (defined
     later) (`kmacro-cycle-ring-previous').

   All commands which operate on the keyboard macro ring use the same
`C-x C-k' prefix.  Most of these commands can be executed and repeated
immediately after each other without repeating the `C-x C-k' prefix.
For example,

     C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d

will rotate the keyboard macro ring to the "second previous" macro,
execute the resulting head macro three times, rotate back to the
original head macro, execute that once, rotate to the "previous" macro,
execute that, and finally delete it from the macro ring.

   The command `C-x C-k C-k' (`kmacro-end-or-call-macro-repeat')
executes the keyboard macro at the head of the macro ring.  You can
repeat the macro immediately by typing another `C-k', or you can rotate
the macro ring immediately by typing `C-n' or `C-p'.

   When a keyboard macro is being defined, `C-x C-k C-k' behaves like
<F4> except that, immediately afterward, you can use most key bindings
of this section without the `C-x C-k' prefix.  For instance, another
`C-k' will re-execute the macro.

   The commands `C-x C-k C-n' (`kmacro-cycle-ring-next') and `C-x C-k
C-p' (`kmacro-cycle-ring-previous') rotate the macro ring, bringing the
next or previous keyboard macro to the head of the macro ring.  The
definition of the new head macro is displayed in the echo area.  You
can continue to rotate the macro ring immediately by repeating just
`C-n' and `C-p' until the desired macro is at the head of the ring.  To
execute the new macro ring head immediately, just type `C-k'.

   Note that Emacs treats the head of the macro ring as the "last
defined keyboard macro".  For instance, <F4> will execute that macro,
and `C-x C-k n' will give it a name.

   The maximum number of macros stored in the keyboard macro ring is
determined by the customizable variable `kmacro-ring-max'.


File: emacs,  Node: Keyboard Macro Counter,  Next: Keyboard Macro Query,  Prev: Keyboard Macro Ring,  Up: Keyboard Macros

17.3 The Keyboard Macro Counter
===============================

Each keyboard macro has an associated counter, which is initialized to
0 when you start defining the macro.  This counter allows you to insert
a number into the buffer that depends on the number of times the macro
has been called.  The counter is incremented each time its value is
inserted into the buffer.

`<F3>'
     In a keyboard macro definition, insert the keyboard macro counter
     value in the buffer (`kmacro-start-macro-or-insert-counter').

`C-x C-k C-i'
     Insert the keyboard macro counter value in the buffer
     (`kmacro-insert-counter').

`C-x C-k C-c'
     Set the keyboard macro counter (`kmacro-set-counter').

`C-x C-k C-a'
     Add the prefix arg to the keyboard macro counter
     (`kmacro-add-counter').

`C-x C-k C-f'
     Specify the format for inserting the keyboard macro counter
     (`kmacro-set-format').

   When you are defining a keyboard macro, the command <F3>
(`kmacro-start-macro-or-insert-counter') inserts the current value of
the keyboard macro's counter into the buffer, and increments the
counter by 1.  (If you are not defining a macro, <F3> begins a macro
definition instead.  *Note Basic Keyboard Macro::.)  You can use a
numeric prefix argument to specify a different increment.  If you just
specify a `C-u' prefix, that is the same as an increment of zero: it
inserts the current counter value without changing it.

   As an example, let us show how the keyboard macro counter can be
used to build a numbered list.  Consider the following key sequence:

     <F3> C-a <F3> . <SPC> <F4>

As part of this keyboard macro definition, the string `0. ' was
inserted into the beginning of the current line.  If you now move
somewhere else in the buffer and type <F4> to invoke the macro, the
string `1. ' is inserted at the beginning of that line.  Subsequent
invocations insert `2. ', `3. ', and so forth.

   The command `C-x C-k C-i' (`kmacro-insert-counter') does the same
thing as <F3>, but it can be used outside a keyboard macro definition.
When no keyboard macro is being defined or executed, it inserts and
increments the counter of the macro at the head of the keyboard macro
ring.

   The command `C-x C-k C-c' (`kmacro-set-counter') sets the current
macro counter to the value of the numeric argument.  If you use it
inside the macro, it operates on each repetition of the macro.  If you
specify just `C-u' as the prefix, while executing the macro, that
resets the counter to the value it had at the beginning of the current
repetition of the macro (undoing any increments so far in this
repetition).

   The command `C-x C-k C-a' (`kmacro-add-counter') adds the prefix
argument to the current macro counter.  With just `C-u' as argument, it
resets the counter to the last value inserted by any keyboard macro.
(Normally, when you use this, the last insertion will be in the same
macro and it will be the same counter.)

   The command `C-x C-k C-f' (`kmacro-set-format') prompts for the
format to use when inserting the macro counter.  The default format is
`%d', which means to insert the number in decimal without any padding.
You can exit with empty minibuffer to reset the format to this default.
You can specify any format string that the `format' function accepts
and that makes sense with a single integer extra argument (*note
Formatting Strings: (elisp)Formatting Strings.).  Do not put the format
string inside double quotes when you insert it in the minibuffer.

   If you use this command while no keyboard macro is being defined or
executed, the new format affects all subsequent macro definitions.
Existing macros continue to use the format in effect when they were
defined.  If you set the format while defining a keyboard macro, this
affects the macro being defined from that point on, but it does not
affect subsequent macros.  Execution of the macro will, at each step,
use the format in effect at that step during its definition.  Changes
to the macro format during execution of a macro, like the corresponding
changes during its definition, have no effect on subsequent macros.

   The format set by `C-x C-k C-f' does not affect insertion of numbers
stored in registers.

   If you use a register as a counter, incrementing it on each
repetition of the macro, that accomplishes the same thing as a keyboard
macro counter.  *Note Number Registers::.  For most purposes, it is
simpler to use a keyboard macro counter.


File: emacs,  Node: Keyboard Macro Query,  Next: Save Keyboard Macro,  Prev: Keyboard Macro Counter,  Up: Keyboard Macros

17.4 Executing Macros with Variations
=====================================

In a keyboard macro, you can create an effect similar to that of
`query-replace', in that the macro asks you each time around whether to
make a change.

`C-x q'
     When this point is reached during macro execution, ask for
     confirmation (`kbd-macro-query').

   While defining the macro, type `C-x q' at the point where you want
the query to occur.  During macro definition, the `C-x q' does nothing,
but when you run the macro later, `C-x q' asks you interactively
whether to continue.

   The valid responses when `C-x q' asks are:

<SPC> (or `y')
     Continue executing the keyboard macro.

<DEL> (or `n')
     Skip the remainder of this repetition of the macro, and start right
     away with the next repetition.

<RET> (or `q')
     Skip the remainder of this repetition and cancel further
     repetitions.

`C-r'
     Enter a recursive editing level, in which you can perform editing
     which is not part of the macro.  When you exit the recursive edit
     using `C-M-c', you are asked again how to continue with the
     keyboard macro.  If you type a <SPC> at this time, the rest of the
     macro definition is executed.  It is up to you to leave point and
     the text in a state such that the rest of the macro will do what
     you want.

   `C-u C-x q', which is `C-x q' with a numeric argument, performs a
completely different function.  It enters a recursive edit reading
input from the keyboard, both when you type it during the definition of
the macro, and when it is executed from the macro.  During definition,
the editing you do inside the recursive edit does not become part of
the macro.  During macro execution, the recursive edit gives you a
chance to do some particularized editing on each repetition.  *Note
Recursive Edit::.


File: emacs,  Node: Save Keyboard Macro,  Next: Edit Keyboard Macro,  Prev: Keyboard Macro Query,  Up: Keyboard Macros

17.5 Naming and Saving Keyboard Macros
======================================

`C-x C-k n'
     Give a command name (for the duration of the Emacs session) to the
     most recently defined keyboard macro (`kmacro-name-last-macro').

`C-x C-k b'
     Bind the most recently defined keyboard macro to a key sequence
     (for the duration of the session) (`kmacro-bind-to-key').

`M-x insert-kbd-macro'
     Insert in the buffer a keyboard macro's definition, as Lisp code.

   If you wish to save a keyboard macro for later use, you can give it
a name using `C-x C-k n' (`kmacro-name-last-macro').  This reads a name
as an argument using the minibuffer and defines that name to execute
the last keyboard macro, in its current form.  (If you later add to the
definition of this macro, that does not alter the name's definition as
a macro.)  The macro name is a Lisp symbol, and defining it in this way
makes it a valid command name for calling with `M-x' or for binding a
key to with `global-set-key' (*note Keymaps::).  If you specify a name
that has a prior definition other than a keyboard macro, an error
message is shown and nothing is changed.

   You can also bind the last keyboard macro (in its current form) to a
key, using `C-x C-k b' (`kmacro-bind-to-key') followed by the key
sequence you want to bind.  You can bind to any key sequence in the
global keymap, but since most key sequences already have other
bindings, you should select the key sequence carefully.  If you try to
bind to a key sequence with an existing binding (in any keymap), this
command asks you for confirmation before replacing the existing binding.

   To avoid problems caused by overriding existing bindings, the key
sequences `C-x C-k 0' through `C-x C-k 9' and `C-x C-k A' through `C-x
C-k Z' are reserved for your own keyboard macro bindings.  In fact, to
bind to one of these key sequences, you only need to type the digit or
letter rather than the whole key sequences.  For example,

     C-x C-k b 4

will bind the last keyboard macro to the key sequence `C-x C-k 4'.

   Once a macro has a command name, you can save its definition in a
file.  Then it can be used in another editing session.  First, visit
the file you want to save the definition in.  Then use this command:

     M-x insert-kbd-macro <RET> MACRONAME <RET>

This inserts some Lisp code that, when executed later, will define the
same macro with the same definition it has now.  (You need not
understand Lisp code to do this, because `insert-kbd-macro' writes the
Lisp code for you.)  Then save the file.  You can load the file later
with `load-file' (*note Lisp Libraries::).  If the file you save in is
your init file `~/.emacs' (*note Init File::) then the macro will be
defined each time you run Emacs.

   If you give `insert-kbd-macro' a numeric argument, it makes
additional Lisp code to record the keys (if any) that you have bound to
MACRONAME, so that the macro will be reassigned the same keys when you
load the file.


File: emacs,  Node: Edit Keyboard Macro,  Next: Keyboard Macro Step-Edit,  Prev: Save Keyboard Macro,  Up: Keyboard Macros

17.6 Editing a Keyboard Macro
=============================

`C-x C-k C-e'
     Edit the last defined keyboard macro (`kmacro-edit-macro').

`C-x C-k e NAME <RET>'
     Edit a previously defined keyboard macro NAME (`edit-kbd-macro').

`C-x C-k l'
     Edit the last 300 keystrokes as a keyboard macro
     (`kmacro-edit-lossage').

   You can edit the last keyboard macro by typing `C-x C-k C-e' or `C-x
C-k RET' (`kmacro-edit-macro').  This formats the macro definition in a
buffer and enters a specialized major mode for editing it.  Type `C-h
m' once in that buffer to display details of how to edit the macro.
When you are finished editing, type `C-c C-c'.

   You can edit a named keyboard macro or a macro bound to a key by
typing `C-x C-k e' (`edit-kbd-macro').  Follow that with the keyboard
input that you would use to invoke the macro--`C-x e' or `M-x NAME' or
some other key sequence.

   You can edit the last 300 keystrokes as a macro by typing `C-x C-k
l' (`kmacro-edit-lossage').


File: emacs,  Node: Keyboard Macro Step-Edit,  Prev: Edit Keyboard Macro,  Up: Keyboard Macros

17.7 Stepwise Editing a Keyboard Macro
======================================

You can interactively replay and edit the last keyboard macro, one
command at a time, by typing `C-x C-k SPC' (`kmacro-step-edit-macro').
Unless you quit the macro using `q' or `C-g', the edited macro replaces
the last macro on the macro ring.

   This macro editing feature shows the last macro in the minibuffer
together with the first (or next) command to be executed, and prompts
you for an action.  You can enter `?' to get a summary of your options.
These actions are available:

   * `SPC' and `y' execute the current command, and advance to the next
     command in the keyboard macro.

   * `n', `d', and `DEL' skip and delete the current command.

   * `f' skips the current command in this execution of the keyboard
     macro, but doesn't delete it from the macro.

   * `<TAB>' executes the current command, as well as all similar
     commands immediately following the current command; for example,
     <TAB> may be used to insert a sequence of characters
     (corresponding to a sequence of `self-insert-command' commands).

   * `c' continues execution (without further editing) until the end of
     the keyboard macro.  If execution terminates normally, the edited
     macro replaces the original keyboard macro.

   * `C-k' skips and deletes the rest of the keyboard macro, terminates
     step-editing, and replaces the original keyboard macro with the
     edited macro.

   * `q' and `C-g' cancels the step-editing of the keyboard macro;
     discarding any changes made to the keyboard macro.

   * `i KEY... C-j' reads and executes a series of key sequences (not
     including the final `C-j'), and inserts them before the current
     command in the keyboard macro, without advancing over the current
     command.

   * `I KEY...' reads one key sequence, executes it, and inserts it
     before the current command in the keyboard macro, without advancing
     over the current command.

   * `r KEY... C-j' reads and executes a series of key sequences (not
     including the final `C-j'), and replaces the current command in
     the keyboard macro with them, advancing over the inserted key
     sequences.

   * `R KEY...' reads one key sequence, executes it, and replaces the
     current command in the keyboard macro with that key sequence,
     advancing over the inserted key sequence.

   * `a KEY... C-j' executes the current command, then reads and
     executes a series of key sequences (not including the final
     `C-j'), and inserts them after the current command in the keyboard
     macro; it then advances over the current command and the inserted
     key sequences.

   * `A KEY... C-j' executes the rest of the commands in the keyboard
     macro, then reads and executes a series of key sequences (not
     including the final `C-j'), and appends them at the end of the
     keyboard macro; it then terminates the step-editing and replaces
     the original keyboard macro with the edited macro.


File: emacs,  Node: Files,  Next: Buffers,  Prev: Keyboard Macros,  Up: Top

18 File Handling
****************

The operating system stores data permanently in named "files", so most
of the text you edit with Emacs comes from a file and is ultimately
stored in a file.

   To edit a file, you must tell Emacs to read the file and prepare a
buffer containing a copy of the file's text.  This is called "visiting"
the file.  Editing commands apply directly to text in the buffer; that
is, to the copy inside Emacs.  Your changes appear in the file itself
only when you "save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, keep multiple versions of them, and operate
on file directories.

* Menu:

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.

* Autorevert::          Auto Reverting non-file buffers.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Diff Mode::           Mode for editing file differences.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* File Archives::       Operating on tar, zip, jar etc. archive files.
* Remote Files::        Accessing files on other machines.
* Quoted File Names::   Quoting special characters in file names.
* File Name Cache::     Completion against a list of files you often use.
* File Conveniences::   Convenience Features for Finding Files.
* Filesets::            Handling sets of files.


File: emacs,  Node: File Names,  Next: Visiting,  Up: Files

18.1 File Names
===============

Many Emacs commands that operate on a file require you to specify the
file name, using the minibuffer (*note Minibuffer File::).

   While in the minibuffer, you can use the usual completion and
history commands (*note Minibuffer::).  Note that file name completion
ignores file names whose extensions appear in the variable
`completion-ignored-extensions' (*note Completion Options::).  Note
also that most commands use "permissive completion with confirmation"
for reading file names: you are allowed to submit a nonexistent file
name, but if you type <RET> immediately after completing up to a
nonexistent file name, Emacs prints `[Confirm]' and you must type a
second <RET> to confirm.  *Note Completion Exit::, for details.

   Each buffer has a "default directory", stored in the buffer-local
variable `default-directory'.  Whenever Emacs reads a file name using
the minibuffer, it usually inserts the default directory into the
minibuffer as the initial contents.  You can inhibit this insertion by
changing the variable `insert-default-directory' to `nil' (*note
Minibuffer File::).  Regardless, Emacs always assumes that any relative
file name is relative to the default directory, e.g. entering a file
name without a directory specifies a file in the default directory.

   When you visit a file, Emacs sets `default-directory' in the
visiting buffer to the directory of its file.  When you create a new
buffer that is not visiting a file, via a command like `C-x b', its
default directory is usually copied from the buffer that was current at
the time (*note Select Buffer::).  You can use the command `M-x pwd' to
see the value of `default-directory' in the current buffer.  The
command `M-x cd' prompts for a directory name, and sets the buffer's
`default-directory' to that directory (doing this does not change the
buffer's file name, if any).

   As an example, when you visit the file `/u/rms/gnu/gnu.tasks', the
default directory is set to `/u/rms/gnu/'.  If you invoke a command
that reads a file name, entering just `foo' in the minibuffer, with a
directory omitted, specifies the file `/u/rms/gnu/foo'; entering
`../.login' specifies `/u/rms/.login'; and entering `new/foo' specifies
`/u/rms/gnu/new/foo'.

   When typing a file name into the minibuffer, you can make use of a
couple of shortcuts: a double slash is interpreted as "ignore
everything before the second slash in the pair", and `~/' is
interpreted as your home directory.  *Note Minibuffer File::.

   The character `$' is used to substitute an environment variable into
a file name.  The name of the environment variable consists of all the
alphanumeric characters after the `$'; alternatively, it can be
enclosed in braces after the `$'.  For example, if you have used the
shell command `export FOO=rms/hacks' to set up an environment variable
named `FOO', then both `/u/$FOO/test.c' and `/u/${FOO}/test.c' are
abbreviations for `/u/rms/hacks/test.c'.  If the environment variable
is not defined, no substitution occurs, so that the character `$' stands
for itself.  Note that environment variables affect Emacs only if they
are applied before Emacs is started.

   To access a file with `$' in its name, if the `$' causes expansion,
type `$$'.  This pair is converted to a single `$' at the same time
that variable substitution is performed for a single `$'.
Alternatively, quote the whole file name with `/:' (*note Quoted File
Names::).  File names which begin with a literal `~' should also be
quoted with `/:'.

   You can include non-ASCII characters in file names.  *Note File Name
Coding::.


File: emacs,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

18.2 Visiting Files
===================

`C-x C-f'
     Visit a file (`find-file').

`C-x C-r'
     Visit a file for viewing, without allowing changes to it
     (`find-file-read-only').

`C-x C-v'
     Visit a different file instead of the one visited last
     (`find-alternate-file').

`C-x 4 f'
     Visit a file, in another window (`find-file-other-window').  Don't
     alter what is displayed in the selected window.

`C-x 5 f'
     Visit a file, in a new frame (`find-file-other-frame').  Don't
     alter what is displayed in the selected frame.

`M-x find-file-literally'
     Visit a file with no conversion of the contents.

   "Visiting" a file means reading its contents into an Emacs buffer so
you can edit them.  Emacs makes a new buffer for each file that you
visit.

   To visit a file, type `C-x C-f' (`find-file') and use the minibuffer
to enter the name of the desired file.  While in the minibuffer, you
can abort the command by typing `C-g'.  *Note File Names::, for details
about entering file names into minibuffers.

   If the specified file exists but the system does not allow you to
read it, an error message is displayed in the echo area.  Otherwise,
you can tell that `C-x C-f' has completed successfully by the
appearance of new text on the screen, and by the buffer name shown in
the mode line (*note Mode Line::).  Emacs normally constructs the
buffer name from the file name, omitting the directory name.  For
example, a file named `/usr/rms/emacs.tex' is visited in a buffer named
`emacs.tex'.  If there is already a buffer with that name, Emacs
constructs a unique name; the normal method is to append `<2>', `<3>',
and so on, but you can select other methods.  *Note Uniquify::.

   To create a new file, just visit it using the same command, `C-x
C-f'.  Emacs displays `(New file)' in the echo area, but in other
respects behaves as if you had visited an existing empty file.

   After visiting a file, the changes you make with editing commands are
made in the Emacs buffer.  They do not take effect in the visited file,
until you "save" the buffer (*note Saving::).  If a buffer contains
changes that have not been saved, we say the buffer is "modified".
This implies that some changes will be lost if the buffer is not saved.
The mode line displays two stars near the left margin to indicate that
the buffer is modified.

   If you visit a file that is already in Emacs, `C-x C-f' switches to
the existing buffer instead of making another copy.  Before doing so,
it checks whether the file has changed since you last visited or saved
it.  If the file has changed, Emacs offers to reread it.

   If you try to visit a file larger than
`large-file-warning-threshold' (the default is 10000000, which is about
10 megabytes), Emacs asks you for confirmation first.  You can answer
`y' to proceed with visiting the file.  Note, however, that Emacs
cannot visit files that are larger than the maximum Emacs buffer size,
which is limited by the amount of memory Emacs can allocate and by the
integers that Emacs can represent (*note Buffers::).  If you try, Emacs
displays an error message saying that the maximum buffer size has been
exceeded.

   If the file name you specify contains shell-style wildcard
characters, Emacs visits all the files that match it.  (On
case-insensitive filesystems, Emacs matches the wildcards disregarding
the letter case.)  Wildcards include `?', `*', and `[...]' sequences.
To enter the wild card `?' in a file name in the minibuffer, you need
to type `C-q ?'.  *Note Quoted File Names::, for information on how to
visit a file whose name actually contains wildcard characters.  You can
disable the wildcard feature by customizing `find-file-wildcards'.

   If you visit the wrong file unintentionally by typing its name
incorrectly, type `C-x C-v' (`find-alternate-file') to visit the file
you really wanted.  `C-x C-v' is similar to `C-x C-f', but it kills the
current buffer (after first offering to save it if it is modified).
When `C-x C-v' reads the file name to visit, it inserts the entire
default file name in the buffer, with point just after the directory
part; this is convenient if you made a slight error in typing the name.

   If you "visit" a file that is actually a directory, Emacs invokes
Dired, the Emacs directory browser.  *Note Dired::.  You can disable
this behavior by setting the variable `find-file-run-dired' to `nil';
in that case, it is an error to try to visit a directory.

   Files which are actually collections of other files, or "file
archives", are visited in special modes which invoke a Dired-like
environment to allow operations on archive members.  *Note File
Archives::, for more about these features.

   If you visit a file that the operating system won't let you modify,
or that is marked read-only, Emacs makes the buffer read-only too, so
that you won't go ahead and make changes that you'll have trouble
saving afterward.  You can make the buffer writable with `C-x C-q'
(`toggle-read-only').  *Note Misc Buffer::.

   If you want to visit a file as read-only in order to protect
yourself from entering changes accidentally, visit it with the command
`C-x C-r' (`find-file-read-only') instead of `C-x C-f'.

   `C-x 4 f' (`find-file-other-window') is like `C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before `C-x 4 f' continues to show the
same buffer it was already showing.  If this command is used when only
one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  *Note Windows::.

   `C-x 5 f' (`find-file-other-frame') is similar, but opens a new
frame, or selects any existing frame showing the specified file.  *Note
Frames::.

   On graphical displays, there are two additional methods for visiting
files.  Firstly, when Emacs is built with a suitable GUI toolkit,
commands invoked with the mouse (by clicking on the menu bar or tool
bar) use the toolkit's standard "File Selection" dialog instead of
prompting for the file name in the minibuffer.  On GNU/Linux and Unix
platforms, Emacs does this when built with GTK, LessTif, and Motif
toolkits; on MS-Windows and Mac, the GUI version does that by default.
For information on how to customize this, see *note Dialog Boxes::.

   Secondly, Emacs supports "drag and drop": dropping a file into an
ordinary Emacs window visits the file using that window.  As an
exception, dropping a file into a window displaying a Dired buffer
moves or copies the file into the displayed directory.  For details,
see *note Drag and Drop::, and *note Misc Dired Features::.

   Each time you visit a file, Emacs automatically scans its contents
to detect what character encoding and end-of-line convention it uses,
and converts these to Emacs's internal encoding and end-of-line
convention within the buffer.  When you save the buffer, Emacs performs
the inverse conversion, writing the file to disk with its original
encoding and end-of-line convention.  *Note Coding Systems::.

   If you wish to edit a file as a sequence of ASCII characters with no
special encoding or conversion, use the `M-x find-file-literally'
command.  This visits a file, like `C-x C-f', but does not do format
conversion (*note Format Conversion: (elisp)Format Conversion.),
character code conversion (*note Coding Systems::), or automatic
uncompression (*note Compressed Files::), and does not add a final
newline because of `require-final-newline' (*note Customize Save::).
If you have already visited the same file in the usual (non-literal)
manner, this command asks you whether to visit it literally instead.

   Two special hook variables allow extensions to modify the operation
of visiting files.  Visiting a file that does not exist runs the
functions in `find-file-not-found-functions'; this variable holds a
list of functions, which are called one by one (with no arguments)
until one of them returns non-`nil'.  This is not a normal hook, and
the name ends in `-functions' rather than `-hook' to indicate that fact.

   Successful visiting of any file, whether existing or not, calls the
functions in `find-file-hook', with no arguments.  This variable is a
normal hook.  In the case of a nonexistent file, the
`find-file-not-found-functions' are run first.  *Note Hooks::.

   There are several ways to specify automatically the major mode for
editing the file (*note Choosing Modes::), and to specify local
variables defined for that file (*note File Variables::).


File: emacs,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

18.3 Saving Files
=================

"Saving" a buffer in Emacs means writing its contents back into the file
that was visited in the buffer.

* Menu:

* Save Commands::       Commands for saving files.
* Backup::              How Emacs saves the old version of your file.
* Customize Save::      Customizing the saving of files.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.
* Shadowing: File Shadowing.  Copying files to "shadows" automatically.
* Time Stamps::         Emacs can update time stamps on saved files.


File: emacs,  Node: Save Commands,  Next: Backup,  Up: Saving

18.3.1 Commands for Saving Files
--------------------------------

These are the commands that relate to saving and writing files.

`C-x C-s'
     Save the current buffer to its file (`save-buffer').

`C-x s'
     Save any or all buffers to their files (`save-some-buffers').

`M-~'
     Forget that the current buffer has been changed (`not-modified').
     With prefix argument (`C-u'), mark the current buffer as changed.

`C-x C-w'
     Save the current buffer with a specified file name (`write-file').

`M-x set-visited-file-name'
     Change the file name under which the current buffer will be saved.

   When you wish to save the file and make your changes permanent, type
`C-x C-s' (`save-buffer').  After saving is finished, `C-x C-s'
displays a message like this:

     Wrote /u/rms/gnu/gnu.tasks

If the current buffer is not modified (no changes have been made in it
since the buffer was created or last saved), saving is not really done,
because it would have no effect.  Instead, `C-x C-s' displays a message
like this in the echo area:

     (No changes need to be saved)

   With a prefix argument, `C-u C-x C-s', Emacs also marks the buffer
to be backed up when the next save is done.  *Note Backup::.

   The command `C-x s' (`save-some-buffers') offers to save any or all
modified buffers.  It asks you what to do with each buffer.  The
possible responses are analogous to those of `query-replace':

`y'
     Save this buffer and ask about the rest of the buffers.

`n'
     Don't save this buffer, but ask about the rest of the buffers.

`!'
     Save this buffer and all the rest with no more questions.

`<RET>'
     Terminate `save-some-buffers' without any more saving.

`.'
     Save this buffer, then exit `save-some-buffers' without even asking
     about other buffers.

`C-r'
     View the buffer that you are currently being asked about.  When
     you exit View mode, you get back to `save-some-buffers', which
     asks the question again.

`d'
     Diff the buffer against its corresponding file, so you can see what
     changes you would be saving.  This calls the command
     `diff-buffer-with-file' (*note Comparing Files::).

`C-h'
     Display a help message about these options.

   `C-x C-c', the key sequence to exit Emacs, invokes
`save-some-buffers' and therefore asks the same questions.

   If you have changed a buffer but do not wish to save the changes,
you should take some action to prevent it.  Otherwise, each time you
use `C-x s' or `C-x C-c', you are liable to save this buffer by
mistake.  One thing you can do is type `M-~' (`not-modified'), which
clears out the indication that the buffer is modified.  If you do this,
none of the save commands will believe that the buffer needs to be
saved.  (`~' is often used as a mathematical symbol for `not'; thus
`M-~' is `not', metafied.)  Alternatively, you can cancel all the
changes made since the file was visited or saved, by reading the text
from the file again.  This is called "reverting".  *Note Reverting::.
(You could also undo all the changes by repeating the undo command `C-x
u' until you have undone all the changes; but reverting is easier.)

   `M-x set-visited-file-name' alters the name of the file that the
current buffer is visiting.  It reads the new file name using the
minibuffer.  Then it marks the buffer as visiting that file name, and
changes the buffer name correspondingly.  `set-visited-file-name' does
not save the buffer in the newly visited file; it just alters the
records inside Emacs in case you do save later.  It also marks the
buffer as "modified" so that `C-x C-s' in that buffer _will_ save.

   If you wish to mark the buffer as visiting a different file and save
it right away, use `C-x C-w' (`write-file').  This is equivalent to
`set-visited-file-name' followed by `C-x C-s', except that `C-x C-w'
asks for confirmation if the file exists.  `C-x C-s' used on a buffer
that is not visiting a file has the same effect as `C-x C-w'; that is,
it reads a file name, marks the buffer as visiting that file, and saves
it there.  The default file name in a buffer that is not visiting a
file is made by combining the buffer name with the buffer's default
directory (*note File Names::).

   If the new file name implies a major mode, then `C-x C-w' switches
to that major mode, in most cases.  The command `set-visited-file-name'
also does this.  *Note Choosing Modes::.

   If Emacs is about to save a file and sees that the date of the latest
version on disk does not match what Emacs last read or wrote, Emacs
notifies you of this fact, because it probably indicates a problem
caused by simultaneous editing and requires your immediate attention.
*Note Simultaneous Editing: Interlocking.


File: emacs,  Node: Backup,  Next: Customize Save,  Prev: Save Commands,  Up: Saving

18.3.2 Backup Files
-------------------

On most operating systems, rewriting a file automatically destroys all
record of what the file used to contain.  Thus, saving a file from Emacs
throws away the old contents of the file--or it would, except that
Emacs carefully copies the old contents to another file, called the
"backup" file, before actually saving.

   Emacs makes a backup for a file only the first time the file is
saved from a buffer.  No matter how many times you subsequently save
the file, its backup remains unchanged.  However, if you kill the
buffer and then visit the file again, a new backup file will be made.

   For most files, the variable `make-backup-files' determines whether
to make backup files.  On most operating systems, its default value is
`t', so that Emacs does write backup files.

   For files managed by a version control system (*note Version
Control::), the variable `vc-make-backup-files' determines whether to
make backup files.  By default it is `nil', since backup files are
redundant when you store all the previous versions in a version control
system.  *Note General VC Options::.

   At your option, Emacs can keep either a single backup for each file,
or make a series of numbered backup files for each file that you edit.
*Note Backup Names::.

   The default value of the `backup-enable-predicate' variable prevents
backup files being written for files in the directories used for
temporary files, specified by `temporary-file-directory' or
`small-temporary-file-directory'.

   You can explicitly tell Emacs to make another backup file from a
buffer, even though that buffer has been saved before.  If you save the
buffer with `C-u C-x C-s', the version thus saved will be made into a
backup file if you save the buffer again.  `C-u C-u C-x C-s' saves the
buffer, but first makes the previous file contents into a new backup
file.  `C-u C-u C-u C-x C-s' does both things: it makes a backup from
the previous contents, and arranges to make another from the newly
saved contents if you save again.

* Menu:

* Names: Backup Names.          How backup files are named.
* Deletion: Backup Deletion.    Emacs deletes excess numbered backups.
* Copying: Backup Copying.      Backups can be made by copying or renaming.


File: emacs,  Node: Backup Names,  Next: Backup Deletion,  Up: Backup

18.3.2.1 Single or Numbered Backups
...................................

When Emacs makes a backup file, its name is normally constructed by
appending `~' to the file name being edited; thus, the backup file for
`eval.c' would be `eval.c~'.

   If access control stops Emacs from writing backup files under the
usual names, it writes the backup file as `~/.emacs.d/%backup%~'.  Only
one such file can exist, so only the most recently made such backup is
available.

   Emacs can also make "numbered backup files".  Numbered backup file
names contain `.~', the number, and another `~' after the original file
name.  Thus, the backup files of `eval.c' would be called `eval.c.~1~',
`eval.c.~2~', and so on, all the way through names like `eval.c.~259~'
and beyond.

   The variable `version-control' determines whether to make single
backup files or multiple numbered backup files.  Its possible values
are:

`nil'
     Make numbered backups for files that have numbered backups already.
     Otherwise, make single backups.  This is the default.

`t'
     Make numbered backups.

`never'
     Never make numbered backups; always make single backups.

The usual way to set this variable is globally, through your init file
or the customization buffer.  However, you can set `version-control'
locally in an individual buffer to control the making of backups for
that buffer's file (*note Locals::).  You can have Emacs set
`version-control' locally whenever you visit a given file (*note File
Variables::).  Some modes, such as Rmail mode, set this variable.

   If you set the environment variable `VERSION_CONTROL', to tell
various GNU utilities what to do with backup files, Emacs also obeys the
environment variable by setting the Lisp variable `version-control'
accordingly at startup.  If the environment variable's value is `t' or
`numbered', then `version-control' becomes `t'; if the value is `nil'
or `existing', then `version-control' becomes `nil'; if it is `never'
or `simple', then `version-control' becomes `never'.

   You can customize the variable `backup-directory-alist' to specify
that files matching certain patterns should be backed up in specific
directories.  This variable applies to both single and numbered
backups.  A typical use is to add an element `("."  . DIR)' to make all
backups in the directory with absolute name DIR; Emacs modifies the
backup file names to avoid clashes between files with the same names
originating in different directories.  Alternatively, adding, `("." .
".~")' would make backups in the invisible subdirectory `.~' of the
original file's directory.  Emacs creates the directory, if necessary,
to make the backup.

   If you define the variable `make-backup-file-name-function' to a
suitable Lisp function, that overrides the usual way Emacs constructs
backup file names.


File: emacs,  Node: Backup Deletion,  Next: Backup Copying,  Prev: Backup Names,  Up: Backup

18.3.2.2 Automatic Deletion of Backups
......................................

To prevent excessive consumption of disk space, Emacs can delete
numbered backup versions automatically.  Generally Emacs keeps the
first few backups and the latest few backups, deleting any in between.
This happens every time a new backup is made.

   The two variables `kept-old-versions' and `kept-new-versions'
control this deletion.  Their values are, respectively, the number of
oldest (lowest-numbered) backups to keep and the number of newest
(highest-numbered) ones to keep, each time a new backup is made.  The
backups in the middle (excluding those oldest and newest) are the
excess middle versions--those backups are deleted.  These variables'
values are used when it is time to delete excess versions, just after a
new backup version is made; the newly made backup is included in the
count in `kept-new-versions'.  By default, both variables are 2.

   If `delete-old-versions' is `t', Emacs deletes the excess backup
files silently.  If it is `nil', the default, Emacs asks you whether it
should delete the excess backup versions.  If it has any other value,
then Emacs never automatically deletes backups.

   Dired's `.' (Period) command can also be used to delete old versions.
*Note Dired Deletion::.


File: emacs,  Node: Backup Copying,  Prev: Backup Deletion,  Up: Backup

18.3.2.3 Copying vs. Renaming
.............................

Backup files can be made by copying the old file or by renaming it.
This makes a difference when the old file has multiple names (hard
links).  If the old file is renamed into the backup file, then the
alternate names become names for the backup file.  If the old file is
copied instead, then the alternate names remain names for the file that
you are editing, and the contents accessed by those names will be the
new contents.

   The method of making a backup file may also affect the file's owner
and group.  If copying is used, these do not change.  If renaming is
used, you become the file's owner, and the file's group becomes the
default (different operating systems have different defaults for the
group).

   The choice of renaming or copying is made as follows:

   * If the variable `backup-by-copying' is non-`nil' (the default is
     `nil'), use copying.

   * Otherwise, if the variable `backup-by-copying-when-linked' is
     non-`nil' (the default is `nil'), and the file has multiple names,
     use copying.

   * Otherwise, if the variable `backup-by-copying-when-mismatch' is
     non-`nil' (the default is `t'), and renaming would change the
     file's owner or group, use copying.

     If you change `backup-by-copying-when-mismatch' to `nil', Emacs
     checks the numeric user-id of the file's owner.  If this is higher
     than `backup-by-copying-when-privileged-mismatch', then it behaves
     as though `backup-by-copying-when-mismatch' is non-`nil' anyway.

   * Otherwise, renaming is the default choice.

   When a file is managed with a version control system (*note Version
Control::), Emacs does not normally make backups in the usual way for
that file.  But check-in and check-out are similar in some ways to
making backups.  One unfortunate similarity is that these operations
typically break hard links, disconnecting the file name you visited from
any alternate names for the same file.  This has nothing to do with
Emacs--the version control system does it.


File: emacs,  Node: Customize Save,  Next: Interlocking,  Prev: Backup,  Up: Saving

18.3.3 Customizing Saving of Files
----------------------------------

If the value of the variable `require-final-newline' is `t', saving or
writing a file silently puts a newline at the end if there isn't
already one there.  If the value is `visit', Emacs adds a newline at
the end of any file that doesn't have one, just after it visits the
file.  (This marks the buffer as modified, and you can undo it.)  If
the value is `visit-save', Emacs adds such newlines both on visiting
and on saving.  If the value is `nil', Emacs leaves the end of the file
unchanged; any other non-`nil' value means to asks you whether to add a
newline.  The default is `nil'.

   Some major modes are designed for specific kinds of files that are
always supposed to end in newlines.  Such major modes set the variable
`require-final-newline' to the value of `mode-require-final-newline',
which defaults to `t'.  By setting the latter variable, you can control
how these modes handle final newlines.

   When Emacs saves a file, it invokes the `fsync' system call to force
the data immediately out to disk.  This is important for safety if the
system crashes or in case of power outage.  However, it can be
disruptive on laptops using power saving, as it may force a disk
spin-up each time you save a file.  If you accept an increased risk of
data loss, you can set `write-region-inhibit-fsync' to a non-`nil'
value to disable the synchronization.


File: emacs,  Node: Interlocking,  Next: File Shadowing,  Prev: Customize Save,  Up: Saving

18.3.4 Protection against Simultaneous Editing
----------------------------------------------

Simultaneous editing occurs when two users visit the same file, both
make changes, and then both save them.  If nobody is informed that this
is happening, whichever user saves first would later find that his
changes were lost.

   On some systems, Emacs notices immediately when the second user
starts to change the file, and issues an immediate warning.  On all
systems, Emacs checks when you save the file, and warns if you are
about to overwrite another user's changes.  You can prevent loss of the
other user's work by taking the proper corrective action instead of
saving the file.

   When you make the first modification in an Emacs buffer that is
visiting a file, Emacs records that the file is "locked" by you.  (It
does this by creating a specially-named symbolic link in the same
directory.)  Emacs removes the lock when you save the changes.  The
idea is that the file is locked whenever an Emacs buffer visiting it
has unsaved changes.

   If you begin to modify the buffer while the visited file is locked by
someone else, this constitutes a "collision".  When Emacs detects a
collision, it asks you what to do, by calling the Lisp function
`ask-user-about-lock'.  You can redefine this function for the sake of
customization.  The standard definition of this function asks you a
question and accepts three possible answers:

`s'
     Steal the lock.  Whoever was already changing the file loses the
     lock, and you gain the lock.

`p'
     Proceed.  Go ahead and edit the file despite its being locked by
     someone else.

`q'
     Quit.  This causes an error (`file-locked'), and the buffer
     contents remain unchanged--the modification you were trying to make
     does not actually take place.

   If Emacs or the operating system crashes, this may leave behind lock
files which are stale, so you may occasionally get warnings about
spurious collisions.  When you determine that the collision is
spurious, just use `p' to tell Emacs to go ahead anyway.

   Note that locking works on the basis of a file name; if a file has
multiple names, Emacs does not prevent two users from editing it
simultaneously under different names.

   A lock file cannot be written in some circumstances, e.g. if Emacs
lacks the system permissions or the system does not support symbolic
links.  In these cases, Emacs can still detect the collision when you
try to save a file, by checking the file's last-modification date.  If
the file has changed since the last time Emacs visited or saved it,
that implies that changes have been made in some other way, and will be
lost if Emacs proceeds with saving.  Emacs then displays a warning
message and asks for confirmation before saving; answer `yes' to save,
and `no' or `C-g' cancel the save.

   If you are notified that simultaneous editing has already taken
place, one way to compare the buffer to its file is the `M-x
diff-buffer-with-file' command.  *Note Comparing Files::.


File: emacs,  Node: File Shadowing,  Next: Time Stamps,  Prev: Interlocking,  Up: Saving

18.3.5 Shadowing Files
----------------------

`M-x shadow-initialize'
     Set up file shadowing.

`M-x shadow-define-literal-group'
     Declare a single file to be shared between sites.

`M-x shadow-define-regexp-group'
     Make all files that match each of a group of files be shared
     between hosts.

`M-x shadow-define-cluster <RET> NAME <RET>'
     Define a shadow file cluster NAME.

`M-x shadow-copy-files'
     Copy all pending shadow files.

`M-x shadow-cancel'
     Cancel the instruction to shadow some files.

   You can arrange to keep identical "shadow" copies of certain files
in more than one place--possibly on different machines.  To do this,
first you must set up a "shadow file group", which is a set of
identically-named files shared between a list of sites.  The file group
is permanent and applies to further Emacs sessions as well as the
current one.  Once the group is set up, every time you exit Emacs, it
will copy the file you edited to the other files in its group.  You can
also do the copying without exiting Emacs, by typing `M-x
shadow-copy-files'.

   To set up a shadow file group, use `M-x shadow-define-literal-group'
or `M-x shadow-define-regexp-group'.  See their documentation strings
for further information.

   Before copying a file to its shadows, Emacs asks for confirmation.
You can answer "no" to bypass copying of this file, this time.  If you
want to cancel the shadowing permanently for a certain file, use `M-x
shadow-cancel' to eliminate or change the shadow file group.

   A "shadow cluster" is a group of hosts that share directories, so
that copying to or from one of them is sufficient to update the file on
all of them.  Each shadow cluster has a name, and specifies the network
address of a primary host (the one we copy files to), and a regular
expression that matches the host names of all the other hosts in the
cluster.  You can define a shadow cluster with `M-x
shadow-define-cluster'.


File: emacs,  Node: Time Stamps,  Prev: File Shadowing,  Up: Saving

18.3.6 Updating Time Stamps Automatically
-----------------------------------------

You can arrange to put a time stamp in a file, so that it is updated
automatically each time you edit and save the file.  The time stamp
must be in the first eight lines of the file, and you should insert it
like this:

     Time-stamp: <>

or like this:

     Time-stamp: " "

   Then add the function `time-stamp' to the hook `before-save-hook'
(*note Hooks::).  When you save the file, this function then
automatically updates the time stamp with the current date and time.
You can also use the command `M-x time-stamp' to update the time stamp
manually.  For other customizations, see the Custom group `time-stamp'.
Note that the time stamp is formatted according to your locale setting
(*note Environment::).


File: emacs,  Node: Reverting,  Next: Autorevert,  Prev: Saving,  Up: Files

18.4 Reverting a Buffer
=======================

If you have made extensive changes to a file-visiting buffer and then
change your mind, you can "revert" the changes and go back to the saved
version of the file.  To do this, type `M-x revert-buffer'.  Since
reverting unintentionally could lose a lot of work, Emacs asks for
confirmation first.

   The `revert-buffer' command tries to position point in such a way
that, if the file was edited only slightly, you will be at
approximately the same part of the text as before.  But if you have
made major changes, point may end up in a totally different location.

   Reverting marks the buffer as "not modified".  It also clears the
buffer's undo history (*note Undo::).  Thus, the reversion cannot be
undone--if you change your mind yet again, you can't use the undo
commands to bring the reverted changes back.

   Some kinds of buffers that are not associated with files, such as
Dired buffers, can also be reverted.  For them, reverting means
recalculating their contents.  Buffers created explicitly with `C-x b'
cannot be reverted; `revert-buffer' reports an error if you try.

   When you edit a file that changes automatically and frequently--for
example, a log of output from a process that continues to run--it may
be useful for Emacs to revert the file without querying you.  To
request this behavior, set the variable `revert-without-query' to a
list of regular expressions.  When a file name matches one of these
regular expressions, `find-file' and `revert-buffer' will revert it
automatically if it has changed--provided the buffer itself is not
modified.  (If you have edited the text, it would be wrong to discard
your changes.)

   You can also tell Emacs to revert buffers periodically.  To do this
for a specific buffer, enable the minor mode Auto-Revert mode by typing
`M-x auto-revert-mode'.  This automatically reverts the current buffer
every five seconds; you can change the interval through the variable
`auto-revert-interval'.  To do the same for all file buffers, type `M-x
global-auto-revert-mode' to enable Global Auto-Revert mode.  These
minor modes do not check or revert remote files, because that is
usually too slow.

   One use of Auto-Revert mode is to "tail" a file such as a system
log, so that changes made to that file by other programs are
continuously displayed.  To do this, just move the point to the end of
the buffer, and it will stay there as the file contents change.
However, if you are sure that the file will only change by growing at
the end, use Auto-Revert Tail mode instead (`auto-revert-tail-mode').
It is more efficient for this.  Auto-Revert Tail mode works also for
remote files.

   *Note VC Undo::, for commands to revert to earlier versions of files
under version control.  *Note VC Mode Line::, for Auto Revert
peculiarities when visiting files under version control.


File: emacs,  Node: Autorevert,  Next: Auto Save,  Prev: Reverting,  Up: Files

18.5 Auto Reverting Non-File Buffers
====================================

Global Auto Revert Mode normally only reverts file buffers.  There are
two ways to auto-revert certain non-file buffers: by enabling Auto
Revert Mode in those buffers (using `M-x auto-revert-mode'); and by
setting `global-auto-revert-non-file-buffers' to a non-`nil' value.
The latter enables Auto Reverting for all types of buffers for which it
is implemented (listed in the menu below).

   Like file buffers, non-file buffers should normally not revert while
you are working on them, or while they contain information that might
get lost after reverting.  Therefore, they do not revert if they are
"modified".  This can get tricky, because deciding when a non-file
buffer should be marked modified is usually more difficult than for
file buffers.

   Another tricky detail is that, for efficiency reasons, Auto Revert
often does not try to detect all possible changes in the buffer, only
changes that are "major" or easy to detect.  Hence, enabling
auto-reverting for a non-file buffer does not always guarantee that all
information in the buffer is up-to-date, and does not necessarily make
manual reverts useless.

   At the other extreme, certain buffers automatically revert every
`auto-revert-interval' seconds.  (This currently only applies to the
Buffer Menu.)  In this case, Auto Revert does not print any messages
while reverting, even when `auto-revert-verbose' is non-`nil'.

   The details depend on the particular types of buffers and are
explained in the corresponding sections.

* Menu:

* Auto Reverting the Buffer Menu:: Auto Revert of the Buffer Menu.
* Auto Reverting Dired::           Auto Revert of Dired buffers.
* Supporting additional buffers::  How to add more Auto Revert support.


File: emacs,  Node: Auto Reverting the Buffer Menu,  Next: Auto Reverting Dired,  Up: Autorevert

18.5.1 Auto Reverting the Buffer Menu
-------------------------------------

If auto-reverting of non-file buffers is enabled, the Buffer Menu
automatically reverts every `auto-revert-interval' seconds, whether
there is a need for it or not.  (It would probably take longer to check
whether there is a need than to actually revert.)

   If the Buffer Menu inappropriately gets marked modified, just revert
it manually using `g' and auto-reverting will resume.  However, if you
marked certain buffers to get deleted or to be displayed, you have to
be careful, because reverting erases all marks.  The fact that adding
marks sets the buffer's modified flag prevents Auto Revert from
automatically erasing the marks.


File: emacs,  Node: Auto Reverting Dired,  Next: Supporting additional buffers,  Prev: Auto Reverting the Buffer Menu,  Up: Autorevert

18.5.2 Auto Reverting Dired buffers
-----------------------------------

Auto-reverting Dired buffers currently works on GNU or Unix style
operating systems.  It may not work satisfactorily on some other
systems.

   Dired buffers only auto-revert when the file list of the buffer's
main directory changes (e.g. when a new file is added).  They do not
auto-revert when information about a particular file changes (e.g. when
the size changes) or when inserted subdirectories change.  To be sure
that _all_ listed information is up to date, you have to manually
revert using `g', _even_ if auto-reverting is enabled in the Dired
buffer.  Sometimes, you might get the impression that modifying or
saving files listed in the main directory actually does cause
auto-reverting.  This is because making changes to a file, or saving
it, very often causes changes in the directory itself; for instance,
through backup files or auto-save files.  However, this is not
guaranteed.

   If the Dired buffer is marked modified and there are no changes you
want to protect, then most of the time you can make auto-reverting
resume by manually reverting the buffer using `g'.  There is one
exception.  If you flag or mark files, you can safely revert the
buffer.  This will not erase the flags or marks (unless the marked file
has been deleted, of course).  However, the buffer will stay modified,
even after reverting, and auto-reverting will not resume.  This is
because, if you flag or mark files, you may be working on the buffer
and you might not want the buffer to change without warning.  If you
want auto-reverting to resume in the presence of marks and flags, mark
the buffer non-modified using `M-~'.  However, adding, deleting or
changing marks or flags will mark it modified again.

   Remote Dired buffers are not auto-reverted (because it may be slow).
Neither are Dired buffers for which you used shell wildcards or file
arguments to list only some of the files.  `*Find*' and `*Locate*'
buffers do not auto-revert either.


File: emacs,  Node: Supporting additional buffers,  Prev: Auto Reverting Dired,  Up: Autorevert

18.5.3 Adding Support for Auto-Reverting additional Buffers.
------------------------------------------------------------

This section is intended for Elisp programmers who would like to add
support for auto-reverting new types of buffers.

   To support auto-reverting the buffer must first of all have a
`revert-buffer-function'.  *Note Reverting: (elisp)Definition of
revert-buffer-function.

   In addition, it _must_ have a `buffer-stale-function'.

 -- Variable: buffer-stale-function
     The value of this variable is a function to check whether a
     non-file buffer needs reverting.  This should be a function with
     one optional argument NOCONFIRM.  The function should return
     non-`nil' if the buffer should be reverted.  The buffer is current
     when this function is called.

     While this function is mainly intended for use in auto-reverting,
     it could be used for other purposes as well.  For instance, if
     auto-reverting is not enabled, it could be used to warn the user
     that the buffer needs reverting.  The idea behind the NOCONFIRM
     argument is that it should be `t' if the buffer is going to be
     reverted without asking the user and `nil' if the function is just
     going to be used to warn the user that the buffer is out of date.
     In particular, for use in auto-reverting, NOCONFIRM is `t'.  If
     the function is only going to be used for auto-reverting, you can
     ignore the NOCONFIRM argument.

     If you just want to automatically auto-revert every
     `auto-revert-interval' seconds (like the Buffer Menu), use:

          (set (make-local-variable 'buffer-stale-function)
               #'(lambda (&optional noconfirm) 'fast))

     in the buffer's mode function.

     The special return value `fast' tells the caller that the need for
     reverting was not checked, but that reverting the buffer is fast.
     It also tells Auto Revert not to print any revert messages, even if
     `auto-revert-verbose' is non-`nil'.  This is important, as getting
     revert messages every `auto-revert-interval' seconds can be very
     annoying.  The information provided by this return value could
     also be useful if the function is consulted for purposes other than
     auto-reverting.

   Once the buffer has a `revert-buffer-function' and a
`buffer-stale-function', several problems usually remain.

   The buffer will only auto-revert if it is marked unmodified.  Hence,
you will have to make sure that various functions mark the buffer
modified if and only if either the buffer contains information that
might be lost by reverting, or there is reason to believe that the user
might be inconvenienced by auto-reverting, because he is actively
working on the buffer.  The user can always override this by manually
adjusting the modified status of the buffer.  To support this, calling
the `revert-buffer-function' on a buffer that is marked unmodified
should always keep the buffer marked unmodified.

   It is important to assure that point does not continuously jump
around as a consequence of auto-reverting.  Of course, moving point
might be inevitable if the buffer radically changes.

   You should make sure that the `revert-buffer-function' does not
print messages that unnecessarily duplicate Auto Revert's own messages,
displayed if `auto-revert-verbose' is `t', and effectively override a
`nil' value for `auto-revert-verbose'.  Hence, adapting a mode for
auto-reverting often involves getting rid of such messages.  This is
especially important for buffers that automatically revert every
`auto-revert-interval' seconds.

   If the new auto-reverting is part of Emacs, you should mention it in
the documentation string of `global-auto-revert-non-file-buffers'.

   Similarly, you should add a node to this chapter's menu.  This node
should at the very least make clear whether enabling auto-reverting for
the buffer reliably assures that all information in the buffer is
completely up to date (or will be after `auto-revert-interval' seconds).


File: emacs,  Node: Auto Save,  Next: File Aliases,  Prev: Autorevert,  Up: Files

18.6 Auto-Saving: Protection Against Disasters
==============================================

From time to time, Emacs automatically saves each visited file in a
separate file, without altering the file you actually use.  This is
called "auto-saving".  It prevents you from losing more than a limited
amount of work if the system crashes.

   When Emacs determines that it is time for auto-saving, it considers
each buffer, and each is auto-saved if auto-saving is enabled for it
and it has been changed since the last time it was auto-saved.  The
message `Auto-saving...' is displayed in the echo area during
auto-saving, if any files are actually auto-saved.  Errors occurring
during auto-saving are caught so that they do not interfere with the
execution of commands you have been typing.

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::                     Recovering text from auto-save files.


File: emacs,  Node: Auto Save Files,  Next: Auto Save Control,  Up: Auto Save

18.6.1 Auto-Save Files
----------------------

Auto-saving does not normally save in the files that you visited,
because it can be very undesirable to save a change that you did not
want to make permanent.  Instead, auto-saving is done in a different
file called the "auto-save file", and the visited file is changed only
when you request saving explicitly (such as with `C-x C-s').

   Normally, the auto-save file name is made by appending `#' to the
front and rear of the visited file name.  Thus, a buffer visiting file
`foo.c' is auto-saved in a file `#foo.c#'.  Most buffers that are not
visiting files are auto-saved only if you request it explicitly; when
they are auto-saved, the auto-save file name is made by appending `#'
to the front and rear of buffer name, then adding digits and letters at
the end for uniqueness.  For example, the `*mail*' buffer in which you
compose messages to be sent might be auto-saved in a file named
`#*mail*#704juu'.  Auto-save file names are made this way unless you
reprogram parts of Emacs to do something different (the functions
`make-auto-save-file-name' and `auto-save-file-name-p').  The file name
to be used for auto-saving in a buffer is calculated when auto-saving
is turned on in that buffer.

   The variable `auto-save-file-name-transforms' allows a degree of
control over the auto-save file name.  It lets you specify a series of
regular expressions and replacements to transform the auto save file
name.  The default value puts the auto-save files for remote files
(*note Remote Files::) into the temporary file directory on the local
machine.

   When you delete a substantial part of the text in a large buffer,
auto save turns off temporarily in that buffer.  This is because if you
deleted the text unintentionally, you might find the auto-save file more
useful if it contains the deleted text.  To reenable auto-saving after
this happens, save the buffer with `C-x C-s', or use `C-u 1 M-x
auto-save-mode'.

   If you want auto-saving to be done in the visited file rather than
in a separate auto-save file, set the variable
`auto-save-visited-file-name' to a non-`nil' value.  In this mode,
there is no real difference between auto-saving and explicit saving.

   A buffer's auto-save file is deleted when you save the buffer in its
visited file.  (You can inhibit this by setting the variable
`delete-auto-save-files' to `nil'.)  Changing the visited file name
with `C-x C-w' or `set-visited-file-name' renames any auto-save file to
go with the new visited name.


File: emacs,  Node: Auto Save Control,  Next: Recover,  Prev: Auto Save Files,  Up: Auto Save

18.6.2 Controlling Auto-Saving
------------------------------

Each time you visit a file, auto-saving is turned on for that file's
buffer if the variable `auto-save-default' is non-`nil' (but not in
batch mode; *note Initial Options::).  The default for this variable is
`t', so auto-saving is the usual practice for file-visiting buffers.
To toggle auto-saving in the current buffer, type `M-x auto-save-mode'.
Auto Save mode acts as a buffer-local minor mode (*note Minor Modes::).

   Emacs auto-saves periodically based on how many characters you have
typed since the last auto-save.  The variable `auto-save-interval'
specifies how many characters there are between auto-saves.  By
default, it is 300.  Emacs doesn't accept values that are too small: if
you customize `auto-save-interval' to a value less than 20, Emacs will
behave as if the value is 20.

   Auto-saving also takes place when you stop typing for a while.  By
default, it does this after 30 seconds of idleness (at this time, Emacs
may also perform garbage collection; *note Garbage Collection:
(elisp)Garbage Collection.).  To change this interval, customize the
variable `auto-save-timeout'.  The actual time period is longer if the
current buffer is long; this is a heuristic which aims to keep out of
your way when you are editing long buffers, in which auto-save takes an
appreciable amount of time.  Auto-saving during idle periods
accomplishes two things: first, it makes sure all your work is saved if
you go away from the terminal for a while; second, it may avoid some
auto-saving while you are actually typing.

   Emacs also does auto-saving whenever it gets a fatal error.  This
includes killing the Emacs job with a shell command such as `kill
%emacs', or disconnecting a phone line or network connection.

   You can perform an auto-save explicitly with the command `M-x
do-auto-save'.


File: emacs,  Node: Recover,  Prev: Auto Save Control,  Up: Auto Save

18.6.3 Recovering Data from Auto-Saves
--------------------------------------

You can use the contents of an auto-save file to recover from a loss of
data with the command `M-x recover-file <RET> FILE <RET>'.  This visits
FILE and then (after your confirmation) restores the contents from its
auto-save file `#FILE#'.  You can then save with `C-x C-s' to put the
recovered text into FILE itself.  For example, to recover file `foo.c'
from its auto-save file `#foo.c#', do:

     M-x recover-file <RET> foo.c <RET>
     yes <RET>
     C-x C-s

   Before asking for confirmation, `M-x recover-file' displays a
directory listing describing the specified file and the auto-save file,
so you can compare their sizes and dates.  If the auto-save file is
older, `M-x recover-file' does not offer to read it.

   If Emacs or the computer crashes, you can recover all the files you
were editing from their auto save files with the command `M-x
recover-session'.  This first shows you a list of recorded interrupted
sessions.  Move point to the one you choose, and type `C-c C-c'.

   Then `recover-session' asks about each of the files that were being
edited during that session, asking whether to recover that file.  If
you answer `y', it calls `recover-file', which works in its normal
fashion.  It shows the dates of the original file and its auto-save
file, and asks once again whether to recover that file.

   When `recover-session' is done, the files you've chosen to recover
are present in Emacs buffers.  You should then save them.  Only
this--saving them--updates the files themselves.

   Emacs records information about interrupted sessions for later
recovery in files named `.saves-PID-HOSTNAME' in the directory
`~/.emacs.d/auto-save-list/'.  This directory is determined by the
variable `auto-save-list-file-prefix'.  If you set
`auto-save-list-file-prefix' to `nil', sessions are not recorded for
recovery.


File: emacs,  Node: File Aliases,  Next: Directories,  Prev: Auto Save,  Up: Files

18.7 File Name Aliases
======================

Symbolic links and hard links both make it possible for several file
names to refer to the same file.  Hard links are alternate names that
refer directly to the file; all the names are equally valid, and no one
of them is preferred.  By contrast, a symbolic link is a kind of defined
alias: when `foo' is a symbolic link to `bar', you can use either name
to refer to the file, but `bar' is the real name, while `foo' is just
an alias.  More complex cases occur when symbolic links point to
directories.

   Normally, if you visit a file which Emacs is already visiting under
a different name, Emacs displays a message in the echo area and uses
the existing buffer visiting that file.  This can happen on systems
that support hard or symbolic links, or if you use a long file name on
a system that truncates long file names, or on a case-insensitive file
system.  You can suppress the message by setting the variable
`find-file-suppress-same-file-warnings' to a non-`nil' value.  You can
disable this feature entirely by setting the variable
`find-file-existing-other-name' to `nil': then if you visit the same
file under two different names, you get a separate buffer for each file
name.

   If the variable `find-file-visit-truename' is non-`nil', then the
file name recorded for a buffer is the file's "truename" (made by
replacing all symbolic links with their target names), rather than the
name you specify.  Setting `find-file-visit-truename' also implies the
effect of `find-file-existing-other-name'.

   Sometimes, a directory is ordinarily accessed through a symbolic
link, and you may want Emacs to preferentially show its "linked" name.
To do this, customize `directory-abbrev-alist'.  Each element in this
list should have the form `(FROM . TO)', which means to replace FROM
with TO whenever FROM appears in a directory name.  The FROM string is a
regular expression (*note Regexps::).  It is matched against directory
names anchored at the first character, and should start with `\`' (to
support directory names with embedded newlines, which would defeat
`^').  The TO string should be an ordinary absolute directory name
pointing to the same directory.  Do not use `~' to stand for a home
directory in the TO string; Emacs performs these substitutions
separately.  Here's an example, from a system on which `/home/fsf' is
normally accessed through a symbolic link named `/fsf':

     (("\\`/home/fsf" . "/fsf"))


File: emacs,  Node: Directories,  Next: Comparing Files,  Prev: File Aliases,  Up: Files

18.8 File Directories
=====================

The file system groups files into "directories".  A "directory listing"
is a list of all the files in a directory.  Emacs provides commands to
create and delete directories, and to make directory listings in brief
format (file names only) and verbose format (sizes, dates, and authors
included).  Emacs also includes a directory browser feature called
Dired; see *note Dired::.

`C-x C-d DIR-OR-PATTERN <RET>'
     Display a brief directory listing (`list-directory').

`C-u C-x C-d DIR-OR-PATTERN <RET>'
     Display a verbose directory listing.

`M-x make-directory <RET> DIRNAME <RET>'
     Create a new directory named DIRNAME.

`M-x delete-directory <RET> DIRNAME <RET>'
     Delete the directory named DIRNAME.  If it isn't empty, you will
     be asked whether you want to delete it recursively.

   The command to display a directory listing is `C-x C-d'
(`list-directory').  It reads using the minibuffer a file name which is
either a directory to be listed or a wildcard-containing pattern for
the files to be listed.  For example,

     C-x C-d /u2/emacs/etc <RET>

lists all the files in directory `/u2/emacs/etc'.  Here is an example
of specifying a file name pattern:

     C-x C-d /u2/emacs/src/*.c <RET>

   Normally, `C-x C-d' displays a brief directory listing containing
just file names.  A numeric argument (regardless of value) tells it to
make a verbose listing including sizes, dates, and owners (like `ls
-l').

   The text of a directory listing is mostly obtained by running `ls'
in an inferior process.  Two Emacs variables control the switches
passed to `ls': `list-directory-brief-switches' is a string giving the
switches to use in brief listings (`"-CF"' by default), and
`list-directory-verbose-switches' is a string giving the switches to
use in a verbose listing (`"-l"' by default).

   In verbose directory listings, Emacs adds information about the
amount of free space on the disk that contains the directory.  To do
this, it runs the program specified by `directory-free-space-program'
with arguments `directory-free-space-args'.

   The command `M-x delete-directory' prompts for a directory name
using the minibuffer, and deletes the directory if it is empty.  If the
directory is not empty, you will be asked whether you want to delete it
recursively.  On systems that have a "Trash" (or "Recycle Bin")
feature, you can make this command move the specified directory to the
Trash instead of deleting it outright, by changing the variable
`delete-by-moving-to-trash' to `t'.  *Note Misc File Ops::, for more
information about using the Trash.


File: emacs,  Node: Comparing Files,  Next: Diff Mode,  Prev: Directories,  Up: Files

18.9 Comparing Files
====================

The command `M-x diff' prompts for two file names, using the
minibuffer, and displays the differences between the two files in a
buffer named `*diff*'.  This works by running the `diff' program, using
options taken from the variable `diff-switches'.  The value of
`diff-switches' should be a string; the default is `"-c"' to specify a
context diff.  *Note Diff: (diff)Top, for more information about the
`diff' program.

   The output of the `diff' command is shown using a major mode called
Diff mode.  *Note Diff Mode::.

   The command `M-x diff-backup' compares a specified file with its
most recent backup.  If you specify the name of a backup file,
`diff-backup' compares it with the source file that it is a backup of.
In all other respects, this behaves like `M-x diff'.

   The command `M-x diff-buffer-with-file' compares a specified buffer
with its corresponding file.  This shows you what changes you would
make to the file if you save the buffer.

   The command `M-x compare-windows' compares the text in the current
window with that in the next window.  (For more information about
windows in Emacs, *note Windows::.)  Comparison starts at point in each
window, after pushing each initial point value on the mark ring in its
respective buffer.  Then it moves point forward in each window, one
character at a time, until it reaches characters that don't match.
Then the command exits.

   If point in the two windows is followed by non-matching text when
the command starts, `M-x compare-windows' tries heuristically to
advance up to matching text in the two windows, and then exits.  So if
you use `M-x compare-windows' repeatedly, each time it either skips one
matching range or finds the start of another.

   With a numeric argument, `compare-windows' ignores changes in
whitespace.  If the variable `compare-ignore-case' is non-`nil', the
comparison ignores differences in case as well.  If the variable
`compare-ignore-whitespace' is non-`nil', `compare-windows' normally
ignores changes in whitespace, and a prefix argument turns that off.

   You can use `M-x smerge-mode' to turn on Smerge mode, a minor mode
for editing output from the `diff3' program.  This is typically the
result of a failed merge from a version control system "update" outside
VC, due to conflicting changes to a file.  Smerge mode provides
commands to resolve conflicts by selecting specific changes.

   *Note Emerge::, for the Emerge facility, which provides a powerful
interface for merging files.


File: emacs,  Node: Diff Mode,  Next: Misc File Ops,  Prev: Comparing Files,  Up: Files

18.10 Diff Mode
===============

Diff mode is a major mode used for the output of `M-x diff' and other
similar commands.  This kind of output is called a "patch", because it
can be passed to the `patch' command to automatically apply the
specified changes.  To select Diff mode manually, type `M-x diff-mode'.

   The changes specified in a patch are grouped into "hunks", which are
contiguous chunks of text that contain one or more changed lines.
Hunks can also include unchanged lines to provide context for the
changes.  Each hunk is preceded by a "hunk header", which specifies the
old and new line numbers at which the hunk occurs.  Diff mode
highlights each hunk header, to distinguish it from the actual contents
of the hunk.

   You can edit a Diff mode buffer like any other buffer.  (If it is
read-only, you need to make it writable first.  *Note Misc Buffer::.)
Whenever you change a hunk, Diff mode attempts to automatically correct
the line numbers in the hunk headers, to ensure that the diff remains
"correct".  To disable automatic line number correction, change the
variable `diff-update-on-the-fly' to `nil'.

   Diff mode treats each hunk as an "error message", similar to
Compilation mode.  Thus, you can use commands such as `C-x '' to visit
the corresponding source locations.  *Note Compilation Mode::.

   In addition, Diff mode provides the following commands to navigate,
manipulate and apply parts of patches:

`M-n'
     Move to the next hunk-start (`diff-hunk-next').

     This command has a side effect: it "refines" the hunk you move to,
     highlighting its changes with better granularity.  To disable this
     feature, type `M-x diff-auto-refine-mode' to toggle off the minor
     mode Diff Auto-Refine mode.  To disable Diff Auto Refine mode by
     default, add this to your init file (*note Hooks::):

          (add-hook 'diff-mode-hook
                    (lambda () (diff-auto-refine-mode -1)))

`M-p'
     Move to the previous hunk-start (`diff-hunk-prev').  Like `M-n',
     this has the side-effect of refining the hunk you move to, unless
     you disable Diff Auto-Refine mode.

`M-}'
     Move to the next file-start, in a multi-file patch
     (`diff-file-next').

`M-{'
     Move to the previous file-start, in a multi-file patch
     (`diff-file-prev').

`M-k'
     Kill the hunk at point (`diff-hunk-kill').

`M-K'
     In a multi-file patch, kill the current file part.
     (`diff-file-kill').

`C-c C-a'
     Apply this hunk to its target file (`diff-apply-hunk').  With a
     prefix argument of `C-u', revert this hunk.

`C-c C-b'
     Highlight the changes of the hunk at point with a finer granularity
     (`diff-refine-hunk').  This allows you to see exactly which parts
     of each changed line were actually changed.

`C-c C-c'
     Go to the source file and line corresponding to this hunk
     (`diff-goto-source').

`C-c C-e'
     Start an Ediff session with the patch (`diff-ediff-patch').  *Note
     Ediff: (ediff)Top.

`C-c C-n'
     Restrict the view to the current hunk (`diff-restrict-view').
     *Note Narrowing::.  With a prefix argument of `C-u', restrict the
     view to the current file of a multiple-file patch.  To widen again,
     use `C-x n w' (`widen').

`C-c C-r'
     Reverse the direction of comparison for the entire buffer
     (`diff-reverse-direction').

`C-c C-s'
     Split the hunk at point (`diff-split-hunk').  This is for manually
     editing patches, and only works with the "unified diff format"
     produced by the `-u' or `--unified' options to the `diff' program.
     If you need to split a hunk in the "context diff format" produced
     by the `-c' or `--context' options to `diff', first convert the
     buffer to the unified diff format with `C-c C-u'.

`C-c C-d'
     Convert the entire buffer to the "context diff format"
     (`diff-unified->context').  With a prefix argument, convert only
     the text within the region.

`C-c C-u'
     Convert the entire buffer to unified diff format
     (`diff-context->unified').  With a prefix argument, convert
     unified format to context format.  When the mark is active, convert
     only the text within the region.

`C-c C-w'
     Refine the current hunk so that it disregards changes in whitespace
     (`diff-refine-hunk').

`C-x 4 A'
     Generate a ChangeLog entry, like `C-x 4 a' does (*note Change
     Log::), for each one of the hunks
     (`diff-add-change-log-entries-other-window').  This creates a
     skeleton of the log of changes that you can later fill with the
     actual descriptions of the changes.  `C-x 4 a' itself in Diff mode
     operates on behalf of the current hunk's file, but gets the
     function name from the patch itself.  This is useful for making
     log entries for functions that are deleted by the patch.

   By default, Diff mode highlights trailing whitespace on modified
lines, so that they are more obvious.  This is done by enabling
Whitespace mode in the Diff buffer (*note Useless Whitespace::).  Diff
mode buffers are set up so that Whitespace mode avoids highlighting
trailing whitespace occurring in the diff context.


File: emacs,  Node: Misc File Ops,  Next: Compressed Files,  Prev: Diff Mode,  Up: Files

18.11 Miscellaneous File Operations
===================================

Emacs has commands for performing many other operations on files.  All
operate on one file; they do not accept wildcard file names.

   `M-x delete-file' prompts for a file and deletes it.  If you are
deleting many files in one directory, it may be more convenient to use
Dired rather than `delete-file'.  *Note Dired Deletion::.

   `M-x move-file-to-trash' moves a file into the system "Trash" (or
"Recycle Bin").  This is a facility available on most operating
systems; files that are moved into the Trash can be brought back later
if you change your mind.

   By default, Emacs deletion commands do _not_ use the Trash.  To use
the Trash (when it is available) for common deletion commands, change
the variable `delete-by-moving-to-trash' to `t'.  This affects the
commands `M-x delete-file' and `M-x delete-directory' (*note
Directories::), as well as the deletion commands in Dired (*note Dired
Deletion::).  Supplying a prefix argument to `M-x delete-file' or `M-x
delete-directory' makes them delete outright, instead of using the
Trash, regardless of `delete-by-moving-to-trash'.

   If a file is under version control (*note Version Control::), you
should delete it using `M-x vc-delete-file' instead of `M-x
delete-file'.  *Note VC Delete/Rename::.

   `M-x copy-file' reads the file OLD and writes a new file named NEW
with the same contents.

   `M-x copy-directory' copies directories, similar to the `cp -r'
shell command.  It prompts for a directory OLD and a destination NEW.
If NEW is an existing directory, it creates a copy of the OLD directory
and puts it in NEW.  If NEW is not an existing directory, it copies all
the contents of OLD into a new directory named NEW.

   `M-x rename-file' reads two file names OLD and NEW using the
minibuffer, then renames file OLD as NEW.  If the file name NEW already
exists, you must confirm with `yes' or renaming is not done; this is
because renaming causes the old meaning of the name NEW to be lost.  If
OLD and NEW are on different file systems, the file OLD is copied and
deleted.  If the argument NEW is just a directory name, the real new
name is in that directory, with the same non-directory component as
OLD.  For example, `M-x rename-file RET ~/foo RET /tmp RET' renames
`~/foo' to `/tmp/foo'.  The same rule applies to all the remaining
commands in this section.  All of them ask for confirmation when the
new file name already exists, too.

   If a file is under version control (*note Version Control::), you
should rename it using `M-x vc-rename-file' instead of `M-x
rename-file'.  *Note VC Delete/Rename::.

   `M-x add-name-to-file' adds an additional name to an existing file
without removing its old name.  The new name is created as a "hard
link" to the existing file.  The new name must belong on the same file
system that the file is on.  On MS-Windows, this command works only if
the file resides in an NTFS file system.  On MS-DOS, it works by
copying the file.

   `M-x make-symbolic-link' reads two file names TARGET and LINKNAME,
then creates a symbolic link named LINKNAME, which points at TARGET.
The effect is that future attempts to open file LINKNAME will refer to
whatever file is named TARGET at the time the opening is done, or will
get an error if the name TARGET is nonexistent at that time.  This
command does not expand the argument TARGET, so that it allows you to
specify a relative name as the target of the link.  Not all systems
support symbolic links; on systems that don't support them, this
command is not defined.

   `M-x insert-file' (also `C-x i') inserts a copy of the contents of
the specified file into the current buffer at point, leaving point
unchanged before the contents.  The position after the inserted
contents is added to the mark ring, without activating the mark (*note
Mark Ring::).

   `M-x insert-file-literally' is like `M-x insert-file', except the
file is inserted "literally": it is treated as a sequence of ASCII
characters with no special encoding or conversion, similar to the `M-x
find-file-literally' command (*note Visiting::).

   `M-x write-region' is the inverse of `M-x insert-file'; it copies
the contents of the region into the specified file.  `M-x
append-to-file' adds the text of the region to the end of the specified
file.  *Note Accumulating Text::.  The variable
`write-region-inhibit-fsync' applies to these commands, as well as
saving files; see *note Customize Save::.

   `M-x set-file-modes' reads a file name followed by a "file mode",
and applies that file mode to the specified file.  File modes, also
called "file permissions", determine whether a file can be read,
written to, or executed, and by whom.  This command reads file modes
using the same symbolic or octal format accepted by the `chmod'
command; for instance, `u+x' means to add execution permission for the
user who owns the file.  It has no effect on operating systems that do
not support file modes.  `chmod' is a convenience alias for this
function.


File: emacs,  Node: Compressed Files,  Next: File Archives,  Prev: Misc File Ops,  Up: Files

18.12 Accessing Compressed Files
================================

Emacs automatically uncompresses compressed files when you visit them,
and automatically recompresses them if you alter them and save them.
Emacs recognizes compressed files by their file names.  File names
ending in `.gz' indicate a file compressed with `gzip'.  Other endings
indicate other compression programs.

   Automatic uncompression and compression apply to all the operations
in which Emacs uses the contents of a file.  This includes visiting it,
saving it, inserting its contents into a buffer, loading it, and byte
compiling it.

   To disable this feature, type the command `M-x
auto-compression-mode'.  You can disable it permanently by customizing
the variable `auto-compression-mode'.


File: emacs,  Node: File Archives,  Next: Remote Files,  Prev: Compressed Files,  Up: Files

18.13 File Archives
===================

A file whose name ends in `.tar' is normally an "archive" made by the
`tar' program.  Emacs views these files in a special mode called Tar
mode which provides a Dired-like list of the contents (*note Dired::).
You can move around through the list just as you would in Dired, and
visit the subfiles contained in the archive.  However, not all Dired
commands are available in Tar mode.

   If Auto Compression mode is enabled (*note Compressed Files::), then
Tar mode is used also for compressed archives--files with extensions
`.tgz', `.tar.Z' and `.tar.gz'.

   The keys `e', `f' and <RET> all extract a component file into its
own buffer.  You can edit it there, and if you save the buffer, the
edited version will replace the version in the Tar buffer.  Clicking
with the mouse on the file name in the Tar buffer does likewise.  `v'
extracts a file into a buffer in View mode (*note View Mode::).  `o'
extracts the file and displays it in another window, so you could edit
the file and operate on the archive simultaneously.

   `d' marks a file for deletion when you later use `x', and `u'
unmarks a file, as in Dired.  `C' copies a file from the archive to
disk and `R' renames a file within the archive.  `g' reverts the buffer
from the archive on disk.  The keys `M', `G', and `O' change the file's
permission bits, group, and owner, respectively.

   Saving the Tar buffer writes a new version of the archive to disk
with the changes you made to the components.

   You don't need the `tar' program to use Tar mode--Emacs reads the
archives directly.  However, accessing compressed archives requires the
appropriate uncompression program.

   A separate but similar Archive mode is used for `arc', `jar', `lzh',
`zip', `rar', `7z', and `zoo' archives, as well as `exe' files that are
self-extracting executables.

   The key bindings of Archive mode are similar to those in Tar mode,
with the addition of the `m' key which marks a file for subsequent
operations, and `M-<DEL>' which unmarks all the marked files.  Also,
the `a' key toggles the display of detailed file information, for those
archive types where it won't fit in a single line.  Operations such as
renaming a subfile, or changing its mode or owner, are supported only
for some of the archive formats.

   Unlike Tar mode, Archive mode runs the archiving programs to unpack
and repack archives.  However, you don't need these programs to look at
the archive table of contents, only to extract or manipulate the
subfiles in the archive.  Details of the program names and their
options can be set in the `Archive' Customize group.


File: emacs,  Node: Remote Files,  Next: Quoted File Names,  Prev: File Archives,  Up: Files

18.14 Remote Files
==================

You can refer to files on other machines using a special file name
syntax:

     /HOST:FILENAME
     /USER@HOST:FILENAME
     /USER@HOST#PORT:FILENAME
     /METHOD:USER@HOST:FILENAME
     /METHOD:USER@HOST#PORT:FILENAME

To carry out this request, Emacs uses a remote-login program such as
`ftp', `ssh', `rlogin', or `telnet'.  You can always specify in the
file name which method to use--for example, `/ftp:USER@HOST:FILENAME'
uses FTP, whereas `/ssh:USER@HOST:FILENAME' uses `ssh'.  When you don't
specify a method in the file name, Emacs chooses the method as follows:

  1. If the host name starts with `ftp.' (with dot), Emacs uses FTP.

  2. If the user name is `ftp' or `anonymous', Emacs uses FTP.

  3. If the variable `tramp-default-method' is set to `ftp', Emacs uses
     FTP.

  4. If `ssh-agent' is running, Emacs uses `scp'.

  5. Otherwise, Emacs uses `ssh'.

You can entirely turn off the remote file name feature by setting the
variable `tramp-mode' to `nil'.  You can turn off the feature in
individual cases by quoting the file name with `/:' (*note Quoted File
Names::).

   Remote file access through FTP is handled by the Ange-FTP package,
which is documented in the following.  Remote file access through the
other methods is handled by the Tramp package, which has its own manual.
*Note The Tramp Manual: (tramp)Top.

   When the Ange-FTP package is used, Emacs logs in through FTP using
the name USER, if that is specified in the remote file name.  If USER
is unspecified, Emacs logs in using your user name on the local system;
but if you set the variable `ange-ftp-default-user' to a string, that
string is used instead.  When logging in, Emacs may also ask for a
password.

   For performance reasons, Emacs does not make backup files for files
accessed via FTP by default.  To make it do so, change the variable
`ange-ftp-make-backup-files' to a non-`nil' value.

   By default, auto-save files for remote files are made in the
temporary file directory on the local machine, as specified by the
variable `auto-save-file-name-transforms'.  *Note Auto Save Files::.

   To visit files accessible by anonymous FTP, you use special user
names `anonymous' or `ftp'.  Passwords for these user names are handled
specially.  The variable `ange-ftp-generate-anonymous-password'
controls what happens: if the value of this variable is a string, then
that string is used as the password; if non-`nil' (the default), then
the value of `user-mail-address' is used; if `nil', then Emacs prompts
you for a password as usual (*note Passwords::).

   Sometimes you may be unable to access files on a remote machine
because a "firewall" in between blocks the connection for security
reasons.  If you can log in on a "gateway" machine from which the
target files _are_ accessible, and whose FTP server supports gatewaying
features, you can still use remote file names; all you have to do is
specify the name of the gateway machine by setting the variable
`ange-ftp-gateway-host', and set `ange-ftp-smart-gateway' to `t'.
Otherwise you may be able to make remote file names work, but the
procedure is complex.  You can read the instructions by typing `M-x
finder-commentary <RET> ange-ftp <RET>'.


File: emacs,  Node: Quoted File Names,  Next: File Name Cache,  Prev: Remote Files,  Up: Files

18.15 Quoted File Names
=======================

You can "quote" an absolute file name to prevent special characters and
syntax in it from having their special effects.  The way to do this is
to add `/:' at the beginning.

   For example, you can quote a local file name which appears remote, to
prevent it from being treated as a remote file name.  Thus, if you have
a directory named `/foo:' and a file named `bar' in it, you can refer
to that file in Emacs as `/:/foo:/bar'.

   `/:' can also prevent `~' from being treated as a special character
for a user's home directory.  For example, `/:/tmp/~hack' refers to a
file whose name is `~hack' in directory `/tmp'.

   Quoting with `/:' is also a way to enter in the minibuffer a file
name that contains `$'.  In order for this to work, the `/:' must be at
the beginning of the minibuffer contents.  (You can also double each
`$'; see *note File Names with $::.)

   You can also quote wildcard characters with `/:', for visiting.  For
example, `/:/tmp/foo*bar' visits the file `/tmp/foo*bar'.

   Another method of getting the same result is to enter
`/tmp/foo[*]bar', which is a wildcard specification that matches only
`/tmp/foo*bar'.  However, in many cases there is no need to quote the
wildcard characters because even unquoted they give the right result.
For example, if the only file name in `/tmp' that starts with `foo' and
ends with `bar' is `foo*bar', then specifying `/tmp/foo*bar' will visit
only `/tmp/foo*bar'.


File: emacs,  Node: File Name Cache,  Next: File Conveniences,  Prev: Quoted File Names,  Up: Files

18.16 File Name Cache
=====================

You can use the "file name cache" to make it easy to locate a file by
name, without having to remember exactly where it is located.  When
typing a file name in the minibuffer, `C-<tab>'
(`file-cache-minibuffer-complete') completes it using the file name
cache.  If you repeat `C-<tab>', that cycles through the possible
completions of what you had originally typed.  (However, note that the
`C-<tab>' character cannot be typed on most text terminals.)

   The file name cache does not fill up automatically.  Instead, you
load file names into the cache using these commands:

`M-x file-cache-add-directory <RET> DIRECTORY <RET>'
     Add each file name in DIRECTORY to the file name cache.

`M-x file-cache-add-directory-using-find <RET> DIRECTORY <RET>'
     Add each file name in DIRECTORY and all of its nested
     subdirectories to the file name cache.

`M-x file-cache-add-directory-using-locate <RET> DIRECTORY <RET>'
     Add each file name in DIRECTORY and all of its nested
     subdirectories to the file name cache, using `locate' to find them
     all.

`M-x file-cache-add-directory-list <RET> VARIABLE <RET>'
     Add each file name in each directory listed in VARIABLE to the
     file name cache.  VARIABLE should be a Lisp variable whose value
     is a list of directory names, like `load-path'.

`M-x file-cache-clear-cache <RET>'
     Clear the cache; that is, remove all file names from it.

   The file name cache is not persistent: it is kept and maintained
only for the duration of the Emacs session.  You can view the contents
of the cache with the `file-cache-display' command.


File: emacs,  Node: File Conveniences,  Next: Filesets,  Prev: File Name Cache,  Up: Files

18.17 Convenience Features for Finding Files
============================================

In this section, we introduce some convenient facilities for finding
recently-opened files, reading file names from a buffer, and viewing
image files.

   If you enable Recentf mode, with `M-x recentf-mode', the `File' menu
includes a submenu containing a list of recently opened files.  `M-x
recentf-save-list' saves the current `recent-file-list' to a file, and
`M-x recentf-edit-list' edits it.

   The `M-x ffap' command generalizes `find-file' with more powerful
heuristic defaults (*note FFAP::), often based on the text at point.
Partial Completion mode offers other features extending `find-file',
which can be used with `ffap'.  *Note Completion Options::.

   Visiting image files automatically selects Image mode.  In this
major mode, you can type `C-c C-c' (`image-toggle-display') to toggle
between displaying the file as an image in the Emacs buffer, and
displaying its underlying text (or raw byte) representation.
Displaying the file as an image works only if Emacs is compiled with
support for displaying such images.  If the displayed image is wider or
taller than the frame, the usual point motion keys (`C-f', `C-p', and
so forth) cause different parts of the image to be displayed.  If the
image can be animated, the command `RET' (`image-toggle-animation')
starts or stops the animation.  Animation plays once, unless the option
`image-animate-loop' is non-`nil'.  Currently, Emacs only supports
animation in GIF files.

   If your Emacs was compiled with ImageMagick support, it is possible
to view a much wider variety of image types in Image mode, by rendering
the images via ImageMagick.  However, this feature is currently
disabled by default.  To enable it, add the following line to your init
file:

     (imagemagick-register-types)

   The Image-Dired package can also be used to view images as
thumbnails.  *Note Image-Dired::.


File: emacs,  Node: Filesets,  Prev: File Conveniences,  Up: Files

18.18 Filesets
==============

If you regularly edit a certain group of files, you can define them as
a "fileset".  This lets you perform certain operations, such as
visiting, `query-replace', and shell commands on all the files at once.
To make use of filesets, you must first add the expression
`(filesets-init)' to your init file (*note Init File::).  This adds a
`Filesets' menu to the menu bar.

   The simplest way to define a fileset is by adding files to it one at
a time.  To add a file to fileset NAME, visit the file and type `M-x
filesets-add-buffer RET NAME RET'.  If there is no fileset NAME, this
creates a new one, which initially contains only the current file.  The
command `M-x filesets-remove-buffer' removes the current file from a
fileset.

   You can also edit the list of filesets directly, with `M-x
filesets-edit' (or by choosing `Edit Filesets' from the `Filesets'
menu).  The editing is performed in a Customize buffer (*note Easy
Customization::).  Normally, a fileset is a simple list of files, but
you can also define a fileset as a regular expression matching file
names.  Some examples of these more complicated filesets are shown in
the Customize buffer.  Remember to select `Save for future sessions' if
you want to use the same filesets in future Emacs sessions.

   You can use the command `M-x filesets-open' to visit all the files
in a fileset, and `M-x filesets-close' to close them.  Use `M-x
filesets-run-cmd' to run a shell command on all the files in a fileset.
These commands are also available from the `Filesets' menu, where each
existing fileset is represented by a submenu.

   *Note Version Control::, for a different concept of "filesets":
groups of files bundled together for version control operations.
Filesets of that type are unnamed, and do not persist across Emacs
sessions.


File: emacs,  Node: Buffers,  Next: Windows,  Prev: Files,  Up: Top

19 Using Multiple Buffers
*************************

The text you are editing in Emacs resides in an object called a
"buffer".  Each time you visit a file, a buffer is used to hold the
file's text.  Each time you invoke Dired, a buffer is used to hold the
directory listing.  If you send a message with `C-x m', a buffer is
used to hold the text of the message.  When you ask for a command's
documentation, that appears in a buffer named `*Help*'.

   Each buffer has a unique name, which can be of any length.  When a
buffer is displayed in a window, its name is shown in the mode line
(*note Mode Line::).  The distinction between upper and lower case
matters in buffer names.  Most buffers are made by visiting files, and
their names are derived from the files' names; however, you can also
create an empty buffer with any name you want.  A newly started Emacs
has several buffers, including one named `*scratch*', which can be used
for evaluating Lisp expressions and is not associated with any file
(*note Lisp Interaction::).

   At any time, one and only one buffer is "selected"; we call it the
"current buffer".  We sometimes say that a command operates on "the
buffer"; this really means that it operates on the current buffer.
When there is only one Emacs window, the buffer displayed in that
window is current.  When there are multiple windows, the buffer
displayed in the "selected window" is current.  *Note Windows::.

   Aside from its textual contents, each buffer records several pieces
of information, such as what file it is visiting (if any), whether it
is modified, and what major mode and minor modes are in effect (*note
Modes::).  These are stored in "buffer-local variables"--variables that
can have a different value in each buffer.  *Note Locals::.

   A buffer's size cannot be larger than some maximum, which is defined
by the largest buffer position representable by "Emacs integers".  This
is because Emacs tracks buffer positions using that data type.  For
typical 64-bit machines, this maximum buffer size is 2^61 - 2 bytes, or
about 2 EiB.  For typical 32-bit machines, the maximum is usually 2^29
- 2 bytes, or about 512 MiB.  Buffer sizes are also limited by the
amount of memory in the system.

* Menu:

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::         Renaming; changing read-onlyness; copying text.
* Kill Buffer::         Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
                          and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer.
* Buffer Convenience::  Convenience and customization features for
                          buffer handling.


File: emacs,  Node: Select Buffer,  Next: List Buffers,  Up: Buffers

19.1 Creating and Selecting Buffers
===================================

`C-x b BUFFER <RET>'
     Select or create a buffer named BUFFER (`switch-to-buffer').

`C-x 4 b BUFFER <RET>'
     Similar, but select BUFFER in another window
     (`switch-to-buffer-other-window').

`C-x 5 b BUFFER <RET>'
     Similar, but select BUFFER in a separate frame
     (`switch-to-buffer-other-frame').

`C-x <LEFT>'
     Select the previous buffer in the buffer list (`previous-buffer').

`C-x <RIGHT>'
     Select the next buffer in the buffer list (`next-buffer').

`C-u M-g M-g'
`C-u M-g g'
     Read a number N and move to line N in the most recently selected
     buffer other than the current buffer.

   The `C-x b' (`switch-to-buffer') command reads a buffer name using
the minibuffer.  Then it makes that buffer current, and displays it in
the currently-selected window.  An empty input specifies the buffer
that was current most recently among those not now displayed in any
window.

   While entering the buffer name, you can use the usual completion and
history commands (*note Minibuffer::).  Note that `C-x b', and related
commands, use "permissive completion with confirmation" for minibuffer
completion: if you type <RET> immediately after completing up to a
nonexistent buffer name, Emacs prints `[Confirm]' and you must type a
second <RET> to submit that buffer name.  *Note Completion Exit::, for
details.

   If you specify a buffer that does not exist, `C-x b' creates a new,
empty buffer that is not visiting any file, and selects it for editing.
The default value of the variable `major-mode' determines the new
buffer's major mode; the default value is Fundamental mode.  *Note
Major Modes::.  One reason to create a new buffer is to use it for
making temporary notes.  If you try to save it, Emacs asks for the file
name to use, and the buffer's major mode is re-established taking that
file name into account (*note Choosing Modes::).

   For conveniently switching between a few buffers, use the commands
`C-x <LEFT>' and `C-x <RIGHT>'.  `C-x <LEFT>' (`previous-buffer')
selects the previous buffer (following the order of most recent
selection in the current frame), while `C-x <RIGHT>' (`next-buffer')
moves through buffers in the reverse direction.

   To select a buffer in a window other than the current one, type `C-x
4 b' (`switch-to-buffer-other-window').  This prompts for a buffer name
using the minibuffer, displays that buffer in another window, and
selects that window.

   Similarly, `C-x 5 b' (`switch-to-buffer-other-frame') prompts for a
buffer name, displays that buffer in another frame, and selects that
frame.  If the buffer is already being shown in a window on another
frame, Emacs selects that window and frame instead of creating a new
frame.

   *Note Displaying Buffers::, for how the `C-x 4 b' and `C-x 5 b'
commands get the window and/or frame to display in.

   In addition, `C-x C-f', and any other command for visiting a file,
can also be used to switch to an existing file-visiting buffer.  *Note
Visiting::.

   `C-u M-g M-g', that is `goto-line' with a plain prefix argument,
reads a number N using the minibuffer, selects the most recently
selected buffer other than the current buffer in another window, and
then moves point to the beginning of line number N in that buffer.
This is mainly useful in a buffer that refers to line numbers in
another buffer: if point is on or just after a number, `goto-line' uses
that number as the default for N.  Note that prefix arguments other
than just `C-u' behave differently.  `C-u 4 M-g M-g' goes to line 4 in
the _current_ buffer, without reading a number from the minibuffer.
(Remember that `M-g M-g' without prefix argument reads a number N and
then moves to line number N in the current buffer.  *Note Moving
Point::.)

   Emacs uses buffer names that start with a space for internal
purposes.  It treats these buffers specially in minor ways--for
example, by default they do not record undo information.  It is best to
avoid using such buffer names yourself.


File: emacs,  Node: List Buffers,  Next: Misc Buffer,  Prev: Select Buffer,  Up: Buffers

19.2 Listing Existing Buffers
=============================

`C-x C-b'
     List the existing buffers (`list-buffers').

   To display a list of existing buffers, type `C-x C-b'.  Each line in
the list shows one buffer's name, major mode and visited file.  The
buffers are listed in the order that they were current; the buffers
that were current most recently come first.

   `.' in the first field of a line indicates that the buffer is
current.  `%' indicates a read-only buffer.  `*' indicates that the
buffer is "modified".  If several buffers are modified, it may be time
to save some with `C-x s' (*note Save Commands::).  Here is an example
of a buffer list:

     CRM Buffer                Size  Mode              File
     . * .emacs                3294  Emacs-Lisp        ~/.emacs
      %  *Help*                 101  Help
         search.c             86055  C                 ~/cvs/emacs/src/search.c
      %  src                  20959  Dired by name     ~/cvs/emacs/src/
       * *mail*                  42  Mail
      %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
      %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
         *scratch*              191  Lisp Interaction
       * *Messages*            1554  Fundamental

The buffer `*Help*' was made by a help request (*note Help::); it is
not visiting any file.  The buffer `src' was made by Dired on the
directory `~/cvs/emacs/src/'.  You can list only buffers that are
visiting files by giving the command a prefix argument, as in `C-u C-x
C-b'.

   `list-buffers' omits buffers whose names begin with a space, unless
they visit files: such buffers are used internally by Emacs.


File: emacs,  Node: Misc Buffer,  Next: Kill Buffer,  Prev: List Buffers,  Up: Buffers

19.3 Miscellaneous Buffer Operations
====================================

`C-x C-q'
     Toggle read-only status of buffer (`toggle-read-only').

`M-x rename-buffer <RET> NAME <RET>'
     Change the name of the current buffer.

`M-x rename-uniquely'
     Rename the current buffer by adding `<NUMBER>' to the end.

`M-x view-buffer <RET> BUFFER <RET>'
     Scroll through buffer BUFFER.  *Note View Mode::.

   A buffer can be "read-only", which means that commands to change its
contents are not allowed.  The mode line indicates read-only buffers
with `%%' or `%*' near the left margin.  Read-only buffers are usually
made by subsystems such as Dired and Rmail that have special commands
to operate on the text; also by visiting a file whose access control
says you cannot write it.

   The command `C-x C-q' (`toggle-read-only') makes a read-only buffer
writable, and makes a writable buffer read-only.  This works by setting
the variable `buffer-read-only', which has a local value in each buffer
and makes the buffer read-only if its value is non-`nil'.

   `M-x rename-buffer' changes the name of the current buffer.  You
specify the new name as a minibuffer argument; there is no default.  If
you specify a name that is in use for some other buffer, an error
happens and no renaming is done.

   `M-x rename-uniquely' renames the current buffer to a similar name
with a numeric suffix added to make it both different and unique.  This
command does not need an argument.  It is useful for creating multiple
shell buffers: if you rename the `*shell*' buffer, then do `M-x shell'
again, it makes a new shell buffer named `*shell*'; meanwhile, the old
shell buffer continues to exist under its new name.  This method is
also good for mail buffers, compilation buffers, and most Emacs
features that create special buffers with particular names.  (With some
of these features, such as `M-x compile', `M-x grep', you need to
switch to some other buffer before using the command again, otherwise
it will reuse the current buffer despite the name change.)

   The commands `M-x append-to-buffer' and `M-x insert-buffer' can also
be used to copy text from one buffer to another.  *Note Accumulating
Text::.


File: emacs,  Node: Kill Buffer,  Next: Several Buffers,  Prev: Misc Buffer,  Up: Buffers

19.4 Killing Buffers
====================

If you continue an Emacs session for a while, you may accumulate a
large number of buffers.  You may then find it convenient to "kill" the
buffers you no longer need.  On most operating systems, killing a
buffer releases its space back to the operating system so that other
programs can use it.  Here are some commands for killing buffers:

`C-x k BUFNAME <RET>'
     Kill buffer BUFNAME (`kill-buffer').

`M-x kill-some-buffers'
     Offer to kill each buffer, one by one.

`M-x kill-matching-buffers'
     Offer to kill all buffers matching a regular expression.

   `C-x k' (`kill-buffer') kills one buffer, whose name you specify in
the minibuffer.  The default, used if you type just <RET> in the
minibuffer, is to kill the current buffer.  If you kill the current
buffer, another buffer becomes current: one that was current in the
recent past but is not displayed in any window now.  If you ask to kill
a file-visiting buffer that is modified, then you must confirm with
`yes' before the buffer is killed.

   The command `M-x kill-some-buffers' asks about each buffer, one by
one.  An answer of `y' means to kill the buffer, just like
`kill-buffer'.  This command ignores buffers whose names begin with a
space, which are used internally by Emacs.

   The command `M-x kill-matching-buffers' prompts for a regular
expression and kills all buffers whose names match that expression.
*Note Regexps::.  Like `kill-some-buffers', it asks for confirmation
before each kill.  This command normally ignores buffers whose names
begin with a space, which are used internally by Emacs.  To kill
internal buffers as well, call `kill-matching-buffers' with a prefix
argument.

   The buffer menu feature is also convenient for killing various
buffers.  *Note Several Buffers::.

   If you want to do something special every time a buffer is killed,
you can add hook functions to the hook `kill-buffer-hook' (*note
Hooks::).

   If you run one Emacs session for a period of days, as many people do,
it can fill up with buffers that you used several days ago.  The command
`M-x clean-buffer-list' is a convenient way to purge them; it kills all
the unmodified buffers that you have not used for a long time.  An
ordinary buffer is killed if it has not been displayed for three days;
however, you can specify certain buffers that should never be killed
automatically, and others that should be killed if they have been unused
for a mere hour.

   You can also have this buffer purging done for you, once a day, by
enabling Midnight mode.  Midnight mode operates each day at midnight;
at that time, it runs `clean-buffer-list', or whichever functions you
have placed in the normal hook `midnight-hook' (*note Hooks::).  To
enable Midnight mode, use the Customization buffer to set the variable
`midnight-mode' to `t'.  *Note Easy Customization::.


File: emacs,  Node: Several Buffers,  Next: Indirect Buffers,  Prev: Kill Buffer,  Up: Buffers

19.5 Operating on Several Buffers
=================================

`M-x buffer-menu'
     Begin editing a buffer listing all Emacs buffers.

`M-x buffer-menu-other-window.'
     Similar, but do it in another window.

   The "buffer menu" opened by `C-x C-b' (*note List Buffers::) does
not merely list buffers.  It also allows you to perform various
operations on buffers, through an interface similar to Dired (*note
Dired::).  You can save buffers, kill them (here called "deleting"
them, for consistency with Dired), or display them.

   To use the buffer menu, type `C-x C-b' and switch to the window
displaying the `*Buffer List*' buffer.  You can also type `M-x
buffer-menu' to open the buffer menu in the selected window.
Alternatively, the command `M-x buffer-menu-other-window' opens the
buffer menu in another window, and selects that window.

   The buffer menu is a read-only buffer, and can be changed only
through the special commands described in this section.  The usual
cursor motion commands can be used in this buffer.  The following
commands apply to the buffer described on the current line:

`d'
     Request to delete (kill) the buffer, then move down.  The request
     shows as a `D' on the line, before the buffer name.  Requested
     deletions take place when you type the `x' command.

`C-d'
     Like `d' but move up afterwards instead of down.

`s'
     Request to save the buffer.  The request shows as an `S' on the
     line.  Requested saves take place when you type the `x' command.
     You may request both saving and deletion for the same buffer.

`x'
     Perform previously requested deletions and saves.

`u'
     Remove any request made for the current line, and move down.

`<DEL>'
     Move to previous line and remove any request made for that line.

   The `d', `C-d', `s' and `u' commands to add or remove flags also
move down (or up) one line.  They accept a numeric argument as a repeat
count.

   These commands operate immediately on the buffer listed on the
current line:

`~'
     Mark the buffer "unmodified".  The command `~' does this
     immediately when you type it.

`%'
     Toggle the buffer's read-only flag.  The command `%' does this
     immediately when you type it.

`t'
     Visit the buffer as a tags table.  *Note Select Tags Table::.

   There are also commands to select another buffer or buffers:

`q'
     Quit the buffer menu--immediately display the most recent formerly
     visible buffer in its place.

`<RET>'
`f'
     Immediately select this line's buffer in place of the `*Buffer
     List*' buffer.

`o'
     Immediately select this line's buffer in another window as if by
     `C-x 4 b', leaving `*Buffer List*' visible.

`C-o'
     Immediately display this line's buffer in another window, but don't
     select the window.

`1'
     Immediately select this line's buffer in a full-screen window.

`2'
     Immediately set up two windows, with this line's buffer selected in
     one, and the previously current buffer (aside from the buffer
     `*Buffer List*') displayed in the other.

`b'
     Bury the buffer listed on this line.

`m'
     Mark this line's buffer to be displayed in another window if you
     exit with the `v' command.  The request shows as a `>' at the
     beginning of the line.  (A single buffer may not have both a delete
     request and a display request.)

`v'
     Immediately select this line's buffer, and also display in other
     windows any buffers previously marked with the `m' command.  If
     you have not marked any buffers, this command is equivalent to `1'.

   There is also a command that affects the entire buffer list:

`T'
     Delete, or reinsert, lines for non-file buffers.  This command
     toggles the inclusion of such buffers in the buffer list.

   What `buffer-menu' actually does is create and switch to a suitable
buffer, and turn on Buffer Menu mode in it.  Everything else described
above is implemented by the special commands provided in Buffer Menu
mode.  One consequence of this is that you can switch from the `*Buffer
List*' buffer to another Emacs buffer, and edit there.  You can
reselect the `*Buffer List*' buffer later, to perform the operations
already requested, or you can kill it, or pay no further attention to
it.

   Normally, the buffer `*Buffer List*' is not updated automatically
when buffers are created and killed; its contents are just text.  If
you have created, deleted or renamed buffers, the way to update
`*Buffer List*' to show what you have done is to type `g'
(`revert-buffer').  You can make this happen regularly every
`auto-revert-interval' seconds if you enable Auto Revert mode in this
buffer, as long as it is not marked modified.  Global Auto Revert mode
applies to the `*Buffer List*' buffer only if
`global-auto-revert-non-file-buffers' is non-`nil'.  *Note
global-auto-revert-non-file-buffers: Autorevert, for details.


File: emacs,  Node: Indirect Buffers,  Next: Buffer Convenience,  Prev: Several Buffers,  Up: Buffers

19.6 Indirect Buffers
=====================

An "indirect buffer" shares the text of some other buffer, which is
called the "base buffer" of the indirect buffer.  In some ways it is a
buffer analogue of a symbolic link between files.

`M-x make-indirect-buffer <RET> BASE-BUFFER <RET> INDIRECT-NAME <RET>'
     Create an indirect buffer named INDIRECT-NAME with base buffer
     BASE-BUFFER.  

`M-x clone-indirect-buffer <RET>'
     Create an indirect buffer that is a twin copy of the current
     buffer.

`C-x 4 c'
     Create an indirect buffer that is a twin copy of the current
     buffer, and select it in another window
     (`clone-indirect-buffer-other-window').

   The text of the indirect buffer is always identical to the text of
its base buffer; changes made by editing either one are visible
immediately in the other.  But in all other respects, the indirect
buffer and its base buffer are completely separate.  They can have
different names, different values of point, different narrowing,
different markers, different major modes, and different local variables.

   An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually works by saving the
base buffer.  Killing the base buffer effectively kills the indirect
buffer, but killing an indirect buffer has no effect on its base buffer.

   One way to use indirect buffers is to display multiple views of an
outline.  *Note Outline Views::.

   A quick and handy way to make an indirect buffer is with the command
`M-x clone-indirect-buffer'.  It creates and selects an indirect buffer
whose base buffer is the current buffer.  With a numeric argument, it
prompts for the name of the indirect buffer; otherwise it uses the name
of the current buffer, with a `<N>' suffix added.  `C-x 4 c'
(`clone-indirect-buffer-other-window') works like `M-x
clone-indirect-buffer', but it selects the new buffer in another
window.  These functions run the hook `clone-indirect-buffer-hook'
after creating the indirect buffer.

   The more general way to make an indirect buffer is with the command
`M-x make-indirect-buffer'.  It creates an indirect buffer named
INDIRECT-NAME from a buffer BASE-BUFFER, prompting for both using the
minibuffer.


File: emacs,  Node: Buffer Convenience,  Prev: Indirect Buffers,  Up: Buffers

19.7 Convenience Features and Customization of Buffer Handling
==============================================================

This section describes several modes and features that make it more
convenient to switch between buffers.

* Menu:

* Uniquify::               Making buffer names unique with directory parts.
* Iswitchb::               Switching between buffers with substrings.
* Buffer Menus::           Configurable buffer menu.


File: emacs,  Node: Uniquify,  Next: Iswitchb,  Up: Buffer Convenience

19.7.1 Making Buffer Names Unique
---------------------------------

When several buffers visit identically-named files, Emacs must give the
buffers distinct names.  The usual method for making buffer names
unique adds `<2>', `<3>', etc. to the end of the buffer names (all but
one of them).

   Other methods work by adding parts of each file's directory to the
buffer name.  To select one, load the library `uniquify' (e.g.  using
`(require 'uniquify)'), and customize the variable
`uniquify-buffer-name-style' (*note Easy Customization::).

   To begin with, the `forward' naming method includes part of the
file's directory name at the beginning of the buffer name; using this
method, buffers visiting the files `/u/rms/tmp/Makefile' and
`/usr/projects/zaphod/Makefile' would be named `tmp/Makefile' and
`zaphod/Makefile', respectively (instead of `Makefile' and
`Makefile<2>').

   In contrast, the `post-forward' naming method would call the buffers
`Makefile|tmp' and `Makefile|zaphod', and the `reverse' naming method
would call them `Makefile\tmp' and `Makefile\zaphod'.  The nontrivial
difference between `post-forward' and `reverse' occurs when just one
directory name is not enough to distinguish two files; then `reverse'
puts the directory names in reverse order, so that `/top/middle/file'
becomes `file\middle\top', while `post-forward' puts them in forward
order after the file name, as in `file|top/middle'.

   Which rule to follow for putting the directory names in the buffer
name is not very important if you are going to _look_ at the buffer
names before you type one.  But as an experienced user, if you know the
rule, you won't have to look.  And then you may find that one rule or
another is easier for you to remember and apply quickly.


File: emacs,  Node: Iswitchb,  Next: Buffer Menus,  Prev: Uniquify,  Up: Buffer Convenience

19.7.2 Switching Between Buffers using Substrings
-------------------------------------------------

Iswitchb global minor mode provides convenient switching between
buffers using substrings of their names.  It replaces the normal
definitions of `C-x b', `C-x 4 b', `C-x 5 b', and `C-x 4 C-o' with
alternative commands that are somewhat "smarter".

   When one of these commands prompts you for a buffer name, you can
type in just a substring of the name you want to choose.  As you enter
the substring, Iswitchb mode continuously displays a list of buffers
that match the substring you have typed.

   At any time, you can type <RET> to select the first buffer in the
list.  So the way to select a particular buffer is to make it the first
in the list.  There are two ways to do this.  You can type more of the
buffer name and thus narrow down the list, excluding unwanted buffers
above the desired one.  Alternatively, you can use `C-s' and `C-r' to
rotate the list until the desired buffer is first.

   <TAB> while entering the buffer name performs completion on the
string you have entered, based on the displayed list of buffers.

   To enable Iswitchb mode, type `M-x iswitchb-mode', or customize the
variable `iswitchb-mode' to `t' (*note Easy Customization::).


File: emacs,  Node: Buffer Menus,  Prev: Iswitchb,  Up: Buffer Convenience

19.7.3 Customizing Buffer Menus
-------------------------------

`M-x bs-show'
     Make a list of buffers similarly to `M-x list-buffers' but
     customizable.

   `M-x bs-show' pops up a buffer list similar to the one normally
displayed by `C-x C-b' but which you can customize.  If you prefer this
to the usual buffer list, you can bind this command to `C-x C-b'.  To
customize this buffer list, use the `bs' Custom group (*note Easy
Customization::).

   MSB global minor mode ("MSB" stands for "mouse select buffer")
provides a different and customizable mouse buffer menu which you may
prefer.  It replaces the bindings of `mouse-buffer-menu', normally on
`C-Down-Mouse-1', and the menu bar buffer menu.  You can customize the
menu in the `msb' Custom group.


File: emacs,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

20 Multiple Windows
*******************

Emacs can split a frame into two or many windows.  Multiple windows can
display parts of different buffers, or different parts of one buffer.
Multiple frames always imply multiple windows, because each frame has
its own set of windows.  Each window belongs to one and only one frame.

* Menu:

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Change Window::       Deleting windows and changing their sizes.
* Displaying Buffers::  How Emacs picks a window for displaying a buffer.
* Window Convenience::  Convenience functions for window handling.


File: emacs,  Node: Basic Window,  Next: Split Window,  Up: Windows

20.1 Concepts of Emacs Windows
==============================

Each Emacs window displays one Emacs buffer at any time.  A single
buffer may appear in more than one window; if it does, any changes in
its text are displayed in all the windows where it appears.  But these
windows can show different parts of the buffer, because each window has
its own value of point.

   At any time, one Emacs window is the "selected window"; the buffer
this window is displaying is the current buffer.  On graphical
displays, the point is indicated by a solid blinking cursor in the
selected window, and by a hollow box in non-selected windows.  On text
terminals, the cursor is drawn only in the selected window.  *Note
Cursor Display::.

   Commands to move point affect the value of point for the selected
Emacs window only.  They do not change the value of point in other
Emacs windows, even those showing the same buffer.  The same is true
for buffer-switching commands such as `C-x b'; they do not affect other
windows at all.  However, there are other commands such as `C-x 4 b'
that select a different window and switch buffers in it.  Also, all
commands that display information in a window, including (for example)
`C-h f' (`describe-function') and `C-x C-b' (`list-buffers'), work by
switching buffers in a nonselected window without affecting the
selected window.

   When multiple windows show the same buffer, they can have different
regions, because they can have different values of point.  However,
they all have the same value for the mark, because each buffer has only
one mark position.

   Each window has its own mode line, which displays the buffer name,
modification status and major and minor modes of the buffer that is
displayed in the window.  The selected window's mode line appears in a
different color.  *Note Mode Line::, for details.


File: emacs,  Node: Split Window,  Next: Other Window,  Prev: Basic Window,  Up: Windows

20.2 Splitting Windows
======================

`C-x 2'
     Split the selected window into two windows, one above the other
     (`split-window-below').

`C-x 3'
     Split the selected window into two windows, positioned side by side
     (`split-window-right').

`C-Mouse-2'
     In the mode line of a window, split that window.

   `C-x 2' (`split-window-below') splits the selected window into two
windows, one above the other.  After splitting, the selected window is
the upper one, and the newly split-off window is below.  Both windows
have the same value of point as before, and display the same portion of
the buffer (or as close to it as possible).  If necessary, the windows
are scrolled to keep point on-screen.  By default, the two windows each
get half the height of the original window.  A positive numeric
argument specifies how many lines to give to the top window; a negative
numeric argument specifies how many lines to give to the bottom window.

   If you change the variable `split-window-keep-point' to `nil', `C-x
2' instead adjusts the portion of the buffer displayed by the two
windows, as well as the value of point in each window, in order to keep
the text on the screen as close as possible to what it was before;
furthermore, if point was in the lower half of the original window, the
bottom window is selected instead of the upper one.

   `C-x 3' (`split-window-right') splits the selected window into two
side-by-side windows.  The left window is the selected one; the right
window displays the same portion of the same buffer, and has the same
value of point.  A positive numeric argument specifies how many columns
to give the left window; a negative numeric argument specifies how many
columns to give the right window.

   When you split a window with `C-x 3', each resulting window occupies
less than the full width of the frame.  If it becomes too narrow, the
buffer may be difficult to read if continuation lines are in use (*note
Continuation Lines::).  Therefore, Emacs automatically switches to line
truncation if the window width becomes narrower than 50 columns.  This
truncation occurs regardless of the value of the variable
`truncate-lines' (*note Line Truncation::); it is instead controlled by
the variable `truncate-partial-width-windows'.  If the value of this
variable is a positive integer (the default is 50), that specifies the
minimum width for a partial-width window before automatic line
truncation occurs; if the value is `nil', automatic line truncation is
disabled; and for any other non-`nil' value, Emacs truncates lines in
every partial-width window regardless of its width.

   On text terminals, side-by-side windows are separated by a vertical
divider which is drawn using the `vertical-border' face.

   If you click `C-Mouse-2' in the mode line of a window, that splits
the window, putting a vertical divider where you click.  Depending on
how Emacs is compiled, you can also split a window by clicking
`C-Mouse-2' in the scroll bar, which puts a horizontal divider where
you click (this feature does not work when Emacs uses GTK+ scroll bars).


File: emacs,  Node: Other Window,  Next: Pop Up Window,  Prev: Split Window,  Up: Windows

20.3 Using Other Windows
========================

`C-x o'
     Select another window (`other-window').

`C-M-v'
     Scroll the next window (`scroll-other-window').

`Mouse-1'
     `Mouse-1', in the text area of a window, selects the window and
     moves point to the position clicked.  Clicking in the mode line
     selects the window without moving point in it.

   With the keyboard, you can switch windows by typing `C-x o'
(`other-window').  That is an `o', for "other", not a zero.  When there
are more than two windows, this command moves through all the windows
in a cyclic order, generally top to bottom and left to right.  After
the rightmost and bottommost window, it goes back to the one at the
upper left corner.  A numeric argument means to move several steps in
the cyclic order of windows.  A negative argument moves around the
cycle in the opposite order.  When the minibuffer is active, the
minibuffer is the last window in the cycle; you can switch from the
minibuffer window to one of the other windows, and later switch back and
finish supplying the minibuffer argument that is requested.  *Note
Minibuffer Edit::.

   The usual scrolling commands (*note Display::) apply to the selected
window only, but there is one command to scroll the next window.
`C-M-v' (`scroll-other-window') scrolls the window that `C-x o' would
select.  It takes arguments, positive and negative, like `C-v'.  (In
the minibuffer, `C-M-v' scrolls the help window associated with the
minibuffer, if any, rather than the next window in the standard cyclic
order; *note Minibuffer Edit::.)

   If you set `mouse-autoselect-window' to a non-`nil' value, moving
the mouse over a different window selects that window.  This feature is
off by default.


File: emacs,  Node: Pop Up Window,  Next: Change Window,  Prev: Other Window,  Up: Windows

20.4 Displaying in Another Window
=================================

`C-x 4' is a prefix key for a variety of commands that switch to a
buffer in a different window--either another existing window, or a new
window created by splitting the selected window.  *Note Window
Choice::, for how Emacs picks or creates the window to use.

`C-x 4 b BUFNAME <RET>'
     Select buffer BUFNAME in another window
     (`switch-to-buffer-other-window').

`C-x 4 C-o BUFNAME <RET>'
     Display buffer BUFNAME in some window, without trying to select it
     (`display-buffer').  *Note Displaying Buffers::, for details about
     how the window is chosen.

`C-x 4 f FILENAME <RET>'
     Visit file FILENAME and select its buffer in another window
     (`find-file-other-window').  *Note Visiting::.

`C-x 4 d DIRECTORY <RET>'
     Select a Dired buffer for directory DIRECTORY in another window
     (`dired-other-window').  *Note Dired::.

`C-x 4 m'
     Start composing a mail message, similar to `C-x m' (*note Sending
     Mail::), but in another window (`mail-other-window').

`C-x 4 .'
     Find a tag in the current tags table, similar to `M-.' (*note
     Tags::), but in another window (`find-tag-other-window').

`C-x 4 r FILENAME <RET>'
     Visit file FILENAME read-only, and select its buffer in another
     window (`find-file-read-only-other-window').  *Note Visiting::.


File: emacs,  Node: Change Window,  Next: Displaying Buffers,  Prev: Pop Up Window,  Up: Windows

20.5 Deleting and Rearranging Windows
=====================================

`C-x 0'
     Delete the selected window (`delete-window').

`C-x 1'
     Delete all windows in the selected frame except the selected window
     (`delete-other-windows').

`C-x 4 0'
     Delete the selected window and kill the buffer that was showing in
     it (`kill-buffer-and-window').  The last character in this key
     sequence is a zero.

`C-x ^'
     Make selected window taller (`enlarge-window').

`C-x }'
     Make selected window wider (`enlarge-window-horizontally').

`C-x {'
     Make selected window narrower (`shrink-window-horizontally').

`C-x -'
     Shrink this window if its buffer doesn't need so many lines
     (`shrink-window-if-larger-than-buffer').

`C-x +'
     Make all windows the same height (`balance-windows').

   To delete the selected window, type `C-x 0' (`delete-window').
(That is a zero.)  Once a window is deleted, the space that it occupied
is given to an adjacent window (but not the minibuffer window, even if
that is active at the time).  Deleting the window has no effect on the
buffer it used to display; the buffer continues to exist, and you can
still switch to with `C-x b'.

   `C-x 4 0' (`kill-buffer-and-window') is a stronger command than `C-x
0'; it kills the current buffer and then deletes the selected window.

   `C-x 1' (`delete-other-windows') deletes all the windows, _except_
the selected one; the selected window expands to use the whole frame.
(This command cannot be used while the minibuffer window is active;
attempting to do so signals an error.)

   The command `C-x ^' (`enlarge-window') makes the selected window one
line taller, taking space from a vertically adjacent window without
changing the height of the frame.  With a positive numeric argument,
this command increases the window height by that many lines; with a
negative argument, it reduces the height by that many lines.  If there
are no vertically adjacent windows (i.e. the window is at the full
frame height), that signals an error.  The command also signals an
error if you attempt to reduce the height of any window below a certain
minimum number of lines, specified by the variable `window-min-height'
(the default is 4).

   Similarly, `C-x }' (`enlarge-window-horizontally') makes the
selected window wider, and `C-x {' (`shrink-window-horizontally') makes
it narrower.  These commands signal an error if you attempt to reduce
the width of any window below a certain minimum number of columns,
specified by the variable `window-min-width' (the default is 10).

   `C-x -' (`shrink-window-if-larger-than-buffer') reduces the height
of the selected window, if it is taller than necessary to show the
whole text of the buffer it is displaying.  It gives the extra lines to
other windows in the frame.

   You can also use `C-x +' (`balance-windows') to even out the heights
of all the windows in the selected frame.

   Mouse clicks on the mode line provide another way to change window
heights and to delete windows.  *Note Mode Line Mouse::.


File: emacs,  Node: Displaying Buffers,  Next: Window Convenience,  Prev: Change Window,  Up: Windows

20.6 Displaying a Buffer in a Window
====================================

It is a common Emacs operation to display or "pop up" some buffer in
response to a user command.  There are several different ways in which
commands do this.

   Many commands, like `C-x C-f' (`find-file'), display the buffer by
"taking over" the selected window, expecting that the user's attention
will be diverted to that buffer.  These commands usually work by
calling `switch-to-buffer' internally (*note Select Buffer::).

   Some commands try to display "intelligently", trying not to take
over the selected window, e.g. by splitting off a new window and
displaying the desired buffer there.  Such commands, which include the
various help commands (*note Help::), work by calling `display-buffer'
internally.  *Note Window Choice::, for details.

   Other commands do the same as `display-buffer', and additionally
select the displaying window so that you can begin editing its buffer.
The command `C-x `' (`next-error') is one example (*note Compilation
Mode::).  Such commands work by calling the function `pop-to-buffer'
internally.  *Note Switching to a Buffer in a Window: (elisp)Switching
Buffers.

   Commands with names ending in `-other-window' behave like
`display-buffer', except that they never display in the selected
window.  Several of these commands are bound in the `C-x 4' prefix key
(*note Pop Up Window::).

   Commands with names ending in `-other-frame' behave like
`display-buffer', except that they (i) never display in the selected
window and (ii) prefer to create a new frame to display the desired
buffer instead of splitting a window--as though the variable
`pop-up-frames' is set to `t' (*note Window Choice::).  Several of
these commands are bound in the `C-x 5' prefix key.

* Menu:

* Window Choice::   How `display-buffer' works.


File: emacs,  Node: Window Choice,  Up: Displaying Buffers

20.6.1 How `display-buffer' works
---------------------------------

The `display-buffer' command (as well as commands that call it
internally) chooses a window to display by following the steps given
below.  *Note Choosing a Window for Display: (elisp)Choosing Window,
for details about how to alter this sequence of steps.

   * First, check if the buffer should be displayed in the selected
     window regardless of other considerations.  You can tell Emacs to
     do this by adding the desired buffer's name to the list
     `same-window-buffer-names', or adding a matching regular
     expression to the list `same-window-regexps'.  By default, these
     variables are `nil', so this step is skipped.

   * Otherwise, if the buffer is already displayed in an existing
     window, "reuse" that window.  Normally, only windows on the
     selected frame are considered, but windows on other frames are
     also reusable if you change `display-buffer-reuse-frames' to `t',
     or if you change `pop-up-frames' (see below) to `t'.

   * Otherwise, if you specified that the buffer should be displayed in
     a special frame by customizing `special-display-buffer-names' or
     `special-display-regexps', do so.  *Note Choosing Window Options:
     (elisp)Choosing Window Options.

   * Otherwise, optionally create a new frame and display the buffer
     there.  By default, this step is skipped.  To enable it, change
     the variable `pop-up-frames' to a non-`nil' value.  The special
     value `graphic-only' means to do this only on graphical displays.

   * Otherwise, try to create a new window by splitting the selected
     window, and display the buffer in that new window.

     The split can be either vertical or horizontal, depending on the
     variables `split-height-threshold' and `split-width-threshold'.
     These variables should have integer values.  If
     `split-height-threshold' is smaller than the selected window's
     height, the split puts the new window below.  Otherwise, if
     `split-width-threshold' is smaller than the window's width, the
     split puts the new window on the right.  If neither condition
     holds, Emacs tries to split so that the new window is below--but
     only if the window was not split before (to avoid excessive
     splitting).

   * Otherwise, display the buffer in an existing window on the selected
     frame.

   * If all the above methods fail for whatever reason, create a new
     frame and display the buffer there.


File: emacs,  Node: Window Convenience,  Prev: Displaying Buffers,  Up: Windows

20.7 Convenience Features for Window Handling
=============================================

Winner mode is a global minor mode that records the changes in the
window configuration (i.e. how the frames are partitioned into
windows), so that you can "undo" them.  You can toggle Winner mode with
`M-x winner-mode', or by customizing the variable `winner-mode'.  When
the mode is enabled, `C-c left' (`winner-undo') undoes the last window
configuration change.  If you change your mind while undoing, you can
redo the changes you had undone using `C-c right' (`M-x winner-redo').

   Follow mode (`M-x follow-mode') synchronizes several windows on the
same buffer so that they always display adjacent sections of that
buffer.  *Note Follow Mode::.

   The Windmove package defines commands for moving directionally
between neighboring windows in a frame.  `M-x windmove-right' selects
the window immediately to the right of the currently selected one, and
similarly for the "left", "up", and "down" counterparts.  `M-x
windmove-default-keybindings' binds these commands to `S-right' etc.;
doing so disables shift selection for those keys (*note Shift
Selection::).

   The command `M-x compare-windows' lets you compare the text shown in
different windows.  *Note Comparing Files::.

   Scroll All mode (`M-x scroll-all-mode') is a global minor mode that
causes scrolling commands and point motion commands to apply to every
single window.


File: emacs,  Node: Frames,  Next: International,  Prev: Windows,  Up: Top

21 Frames and Graphical Displays
********************************

When Emacs is started on a graphical display, e.g. on the X Window
System, it occupies a graphical system-level "window".  In this manual,
we call this a "frame", reserving the word "window" for the part of the
frame used for displaying a buffer.  A frame initially contains one
window, but it can be subdivided into multiple windows (*note
Windows::).  A frame normally also contains a menu bar, tool bar, and
echo area.

   You can also create additional frames (*note Creating Frames::).
All frames created in the same Emacs session have access to the same
underlying buffers and other data.  For instance, if a buffer is being
shown in more than one frame, any changes made to it in one frame show
up immediately in the other frames too.

   Typing `C-x C-c' closes all the frames on the current display, and
ends the Emacs session if it has no frames open on any other displays
(*note Exiting::).  To close just the selected frame, type `C-x 5 0'
(that is zero, not `o').

   This chapter describes Emacs features specific to graphical displays
(particularly mouse commands), and features for managing multiple
frames.  On text terminals, many of these features are unavailable.
However, it is still possible to create multiple "frames" on text
terminals; such frames are displayed one at a time, filling the entire
terminal screen (*note Non-Window Terminals::).  It is also possible to
use the mouse on some text terminals (*note Text-Only Mouse::, for
doing so on GNU and Unix systems; and *note MS-DOS Mouse::, for doing
so on MS-DOS).

* Menu:

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Word and Line Mouse:: Mouse commands for selecting whole words or lines.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Frame Commands::      Iconifying, deleting, and switching frames.
* Fonts::               Changing the frame font.
* Speedbar::            How to make and use a speedbar frame.
* Multiple Displays::   How one Emacs instance can talk to several displays.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::         How to enable and disable scroll bars; how to use them.
* Drag and Drop::       Using drag and drop to open files and insert text.
* Menu Bars::           Enabling and disabling the menu bar.
* Tool Bars::           Enabling and disabling the tool bar.
* Dialog Boxes::        Controlling use of dialog boxes.
* Tooltips::            Displaying information at the current mouse position.
* Mouse Avoidance::     Preventing the mouse pointer from obscuring text.
* Non-Window Terminals::  Multiple frames on terminals that show only one.
* Text-Only Mouse::     Using the mouse in text terminals.


File: emacs,  Node: Mouse Commands,  Next: Word and Line Mouse,  Up: Frames

21.1 Mouse Commands for Editing
===============================

`Mouse-1'
     Move point to where you click (`mouse-set-point').

`Drag-Mouse-1'
     Activate the region around the text selected by dragging, and copy
     it to the kill ring (`mouse-set-region').

`Mouse-2'
     Yank the last killed text at the click position
     (`mouse-yank-at-click').

`Mouse-3'
     If the region is active, move the nearer end of the region to the
     click position; otherwise, set mark at the current value of point
     and point at the click position.  Save the resulting region in the
     kill ring; on a second click, kill it (`mouse-save-then-kill').

   The most basic mouse command is `mouse-set-point', which is invoked
by clicking with the left mouse button, `Mouse-1', in the text area of
a window.  This moves point to the position where you clicked.  If that
window was not the selected window, it becomes the selected window.

   Normally, if the frame you clicked in was not the selected frame, it
is made the selected frame, in addition to selecting the window and
setting the cursor.  On the X Window System, you can change this by
setting the variable `x-mouse-click-focus-ignore-position' to `t'.  In
that case, the initial click on an unselected frame just selects the
frame, without doing anything else; clicking again selects the window
and sets the cursor position.

   Holding down `Mouse-1' and "dragging" the mouse over a stretch of
text activates the region around that text (`mouse-set-region'),
placing the mark where you started holding down the mouse button, and
point where you release it (*note Mark::).  In addition, the text in
the region becomes the primary selection (*note Primary Selection::).

   If you change the variable `mouse-drag-copy-region' to a non-`nil'
value, dragging the mouse over a stretch of text also adds the text to
the kill ring.  The default is `nil'.

   If you move the mouse off the top or bottom of the window while
dragging, the window scrolls at a steady rate until you move the mouse
back into the window.  This way, you can select regions that don't fit
entirely on the screen.  The number of lines scrolled per step depends
on how far away from the window edge the mouse has gone; the variable
`mouse-scroll-min-lines' specifies a minimum step size.

   Clicking with the middle mouse button, `Mouse-2', moves point to the
position where you clicked and inserts the contents of the primary
selection (`mouse-yank-primary').  *Note Primary Selection::.  This
behavior is consistent with other X applications.  Alternatively, you
can rebind `Mouse-2' to `mouse-yank-at-click', which performs a yank at
point.

   If you change the variable `mouse-yank-at-point' to a non-`nil'
value, `Mouse-2' does not move point; it inserts the text at point,
regardless of where you clicked or even which of the frame's windows
you clicked on.  This variable affects both `mouse-yank-primary' and
`mouse-yank-at-click'.

   Clicking with the right mouse button, `Mouse-3', runs the command
`mouse-save-then-kill'.  This performs several actions depending on
where you click and the status of the region:

   * If no region is active, clicking `Mouse-3' activates the region,
     placing the mark where point was and point at the clicked position.

   * If a region is active, clicking `Mouse-3' adjusts the nearer end
     of the region by moving it to the clicked position.  The adjusted
     region's text is copied to the kill ring; if the text in the
     original region was already on the kill ring, it replaces it there.

   * If you originally specified the region using a double or triple
     `Mouse-1', so that the region is defined to consist of entire
     words or lines (*note Word and Line Mouse::), then adjusting the
     region with `Mouse-3' also proceeds by entire words or lines.

   * If you use `Mouse-3' a second time consecutively, at the same
     place, that kills the region already selected.  Thus, the simplest
     way to kill text with the mouse is to click `Mouse-1' at one end,
     then click `Mouse-3' twice at the other end.  To copy the text
     into the kill ring without deleting it from the buffer, press
     `Mouse-3' just once--or just drag across the text with `Mouse-1'.
     Then you can copy it elsewhere by yanking it.

   The `mouse-save-then-kill' command also obeys the variable
`mouse-drag-copy-region' (described above).  If the value is non-`nil',
then whenever the command sets or adjusts the active region, the text
in the region is also added to the kill ring.  If the latest kill ring
entry had been added the same way, that entry is replaced rather than
making a new entry.

   Whenever you set the region using any of the mouse commands
described above, the mark will be deactivated by any subsequent
unshifted cursor motion command, in addition to the usual ways of
deactivating the mark.  *Note Shift Selection::.

   Some mice have a "wheel" which can be used for scrolling.  Emacs
supports scrolling windows with the mouse wheel, by default, on most
graphical displays.  To toggle this feature, use `M-x
mouse-wheel-mode'.  The variables `mouse-wheel-follow-mouse' and
`mouse-wheel-scroll-amount' determine where and by how much buffers are
scrolled.  The variable `mouse-wheel-progressive-speed' determines
whether the scroll speed is linked to how fast you move the wheel.


File: emacs,  Node: Word and Line Mouse,  Next: Mouse References,  Prev: Mouse Commands,  Up: Frames

21.2 Mouse Commands for Words and Lines
=======================================

These variants of `Mouse-1' select entire words or lines at a time.
Emacs activates the region around the selected text, which is also
copied to the kill ring.

`Double-Mouse-1'
     Select the text around the word which you click on.

     Double-clicking on a character with "symbol" syntax (such as
     underscore, in C mode) selects the symbol surrounding that
     character.  Double-clicking on a character with open- or
     close-parenthesis syntax selects the parenthetical grouping which
     that character starts or ends.  Double-clicking on a character
     with string-delimiter syntax (such as a single-quote or
     double-quote in C) selects the string constant (Emacs uses
     heuristics to figure out whether that character is the beginning
     or the end of it).

`Double-Drag-Mouse-1'
     Select the text you drag across, in the form of whole words.

`Triple-Mouse-1'
     Select the line you click on.

`Triple-Drag-Mouse-1'
     Select the text you drag across, in the form of whole lines.


File: emacs,  Node: Mouse References,  Next: Menu Mouse Clicks,  Prev: Word and Line Mouse,  Up: Frames

21.3 Following References with the Mouse
========================================

Some Emacs buffers include "buttons", or "hyperlinks": pieces of text
that perform some action (e.g. following a reference) when activated
(e.g. by clicking on them).  Usually, a button's text is visually
highlighted: it is underlined, or a box is drawn around it.  If you
move the mouse over a button, the shape of the mouse cursor changes and
the button lights up.  If you change the variable `mouse-highlight' to
`nil', Emacs disables this highlighting.

   You can activate a button by moving point to it and typing <RET>, or
by clicking either `Mouse-1' or `Mouse-2' on the button.  For example,
in a Dired buffer, each file name is a button; activating it causes
Emacs to visit that file (*note Dired::).  In a `*Compilation*' buffer,
each error message is a button, and activating it visits the source
code for that error (*note Compilation::).

   Although clicking `Mouse-1' on a button usually activates the
button, if you hold the mouse button down for a period of time before
releasing it (specifically, for more than 450 milliseconds), then Emacs
moves point where you clicked, without activating the button.  In this
way, you can use the mouse to move point over a button without
activating it.  Dragging the mouse over or onto a button has its usual
behavior of setting the region, and does not activate the button.

   You can change how `Mouse-1' applies to buttons by customizing the
variable `mouse-1-click-follows-link'.  If the value is a positive
integer, that determines how long you need to hold the mouse button
down for, in milliseconds, to cancel button activation; the default is
450, as described in the previous paragraph.  If the value is `nil',
`Mouse-1' just sets point where you clicked, and does not activate
buttons.  If the value is `double', double clicks activate buttons but
single clicks just set point.

   Normally, `Mouse-1' on a button activates the button even if it is
in a non-selected window.  If you change the variable
`mouse-1-click-in-non-selected-windows' to `nil', `Mouse-1' on a button
in an unselected window moves point to the clicked position and selects
that window, without activating the button.


File: emacs,  Node: Menu Mouse Clicks,  Next: Mode Line Mouse,  Prev: Mouse References,  Up: Frames

21.4 Mouse Clicks for Menus
===========================

Several mouse clicks with the <CTRL> and <SHIFT> modifiers bring up
menus.

`C-Mouse-1'
     This menu is for selecting a buffer.

     The MSB ("mouse select buffer") global minor mode makes this menu
     smarter and more customizable.  *Note Buffer Menus::.

`C-Mouse-2'
     This menu contains entries for examining faces and other text
     properties, and well as for setting them (the latter is mainly
     useful when editing enriched text; *note Enriched Text::).

`C-Mouse-3'
     This menu is mode-specific.  For most modes if Menu-bar mode is on,
     this menu has the same items as all the mode-specific menu-bar
     menus put together.  Some modes may specify a different menu for
     this button.  If Menu Bar mode is off, this menu contains all the
     items which would be present in the menu bar--not just the
     mode-specific ones--so that you can access them without having to
     display the menu bar.

`S-Mouse-1'
     This menu is for changing the default face within the window's
     buffer.  *Note Text Scale::.

   Some graphical applications use `Mouse-3' for a mode-specific menu.
If you prefer `Mouse-3' in Emacs to bring up such a menu instead of
running the `mouse-save-then-kill' command, rebind `Mouse-3' by adding
the following line to your init file (*note Init Rebinding::):

     (global-set-key [mouse-3] 'mouse-popup-menubar-stuff)


File: emacs,  Node: Mode Line Mouse,  Next: Creating Frames,  Prev: Menu Mouse Clicks,  Up: Frames

21.5 Mode Line Mouse Commands
=============================

You can use mouse clicks on window mode lines to select and manipulate
windows.

   Some areas of the mode line, such as the buffer name, and major and
minor mode names, have their own special mouse bindings.  These areas
are highlighted when you hold the mouse over them, and information about
the special bindings will be displayed (*note Tooltips::).  This
section's commands do not apply in those areas.

`Mouse-1'
     `Mouse-1' on a mode line selects the window it belongs to.  By
     dragging `Mouse-1' on the mode line, you can move it, thus
     changing the height of the windows above and below.  Changing
     heights with the mouse in this way never deletes windows, it just
     refuses to make any window smaller than the minimum height.

`Mouse-2'
     `Mouse-2' on a mode line expands that window to fill its frame.

`Mouse-3'
     `Mouse-3' on a mode line deletes the window it belongs to.  If the
     frame has only one window, it does nothing.

`C-Mouse-2'
     `C-Mouse-2' on a mode line splits that window, producing two
     side-by-side windows with the boundary running through the click
     position (*note Split Window::).

   Furthermore, by clicking and dragging `Mouse-1' on the divider
between two side-by-side mode lines, you can move the vertical boundary
to the left or right.


File: emacs,  Node: Creating Frames,  Next: Frame Commands,  Prev: Mode Line Mouse,  Up: Frames

21.6 Creating Frames
====================

The prefix key `C-x 5' is analogous to `C-x 4'.  Whereas each `C-x 4'
command pops up a buffer in a different window in the selected frame
(*note Pop Up Window::), the `C-x 5' commands use a different frame.
If an existing visible or iconified ("minimized") frame already
displays the requested buffer, that frame is raised and deiconified
("un-minimized"); otherwise, a new frame is created on the current
display terminal.

   The various `C-x 5' commands differ in how they find or create the
buffer to select:

`C-x 5 2'
     Create a new frame (`make-frame-command').

`C-x 5 b BUFNAME <RET>'
     Select buffer BUFNAME in another frame.  This runs
     `switch-to-buffer-other-frame'.

`C-x 5 f FILENAME <RET>'
     Visit file FILENAME and select its buffer in another frame.  This
     runs `find-file-other-frame'.  *Note Visiting::.

`C-x 5 d DIRECTORY <RET>'
     Select a Dired buffer for directory DIRECTORY in another frame.
     This runs `dired-other-frame'.  *Note Dired::.

`C-x 5 m'
     Start composing a mail message in another frame.  This runs
     `mail-other-frame'.  It is the other-frame variant of `C-x m'.
     *Note Sending Mail::.

`C-x 5 .'
     Find a tag in the current tag table in another frame.  This runs
     `find-tag-other-frame', the multiple-frame variant of `M-.'.
     *Note Tags::.

`C-x 5 r FILENAME <RET>'
     Visit file FILENAME read-only, and select its buffer in another
     frame.  This runs `find-file-read-only-other-frame'.  *Note
     Visiting::.

   You can control the appearance and behavior of the newly-created
frames by specifying "frame parameters".  *Note Frame Parameters::.


File: emacs,  Node: Frame Commands,  Next: Fonts,  Prev: Creating Frames,  Up: Frames

21.7 Frame Commands
===================

The following commands are used to delete and operate on frames:

`C-x 5 0'
     Delete the selected frame (`delete-frame').  This signals an error
     if there is only one frame.

`C-z'
     Minimize (or "iconify) the selected Emacs frame (`suspend-frame').
     *Note Exiting::.

`C-x 5 o'
     Select another frame, and raise it.  If you repeat this command, it
     cycles through all the frames on your terminal.

`C-x 5 1'
     Delete all frames on the current terminal, except the selected one.

   The `C-x 5 0' (`delete-frame') command deletes the selected frame.
However, it will refuse to delete the last frame in an Emacs session,
to prevent you from losing the ability to interact with the Emacs
session.  Note that when Emacs is run as a daemon (*note Emacs
Server::), there is always a "virtual frame" that remains after all the
ordinary, interactive frames are deleted.  In this case, `C-x 5 0' can
delete the last interactive frame; you can use `emacsclient' to
reconnect to the Emacs session.

   The `C-x 5 1' (`delete-other-frames') command deletes all other
frames on the current terminal (this terminal refers to either a
graphical display, or a text terminal; *note Non-Window Terminals::).
If the Emacs session has frames open on other graphical displays or
text terminals, those are not deleted.

   The `C-x 5 o' (`other-frame') command selects the next frame on the
current terminal.  If you are using Emacs on the X Window System with a
window manager that selects (or "gives focus to") whatever frame the
mouse cursor is over, you have to change the variable
`focus-follows-mouse' to `t' in order for this command to work
properly.  Then invoking `C-x 5 o' will also warp the mouse cursor to
the chosen frame.


File: emacs,  Node: Fonts,  Next: Speedbar,  Prev: Frame Commands,  Up: Frames

21.8 Fonts
==========

By default, Emacs displays text on graphical displays using a 12-point
monospace font.  There are several different ways to specify a
different font:

   * Click on `Set Default Font' in the `Options' menu.  To save this
     for future sessions, click on `Save Options' in the `Options' menu.

   * Add a line to your init file, modifying the variable
     `default-frame-alist' to specify the `font' parameter (*note Frame
     Parameters::), like this:

          (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-10"))

   * Add an `emacs.font' X resource setting to your X resource file,
     like this:

          emacs.font: DejaVu Sans Mono-12

     You must restart X, or use the `xrdb' command, for the X resources
     file to take effect.  *Note Resources::.  Do not quote font names
     in X resource files.

   * If you are running Emacs on the GNOME desktop, you can tell Emacs
     to use the default system font by setting the variable
     `font-use-system-font' to `t' (the default is `nil').  For this to
     work, Emacs must have been compiled with Gconf support.

   * Use the command line option `-fn' (or `--font').  *Note Font X::.

   To check what font you're currently using, the `C-u C-x =' command
can be helpful.  It describes the character at point, and names the
font that it's rendered in.

   On X, there are four different ways to express a "font name".  The
first is to use a "Fontconfig pattern".  Fontconfig patterns have the
following form:

     FONTNAME[-FONTSIZE][:NAME1=VALUES1][:NAME2=VALUES2]...

Within this format, any of the elements in braces may be omitted.
Here, FONTNAME is the "family name" of the font, such as `Monospace' or
`DejaVu Sans Mono'; FONTSIZE is the "point size" of the font (one
"printer's point" is about 1/72 of an inch); and the `NAME=VALUES'
entries specify settings such as the slant and weight of the font.
Each VALUES may be a single value, or a list of values separated by
commas.  In addition, some property values are valid with only one kind
of property name, in which case the `NAME=' part may be omitted.

   Here is a list of common font properties:

`slant'
     One of `italic', `oblique', or `roman'.

`weight'
     One of `light', `medium', `demibold', `bold' or `black'.

`style'
     Some fonts define special styles which are a combination of slant
     and weight.  For instance, `Dejavu Sans' defines the `book' style,
     which overrides the slant and weight properties.

`width'
     One of `condensed', `normal', or `expanded'.

`spacing'
     One of `monospace', `proportional', `dual-width', or `charcell'.

Here are some examples of Fontconfig patterns:

     Monospace
     Monospace-12
     Monospace-12:bold
     DejaVu Sans Mono:bold:italic
     Monospace-12:weight=bold:slant=italic

   For a more detailed description of Fontconfig patterns, see the
Fontconfig manual, which is distributed with Fontconfig and available
online at `http://fontconfig.org/fontconfig-user.html'.

   The second way to specify a font is to use a "GTK font pattern".
These have the syntax

     FONTNAME [PROPERTIES] [FONTSIZE]

where FONTNAME is the family name, PROPERTIES is a list of property
values separated by spaces, and FONTSIZE is the point size.  The
properties that you may specify for GTK font patterns are as follows:

   * Slant properties: `Italic' or `Oblique'.  If omitted, the default
     (roman) slant is implied.

   * Weight properties: `Bold', `Book', `Light', `Medium', `Semi-bold',
     or `Ultra-light'.  If omitted, `Medium' weight is implied.

   * Width properties: `Semi-Condensed' or `Condensed'.  If omitted, a
     default width is used.

Here are some examples of GTK font patterns:

     Monospace 12
     Monospace Bold Italic 12

   The third way to specify a font is to use an "XLFD" ("X Logical Font
Description").  This is the traditional method for specifying fonts
under X.  Each XLFD consists of fourteen words or numbers, separated by
dashes, like this:

     -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

A wildcard character (`*') in an XLFD matches any sequence of
characters (including none), and `?' matches any single character.
However, matching is implementation-dependent, and can be inaccurate
when wildcards match dashes in a long name.  For reliable results,
supply all 14 dashes and use wildcards only within a field.  Case is
insignificant in an XLFD.  The syntax for an XLFD is as follows:

     -MAKER-FAMILY-WEIGHT-SLANT-WIDTHTYPE-STYLE...
     ...-PIXELS-HEIGHT-HORIZ-VERT-SPACING-WIDTH-REGISTRY-ENCODING

The entries have the following meanings:

MAKER
     The name of the font manufacturer.

FAMILY
     The name of the font family (e.g. `courier').

WEIGHT
     The font weight--normally either `bold', `medium' or `light'.
     Some font names support other values.

SLANT
     The font slant--normally `r' (roman), `i' (italic), `o' (oblique),
     `ri' (reverse italic), or `ot' (other).  Some font names support
     other values.

WIDTHTYPE
     The font width--normally `normal', `condensed', `semicondensed',
     or `extended'.  Some font names support other values.

STYLE
     An optional additional style name.  Usually it is empty--most XLFDs
     have two hyphens in a row at this point.

PIXELS
     The font height, in pixels.

HEIGHT
     The font height on the screen, measured in tenths of a printer's
     point.  This is the point size of the font, times ten.  For a given
     vertical resolution, HEIGHT and PIXELS are proportional;
     therefore, it is common to specify just one of them and use `*'
     for the other.

HORIZ
     The horizontal resolution, in pixels per inch, of the screen for
     which the font is intended.

VERT
     The vertical resolution, in pixels per inch, of the screen for
     which the font is intended.  Normally the resolution of the fonts
     on your system is the right value for your screen; therefore, you
     normally specify `*' for this and HORIZ.

SPACING
     This is `m' (monospace), `p' (proportional) or `c' (character
     cell).

WIDTH
     The average character width, in pixels, multiplied by ten.

REGISTRY
ENCODING
     The X font character set that the font depicts.  (X font character
     sets are not the same as Emacs character sets, but they are
     similar.)  You can use the `xfontsel' program to check which
     choices you have.  Normally you should use `iso8859' for REGISTRY
     and `1' for ENCODING.

   The fourth and final method of specifying a font is to use a "font
nickname".  Certain fonts have shorter nicknames, which you can use
instead of a normal font specification.  For instance, `6x13' is
equivalent to

     -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

   On X, Emacs recognizes two types of fonts: "client-side" fonts,
which are provided by the Xft and Fontconfig libraries, and
"server-side" fonts, which are provided by the X server itself.  Most
client-side fonts support advanced font features such as antialiasing
and subpixel hinting, while server-side fonts do not.  Fontconfig and
GTK patterns match only client-side fonts.

   You will probably want to use a fixed-width default font--that is, a
font in which all characters have the same width.  For Xft and
Fontconfig fonts, you can use the `fc-list' command to list the
available fixed-width fonts, like this:

     fc-list :spacing=mono fc-list :spacing=charcell

For server-side X fonts, you can use the `xlsfonts' program to list the
available fixed-width fonts, like this:

     xlsfonts -fn '*x*' | egrep "^[0-9]+x[0-9]+"
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-m*'
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-c*'

Any font with `m' or `c' in the SPACING field of the XLFD is a
fixed-width font.  To see what a particular font looks like, use the
`xfd' command.  For example:

     xfd -fn 6x13

displays the entire font `6x13'.

   While running Emacs, you can also set the font of a specific kind of
text (*note Faces::), or a particular frame (*note Frame Parameters::).


File: emacs,  Node: Speedbar,  Next: Multiple Displays,  Prev: Fonts,  Up: Frames

21.9 Speedbar Frames
====================

The "speedbar" is a special frame for conveniently navigating in or
operating on another frame.  The speedbar, when it exists, is always
associated with a specific frame, called its "attached frame"; all
speedbar operations act on that frame.

   Type `M-x speedbar' to create the speedbar and associate it with the
current frame.  To dismiss the speedbar, type `M-x speedbar' again, or
select the speedbar and type `q'.  (You can also delete the speedbar
frame like any other Emacs frame.)  If you wish to associate the
speedbar with a different frame, dismiss it and call `M-x speedbar'
from that frame.

   The speedbar can operate in various modes.  Its default mode is
"File Display" mode, which shows the files in the current directory of
the selected window of the attached frame, one file per line.  Clicking
on a file name visits that file in the selected window of the attached
frame, and clicking on a directory name shows that directory in the
speedbar (*note Mouse References::).  Each line also has a box, `[+]'
or `<+>', that you can click on to "expand" the contents of that item.
Expanding a directory adds the contents of that directory to the
speedbar display, underneath the directory's own line.  Expanding an
ordinary file adds a list of the tags in that file to the speedbar
display; you can click on a tag name to jump to that tag in the
selected window of the attached frame.  When a file or directory is
expanded, the `[+]' changes to `[-]'; you can click on that box to
"contract" the item, hiding its contents.

   You navigate through the speedbar using the keyboard, too.  Typing
`RET' while point is on a line in the speedbar is equivalent to
clicking the item on the current line, and `SPC' expands or contracts
the item.  `U' displays the parent directory of the current directory.
To copy, delete, or rename the file on the current line, type `C', `D',
and `R' respectively.  To create a new directory, type `M'.

   Another general-purpose speedbar mode is "Buffer Display" mode; in
this mode, the speedbar displays a list of Emacs buffers.  To switch to
this mode, type `b' in the speedbar.  To return to File Display mode,
type `f'.  You can also change the display mode by clicking `mouse-3'
anywhere in the speedbar window (or `mouse-1' on the mode-line) and
selecting `Displays' in the pop-up menu.

   Some major modes, including Rmail mode, Info, and GUD, have
specialized ways of putting useful items into the speedbar for you to
select.  For example, in Rmail mode, the speedbar shows a list of Rmail
files, and lets you move the current message to another Rmail file by
clicking on its `<M>' box.

   For more details on using and programming the speedbar, *Note
Speedbar: (speedbar)Top.


File: emacs,  Node: Multiple Displays,  Next: Frame Parameters,  Prev: Speedbar,  Up: Frames

21.10 Multiple Displays
=======================

A single Emacs can talk to more than one X display.  Initially, Emacs
uses just one display--the one specified with the `DISPLAY' environment
variable or with the `--display' option (*note Initial Options::).  To
connect to another display, use the command `make-frame-on-display':

`M-x make-frame-on-display <RET> DISPLAY <RET>'
     Create a new frame on display DISPLAY.

   A single X server can handle more than one screen.  When you open
frames on two screens belonging to one server, Emacs knows they share a
single keyboard, and it treats all the commands arriving from these
screens as a single stream of input.

   When you open frames on different X servers, Emacs makes a separate
input stream for each server.  Each server also has its own selected
frame.  The commands you enter with a particular X server apply to that
server's selected frame.


File: emacs,  Node: Frame Parameters,  Next: Scroll Bars,  Prev: Multiple Displays,  Up: Frames

21.11 Frame Parameters
======================

You can control the default appearance and behavior of all frames by
specifying a default list of "frame parameters" in the variable
`default-frame-alist'.  Its value should be a list of entries, each
specifying a parameter name and a value for that parameter.  These
entries take effect whenever Emacs creates a new frame, including the
initial frame.

   For example, you can add the following lines to your init file
(*note Init File::) to set the default frame width to 90 character
columns, the default frame height to 40 character rows, and the default
font to `Monospace-10':

     (add-to-list 'default-frame-alist '(width  . 90))
     (add-to-list 'default-frame-alist '(height . 40))
     (add-to-list 'default-frame-alist '(font . "Monospace-10"))

   For a list of frame parameters and their effects, see *note Frame
Parameters: (elisp)Frame Parameters.

   You can also specify a list of frame parameters which apply to just
the initial frame, by customizing the variable `initial-frame-alist'.

   If Emacs is compiled to use an X toolkit, frame parameters that
specify colors and fonts don't affect menus and the menu bar, since
those are drawn by the toolkit and not directly by Emacs.


File: emacs,  Node: Scroll Bars,  Next: Drag and Drop,  Prev: Frame Parameters,  Up: Frames

21.12 Scroll Bars
=================

On graphical displays, there is a "scroll bar" on the side of each
Emacs window.  Clicking `Mouse-1' on the scroll bar's up and down
buttons scrolls the window by one line at a time.  Clicking `Mouse-1'
above or below the scroll bar's inner box scrolls the window by nearly
the entire height of the window, like `M-v' and `C-v' respectively
(*note Moving Point::).  Dragging the inner box scrolls continuously.

   If Emacs is compiled on the X Window System without X toolkit
support, the scroll bar behaves differently.  Clicking `Mouse-1'
anywhere on the scroll bar scrolls forward like `C-v', while `Mouse-3'
scrolls backward like `M-v'.  Clicking `Mouse-2' in the scroll bar lets
you drag the inner box up and down.

   To toggle the use of scroll bars, type `M-x scroll-bar-mode'.  This
command applies to all frames, including frames yet to be created.  To
toggle scroll bars for just the selected frame, use the command `M-x
toggle-scroll-bar'.

   To control the use of scroll bars at startup, customize the variable
`scroll-bar-mode'.  Its value should be either `right' (put scroll bars
on the right side of windows), `left' (put them on the left), or `nil'
(disable scroll bars).  By default, Emacs puts scroll bars on the right
if it was compiled with GTK+ support on the X Window System, and on
MS-Windows or Mac OS; Emacs puts scroll bars on the left if compiled on
the X Window System without GTK+ support (following the old convention
for X applications).

   You can also use the X resource `verticalScrollBars' to enable or
disable the scroll bars (*note Resources::).  To control the scroll bar
width, change the `scroll-bar-width' frame parameter (*note Frame
Parameters: (elisp)Frame Parameters.).


File: emacs,  Node: Drag and Drop,  Next: Menu Bars,  Prev: Scroll Bars,  Up: Frames

21.13 Drag and Drop
===================

In most graphical desktop environments, Emacs has basic support for
"drag and drop" operations.  For instance, dropping text onto an Emacs
frame inserts the text where it is dropped.  Dropping a file onto an
Emacs frame visits that file.  As a special case, dropping the file on
a Dired buffer moves or copies the file (according to the conventions
of the application it came from) into the directory displayed in that
buffer.

   Dropping a file normally visits it in the window you drop it on.  If
you prefer to visit the file in a new window in such cases, customize
the variable `dnd-open-file-other-window'.

   The XDND and Motif drag and drop protocols, and the old KDE 1.x
protocol, are currently supported.


File: emacs,  Node: Menu Bars,  Next: Tool Bars,  Prev: Drag and Drop,  Up: Frames

21.14 Menu Bars
===============

You can toggle the use of menu bars with `M-x menu-bar-mode'.  With no
argument, this command toggles Menu Bar mode, a global minor mode.
With an argument, the command turns Menu Bar mode on if the argument is
positive, off if the argument is not positive.  To control the use of
menu bars at startup, customize the variable `menu-bar-mode'.

   Expert users often turn off the menu bar, especially on text
terminals, where this makes one additional line available for text.  If
the menu bar is off, you can still pop up a menu of its contents with
`C-Mouse-3' on a display which supports pop-up menus.  *Note Menu Mouse
Clicks::.

   *Note Menu Bar::, for information on how to invoke commands with the
menu bar.  *Note X Resources::, for how to customize the menu bar
menus' visual appearance.


File: emacs,  Node: Tool Bars,  Next: Dialog Boxes,  Prev: Menu Bars,  Up: Frames

21.15 Tool Bars
===============

On graphical displays, Emacs puts a "tool bar" at the top of each
frame, just below the menu bar.  This is a row of icons which you can
click on with the mouse to invoke various commands.

   The global (default) tool bar contains general commands.  Some major
modes define their own tool bars; whenever a buffer with such a major
mode is current, the mode's tool bar replaces the global tool bar.

   To toggle the use of tool bars, type `M-x tool-bar-mode'.  This
command applies to all frames, including frames yet to be created.  To
control the use of tool bars at startup, customize the variable
`tool-bar-mode'.

   When Emacs is compiled with GTK+ support, each tool bar item can
consist of an image, or a text label, or both.  By default, Emacs
follows the Gnome desktop's tool bar style setting; if none is defined,
it displays tool bar items as just images.  To impose a specific tool
bar style, customize the variable `tool-bar-style'.

   You can also control the placement of the tool bar for the GTK+ tool
bar with the frame parameter `tool-bar-position'.  *Note Frame
Parameters: (elisp)Frame Parameters.


File: emacs,  Node: Dialog Boxes,  Next: Tooltips,  Prev: Tool Bars,  Up: Frames

21.16 Using Dialog Boxes
========================

A dialog box is a special kind of menu for asking you a yes-or-no
question or some other special question.  Many Emacs commands use a
dialog box to ask a yes-or-no question, if you used the mouse to invoke
the command that led to the question.

   To disable the use of dialog boxes, change the variable
`use-dialog-box' to `nil'.  In that case, Emacs always performs
yes-or-no prompts using the echo area and keyboard input.  This
variable also controls whether to use file selection windows (but those
are not supported on all platforms).

   A file selection window is a special kind of dialog box for asking
for file names.  You can customize the variable `use-file-dialog' to
suppress the use of file selection windows, even if you still want
other kinds of dialogs.  This variable has no effect if you have
suppressed all dialog boxes with the variable `use-dialog-box'.

   When Emacs is compiled with GTK+ support, it uses the GTK+ "file
chooser" dialog.  Emacs adds an additional toggle button to this
dialog, which you can use to enable or disable the display of hidden
files (files starting with a dot) in that dialog.  If you want this
toggle to be activated by default, change the variable
`x-gtk-show-hidden-files' to `t'.  In addition, Emacs adds help text to
the GTK+ file chooser dialog; to disable this help text, change the
variable `x-gtk-file-dialog-help-text' to `nil'.


File: emacs,  Node: Tooltips,  Next: Mouse Avoidance,  Prev: Dialog Boxes,  Up: Frames

21.17 Tooltips
==============

"Tooltips" are small windows that display text information at the
current mouse position.  They activate when there is a pause in mouse
movement over some significant piece of text in a window, or the mode
line, or some other part of the Emacs frame such as a tool bar button
or menu item.

   You can toggle the use of tooltips with the command `M-x
tooltip-mode'.  When Tooltip mode is disabled, the help text is
displayed in the echo area instead.  To control the use of tooltips at
startup, customize the variable `tooltip-mode'.

   The variables `tooltip-delay' specifies how long Emacs should wait
before displaying a tooltip.  For additional customization options for
displaying tooltips, use `M-x customize-group <RET> tooltip <RET>'.

   If Emacs is built with GTK+ support, it displays tooltips via GTK+,
using the default appearance of GTK+ tooltips.  To disable this, change
the variable `x-gtk-use-system-tooltips' to `nil'.  If you do this, or
if Emacs is built without GTK+ support, most attributes of the tooltip
text are specified by the `tooltip' face, and by X resources (*note X
Resources::).

   "GUD tooltips" are special tooltips that show the values of
variables when debugging a program with GUD.  *Note Debugger
Operation::.


File: emacs,  Node: Mouse Avoidance,  Next: Non-Window Terminals,  Prev: Tooltips,  Up: Frames

21.18 Mouse Avoidance
=====================

On graphical terminals, the mouse pointer may obscure the text in the
Emacs frame.  Emacs provides two methods to avoid this problem.

   Firstly, Emacs hides the mouse pointer each time you type a
self-inserting character, if the pointer lies inside an Emacs frame;
moving the mouse pointer makes it visible again.  To disable this
feature, set the variable `make-pointer-invisible' to `nil'.

   Secondly, you can use Mouse Avoidance mode, a minor mode, to keep
the mouse pointer away from point.  To use Mouse Avoidance mode,
customize the variable `mouse-avoidance-mode'.  You can set this to
various values to move the mouse in several ways:

`banish'
     Move the mouse to the upper-right corner on any key-press;

`exile'
     Move the mouse to the corner only if the cursor gets too close,
     and allow it to return once the cursor is out of the way;

`jump'
     If the cursor gets too close to the mouse, displace the mouse a
     random distance & direction;

`animate'
     As `jump', but shows steps along the way for illusion of motion;

`cat-and-mouse'
     The same as `animate';

`proteus'
     As `animate', but changes the shape of the mouse pointer too.

   You can also use the command `M-x mouse-avoidance-mode' to enable
the mode.  Whenever Mouse Avoidance mode moves the mouse, it also
raises the frame.


File: emacs,  Node: Non-Window Terminals,  Next: Text-Only Mouse,  Prev: Mouse Avoidance,  Up: Frames

21.19 Non-Window Terminals
==========================

On a text terminal, Emacs can display only one Emacs frame at a time.
However, you can still create multiple Emacs frames, and switch between
them.  Switching frames on these terminals is much like switching
between different window configurations.

   Use `C-x 5 2' to create a new frame and switch to it; use `C-x 5 o'
to cycle through the existing frames; use `C-x 5 0' to delete the
current frame.

   Each frame has a number to distinguish it.  If your terminal can
display only one frame at a time, the selected frame's number N appears
near the beginning of the mode line, in the form `FN'.

   `FN' is in fact the frame's initial name.  You can give frames more
meaningful names if you wish, and you can select a frame by its name.
Use the command `M-x set-frame-name <RET> NAME <RET>' to specify a new
name for the selected frame, and use `M-x select-frame-by-name <RET>
NAME <RET>' to select a frame according to its name.  The name you
specify appears in the mode line when the frame is selected.


File: emacs,  Node: Text-Only Mouse,  Prev: Non-Window Terminals,  Up: Frames

21.20 Using a Mouse in Text Terminals
=====================================

Some text terminals support mouse clicks in the terminal window.

   In a terminal emulator which is compatible with `xterm', you can use
`M-x xterm-mouse-mode' to give Emacs control over simple uses of the
mouse--basically, only non-modified single clicks are supported.  The
normal `xterm' mouse functionality for such clicks is still available
by holding down the `SHIFT' key when you press the mouse button.  Xterm
Mouse mode is a global minor mode (*note Minor Modes::).  Repeating the
command turns the mode off again.

   In the console on GNU/Linux, you can use `M-x gpm-mouse-mode' to
enable mouse support.  You must have the gpm server installed and
running on your system in order for this to work.

   *Note MS-DOS Mouse::, for information about mouse support on MS-DOS.


File: emacs,  Node: International,  Next: Modes,  Prev: Frames,  Up: Top

22 International Character Set Support
**************************************

Emacs supports a wide variety of international character sets,
including European and Vietnamese variants of the Latin alphabet, as
well as Cyrillic, Devanagari (for Hindi and Marathi), Ethiopic, Greek,
Han (for Chinese and Japanese), Hangul (for Korean), Hebrew, IPA,
Kannada, Lao, Malayalam, Tamil, Thai, Tibetan, and Vietnamese scripts.
Emacs also supports various encodings of these characters that are used
by other internationalized software, such as word processors and
mailers.

   Emacs allows editing text with international characters by supporting
all the related activities:

   * You can visit files with non-ASCII characters, save non-ASCII
     text, and pass non-ASCII text between Emacs and programs it
     invokes (such as compilers, spell-checkers, and mailers).  Setting
     your language environment (*note Language Environments::) takes
     care of setting up the coding systems and other options for a
     specific language or culture.  Alternatively, you can specify how
     Emacs should encode or decode text for each command; see *note
     Text Coding::.

   * You can display non-ASCII characters encoded by the various
     scripts.  This works by using appropriate fonts on graphics
     displays (*note Defining Fontsets::), and by sending special codes
     to text displays (*note Terminal Coding::).  If some characters
     are displayed incorrectly, refer to *note Undisplayable
     Characters::, which describes possible problems and explains how
     to solve them.

   * Characters from scripts whose natural ordering of text is from
     right to left are reordered for display (*note Bidirectional
     Editing::).  These scripts include Arabic, Hebrew, Syriac, Thaana,
     and a few others.

   * You can insert non-ASCII characters or search for them.  To do
     that, you can specify an input method (*note Select Input
     Method::) suitable for your language, or use the default input
     method set up when you chose your language environment.  If your
     keyboard can produce non-ASCII characters, you can select an
     appropriate keyboard coding system (*note Terminal Coding::), and
     Emacs will accept those characters.  Latin-1 characters can also
     be input by using the `C-x 8' prefix, see *note Unibyte Mode::.

     With the X Window System, your locale should be set to an
     appropriate value to make sure Emacs interprets keyboard input
     correctly; see *note locales: Language Environments.

   The rest of this chapter describes these issues in detail.

* Menu:

* International Chars::     Basic concepts of multibyte characters.
* Disabling Multibyte::     Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Specifying a file's coding system explicitly.
* Output Coding::           Choosing coding systems for output.
* Text Coding::             Choosing conversion to use for file text.
* Communication Coding::    Coding systems for interprocess communication.
* File Name Coding::        Coding systems for file _names_.
* Terminal Coding::         Specifying coding systems for converting
                              terminal input and output.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Modifying Fontsets::      Modifying an existing fontset.
* Undisplayable Characters:: When characters don't display.
* Unibyte Mode::            You can pick one European character set
                              to use without multibyte characters.
* Charsets::                How Emacs groups its internal character codes.
* Bidirectional Editing::   Support for right-to-left scripts.


File: emacs,  Node: International Chars,  Next: Disabling Multibyte,  Up: International

22.1 Introduction to International Character Sets
=================================================

The users of international character sets and scripts have established
many more-or-less standard coding systems for storing files.  These
coding systems are typically "multibyte", meaning that sequences of two
or more bytes are used to represent individual non-ASCII characters.

   Internally, Emacs uses its own multibyte character encoding, which
is a superset of the "Unicode" standard.  This internal encoding allows
characters from almost every known script to be intermixed in a single
buffer or string.  Emacs translates between the multibyte character
encoding and various other coding systems when reading and writing
files, and when exchanging data with subprocesses.

   The command `C-h h' (`view-hello-file') displays the file
`etc/HELLO', which illustrates various scripts by showing how to say
"hello" in many languages.  If some characters can't be displayed on
your terminal, they appear as `?' or as hollow boxes (*note
Undisplayable Characters::).

   Keyboards, even in the countries where these character sets are
used, generally don't have keys for all the characters in them.  You
can insert characters that your keyboard does not support, using `C-q'
(`quoted-insert') or `C-x 8 <RET>' (`ucs-insert').  *Note Inserting
Text::.  Emacs also supports various "input methods", typically one for
each script or language, which make it easier to type characters in the
script.  *Note Input Methods::.

   The prefix key `C-x <RET>' is used for commands that pertain to
multibyte characters, coding systems, and input methods.

   The command `C-x =' (`what-cursor-position') shows information about
the character at point.  In addition to the character position, which
was described in *note Position Info::, this command displays how the
character is encoded.  For instance, it displays the following line in
the echo area for the character `c':

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   The four values after `Char:' describe the character that follows
point, first by showing it and then by giving its character code in
decimal, octal and hex.  For a non-ASCII multibyte character, these are
followed by `file' and the character's representation, in hex, in the
buffer's coding system, if that coding system encodes the character
safely and with a single byte (*note Coding Systems::).  If the
character's encoding is longer than one byte, Emacs shows `file ...'.

   As a special case, if the character lies in the range 128 (0200
octal) through 159 (0237 octal), it stands for a "raw" byte that does
not correspond to any specific displayable character.  Such a
"character" lies within the `eight-bit-control' character set, and is
displayed as an escaped octal character code.  In this case, `C-x ='
shows `part of display ...' instead of `file'.

   With a prefix argument (`C-u C-x ='), this command displays a
detailed description of the character in a window:

   * The character set name, and the codes that identify the character
     within that character set; ASCII characters are identified as
     belonging to the `ascii' character set.

   * The character's syntax and categories.

   * The character's encodings, both internally in the buffer, and
     externally if you were to save the file.

   * What keys to type to input the character in the current input
     method (if it supports the character).

   * If you are running Emacs on a graphical display, the font name and
     glyph code for the character.  If you are running Emacs on a text
     terminal, the code(s) sent to the terminal.

   * The character's text properties (*note Text Properties:
     (elisp)Text Properties.), including any non-default faces used to
     display the character, and any overlays containing it (*note
     Overlays: (elisp)Overlays.).

   Here's an example showing the Latin-1 character A with grave accent,
in a buffer whose coding system is `utf-8-unix':

                  position: 1 of 1 (0%), column: 0
                 character:  (displayed as ) (codepoint 192, #o300, #xc0)
         preferred charset: unicode (Unicode (ISO10646))
     code point in charset: 0xC0
                    syntax: w       which means: word
                  category: .:Base, L:Left-to-right (strong),
                            j:Japanese, l:Latin, v:Viet
               buffer code: #xC3 #x80
                 file code: not encodable by coding system undecided-unix
                   display: by this font (glyph code)
         xft:-unknown-DejaVu Sans Mono-normal-normal-
             normal-*-13-*-*-*-m-0-iso10646-1 (#x82)

     Character code properties: customize what to show
       name: LATIN CAPITAL LETTER A WITH GRAVE
       old-name: LATIN CAPITAL LETTER A GRAVE
       general-category: Lu (Letter, Uppercase)
       decomposition: (65 768) ('A' '`')


File: emacs,  Node: Disabling Multibyte,  Next: Language Environments,  Prev: International Chars,  Up: International

22.2 Disabling Multibyte Characters
===================================

By default, Emacs starts in multibyte mode: it stores the contents of
buffers and strings using an internal encoding that represents
non-ASCII characters using multi-byte sequences.  Multibyte mode allows
you to use all the supported languages and scripts without limitations.

   Under very special circumstances, you may want to disable multibyte
character support, for a specific buffer.  When multibyte characters
are disabled in a buffer, we call that "unibyte mode".  In unibyte
mode, each character in the buffer has a character code ranging from 0
through 255 (0377 octal); 0 through 127 (0177 octal) represent ASCII
characters, and 128 (0200 octal) through 255 (0377 octal) represent
non-ASCII characters.

   To edit a particular file in unibyte representation, visit it using
`find-file-literally'.  *Note Visiting::.  You can convert a multibyte
buffer to unibyte by saving it to a file, killing the buffer, and
visiting the file again with `find-file-literally'.  Alternatively, you
can use `C-x <RET> c' (`universal-coding-system-argument') and specify
`raw-text' as the coding system with which to visit or save a file.
*Note Text Coding::.  Unlike `find-file-literally', finding a file as
`raw-text' doesn't disable format conversion, uncompression, or auto
mode selection.

   Emacs normally loads Lisp files as multibyte.  This includes the
Emacs initialization file, `.emacs', and the initialization files of
packages such as Gnus.  However, you can specify unibyte loading for a
particular Lisp file, by adding an entry `unibyte: t' in a file local
variables section (*note File Variables::).  Then that file is always
loaded as unibyte text.  Note that this does not represent a real
`unibyte' variable, rather it just acts as an indicator to Emacs in the
same way as `coding' does (*note Specify Coding::).  Note also that
this feature only applies to _loading_ Lisp files for evaluation, not
to visiting them for editing.  You can also load a Lisp file as
unibyte, on any one occasion, by typing `C-x <RET> c raw-text <RET>'
immediately before loading it.

   The buffer-local variable `enable-multibyte-characters' is non-`nil'
in multibyte buffers, and `nil' in unibyte ones.  The mode line also
indicates whether a buffer is multibyte or not.  *Note Mode Line::.
With a graphical display, in a multibyte buffer, the portion of the
mode line that indicates the character set has a tooltip that (amongst
other things) says that the buffer is multibyte.  In a unibyte buffer,
the character set indicator is absent.  Thus, in a unibyte buffer (when
using a graphical display) there is normally nothing before the
indication of the visited file's end-of-line convention (colon,
backslash, etc.), unless you are using an input method.

   You can turn off multibyte support in a specific buffer by invoking
the command `toggle-enable-multibyte-characters' in that buffer.


File: emacs,  Node: Language Environments,  Next: Input Methods,  Prev: Disabling Multibyte,  Up: International

22.3 Language Environments
==========================

All supported character sets are supported in Emacs buffers whenever
multibyte characters are enabled; there is no need to select a
particular language in order to display its characters.  However, it is
important to select a "language environment" in order to set various
defaults.  Roughly speaking, the language environment represents a
choice of preferred script rather than a choice of language.

   The language environment controls which coding systems to recognize
when reading text (*note Recognize Coding::).  This applies to files,
incoming mail, and any other text you read into Emacs.  It may also
specify the default coding system to use when you create a file.  Each
language environment also specifies a default input method.

   To select a language environment, customize
`current-language-environment' or use the command `M-x
set-language-environment'.  It makes no difference which buffer is
current when you use this command, because the effects apply globally
to the Emacs session.  The supported language environments (see the
variable `language-info-alist') include:

     ASCII, Belarusian, Bengali, Brazilian Portuguese, Bulgarian, Cham,
     Chinese-BIG5, Chinese-CNS, Chinese-EUC-TW, Chinese-GB, Chinese-GBK,
     Chinese-GB18030, Croatian, Cyrillic-ALT, Cyrillic-ISO,
     Cyrillic-KOI8, Czech, Devanagari, Dutch, English, Esperanto,
     Ethiopic, French, Georgian, German, Greek, Gujarati, Hebrew, IPA,
     Italian, Japanese, Kannada, Khmer, Korean, Lao, Latin-1, Latin-2,
     Latin-3, Latin-4, Latin-5, Latin-6, Latin-7, Latin-8 (Celtic),
     Latin-9 (updated Latin-1 with the Euro sign), Latvian, Lithuanian,
     Malayalam, Oriya, Polish, Punjabi, Romanian, Russian, Sinhala,
     Slovak, Slovenian, Spanish, Swedish, TaiViet, Tajik, Tamil,
     Telugu, Thai, Tibetan, Turkish, UTF-8 (for a setup which prefers
     Unicode characters and files encoded in UTF-8), Ukrainian,
     Vietnamese, Welsh, and Windows-1255 (for a setup which prefers
     Cyrillic characters and files encoded in Windows-1255).

   To display the script(s) used by your language environment on a
graphical display, you need to have suitable fonts.  *Note Fontsets::,
for more details about setting up your fonts.

   Some operating systems let you specify the character-set locale you
are using by setting the locale environment variables `LC_ALL',
`LC_CTYPE', or `LANG'.  (If more than one of these is set, the first
one that is nonempty specifies your locale for this purpose.)  During
startup, Emacs looks up your character-set locale's name in the system
locale alias table, matches its canonical name against entries in the
value of the variables `locale-charset-language-names' and
`locale-language-names' (the former overrides the latter), and selects
the corresponding language environment if a match is found.  It also
adjusts the display table and terminal coding system, the locale coding
system, the preferred coding system as needed for the locale, and--last
but not least--the way Emacs decodes non-ASCII characters sent by your
keyboard.

   If you modify the `LC_ALL', `LC_CTYPE', or `LANG' environment
variables while running Emacs (by using `M-x setenv'), you may want to
invoke the `set-locale-environment' function afterwards to readjust the
language environment from the new locale.

   The `set-locale-environment' function normally uses the preferred
coding system established by the language environment to decode system
messages.  But if your locale matches an entry in the variable
`locale-preferred-coding-systems', Emacs uses the corresponding coding
system instead.  For example, if the locale `ja_JP.PCK' matches
`japanese-shift-jis' in `locale-preferred-coding-systems', Emacs uses
that encoding even though it might normally use `japanese-iso-8bit'.

   You can override the language environment chosen at startup with
explicit use of the command `set-language-environment', or with
customization of `current-language-environment' in your init file.

   To display information about the effects of a certain language
environment LANG-ENV, use the command `C-h L LANG-ENV <RET>'
(`describe-language-environment').  This tells you which languages this
language environment is useful for, and lists the character sets,
coding systems, and input methods that go with it.  It also shows some
sample text to illustrate scripts used in this language environment.
If you give an empty input for LANG-ENV, this command describes the
chosen language environment.    You can customize any language
environment with the normal hook `set-language-environment-hook'.  The
command `set-language-environment' runs that hook after setting up the
new language environment.  The hook functions can test for a specific
language environment by checking the variable
`current-language-environment'.  This hook is where you should put
non-default settings for specific language environments, such as coding
systems for keyboard input and terminal output, the default input
method, etc.

   Before it starts to set up the new language environment,
`set-language-environment' first runs the hook
`exit-language-environment-hook'.  This hook is useful for undoing
customizations that were made with `set-language-environment-hook'.
For instance, if you set up a special key binding in a specific language
environment using `set-language-environment-hook', you should set up
`exit-language-environment-hook' to restore the normal binding for that
key.


File: emacs,  Node: Input Methods,  Next: Select Input Method,  Prev: Language Environments,  Up: International

22.4 Input Methods
==================

An "input method" is a kind of character conversion designed
specifically for interactive input.  In Emacs, typically each language
has its own input method; sometimes several languages that use the same
characters can share one input method.  A few languages support several
input methods.

   The simplest kind of input method works by mapping ASCII letters
into another alphabet; this allows you to use one other alphabet
instead of ASCII.  The Greek and Russian input methods work this way.

   A more powerful technique is composition: converting sequences of
characters into one letter.  Many European input methods use composition
to produce a single non-ASCII letter from a sequence that consists of a
letter followed by accent characters (or vice versa).  For example, some
methods convert the sequence `o ^' into a single accented letter.
These input methods have no special commands of their own; all they do
is compose sequences of printing characters.

   The input methods for syllabic scripts typically use mapping followed
by composition.  The input methods for Thai and Korean work this way.
First, letters are mapped into symbols for particular sounds or tone
marks; then, sequences of these that make up a whole syllable are
mapped into one syllable sign.

   Chinese and Japanese require more complex methods.  In Chinese input
methods, first you enter the phonetic spelling of a Chinese word (in
input method `chinese-py', among others), or a sequence of portions of
the character (input methods `chinese-4corner' and `chinese-sw', and
others).  One input sequence typically corresponds to many possible
Chinese characters.  You select the one you mean using keys such as
`C-f', `C-b', `C-n', `C-p' (or the arrow keys), and digits, which have
special meanings in this situation.

   The possible characters are conceptually arranged in several rows,
with each row holding up to 10 alternatives.  Normally, Emacs displays
just one row at a time, in the echo area; `(I/J)' appears at the
beginning, to indicate that this is the Ith row out of a total of J
rows.  Type `C-n' or `C-p' to display the next row or the previous row.

   Type `C-f' and `C-b' to move forward and backward among the
alternatives in the current row.  As you do this, Emacs highlights the
current alternative with a special color; type `C-<SPC>' to select the
current alternative and use it as input.  The alternatives in the row
are also numbered; the number appears before the alternative.  Typing a
number selects the associated alternative of the current row and uses
it as input.

   <TAB> in these Chinese input methods displays a buffer showing all
the possible characters at once; then clicking `Mouse-2' on one of them
selects that alternative.  The keys `C-f', `C-b', `C-n', `C-p', and
digits continue to work as usual, but they do the highlighting in the
buffer showing the possible characters, rather than in the echo area.

   In Japanese input methods, first you input a whole word using
phonetic spelling; then, after the word is in the buffer, Emacs
converts it into one or more characters using a large dictionary.  One
phonetic spelling corresponds to a number of different Japanese words;
to select one of them, use `C-n' and `C-p' to cycle through the
alternatives.

   Sometimes it is useful to cut off input method processing so that the
characters you have just entered will not combine with subsequent
characters.  For example, in input method `latin-1-postfix', the
sequence `o ^' combines to form an `o' with an accent.  What if you
want to enter them as separate characters?

   One way is to type the accent twice; this is a special feature for
entering the separate letter and accent.  For example, `o ^ ^' gives
you the two characters `o^'.  Another way is to type another letter
after the `o'--something that won't combine with that--and immediately
delete it.  For example, you could type `o o <DEL> ^' to get separate
`o' and `^'.

   Another method, more general but not quite as easy to type, is to use
`C-\ C-\' between two characters to stop them from combining.  This is
the command `C-\' (`toggle-input-method') used twice.  *Note Select
Input Method::.

   `C-\ C-\' is especially useful inside an incremental search, because
it stops waiting for more characters to combine, and starts searching
for what you have already entered.

   To find out how to input the character after point using the current
input method, type `C-u C-x ='.  *Note Position Info::.

   The variables `input-method-highlight-flag' and
`input-method-verbose-flag' control how input methods explain what is
happening.  If `input-method-highlight-flag' is non-`nil', the partial
sequence is highlighted in the buffer (for most input methods--some
disable this feature).  If `input-method-verbose-flag' is non-`nil',
the list of possible characters to type next is displayed in the echo
area (but not when you are in the minibuffer).

   Another facility for typing characters not on your keyboard is by
using `C-x 8 <RET>' (`ucs-insert') to insert a single character based
on its Unicode name or code-point; see *note Inserting Text::.


File: emacs,  Node: Select Input Method,  Next: Coding Systems,  Prev: Input Methods,  Up: International

22.5 Selecting an Input Method
==============================

`C-\'
     Enable or disable use of the selected input method
     (`toggle-input-method').

`C-x <RET> C-\ METHOD <RET>'
     Select a new input method for the current buffer
     (`set-input-method').

`C-h I METHOD <RET>'
`C-h C-\ METHOD <RET>'
     Describe the input method METHOD (`describe-input-method').  By
     default, it describes the current input method (if any).  This
     description should give you the full details of how to use any
     particular input method.

`M-x list-input-methods'
     Display a list of all the supported input methods.

   To choose an input method for the current buffer, use `C-x <RET>
C-\' (`set-input-method').  This command reads the input method name
from the minibuffer; the name normally starts with the language
environment that it is meant to be used with.  The variable
`current-input-method' records which input method is selected.

   Input methods use various sequences of ASCII characters to stand for
non-ASCII characters.  Sometimes it is useful to turn off the input
method temporarily.  To do this, type `C-\' (`toggle-input-method').
To reenable the input method, type `C-\' again.

   If you type `C-\' and you have not yet selected an input method, it
prompts you to specify one.  This has the same effect as using `C-x
<RET> C-\' to specify an input method.

   When invoked with a numeric argument, as in `C-u C-\',
`toggle-input-method' always prompts you for an input method,
suggesting the most recently selected one as the default.

   Selecting a language environment specifies a default input method for
use in various buffers.  When you have a default input method, you can
select it in the current buffer by typing `C-\'.  The variable
`default-input-method' specifies the default input method (`nil' means
there is none).

   In some language environments, which support several different input
methods, you might want to use an input method different from the
default chosen by `set-language-environment'.  You can instruct Emacs
to select a different default input method for a certain language
environment, if you wish, by using `set-language-environment-hook'
(*note set-language-environment-hook: Language Environments.).  For
example:

     (defun my-chinese-setup ()
       "Set up my private Chinese environment."
       (if (equal current-language-environment "Chinese-GB")
           (setq default-input-method "chinese-tonepy")))
     (add-hook 'set-language-environment-hook 'my-chinese-setup)

This sets the default input method to be `chinese-tonepy' whenever you
choose a Chinese-GB language environment.

   You can instruct Emacs to activate a certain input method
automatically.  For example:

     (add-hook 'text-mode-hook
       (lambda () (set-input-method "german-prefix")))

This automatically activates the input method "german-prefix" in Text
mode.

   Some input methods for alphabetic scripts work by (in effect)
remapping the keyboard to emulate various keyboard layouts commonly used
for those scripts.  How to do this remapping properly depends on your
actual keyboard layout.  To specify which layout your keyboard has, use
the command `M-x quail-set-keyboard-layout'.

   You can use the command `M-x quail-show-key' to show what key (or
key sequence) to type in order to input the character following point,
using the selected keyboard layout.  The command `C-u C-x =' also shows
that information, in addition to other information about the character.

   `M-x list-input-methods' displays a list of all the supported input
methods.  The list gives information about each input method, including
the string that stands for it in the mode line.



Local Variables:
coding: iso-8859-1
End:
