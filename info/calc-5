This is ../../info/calc, produced by makeinfo version 4.13 from
calc.texi.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990-1991, 2001-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being just "GNU GENERAL
     PUBLIC LICENSE", with the Front-Cover texts being "A GNU Manual,"
     and with the Back-Cover Texts as in (a) below.  A copy of the
     license is included in the section entitled "GNU Free
     Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs misc features
START-INFO-DIR-ENTRY
* Calc: (calc).                 Advanced desk calculator and mathematical tool.
END-INFO-DIR-ENTRY


File: calc,  Node: Internals,  Prev: Calling Calc from Your Programs,  Up: Lisp Definitions

19.5.7 Calculator Internals
---------------------------

This section describes the Lisp functions defined by the Calculator that
may be of use to user-written Calculator programs (as described in the
rest of this chapter).  These functions are shown by their names as they
conventionally appear in `defmath'.  Their full Lisp names are
generally gotten by prepending `calcFunc-' or `math-' to their apparent
names.  (Names that begin with `calc-' are already in their full Lisp
form.)  You can use the actual full names instead if you prefer them,
or if you are calling these functions from regular Lisp.

   The functions described here are scattered throughout the various
Calc component files.  Note that `calc.el' includes `autoload's for
only a few component files; when Calc wants to call an advanced
function it calls `(calc-extensions)' first; this function autoloads
`calc-ext.el', which in turn autoloads all the functions in the
remaining component files.

   Because `defmath' itself uses the extensions, user-written code
generally always executes with the extensions already loaded, so
normally you can use any Calc function and be confident that it will be
autoloaded for you when necessary.  If you are doing something special,
check carefully to make sure each function you are using is from
`calc.el' or its components, and call `(calc-extensions)' before using
any function based in `calc-ext.el' if you can't prove this file will
already be loaded.

* Menu:

* Data Type Formats::
* Interactive Lisp Functions::
* Stack Lisp Functions::
* Predicates::
* Computational Lisp Functions::
* Vector Lisp Functions::
* Symbolic Lisp Functions::
* Formatting Lisp Functions::
* Hooks::


File: calc,  Node: Data Type Formats,  Next: Interactive Lisp Functions,  Prev: Internals,  Up: Internals

19.5.7.1 Data Type Formats
..........................

Integers are stored in either of two ways, depending on their magnitude.
Integers less than one million in absolute value are stored as standard
Lisp integers.  This is the only storage format for Calc data objects
which is not a Lisp list.

   Large integers are stored as lists of the form `(bigpos D0 D1 D2
...)' for positive integers 1000000 or more, or `(bigneg D0 D1 D2 ...)'
for negative integers -1000000 or less.  Each D is a base-1000 "digit,"
a Lisp integer from 0 to 999.  The least significant digit is D0; the
last digit, DN, which is always nonzero, is the most significant digit.
For example, the integer -12345678 is stored as `(bigneg 678 345 12)'.

   The distinction between small and large integers is entirely hidden
from the user.  In `defmath' definitions, the Lisp predicate `integerp'
returns true for either kind of integer, and in general both big and
small integers are accepted anywhere the word "integer" is used in this
manual.  If the distinction must be made, native Lisp integers are
called "fixnums" and large integers are called "bignums".

   Fractions are stored as a list of the form, `(frac N D)' where N is
an integer (big or small) numerator, D is an integer denominator
greater than one, and N and D are relatively prime.  Note that
fractions where D is one are automatically converted to plain integers
by all math routines; fractions where D is negative are normalized by
negating the numerator and denominator.

   Floating-point numbers are stored in the form, `(float MANT EXP)',
where MANT (the "mantissa") is an integer less than `10^P' in absolute
value (P represents the current precision), and EXP (the "exponent") is
a fixnum.  The value of the float is `MANT * 10^EXP'.  For example, the
number -3.14 is stored as `(float -314 -2) = -314*10^-2'.  Other
constraints are that the number 0.0 is always stored as `(float 0 0)',
and, except for the 0.0 case, the rightmost base-10 digit of MANT is
always nonzero.  (If the rightmost digit is zero, the number is
rearranged by dividing MANT by ten and incrementing EXP.)

   Rectangular complex numbers are stored in the form `(cplx RE IM)',
where RE and IM are each real numbers, either integers, fractions, or
floats.  The value is `RE + IMi'.  The IM part is nonzero; complex
numbers with zero imaginary components are converted to real numbers
automatically.

   Polar complex numbers are stored in the form `(polar R THETA)',
where R is a positive real value and THETA is a real value or HMS form
representing an angle.  This angle is usually normalized to lie in the
interval `(-180 .. 180)' degrees, or `(-pi .. pi)' radians, according
to the current angular mode.  If the angle is 0 the value is converted
to a real number automatically.  (If the angle is 180 degrees, the
value is usually also converted to a negative real number.)

   Hours-minutes-seconds forms are stored as `(hms H M S)', where H is
an integer or an integer-valued float (i.e., a float with `EXP >= 0'),
M is an integer or integer-valued float in the range `[0 .. 60)', and S
is any real number in the range `[0 .. 60)'.

   Date forms are stored as `(date N)', where N is a real number that
counts days since midnight on the morning of January 1, 1 AD.  If N is
an integer, this is a pure date form.  If N is a fraction or float,
this is a date/time form.

   Modulo forms are stored as `(mod N M)', where M is a positive real
number or HMS form, and N is a real number or HMS form in the range `[0
.. M)'.

   Error forms are stored as `(sdev X SIGMA)', where X is the mean
value and SIGMA is the standard deviation.  Each component is either a
number, an HMS form, or a symbolic object (a variable or function
call).  If SIGMA is zero, the value is converted to a plain real
number.  If SIGMA is negative or complex, it is automatically
normalized to be a positive real.

   Interval forms are stored as `(intv MASK LO HI)', where MASK is one
of the integers 0, 1, 2, or 3, and LO and HI are real numbers, HMS
forms, or symbolic objects.  The MASK is a binary integer where 1
represents the fact that the interval is closed on the high end, and 2
represents the fact that it is closed on the low end.  (Thus 3
represents a fully closed interval.)  The interval `(intv 3 X X)' is
converted to the plain number X; intervals `(intv MASK X X)' for any
other MASK represent empty intervals.  If HI is less than LO, the
interval is converted to a standard empty interval by replacing HI with
LO.

   Vectors are stored as `(vec V1 V2 ...)', where V1 is the first
element of the vector, V2 is the second, and so on.  An empty vector is
stored as `(vec)'.  A matrix is simply a vector where all V's are
themselves vectors of equal lengths.  Note that Calc vectors are
unrelated to the Emacs Lisp "vector" type, which is generally unused by
Calc data structures.

   Variables are stored as `(var NAME SYM)', where NAME is a Lisp
symbol whose print name is used as the visible name of the variable,
and SYM is a Lisp symbol in which the variable's value is actually
stored.  Thus, `(var pi var-pi)' represents the special constant `pi'.
Almost always, the form is `(var V var-V)'.  If the variable name was
entered with `#' signs (which are converted to hyphens internally), the
form is `(var U V)', where U is a symbol whose name contains `#'
characters, and V is a symbol that contains `-' characters instead.
The value of a variable is the Calc object stored in its SYM symbol's
value cell.  If the symbol's value cell is void or if it contains
`nil', the variable has no value.  Special constants have the form
`(special-const VALUE)' stored in their value cell, where VALUE is a
formula which is evaluated when the constant's value is requested.
Variables which represent units are not stored in any special way; they
are units only because their names appear in the units table.  If the
value cell contains a string, it is parsed to get the variable's value
when the variable is used.

   A Lisp list with any other symbol as the first element is a function
call.  The symbols `+', `-', `*', `/', `%', `^', and `|' represent
special binary operators; these lists are always of the form `(OP LHS
RHS)' where LHS is the sub-formula on the lefthand side and RHS is the
sub-formula on the right.  The symbol `neg' represents unary negation;
this list is always of the form `(neg ARG)'.  Any other symbol FUNC
represents a function that would be displayed in function-call
notation; the symbol FUNC is in general always of the form
`calcFunc-NAME'.  The function cell of the symbol FUNC should contain a
Lisp function for evaluating a call to FUNC.  This function is passed
the remaining elements of the list (themselves already evaluated) as
arguments; such functions should return `nil' or call `reject-arg' to
signify that they should be left in symbolic form, or they should
return a Calc object which represents their value, or a list of such
objects if they wish to return multiple values.  (The latter case is
allowed only for functions which are the outer-level call in an
expression whose value is about to be pushed on the stack; this feature
is considered obsolete and is not used by any built-in Calc functions.)


File: calc,  Node: Interactive Lisp Functions,  Next: Stack Lisp Functions,  Prev: Data Type Formats,  Up: Internals

19.5.7.2 Interactive Functions
..............................

The functions described here are used in implementing interactive Calc
commands.  Note that this list is not exhaustive!  If there is an
existing command that behaves similarly to the one you want to define,
you may find helpful tricks by checking the source code for that
command.

 -- Function: calc-set-command-flag flag
     Set the command flag FLAG.  This is generally a Lisp symbol, but
     may in fact be anything.  The effect is to add FLAG to the list
     stored in the variable `calc-command-flags', unless it is already
     there.  *Note Defining Simple Commands::.

 -- Function: calc-clear-command-flag flag
     If FLAG appears among the list of currently-set command flags,
     remove it from that list.

 -- Function: calc-record-undo rec
     Add the "undo record" REC to the list of steps to take if the
     current operation should need to be undone.  Stack push and pop
     functions automatically call `calc-record-undo', so the kinds of
     undo records you might need to create take the form `(set SYM
     VALUE)', which says that the Lisp variable SYM was changed and had
     previously contained VALUE; `(store VAR VALUE)' which says that
     the Calc variable VAR (a string which is the name of the symbol
     that contains the variable's value) was stored and its previous
     value was VALUE (either a Calc data object, or `nil' if the
     variable was previously void); or `(eval UNDO REDO ARGS ...)',
     which means that to undo requires calling the function `(UNDO ARGS
     ...)' and, if the undo is later redone, calling `(REDO ARGS ...)'.

 -- Function: calc-record-why msg args
     Record the error or warning message MSG, which is normally a
     string.  This message will be replayed if the user types `w'
     (`calc-why'); if the message string begins with a `*', it is
     considered important enough to display even if the user doesn't
     type `w'.  If one or more ARGS are present, the displayed message
     will be of the form, `MSG: ARG1, ARG2, ...', where the arguments
     are formatted on the assumption that they are either strings or
     Calc objects of some sort.  If MSG is a symbol, it is the name of
     a Calc predicate (such as `integerp' or `numvecp') which the
     arguments did not satisfy; it is expanded to a suitable string
     such as "Expected an integer."  The `reject-arg' function calls
     `calc-record-why' automatically; *note Predicates::.

 -- Function: calc-is-inverse
     This predicate returns true if the current command is inverse,
     i.e., if the Inverse (`I' key) flag was set.

 -- Function: calc-is-hyperbolic
     This predicate is the analogous function for the `H' key.


File: calc,  Node: Stack Lisp Functions,  Next: Predicates,  Prev: Interactive Lisp Functions,  Up: Internals

19.5.7.3 Stack-Oriented Functions
.................................

The functions described here perform various operations on the Calc
stack and trail.  They are to be used in interactive Calc commands.

 -- Function: calc-push-list vals n
     Push the Calc objects in list VALS onto the stack at stack level
     N.  If N is omitted it defaults to 1, so that the elements are
     pushed at the top of the stack.  If N is greater than 1, the
     elements will be inserted into the stack so that the last element
     will end up at level N, the next-to-last at level N+1, etc.  The
     elements of VALS are assumed to be valid Calc objects, and are not
     evaluated, rounded, or renormalized in any way.  If VALS is an
     empty list, nothing happens.

     The stack elements are pushed without any sub-formula selections.
     You can give an optional third argument to this function, which
     must be a list the same size as VALS of selections.  Each selection
     must be `eq' to some sub-formula of the corresponding formula in
     VALS, or `nil' if that formula should have no selection.

 -- Function: calc-top-list n m
     Return a list of the N objects starting at level M of the stack.
     If M is omitted it defaults to 1, so that the elements are taken
     from the top of the stack.  If N is omitted, it also defaults to
     1, so that the top stack element (in the form of a one-element
     list) is returned.  If M is greater than 1, the Mth stack element
     will be at the end of the list, the M+1st element will be
     next-to-last, etc.  If N or M are out of range, the command is
     aborted with a suitable error message.  If N is zero, the function
     returns an empty list.  The stack elements are not evaluated,
     rounded, or renormalized.

     If any stack elements contain selections, and selections have not
     been disabled by the `j e' (`calc-enable-selections') command,
     this function returns the selected portions rather than the entire
     stack elements.  It can be given a third "selection-mode" argument
     which selects other behaviors.  If it is the symbol `t', then a
     selection in any of the requested stack elements produces an
     "invalid operation on selections" error.  If it is the symbol
     `full', the whole stack entry is always returned regardless of
     selections.  If it is the symbol `sel', the selected portion is
     always returned, or `nil' if there is no selection.  (This mode
     ignores the `j e' command.)  If the symbol is `entry', the
     complete stack entry in list form is returned; the first element
     of this list will be the whole formula, and the third element will
     be the selection (or `nil').

 -- Function: calc-pop-stack n m
     Remove the specified elements from the stack.  The parameters N
     and M are defined the same as for `calc-top-list'.  The return
     value of `calc-pop-stack' is uninteresting.

     If there are any selected sub-formulas among the popped elements,
     and `j e' has not been used to disable selections, this produces an
     error without changing the stack.  If you supply an optional third
     argument of `t', the stack elements are popped even if they
     contain selections.

 -- Function: calc-record-list vals tag
     This function records one or more results in the trail.  The VALS
     are a list of strings or Calc objects.  The TAG is the
     four-character tag string to identify the values.  If TAG is
     omitted, a blank tag will be used.

 -- Function: calc-normalize n
     This function takes a Calc object and "normalizes" it.  At the very
     least this involves re-rounding floating-point values according to
     the current precision and other similar jobs.  Also, unless the
     user has selected No-Simplify mode (*note Simplification Modes::),
     this involves actually evaluating a formula object by executing
     the function calls it contains, and possibly also doing algebraic
     simplification, etc.

 -- Function: calc-top-list-n n m
     This function is identical to `calc-top-list', except that it calls
     `calc-normalize' on the values that it takes from the stack.  They
     are also passed through `check-complete', so that incomplete
     objects will be rejected with an error message.  All computational
     commands should use this in preference to `calc-top-list'; the only
     standard Calc commands that operate on the stack without
     normalizing are stack management commands like `calc-enter' and
     `calc-roll-up'.  This function accepts the same optional
     selection-mode argument as `calc-top-list'.

 -- Function: calc-top-n m
     This function is a convenient form of `calc-top-list-n' in which
     only a single element of the stack is taken and returned, rather
     than a list of elements.  This also accepts an optional
     selection-mode argument.

 -- Function: calc-enter-result n tag vals
     This function is a convenient interface to most of the above
     functions.  The VALS argument should be either a single Calc
     object, or a list of Calc objects; the object or objects are
     normalized, and the top N stack entries are replaced by the
     normalized objects.  If TAG is non-`nil', the normalized objects
     are also recorded in the trail.  A typical stack-based
     computational command would take the form,

          (calc-enter-result N TAG (cons 'calcFunc-FUNC
                                         (calc-top-list-n N)))

     If any of the N stack elements replaced contain sub-formula
     selections, and selections have not been disabled by `j e', this
     function takes one of two courses of action.  If N is equal to the
     number of elements in VALS, then each element of VALS is spliced
     into the corresponding selection; this is what happens when you
     use the <TAB> key, or when you use a unary arithmetic operation
     like `sqrt'.  If VALS has only one element but N is greater than
     one, there must be only one selection among the top N stack
     elements; the element from VALS is spliced into that selection.
     This is what happens when you use a binary arithmetic operation
     like `+'.  Any other combination of N and VALS is an error when
     selections are present.

 -- Function: calc-unary-op tag func arg
     This function implements a unary operator that allows a numeric
     prefix argument to apply the operator over many stack entries.  If
     the prefix argument ARG is `nil', this uses `calc-enter-result' as
     outlined above.  Otherwise, it maps the function over several stack
     elements; *note Prefix Arguments::.  For example,

          (defun calc-zeta (arg)
            (interactive "P")
            (calc-unary-op "zeta" 'calcFunc-zeta arg))

 -- Function: calc-binary-op tag func arg ident unary
     This function implements a binary operator, analogously to
     `calc-unary-op'.  The optional IDENT and UNARY arguments specify
     the behavior when the prefix argument is zero or one,
     respectively.  If the prefix is zero, the value IDENT is pushed
     onto the stack, if specified, otherwise an error message is
     displayed.  If the prefix is one, the unary function UNARY is
     applied to the top stack element, or, if UNARY is not specified,
     nothing happens.  When the argument is two or more, the binary
     function FUNC is reduced across the top ARG stack elements; when
     the argument is negative, the function is mapped between the
     next-to-top -ARG stack elements and the top element.

 -- Function: calc-stack-size
     Return the number of elements on the stack as an integer.  This
     count does not include elements that have been temporarily hidden
     by stack truncation; *note Truncating the Stack::.

 -- Function: calc-cursor-stack-index n
     Move the point to the Nth stack entry.  If N is zero, this will be
     the `.' line.  If N is from 1 to the current stack size, this will
     be the beginning of the first line of that stack entry's display.
     If line numbers are enabled, this will move to the first character
     of the line number, not the stack entry itself.

 -- Function: calc-substack-height n
     Return the number of lines between the beginning of the Nth stack
     entry and the bottom of the buffer.  If N is zero, this will be
     one (assuming no stack truncation).  If all stack entries are one
     line long (i.e., no matrices are displayed), the return value will
     be equal N+1 as long as N is in range.  (Note that in Big mode,
     the return value includes the blank lines that separate stack
     entries.)

 -- Function: calc-refresh
     Erase the `*Calculator*' buffer and reformat its contents from
     memory.  This must be called after changing any parameter, such as
     the current display radix, which might change the appearance of
     existing stack entries.  (During a keyboard macro invoked by the
     `X' key, refreshing is suppressed, but a flag is set so that the
     entire stack will be refreshed rather than just the top few
     elements when the macro finishes.)


File: calc,  Node: Predicates,  Next: Computational Lisp Functions,  Prev: Stack Lisp Functions,  Up: Internals

19.5.7.4 Predicates
...................

The functions described here are predicates, that is, they return a
true/false value where `nil' means false and anything else means true.
These predicates are expanded by `defmath', for example, from `zerop'
to `math-zerop'.  In many cases they correspond to native Lisp
functions by the same name, but are extended to cover the full range of
Calc data types.

 -- Function: zerop x
     Returns true if X is numerically zero, in any of the Calc data
     types.  (Note that for some types, such as error forms and
     intervals, it never makes sense to return true.)  In `defmath',
     the expression `(= x 0)' will automatically be converted to
     `(math-zerop x)', and `(/= x 0)' will be converted to `(not
     (math-zerop x))'.

 -- Function: negp x
     Returns true if X is negative.  This accepts negative real numbers
     of various types, negative HMS and date forms, and intervals in
     which all included values are negative.  In `defmath', the
     expression `(< x 0)' will automatically be converted to
     `(math-negp x)', and `(>= x 0)' will be converted to `(not
     (math-negp x))'.

 -- Function: posp x
     Returns true if X is positive (and non-zero).  For complex
     numbers, none of these three predicates will return true.

 -- Function: looks-negp x
     Returns true if X is "negative-looking."  This returns true if X
     is a negative number, or a formula with a leading minus sign such
     as `-a/b'.  In other words, this is an object which can be made
     simpler by calling `(- X)'.

 -- Function: integerp x
     Returns true if X is an integer of any size.

 -- Function: fixnump x
     Returns true if X is a native Lisp integer.

 -- Function: natnump x
     Returns true if X is a nonnegative integer of any size.

 -- Function: fixnatnump x
     Returns true if X is a nonnegative Lisp integer.

 -- Function: num-integerp x
     Returns true if X is numerically an integer, i.e., either a true
     integer or a float with no significant digits to the right of the
     decimal point.

 -- Function: messy-integerp x
     Returns true if X is numerically, but not literally, an integer.
     A value is `num-integerp' if it is `integerp' or `messy-integerp'
     (but it is never both at once).

 -- Function: num-natnump x
     Returns true if X is numerically a nonnegative integer.

 -- Function: evenp x
     Returns true if X is an even integer.

 -- Function: looks-evenp x
     Returns true if X is an even integer, or a formula with a leading
     multiplicative coefficient which is an even integer.

 -- Function: oddp x
     Returns true if X is an odd integer.

 -- Function: ratp x
     Returns true if X is a rational number, i.e., an integer or a
     fraction.

 -- Function: realp x
     Returns true if X is a real number, i.e., an integer, fraction, or
     floating-point number.

 -- Function: anglep x
     Returns true if X is a real number or HMS form.

 -- Function: floatp x
     Returns true if X is a float, or a complex number, error form,
     interval, date form, or modulo form in which at least one component
     is a float.

 -- Function: complexp x
     Returns true if X is a rectangular or polar complex number (but
     not a real number).

 -- Function: rect-complexp x
     Returns true if X is a rectangular complex number.

 -- Function: polar-complexp x
     Returns true if X is a polar complex number.

 -- Function: numberp x
     Returns true if X is a real number or a complex number.

 -- Function: scalarp x
     Returns true if X is a real or complex number or an HMS form.

 -- Function: vectorp x
     Returns true if X is a vector (this simply checks if its argument
     is a list whose first element is the symbol `vec').

 -- Function: numvecp x
     Returns true if X is a number or vector.

 -- Function: matrixp x
     Returns true if X is a matrix, i.e., a vector of one or more
     vectors, all of the same size.

 -- Function: square-matrixp x
     Returns true if X is a square matrix.

 -- Function: objectp x
     Returns true if X is any numeric Calc object, including real and
     complex numbers, HMS forms, date forms, error forms, intervals, and
     modulo forms.  (Note that error forms and intervals may include
     formulas as their components; see `constp' below.)

 -- Function: objvecp x
     Returns true if X is an object or a vector.  This also accepts
     incomplete objects, but it rejects variables and formulas (except
     as mentioned above for `objectp').

 -- Function: primp x
     Returns true if X is a "primitive" or "atomic" Calc object, i.e.,
     one whose components cannot be regarded as sub-formulas.  This
     includes variables, and all `objectp' types except error forms and
     intervals.

 -- Function: constp x
     Returns true if X is constant, i.e., a real or complex number, HMS
     form, date form, or error form, interval, or vector all of whose
     components are `constp'.

 -- Function: lessp x y
     Returns true if X is numerically less than Y.  Returns false if X
     is greater than or equal to Y, or if the order is undefined or
     cannot be determined.  Generally speaking, this works by checking
     whether `X - Y' is `negp'.  In `defmath', the expression `(< x y)'
     will automatically be converted to `(lessp x y)'; expressions
     involving `>', `<=', and `>=' are similarly converted in terms of
     `lessp'.

 -- Function: beforep x y
     Returns true if X comes before Y in a canonical ordering of Calc
     objects.  If X and Y are both real numbers, this will be the same
     as `lessp'.  But whereas `lessp' considers other types of objects
     to be unordered, `beforep' puts any two objects into a definite,
     consistent order.  The `beforep' function is used by the `V S'
     vector-sorting command, and also by `a s' to put the terms of a
     product into canonical order: This allows `x y + y x' to be
     simplified easily to `2 x y'.

 -- Function: equal x y
     This is the standard Lisp `equal' predicate; it returns true if X
     and Y are structurally identical.  This is the usual way to
     compare numbers for equality, but note that `equal' will treat 0
     and 0.0 as different.

 -- Function: math-equal x y
     Returns true if X and Y are numerically equal, either because they
     are `equal', or because their difference is `zerop'.  In
     `defmath', the expression `(= x y)' will automatically be
     converted to `(math-equal x y)'.

 -- Function: equal-int x n
     Returns true if X and N are numerically equal, where N is a fixnum
     which is not a multiple of 10.  This will automatically be used by
     `defmath' in place of the more general `math-equal' whenever
     possible.

 -- Function: nearly-equal x y
     Returns true if X and Y, as floating-point numbers, are equal
     except possibly in the last decimal place.  For example, 314.159
     and 314.166 are considered nearly equal if the current precision
     is 6 (since they differ by 7 units), but not if the current
     precision is 7 (since they differ by 70 units).  Most functions
     which use series expansions use `with-extra-prec' to evaluate the
     series with 2 extra digits of precision, then use `nearly-equal'
     to decide when the series has converged; this guards against
     cumulative error in the series evaluation without doing extra work
     which would be lost when the result is rounded back down to the
     current precision.  In `defmath', this can be written `(~= X Y)'.
     The X and Y can be numbers of any kind, including complex.

 -- Function: nearly-zerop x y
     Returns true if X is nearly zero, compared to Y.  This checks
     whether X plus Y would by be `nearly-equal' to Y itself, to within
     the current precision, in other words, if adding X to Y would have
     a negligible effect on Y due to roundoff error.  X may be a real
     or complex number, but Y must be real.

 -- Function: is-true x
     Return true if the formula X represents a true value in Calc, not
     Lisp, terms.  It tests if X is a non-zero number or a provably
     non-zero formula.

 -- Function: reject-arg val pred
     Abort the current function evaluation due to unacceptable argument
     values.  This calls `(calc-record-why PRED VAL)', then signals a
     Lisp error which `normalize' will trap.  The net effect is that the
     function call which led here will be left in symbolic form.

 -- Function: inexact-value
     If Symbolic mode is enabled, this will signal an error that causes
     `normalize' to leave the formula in symbolic form, with the message
     "Inexact result."  (This function has no effect when not in
     Symbolic mode.)  Note that if your function calls `(sin 5)' in
     Symbolic mode, the `sin' function will call `inexact-value', which
     will cause your function to be left unsimplified.  You may instead
     wish to call `(normalize (list 'calcFunc-sin 5))', which in
     Symbolic mode will return the formula `sin(5)' to your function.

 -- Function: overflow
     This signals an error that will be reported as a floating-point
     overflow.

 -- Function: underflow
     This signals a floating-point underflow.


File: calc,  Node: Computational Lisp Functions,  Next: Vector Lisp Functions,  Prev: Predicates,  Up: Internals

19.5.7.5 Computational Functions
................................

The functions described here do the actual computational work of the
Calculator.  In addition to these, note that any function described in
the main body of this manual may be called from Lisp; for example, if
the documentation refers to the `calc-sqrt' [`sqrt'] command, this
means `calc-sqrt' is an interactive stack-based square-root command and
`sqrt' (which `defmath' expands to `calcFunc-sqrt') is the actual Lisp
function for taking square roots.

   The functions `math-add', `math-sub', `math-mul', `math-div',
`math-mod', and `math-neg' are not included in this list, since
`defmath' allows you to write native Lisp `+', `-', `*', `/', `%', and
unary `-', respectively, instead.

 -- Function: normalize val
     (Full form: `math-normalize'.)  Reduce the value VAL to standard
     form.  For example, if VAL is a fixnum, it will be converted to a
     bignum if it is too large, and if VAL is a bignum it will be
     normalized by clipping off trailing (i.e., most-significant) zero
     digits and converting to a fixnum if it is small.  All the various
     data types are similarly converted to their standard forms.
     Variables are left alone, but function calls are actually evaluated
     in formulas.  For example, normalizing `(+ 2 (calcFunc-abs -4))'
     will return 6.

     If a function call fails, because the function is void or has the
     wrong number of parameters, or because it returns `nil' or calls
     `reject-arg' or `inexact-result', `normalize' returns the formula
     still in symbolic form.

     If the current simplification mode is "none" or "numeric arguments
     only," `normalize' will act appropriately.  However, the more
     powerful simplification modes (like Algebraic Simplification) are
     not handled by `normalize'.  They are handled by `calc-normalize',
     which calls `normalize' and possibly some other routines, such as
     `simplify' or `simplify-units'.  Programs generally will never
     call `calc-normalize' except when popping or pushing values on the
     stack.

 -- Function: evaluate-expr expr
     Replace all variables in EXPR that have values with their values,
     then use `normalize' to simplify the result.  This is what happens
     when you press the `=' key interactively.

 -- Macro: with-extra-prec n body
     Evaluate the Lisp forms in BODY with precision increased by N
     digits.  This is a macro which expands to

          (math-normalize
            (let ((calc-internal-prec (+ calc-internal-prec N)))
              BODY))

     The surrounding call to `math-normalize' causes a floating-point
     result to be rounded down to the original precision afterwards.
     This is important because some arithmetic operations assume a
     number's mantissa contains no more digits than the current
     precision allows.

 -- Function: make-frac n d
     Build a fraction `N:D'.  This is equivalent to calling `(normalize
     (list 'frac N D))', but more efficient.

 -- Function: make-float mant exp
     Build a floating-point value out of MANT and EXP, both of which
     are arbitrary integers.  This function will return a properly
     normalized float value, or signal an overflow or underflow if EXP
     is out of range.

 -- Function: make-sdev x sigma
     Build an error form out of X and the absolute value of SIGMA.  If
     SIGMA is zero, the result is the number X directly.  If SIGMA is
     negative or complex, its absolute value is used.  If X or SIGMA is
     not a valid type of object for use in error forms, this calls
     `reject-arg'.

 -- Function: make-intv mask lo hi
     Build an interval form out of MASK (which is assumed to be an
     integer from 0 to 3), and the limits LO and HI.  If LO is greater
     than HI, an empty interval form is returned.  This calls
     `reject-arg' if LO or HI is unsuitable.

 -- Function: sort-intv mask lo hi
     Build an interval form, similar to `make-intv', except that if LO
     is less than HI they are simply exchanged, and the bits of MASK
     are swapped accordingly.

 -- Function: make-mod n m
     Build a modulo form out of N and the modulus M.  Since modulo
     forms do not allow formulas as their components, if N or M is not
     a real number or HMS form the result will be a formula which is a
     call to `makemod', the algebraic version of this function.

 -- Function: float x
     Convert X to floating-point form.  Integers and fractions are
     converted to numerically equivalent floats; components of complex
     numbers, vectors, HMS forms, date forms, error forms, intervals,
     and modulo forms are recursively floated.  If the argument is a
     variable or formula, this calls `reject-arg'.

 -- Function: compare x y
     Compare the numbers X and Y, and return -1 if `(lessp X Y)', 1 if
     `(lessp Y X)', 0 if `(math-equal X Y)', or 2 if the order is
     undefined or cannot be determined.

 -- Function: numdigs n
     Return the number of digits of integer N, effectively
     `ceil(log10(N))', but much more efficient.  Zero is considered to
     have zero digits.

 -- Function: scale-int x n
     Shift integer X left N decimal digits, or right -N digits with
     truncation toward zero.

 -- Function: scale-rounding x n
     Like `scale-int', except that a right shift rounds to the nearest
     integer rather than truncating.

 -- Function: fixnum n
     Return the integer N as a fixnum, i.e., a native Lisp integer.  If
     N is outside the permissible range for Lisp integers (usually 24
     binary bits) the result is undefined.

 -- Function: sqr x
     Compute the square of X; short for `(* X X)'.

 -- Function: quotient x y
     Divide integer X by integer Y; return an integer quotient and
     discard the remainder.  If X or Y is negative, the direction of
     rounding is undefined.

 -- Function: idiv x y
     Perform an integer division; if X and Y are both nonnegative
     integers, this uses the `quotient' function, otherwise it computes
     `floor(X/Y)'.  Thus the result is well-defined but slower than for
     `quotient'.

 -- Function: imod x y
     Divide integer X by integer Y; return the integer remainder and
     discard the quotient.  Like `quotient', this works only for
     integer arguments and is not well-defined for negative arguments.
     For a more well-defined result, use `(% X Y)'.

 -- Function: idivmod x y
     Divide integer X by integer Y; return a cons cell whose `car' is
     `(quotient X Y)' and whose `cdr' is `(imod X Y)'.

 -- Function: pow x y
     Compute X to the power Y.  In `defmath' code, this can also be
     written `(^ X Y)' or `(expt X Y)'.

 -- Function: abs-approx x
     Compute a fast approximation to the absolute value of X.  For
     example, for a rectangular complex number the result is the sum of
     the absolute values of the components.

 -- Function: pi
     The function `(pi)' computes `pi' to the current precision.  Other
     related constant-generating functions are `two-pi', `pi-over-2',
     `pi-over-4', `pi-over-180', `sqrt-two-pi', `e', `sqrt-e', `ln-2',
     `ln-10', `phi' and `gamma-const'.  Each function returns a
     floating-point value in the current precision, and each uses
     caching so that all calls after the first are essentially free.

 -- Macro: math-defcache FUNC INITIAL FORM
     This macro, usually used as a top-level call like `defun' or
     `defvar', defines a new cached constant analogous to `pi', etc.
     It defines a function `func' which returns the requested value; if
     INITIAL is non-`nil' it must be a `(float ...)' form which serves
     as an initial value for the cache.  If FUNC is called when the
     cache is empty or does not have enough digits to satisfy the
     current precision, the Lisp expression FORM is evaluated with the
     current precision increased by four, and the result minus its two
     least significant digits is stored in the cache.  For example,
     calling `(pi)' with a precision of 30 computes `pi' to 34 digits,
     rounds it down to 32 digits for future use, then rounds it again
     to 30 digits for use in the present request.

 -- Function: full-circle symb
     If the current angular mode is Degrees or HMS, this function
     returns the integer 360.  In Radians mode, this function returns
     either the corresponding value in radians to the current
     precision, or the formula `2*pi', depending on the Symbolic mode.
     There are also similar function `half-circle' and `quarter-circle'.

 -- Function: power-of-2 n
     Compute two to the integer power N, as a (potentially very large)
     integer.  Powers of two are cached, so only the first call for a
     particular N is expensive.

 -- Function: integer-log2 n
     Compute the base-2 logarithm of N, which must be an integer which
     is a power of two.  If N is not a power of two, this function will
     return `nil'.

 -- Function: div-mod a b m
     Divide A by B, modulo M.  This returns `nil' if there is no
     solution, or if any of the arguments are not integers.

 -- Function: pow-mod a b m
     Compute A to the power B, modulo M.  If A, B, and M are integers,
     this uses an especially efficient algorithm.  Otherwise, it simply
     computes `(% (^ a b) m)'.

 -- Function: isqrt n
     Compute the integer square root of N.  This is the square root of
     N rounded down toward zero, i.e., `floor(sqrt(N))'.  If N is
     itself an integer, the computation is especially efficient.

 -- Function: to-hms a ang
     Convert the argument A into an HMS form.  If ANG is specified, it
     is the angular mode in which to interpret A, either `deg' or
     `rad'.  Otherwise, the current angular mode is used.  If A is
     already an HMS form it is returned as-is.

 -- Function: from-hms a ang
     Convert the HMS form A into a real number.  If ANG is specified,
     it is the angular mode in which to express the result, otherwise
     the current angular mode is used.  If A is already a real number,
     it is returned as-is.

 -- Function: to-radians a
     Convert the number or HMS form A to radians from the current
     angular mode.

 -- Function: from-radians a
     Convert the number A from radians to the current angular mode.  If
     A is a formula, this returns the formula `deg(A)'.

 -- Function: to-radians-2 a
     Like `to-radians', except that in Symbolic mode a degrees to
     radians conversion yields a formula like `A*pi/180'.

 -- Function: from-radians-2 a
     Like `from-radians', except that in Symbolic mode a radians to
     degrees conversion yields a formula like `A*180/pi'.

 -- Function: random-digit
     Produce a random base-1000 digit in the range 0 to 999.

 -- Function: random-digits n
     Produce a random N-digit integer; this will be an integer in the
     interval `[0, 10^N)'.

 -- Function: random-float
     Produce a random float in the interval `[0, 1)'.

 -- Function: prime-test n iters
     Determine whether the integer N is prime.  Return a list which has
     one of these forms: `(nil F)' means the number is non-prime
     because it was found to be divisible by F; `(nil)' means it was
     found to be non-prime by table look-up (so no factors are known);
     `(nil unknown)' means it is definitely non-prime but no factors
     are known because N was large enough that Fermat's probabilistic
     test had to be used; `(t)' means the number is definitely prime;
     and `(maybe I P)' means that Fermat's test, after I iterations, is
     P percent sure that the number is prime.  The ITERS parameter is
     the number of Fermat iterations to use, in the case that this is
     necessary.  If `prime-test' returns "maybe," you can call it again
     with the same N to get a greater certainty; `prime-test' remembers
     where it left off.

 -- Function: to-simple-fraction f
     If F is a floating-point number which can be represented exactly
     as a small rational number. return that number, else return F.
     For example, 0.75 would be converted to 3:4.  This function is very
     fast.

 -- Function: to-fraction f tol
     Find a rational approximation to floating-point number F to within
     a specified tolerance TOL; this corresponds to the algebraic
     function `frac', and can be rather slow.

 -- Function: quarter-integer n
     If N is an integer or integer-valued float, this function returns
     zero.  If N is a half-integer (i.e., an integer plus 1:2 or 0.5),
     it returns 2.  If N is a quarter-integer, it returns 1 or 3.  If N
     is anything else, this function returns `nil'.


File: calc,  Node: Vector Lisp Functions,  Next: Symbolic Lisp Functions,  Prev: Computational Lisp Functions,  Up: Internals

19.5.7.6 Vector Functions
.........................

The functions described here perform various operations on vectors and
matrices.

 -- Function: math-concat x y
     Do a vector concatenation; this operation is written `X | Y' in a
     symbolic formula.  *Note Building Vectors::.

 -- Function: vec-length v
     Return the length of vector V.  If V is not a vector, the result
     is zero.  If V is a matrix, this returns the number of rows in the
     matrix.

 -- Function: mat-dimens m
     Determine the dimensions of vector or matrix M.  If M is not a
     vector, the result is an empty list.  If M is a plain vector but
     not a matrix, the result is a one-element list containing the
     length of the vector.  If M is a matrix with R rows and C columns,
     the result is the list `(R C)'.  Higher-order tensors produce
     lists of more than two dimensions.  Note that the object `[[1, 2,
     3], [4, 5]]' is a vector of vectors not all the same size, and is
     treated by this and other Calc routines as a plain vector of two
     elements.

 -- Function: dimension-error
     Abort the current function with a message of "Dimension error."
     The Calculator will leave the function being evaluated in symbolic
     form; this is really just a special case of `reject-arg'.

 -- Function: build-vector args
     Return a Calc vector with ARGS as elements.  For example,
     `(build-vector 1 2 3)' returns the Calc vector `[1, 2, 3]', stored
     internally as the list `(vec 1 2 3)'.

 -- Function: make-vec obj dims
     Return a Calc vector or matrix all of whose elements are equal to
     OBJ.  For example, `(make-vec 27 3 4)' returns a 3x4 matrix filled
     with 27's.

 -- Function: row-matrix v
     If V is a plain vector, convert it into a row matrix, i.e., a
     matrix whose single row is V.  If V is already a matrix, leave it
     alone.

 -- Function: col-matrix v
     If V is a plain vector, convert it into a column matrix, i.e., a
     matrix with each element of V as a separate row.  If V is already
     a matrix, leave it alone.

 -- Function: map-vec f v
     Map the Lisp function F over the Calc vector V.  For example,
     `(map-vec 'math-floor v)' returns a vector of the floored
     components of vector V.

 -- Function: map-vec-2 f a b
     Map the Lisp function F over the two vectors A and B.  If A and B
     are vectors of equal length, the result is a vector of the results
     of calling `(F AI BI)' for each pair of elements AI and BI.  If
     either A or B is a scalar, it is matched with each value of the
     other vector.  For example, `(map-vec-2 'math-add v 1)' returns
     the vector V with each element increased by one.  Note that using
     `'+' would not work here, since `defmath' does not expand function
     names everywhere, just where they are in the function position of
     a Lisp expression.

 -- Function: reduce-vec f v
     Reduce the function F over the vector V.  For example, if V is
     `[10, 20, 30, 40]', this calls `(f (f (f 10 20) 30) 40)'.  If V is
     a matrix, this reduces over the rows of V.

 -- Function: reduce-cols f m
     Reduce the function F over the columns of matrix M.  For example,
     if M is `[[1, 2], [3, 4], [5, 6]]', the result is a vector of the
     two elements `(f (f 1 3) 5)' and `(f (f 2 4) 6)'.

 -- Function: mat-row m n
     Return the Nth row of matrix M.  This is equivalent to `(elt m
     n)'.  For a slower but safer version, use `mrow'.  (*Note
     Extracting Elements::.)

 -- Function: mat-col m n
     Return the Nth column of matrix M, in the form of a vector.  The
     arguments are not checked for correctness.

 -- Function: mat-less-row m n
     Return a copy of matrix M with its Nth row deleted.  The number N
     must be in range from 1 to the number of rows in M.

 -- Function: mat-less-col m n
     Return a copy of matrix M with its Nth column deleted.

 -- Function: transpose m
     Return the transpose of matrix M.

 -- Function: flatten-vector v
     Flatten nested vector V into a vector of scalars.  For example, if
     V is `[[1, 2, 3], [4, 5]]' the result is `[1, 2, 3, 4, 5]'.

 -- Function: copy-matrix m
     If M is a matrix, return a copy of M.  This maps `copy-sequence'
     over the rows of M; in Lisp terms, each element of the result
     matrix will be `eq' to the corresponding element of M, but none of
     the `cons' cells that make up the structure of the matrix will be
     `eq'.  If M is a plain vector, this is the same as `copy-sequence'.

 -- Function: swap-rows m r1 r2
     Exchange rows R1 and R2 of matrix M in-place.  In other words,
     unlike most of the other functions described here, this function
     changes M itself rather than building up a new result matrix.  The
     return value is M, i.e., `(eq (swap-rows m 1 2) m)' is true, with
     the side effect of exchanging the first two rows of M.


File: calc,  Node: Symbolic Lisp Functions,  Next: Formatting Lisp Functions,  Prev: Vector Lisp Functions,  Up: Internals

19.5.7.7 Symbolic Functions
...........................

The functions described here operate on symbolic formulas in the
Calculator.

 -- Function: calc-prepare-selection num
     Prepare a stack entry for selection operations.  If NUM is
     omitted, the stack entry containing the cursor is used; otherwise,
     it is the number of the stack entry to use.  This function stores
     useful information about the current stack entry into a set of
     variables.  `calc-selection-cache-num' contains the number of the
     stack entry involved (equal to NUM if you specified it);
     `calc-selection-cache-entry' contains the stack entry as a list
     (such as `calc-top-list' would return with `entry' as the
     selection mode); and `calc-selection-cache-comp' contains a
     special "tagged" composition (*note Formatting Lisp Functions::)
     which allows Calc to relate cursor positions in the buffer with
     their corresponding sub-formulas.

     A slight complication arises in the selection mechanism because
     formulas may contain small integers.  For example, in the vector
     `[1, 2, 1]' the first and last elements are `eq' to each other;
     selections are recorded as the actual Lisp object that appears
     somewhere in the tree of the whole formula, but storing `1' would
     falsely select both `1''s in the vector.  So
     `calc-prepare-selection' also checks the stack entry and replaces
     any plain integers with "complex number" lists of the form `(cplx
     N 0)'.  This list will be displayed the same as a plain N and the
     change will be completely invisible to the user, but it will
     guarantee that no two sub-formulas of the stack entry will be `eq'
     to each other.  Next time the stack entry is involved in a
     computation, `calc-normalize' will replace these lists with plain
     numbers again, again invisibly to the user.

 -- Function: calc-encase-atoms x
     This modifies the formula X to ensure that each part of the
     formula is a unique atom, using the `(cplx N 0)' trick described
     above.  This function may use `setcar' to modify the formula
     in-place.

 -- Function: calc-find-selected-part
     Find the smallest sub-formula of the current formula that contains
     the cursor.  This assumes `calc-prepare-selection' has been called
     already.  If the cursor is not actually on any part of the
     formula, this returns `nil'.

 -- Function: calc-change-current-selection selection
     Change the currently prepared stack element's selection to
     SELECTION, which should be `eq' to some sub-formula of the stack
     element, or `nil' to unselect the formula.  The stack element's
     appearance in the Calc buffer is adjusted to reflect the new
     selection.

 -- Function: calc-find-nth-part expr n
     Return the Nth sub-formula of EXPR.  This function is used by the
     selection commands, and (unless `j b' has been used) treats sums
     and products as flat many-element formulas.  Thus if EXPR is `((a
     + b) - c) + d', calling `calc-find-nth-part' with N equal to four
     will return `d'.

 -- Function: calc-find-parent-formula expr part
     Return the sub-formula of EXPR which immediately contains PART.
     If EXPR is `a*b + (c+1)*d' and PART is `eq' to the `c+1' term of
     EXPR, then this function will return `(c+1)*d'.  If PART turns out
     not to be a sub-formula of EXPR, the function returns `nil'.  If
     PART is `eq' to EXPR, the function returns `t'.  This function
     does not take associativity into account.

 -- Function: calc-find-assoc-parent-formula expr part
     This is the same as `calc-find-parent-formula', except that
     (unless `j b' has been used) it continues widening the selection
     to contain a complete level of the formula.  Given `a' from `((a +
     b) - c) + d', `calc-find-parent-formula' will return `a + b' but
     `calc-find-assoc-parent-formula' will return the whole expression.

 -- Function: calc-grow-assoc-formula expr part
     This expands sub-formula PART of EXPR to encompass a complete
     level of the formula.  If PART and its immediate parent are not
     compatible associative operators, or if `j b' has been used, this
     simply returns PART.

 -- Function: calc-find-sub-formula expr part
     This finds the immediate sub-formula of EXPR which contains PART.
     It returns an index N such that `(calc-find-nth-part EXPR N)'
     would return PART.  If PART is not a sub-formula of EXPR, it
     returns `nil'.  If PART is `eq' to EXPR, it returns `t'.  This
     function does not take associativity into account.

 -- Function: calc-replace-sub-formula expr old new
     This function returns a copy of formula EXPR, with the sub-formula
     that is `eq' to OLD replaced by NEW.

 -- Function: simplify expr
     Simplify the expression EXPR by applying various algebraic rules.
     This is what the `a s' (`calc-simplify') command uses.  This
     always returns a copy of the expression; the structure EXPR points
     to remains unchanged in memory.

     More precisely, here is what `simplify' does:  The expression is
     first normalized and evaluated by calling `normalize'.  If any
     `AlgSimpRules' have been defined, they are then applied.  Then the
     expression is traversed in a depth-first, bottom-up fashion; at
     each level, any simplifications that can be made are made until no
     further changes are possible.  Once the entire formula has been
     traversed in this way, it is compared with the original formula
     (from before the call to `normalize') and, if it has changed, the
     entire procedure is repeated (starting with `normalize') until no
     further changes occur.  Usually only two iterations are needed:
     one to simplify the formula, and another to verify that no further
     simplifications were possible.

 -- Function: simplify-extended expr
     Simplify the expression EXPR, with additional rules enabled that
     help do a more thorough job, while not being entirely "safe" in all
     circumstances.  (For example, this mode will simplify `sqrt(x^2)'
     to `x', which is only valid when X is positive.)  This is
     implemented by temporarily binding the variable
     `math-living-dangerously' to `t' (using a `let' form) and calling
     `simplify'.  Dangerous simplification rules are written to check
     this variable before taking any action.

 -- Function: simplify-units expr
     Simplify the expression EXPR, treating variable names as units
     whenever possible.  This works by binding the variable
     `math-simplifying-units' to `t' while calling `simplify'.

 -- Macro: math-defsimplify funcs body
     Register a new simplification rule; this is normally called as a
     top-level form, like `defun' or `defmath'.  If FUNCS is a symbol
     (like `+' or `calcFunc-sqrt'), this simplification rule is applied
     to the formulas which are calls to the specified function.  Or,
     FUNCS can be a list of such symbols; the rule applies to all
     functions on the list.  The BODY is written like the body of a
     function with a single argument called `expr'.  The body will be
     executed with `expr' bound to a formula which is a call to one of
     the functions FUNCS.  If the function body returns `nil', or if it
     returns a result `equal' to the original `expr', it is ignored and
     Calc goes on to try the next simplification rule that applies.  If
     the function body returns something different, that new formula is
     substituted for EXPR in the original formula.

     At each point in the formula, rules are tried in the order of the
     original calls to `math-defsimplify'; the search stops after the
     first rule that makes a change.  Thus later rules for that same
     function will not have a chance to trigger until the next iteration
     of the main `simplify' loop.

     Note that, since `defmath' is not being used here, BODY must be
     written in true Lisp code without the conveniences that `defmath'
     provides.  If you prefer, you can have BODY simply call another
     function (defined with `defmath') which does the real work.

     The arguments of a function call will already have been simplified
     before any rules for the call itself are invoked.  Since a new
     argument list is consed up when this happens, this means that the
     rule's body is allowed to rearrange the function's arguments
     destructively if that is convenient.  Here is a typical example of
     a simplification rule:

          (math-defsimplify calcFunc-arcsinh
            (or (and (math-looks-negp (nth 1 expr))
                     (math-neg (list 'calcFunc-arcsinh
                                     (math-neg (nth 1 expr)))))
                (and (eq (car-safe (nth 1 expr)) 'calcFunc-sinh)
                     (or math-living-dangerously
                         (math-known-realp (nth 1 (nth 1 expr))))
                     (nth 1 (nth 1 expr)))))

     This is really a pair of rules written with one `math-defsimplify'
     for convenience; the first replaces `arcsinh(-x)' with
     `-arcsinh(x)', and the second, which is safe only for real `x',
     replaces `arcsinh(sinh(x))' with `x'.

 -- Function: common-constant-factor expr
     Check EXPR to see if it is a sum of terms all multiplied by the
     same rational value.  If so, return this value.  If not, return
     `nil'.  For example, if called on `6x + 9y + 12z', it would return
     3, since 3 is a common factor of all the terms.

 -- Function: cancel-common-factor expr factor
     Assuming EXPR is a sum with FACTOR as a common factor, divide each
     term of the sum by FACTOR.  This is done by destructively
     modifying parts of EXPR, on the assumption that it is being used
     by a simplification rule (where such things are allowed; see
     above).  For example, consider this built-in rule for square roots:

          (math-defsimplify calcFunc-sqrt
            (let ((fac (math-common-constant-factor (nth 1 expr))))
              (and fac (not (eq fac 1))
                   (math-mul (math-normalize (list 'calcFunc-sqrt fac))
                             (math-normalize
                              (list 'calcFunc-sqrt
                                    (math-cancel-common-factor
                                     (nth 1 expr) fac)))))))

 -- Function: frac-gcd a b
     Compute a "rational GCD" of A and B, which must both be rational
     numbers.  This is the fraction composed of the GCD of the
     numerators of A and B, over the GCD of the denominators.  It is
     used by `common-constant-factor'.  Note that the standard `gcd'
     function uses the LCM to combine the denominators.

 -- Function: map-tree func expr many
     Try applying Lisp function FUNC to various sub-expressions of
     EXPR.  Initially, call FUNC with EXPR itself as an argument.  If
     this returns an expression which is not `equal' to EXPR, apply
     FUNC again until eventually it does return EXPR with no changes.
     Then, if EXPR is a function call, recursively apply FUNC to each
     of the arguments.  This keeps going until no changes occur
     anywhere in the expression; this final expression is returned by
     `map-tree'.  Note that, unlike simplification rules, FUNC
     functions may _not_ make destructive changes to EXPR.  If a third
     argument MANY is provided, it is an integer which says how many
     times FUNC may be applied; the default, as described above, is
     infinitely many times.

 -- Function: compile-rewrites rules
     Compile the rewrite rule set specified by RULES, which should be a
     formula that is either a vector or a variable name.  If the latter,
     the compiled rules are saved so that later `compile-rules' calls
     for that same variable can return immediately.  If there are
     problems with the rules, this function calls `error' with a
     suitable message.

 -- Function: apply-rewrites expr crules heads
     Apply the compiled rewrite rule set CRULES to the expression EXPR.
     This will make only one rewrite and only checks at the top level
     of the expression.  The result `nil' if no rules matched, or if
     the only rules that matched did not actually change the
     expression.  The HEADS argument is optional; if is given, it
     should be a list of all function names that (may) appear in EXPR.
     The rewrite compiler tags each rule with the rarest-looking
     function name in the rule; if you specify HEADS, `apply-rewrites'
     can use this information to narrow its search down to just a few
     rules in the rule set.

 -- Function: rewrite-heads expr
     Compute a HEADS list for EXPR suitable for use with
     `apply-rewrites', as discussed above.

 -- Function: rewrite expr rules many
     This is an all-in-one rewrite function.  It compiles the rule set
     specified by RULES, then uses `map-tree' to apply the rules
     throughout EXPR up to MANY (default infinity) times.

 -- Function: match-patterns pat vec not-flag
     Given a Calc vector VEC and an uncompiled pattern set or pattern
     set variable PAT, this function returns a new vector of all
     elements of VEC which do (or don't, if NOT-FLAG is non-`nil')
     match any of the patterns in PAT.

 -- Function: deriv expr var value symb
     Compute the derivative of EXPR with respect to variable VAR (which
     may actually be any sub-expression).  If VALUE is specified, the
     derivative is evaluated at the value of VAR; otherwise, the
     derivative is left in terms of VAR.  If the expression contains
     functions for which no derivative formula is known, new derivative
     functions are invented by adding primes to the names; *note
     Calculus::.  However, if SYMB is non-`nil', the presence of
     nondifferentiable functions in EXPR instead cancels the whole
     differentiation, and `deriv' returns `nil' instead.

     Derivatives of an N-argument function can be defined by adding a
     `math-derivative-N' property to the property list of the symbol
     for the function's derivative, which will be the function name
     followed by an apostrophe.  The value of the property should be a
     Lisp function; it is called with the same arguments as the
     original function call that is being differentiated.  It should
     return a formula for the derivative.  For example, the derivative
     of `ln' is defined by

          (put 'calcFunc-ln\' 'math-derivative-1
               (function (lambda (u) (math-div 1 u))))

     The two-argument `log' function has two derivatives,
          (put 'calcFunc-log\' 'math-derivative-2     ; d(log(x,b)) / dx
               (function (lambda (x b) ... )))
          (put 'calcFunc-log\'2 'math-derivative-2    ; d(log(x,b)) / db
               (function (lambda (x b) ... )))

 -- Function: tderiv expr var value symb
     Compute the total derivative of EXPR.  This is the same as
     `deriv', except that variables other than VAR are not assumed to
     be constant with respect to VAR.

 -- Function: integ expr var low high
     Compute the integral of EXPR with respect to VAR.  *Note
     Calculus::, for further details.

 -- Macro: math-defintegral funcs body
     Define a rule for integrating a function or functions of one
     argument; this macro is very similar in format to
     `math-defsimplify'.  The main difference is that here BODY is the
     body of a function with a single argument `u' which is bound to
     the argument to the function being integrated, not the function
     call itself.  Also, the variable of integration is available as
     `math-integ-var'.  If evaluation of the integral requires doing
     further integrals, the body should call `(math-integral X)' to
     find the integral of X with respect to `math-integ-var'; this
     function returns `nil' if the integral could not be done.  Some
     examples:

          (math-defintegral calcFunc-conj
            (let ((int (math-integral u)))
              (and int
                   (list 'calcFunc-conj int))))

          (math-defintegral calcFunc-cos
            (and (equal u math-integ-var)
                 (math-from-radians-2 (list 'calcFunc-sin u))))

     In the `cos' example, we define only the integral of `cos(x) dx',
     relying on the general integration-by-substitution facility to
     handle cosines of more complicated arguments.  An integration rule
     should return `nil' if it can't do the integral; if several rules
     are defined for the same function, they are tried in order until
     one returns a non-`nil' result.

 -- Macro: math-defintegral-2 funcs body
     Define a rule for integrating a function or functions of two
     arguments.  This is exactly analogous to `math-defintegral',
     except that BODY is written as the body of a function with two
     arguments, U and V.

 -- Function: solve-for lhs rhs var full
     Attempt to solve the equation `LHS = RHS' by isolating the
     variable VAR on the lefthand side; return the resulting righthand
     side, or `nil' if the equation cannot be solved.  The variable VAR
     must appear at least once in LHS or RHS.  Note that the return
     value is a formula which does not contain VAR; this is different
     from the user-level `solve' and `finv' functions, which return a
     rearranged equation or a functional inverse, respectively.  If
     FULL is non-`nil', a full solution including dummy signs and dummy
     integers will be produced.  User-defined inverses are provided as
     properties in a manner similar to derivatives:

          (put 'calcFunc-ln 'math-inverse
               (function (lambda (x) (list 'calcFunc-exp x))))

     This function can call `(math-solve-get-sign X)' to create a new
     arbitrary sign variable, returning X times that sign, and
     `(math-solve-get-int X)' to create a new arbitrary integer
     variable multiplied by X.  These functions simply return X if the
     caller requested a non-"full" solution.

 -- Function: solve-eqn expr var full
     This version of `solve-for' takes an expression which will
     typically be an equation or inequality.  (If it is not, it will be
     interpreted as the equation `EXPR = 0'.)  It returns an equation
     or inequality, or `nil' if no solution could be found.

 -- Function: solve-system exprs vars full
     This function solves a system of equations.  Generally, EXPRS and
     VARS will be vectors of equal length.  *Note Solving Systems of
     Equations::, for other options.

 -- Function: expr-contains expr var
     Returns a non-`nil' value if VAR occurs as a subexpression of EXPR.

     This function might seem at first to be identical to
     `calc-find-sub-formula'.  The key difference is that
     `expr-contains' uses `equal' to test for matches, whereas
     `calc-find-sub-formula' uses `eq'.  In the formula `f(a, a)', the
     two `a's will be `equal' but not `eq' to each other.

 -- Function: expr-contains-count expr var
     Returns the number of occurrences of VAR as a subexpression of
     EXPR, or `nil' if there are no occurrences.

 -- Function: expr-depends expr var
     Returns true if EXPR refers to any variable the occurs in VAR.  In
     other words, it checks if EXPR and VAR have any variables in
     common.

 -- Function: expr-contains-vars expr
     Return true if EXPR contains any variables, or `nil' if EXPR
     contains only constants and functions with constant arguments.

 -- Function: expr-subst expr old new
     Returns a copy of EXPR, with all occurrences of OLD replaced by
     NEW.  This treats `lambda' forms specially with respect to the
     dummy argument variables, so that the effect is always to return
     EXPR evaluated at OLD = NEW.

 -- Function: multi-subst expr old new
     This is like `expr-subst', except that OLD and NEW are lists of
     expressions to be substituted simultaneously.  If one list is
     shorter than the other, trailing elements of the longer list are
     ignored.

 -- Function: expr-weight expr
     Returns the "weight" of EXPR, basically a count of the total
     number of objects and function calls that appear in EXPR.  For
     "primitive" objects, this will be one.

 -- Function: expr-height expr
     Returns the "height" of EXPR, which is the deepest level to which
     function calls are nested.  (Note that `A + B' counts as a
     function call.)  For primitive objects, this returns zero.

 -- Function: polynomial-p expr var
     Check if EXPR is a polynomial in variable (or sub-expression) VAR.
     If so, return the degree of the polynomial, that is, the highest
     power of VAR that appears in EXPR.  For example, for `(x^2 + 3)^3
     + 4' this would return 6.  This function returns `nil' unless
     EXPR, when expanded out by `a x' (`calc-expand'), would consist of
     a sum of terms in which VAR appears only raised to nonnegative
     integer powers.  Note that if VAR does not occur in EXPR, then
     EXPR is considered a polynomial of degree 0.

 -- Function: is-polynomial expr var degree loose
     Check if EXPR is a polynomial in variable or sub-expression VAR,
     and, if so, return a list representation of the polynomial where
     the elements of the list are coefficients of successive powers of
     VAR: `A + B x + C x^3' would produce the list `(A B 0 C)', and `(x
     + 1)^2' would produce the list `(1 2 1)'.  The highest element of
     the list will be non-zero, with the special exception that if EXPR
     is the constant zero, the returned value will be `(0)'.  Return
     `nil' if EXPR is not a polynomial in VAR.  If DEGREE is specified,
     this will not consider polynomials of degree higher than that
     value.  This is a good precaution because otherwise an input of
     `(x+1)^1000' will cause a huge coefficient list to be built.  If
     LOOSE is non-`nil', then a looser definition of a polynomial is
     used in which coefficients are no longer required not to depend on
     VAR, but are only required not to take the form of polynomials
     themselves.  For example, `sin(x) x^2 + cos(x)' is a loose
     polynomial with coefficients `((calcFunc-cos x) 0 (calcFunc-sin
     x))'.  The result will never be `nil' in loose mode, since any
     expression can be interpreted as a "constant" loose polynomial.

 -- Function: polynomial-base expr pred
     Check if EXPR is a polynomial in any variable that occurs in it;
     if so, return that variable.  (If EXPR is a multivariate
     polynomial, this chooses one variable arbitrarily.)  If PRED is
     specified, it should be a Lisp function which is called as `(PRED
     SUBEXPR)', and which should return true if `mpb-top-expr' (a
     global name for the original EXPR) is a suitable polynomial in
     SUBEXPR.  The default predicate uses `(polynomial-p mpb-top-expr
     SUBEXPR)'; you can use PRED to specify additional conditions.  Or,
     you could have PRED build up a list of every suitable SUBEXPR that
     is found.

 -- Function: poly-simplify poly
     Simplify polynomial coefficient list POLY by (destructively)
     clipping off trailing zeros.

 -- Function: poly-mix a ac b bc
     Mix two polynomial lists A and B (in the form returned by
     `is-polynomial') in a linear combination with coefficient
     expressions AC and BC.  The result is a (not necessarily
     simplified) polynomial list representing `AC A + BC B'.

 -- Function: poly-mul a b
     Multiply two polynomial coefficient lists A and B.  The result
     will be in simplified form if the inputs were simplified.

 -- Function: build-polynomial-expr poly var
     Construct a Calc formula which represents the polynomial
     coefficient list POLY applied to variable VAR.  The `a c'
     (`calc-collect') command uses `is-polynomial' to turn an
     expression into a coefficient list, then `build-polynomial-expr'
     to turn the list back into an expression in regular form.

 -- Function: check-unit-name var
     Check if VAR is a variable which can be interpreted as a unit
     name.  If so, return the units table entry for that unit.  This
     will be a list whose first element is the unit name (not counting
     prefix characters) as a symbol and whose second element is the
     Calc expression which defines the unit.  (Refer to the Calc sources
     for details on the remaining elements of this list.)  If VAR is
     not a variable or is not a unit name, return `nil'.

 -- Function: units-in-expr-p expr sub-exprs
     Return true if EXPR contains any variables which can be
     interpreted as units.  If SUB-EXPRS is `t', the entire expression
     is searched.  If SUB-EXPRS is `nil', this checks whether EXPR is
     directly a units expression.

 -- Function: single-units-in-expr-p expr
     Check whether EXPR contains exactly one units variable.  If so,
     return the units table entry for the variable.  If EXPR does not
     contain any units, return `nil'.  If EXPR contains two or more
     units, return the symbol `wrong'.

 -- Function: to-standard-units expr which
     Convert units expression EXPR to base units.  If WHICH is `nil',
     use Calc's native base units.  Otherwise, WHICH can specify a
     units system, which is a list of two-element lists, where the
     first element is a Calc base symbol name and the second is an
     expression to substitute for it.

 -- Function: remove-units expr
     Return a copy of EXPR with all units variables replaced by ones.
     This expression is generally normalized before use.

 -- Function: extract-units expr
     Return a copy of EXPR with everything but units variables replaced
     by ones.


File: calc,  Node: Formatting Lisp Functions,  Next: Hooks,  Prev: Symbolic Lisp Functions,  Up: Internals

19.5.7.8 I/O and Formatting Functions
.....................................

The functions described here are responsible for parsing and formatting
Calc numbers and formulas.

 -- Function: calc-eval str sep arg1 arg2 ...
     This is the simplest interface to the Calculator from another Lisp
     program.  *Note Calling Calc from Your Programs::.

 -- Function: read-number str
     If string STR contains a valid Calc number, either integer,
     fraction, float, or HMS form, this function parses and returns that
     number.  Otherwise, it returns `nil'.

 -- Function: read-expr str
     Read an algebraic expression from string STR.  If STR does not
     have the form of a valid expression, return a list of the form
     `(error POS MSG)' where POS is an integer index into STR of the
     general location of the error, and MSG is a string describing the
     problem.

 -- Function: read-exprs str
     Read a list of expressions separated by commas, and return it as a
     Lisp list.  If an error occurs in any expressions, an error list as
     shown above is returned instead.

 -- Function: calc-do-alg-entry initial prompt no-norm
     Read an algebraic formula or formulas using the minibuffer.  All
     conventions of regular algebraic entry are observed.  The return
     value is a list of Calc formulas; there will be more than one if
     the user entered a list of values separated by commas.  The result
     is `nil' if the user presses Return with a blank line.  If INITIAL
     is given, it is a string which the minibuffer will initially
     contain.  If PROMPT is given, it is the prompt string to use; the
     default is "Algebraic:".  If NO-NORM is `t', the formulas will be
     returned exactly as parsed; otherwise, they will be passed through
     `calc-normalize' first.

     To support the use of `$' characters in the algebraic entry, use
     `let' to bind `calc-dollar-values' to a list of the values to be
     substituted for `$', `$$', and so on, and bind `calc-dollar-used'
     to 0.  Upon return, `calc-dollar-used' will have been changed to
     the highest number of consecutive `$'s that actually appeared in
     the input.

 -- Function: format-number a
     Convert the real or complex number or HMS form A to string form.

 -- Function: format-flat-expr a prec
     Convert the arbitrary Calc number or formula A to string form, in
     the style used by the trail buffer and the `calc-edit' command.
     This is a simple format designed mostly to guarantee the string is
     of a form that can be re-parsed by `read-expr'.  Most formatting
     modes, such as digit grouping, complex number format, and point
     character, are ignored to ensure the result will be re-readable.
     The PREC parameter is normally 0; if you pass a large integer like
     1000 instead, the expression will be surrounded by parentheses
     unless it is a plain number or variable name.

 -- Function: format-nice-expr a width
     This is like `format-flat-expr' (with PREC equal to 0), except
     that newlines will be inserted to keep lines down to the specified
     WIDTH, and vectors that look like matrices or rewrite rules are
     written in a pseudo-matrix format.  The `calc-edit' command uses
     this when only one stack entry is being edited.

 -- Function: format-value a width
     Convert the Calc number or formula A to string form, using the
     format seen in the stack buffer.  Beware the string returned may
     not be re-readable by `read-expr', for example, because of digit
     grouping.  Multi-line objects like matrices produce strings that
     contain newline characters to separate the lines.  The W
     parameter, if given, is the target window size for which to format
     the expressions.  If W is omitted, the width of the Calculator
     window is used.

 -- Function: compose-expr a prec
     Format the Calc number or formula A according to the current
     language mode, returning a "composition."  To learn about the
     structure of compositions, see the comments in the Calc source
     code.  You can specify the format of a given type of function call
     by putting a `math-compose-LANG' property on the function's symbol,
     whose value is a Lisp function that takes A and PREC as arguments
     and returns a composition.  Here LANG is a language mode name, one
     of `normal', `big', `c', `pascal', `fortran', `tex', `eqn',
     `math', or `maple'.  In Big mode, Calc actually tries
     `math-compose-big' first, then tries `math-compose-normal'.  If
     this property does not exist, or if the function returns `nil',
     the function is written in the normal function-call notation for
     that language.

 -- Function: composition-to-string c w
     Convert a composition structure returned by `compose-expr' into a
     string.  Multi-line compositions convert to strings containing
     newline characters.  The target window size is given by W.  The
     `format-value' function basically calls `compose-expr' followed by
     `composition-to-string'.

 -- Function: comp-width c
     Compute the width in characters of composition C.

 -- Function: comp-height c
     Compute the height in lines of composition C.

 -- Function: comp-ascent c
     Compute the portion of the height of composition C which is on or
     above the baseline.  For a one-line composition, this will be one.

 -- Function: comp-descent c
     Compute the portion of the height of composition C which is below
     the baseline.  For a one-line composition, this will be zero.

 -- Function: comp-first-char c
     If composition C is a "flat" composition, return the first
     (leftmost) character of the composition as an integer.  Otherwise,
     return `nil'.

 -- Function: comp-last-char c
     If composition C is a "flat" composition, return the last
     (rightmost) character, otherwise return `nil'.


File: calc,  Node: Hooks,  Prev: Formatting Lisp Functions,  Up: Internals

19.5.7.9 Hooks
..............

Hooks are variables which contain Lisp functions (or lists of functions)
which are called at various times.  Calc defines a number of hooks that
help you to customize it in various ways.  Calc uses the Lisp function
`run-hooks' to invoke the hooks shown below.  Several other
customization-related variables are also described here.

 -- Variable: calc-load-hook
     This hook is called at the end of `calc.el', after the file has
     been loaded, before any functions in it have been called, but after
     `calc-mode-map' and similar variables have been set up.

 -- Variable: calc-ext-load-hook
     This hook is called at the end of `calc-ext.el'.

 -- Variable: calc-start-hook
     This hook is called as the last step in a `M-x calc' command.  At
     this point, the Calc buffer has been created and initialized if
     necessary, the Calc window and trail window have been created, and
     the "Welcome to Calc" message has been displayed.

 -- Variable: calc-mode-hook
     This hook is called when the Calc buffer is being created.  Usually
     this will only happen once per Emacs session.  The hook is called
     after Emacs has switched to the new buffer, the mode-settings file
     has been read if necessary, and all other buffer-local variables
     have been set up.  After this hook returns, Calc will perform a
     `calc-refresh' operation, set up the mode line display, then
     evaluate any deferred `calc-define' properties that have not been
     evaluated yet.

 -- Variable: calc-trail-mode-hook
     This hook is called when the Calc Trail buffer is being created.
     It is called as the very last step of setting up the Trail buffer.
     Like `calc-mode-hook', this will normally happen only once per
     Emacs session.

 -- Variable: calc-end-hook
     This hook is called by `calc-quit', generally because the user
     presses `q' or `C-x * c' while in Calc.  The Calc buffer will be
     the current buffer.  The hook is called as the very first step,
     before the Calc window is destroyed.

 -- Variable: calc-window-hook
     If this hook is non-`nil', it is called to create the Calc window.
     Upon return, this new Calc window should be the current window.
     (The Calc buffer will already be the current buffer when the hook
     is called.)  If the hook is not defined, Calc will generally use
     `split-window', `set-window-buffer', and `select-window' to create
     the Calc window.

 -- Variable: calc-trail-window-hook
     If this hook is non-`nil', it is called to create the Calc Trail
     window.  The variable `calc-trail-buffer' will contain the buffer
     which the window should use.  Unlike `calc-window-hook', this hook
     must _not_ switch into the new window.

 -- Variable: calc-embedded-mode-hook
     This hook is called the first time that Embedded mode is entered.

 -- Variable: calc-embedded-new-buffer-hook
     This hook is called each time that Embedded mode is entered in a
     new buffer.

 -- Variable: calc-embedded-new-formula-hook
     This hook is called each time that Embedded mode is enabled for a
     new formula.

 -- Variable: calc-edit-mode-hook
     This hook is called by `calc-edit' (and the other "edit" commands)
     when the temporary editing buffer is being created.  The buffer
     will have been selected and set up to be in `calc-edit-mode', but
     will not yet have been filled with text.  (In fact it may still
     have leftover text from a previous `calc-edit' command.)

 -- Variable: calc-mode-save-hook
     This hook is called by the `calc-save-modes' command, after Calc's
     own mode features have been inserted into the Calc init file and
     just before the "End of mode settings" message is inserted.

 -- Variable: calc-reset-hook
     This hook is called after `C-x * 0' (`calc-reset') has reset all
     modes.  The Calc buffer will be the current buffer.

 -- Variable: calc-other-modes
     This variable contains a list of strings.  The strings are
     concatenated at the end of the modes portion of the Calc mode line
     (after standard modes such as "Deg", "Inv" and "Hyp").  Each
     string should be a short, single word followed by a space.  The
     variable is `nil' by default.

 -- Variable: calc-mode-map
     This is the keymap that is used by Calc mode.  The best time to
     adjust it is probably in a `calc-mode-hook'.  If the Calc
     extensions package (`calc-ext.el') has not yet been loaded, many
     of these keys will be bound to `calc-missing-key', which is a
     command that loads the extensions package and "retypes" the key.
     If your `calc-mode-hook' rebinds one of these keys, it will
     probably be overridden when the extensions are loaded.

 -- Variable: calc-digit-map
     This is the keymap that is used during numeric entry.  Numeric
     entry uses the minibuffer, but this map binds every non-numeric
     key to `calcDigit-nondigit' which generally calls
     `exit-minibuffer' and "retypes" the key.

 -- Variable: calc-alg-ent-map
     This is the keymap that is used during algebraic entry.  This is
     mostly a copy of `minibuffer-local-map'.

 -- Variable: calc-store-var-map
     This is the keymap that is used during entry of variable names for
     commands like `calc-store' and `calc-recall'.  This is mostly a
     copy of `minibuffer-local-completion-map'.

 -- Variable: calc-edit-mode-map
     This is the (sparse) keymap used by `calc-edit' and other
     temporary editing commands.  It binds <RET>, <LFD>, and `C-c C-c'
     to `calc-edit-finish'.

 -- Variable: calc-mode-var-list
     This is a list of variables which are saved by `calc-save-modes'.
     Each entry is a list of two items, the variable (as a Lisp symbol)
     and its default value.  When modes are being saved, each variable
     is compared with its default value (using `equal') and any
     non-default variables are written out.

 -- Variable: calc-local-var-list
     This is a list of variables which should be buffer-local to the
     Calc buffer.  Each entry is a variable name (as a Lisp symbol).
     These variables also have their default values manipulated by the
     `calc' and `calc-quit' commands; *note Multiple Calculators::.
     Since `calc-mode-hook' is called after this list has been used the
     first time, your hook should add a variable to the list and also
     call `make-local-variable' itself.


File: calc,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Programming,  Up: Top

Appendix A GNU GENERAL PUBLIC LICENSE
*************************************

                        Version 3, 29 June 2007

     Copyright (C) 2007 Free Software Foundation, Inc. `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains
free software for all its users.  We, the Free Software Foundation, use
the GNU General Public License for most of our software; it applies
also to any other work released this way by its authors.  You can apply
it to your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the software,
or if you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users' freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those domains
in future versions of the GPL, as needed to protect the freedom of
users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     "This License" refers to version 3 of the GNU General Public
     License.

     "Copyright" also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     "The Program" refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as "you".  "Licensees" and
     "recipients" may be individuals or organizations.

     To "modify" a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a "modified
     version" of the earlier work or a work "based on" the earlier work.

     A "covered work" means either the unmodified Program or a work
     based on the Program.

     To "propagate" a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it
     on a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To "convey" a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays "Appropriate Legal Notices"
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may
     convey the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The "source code" for a work means the preferred form of the work
     for making modifications to it.  "Object code" means any
     non-source form of a work.

     A "Standard Interface" means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The "System Libraries" of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work
     with that Major Component, or to implement a Standard Interface
     for which an implementation is available to the public in source
     code form.  A "Major Component", in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The "Corresponding Source" for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including
     scripts to control those activities.  However, it does not include
     the work's System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files
     associated with source files for the work, and the source code for
     shared libraries and dynamically linked subprograms that the work
     is specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output,
     given its content, constitutes a covered work.  This License
     acknowledges your rights of fair use or other equivalent, as
     provided by copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for
     you, or provide you with facilities for running those works,
     provided that you comply with the terms of this License in
     conveying all material for which you do not control copyright.
     Those thus making or running the covered works for you must do so
     exclusively on your behalf, under your direction and control, on
     terms that prohibit them from making any copies of your
     copyrighted material outside their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention
     to limit operation or modification of the work as a means of
     enforcing, against the work's users, your or third parties' legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program's source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to "keep intact all notices".

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an "aggregate" if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation's users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for
          as long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of
          the written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access
          to the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated
          by you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to
          the object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long
          as needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.


     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A "User Product" is either (1) a "consumer product", which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product
     is a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     "normally used" refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     "Installation Information" for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or
     installed by the recipient, or for the User Product in which it
     has been modified or installed.  Access to a network may be denied
     when the modification itself materially and adversely affects the
     operation of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     "Additional permissions" are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License
     with terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be
          marked in reasonable ways as different from the original
          version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered "further
     restrictions" within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or
     conveying under this License, you may add to a covered work
     material governed by the terms of that license document, provided
     that the further restriction does not survive such relicensing or
     conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under
     the third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, you do not qualify to receive new
     licenses for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

 10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An "entity transaction" is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party's predecessor in interest had or
     could give under the previous paragraph, plus a right to
     possession of the Corresponding Source of the work from the
     predecessor in interest, if the predecessor has it or can get it
     with reasonable efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for
     exercise of rights granted under this License, and you may not
     initiate litigation (including a cross-claim or counterclaim in a
     lawsuit) alleging that any patent claim is infringed by making,
     using, selling, offering for sale, or importing the Program or any
     portion of it.

 11. Patents.

     A "contributor" is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor's "contributor
     version".

     A contributor's "essential patent claims" are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, "control"
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor's essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its
     contributor version.

     In the following three paragraphs, a "patent license" is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To
     "grant" such a patent license to a party means to make such an
     agreement or commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  "Knowingly relying" means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient's use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is "discriminatory" if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under
     which you make payment to the third party based on the extent of
     your activity of conveying the work, and under which the third
     party grants, to any of the parties who would receive the covered
     work from you, a discriminatory patent license (a) in connection
     with copies of the covered work conveyed by you (or copies made
     from those copies), or (b) primarily for and in connection with
     specific products or compilations that contain the covered work,
     unless you entered into that arrangement, or that patent license
     was granted, prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

 12. No Surrender of Others' Freedom.

     If conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot convey a covered work so as to satisfy
     simultaneously your obligations under this License and any other
     pertinent obligations, then as a consequence you may not convey it
     at all.  For example, if you agree to terms that obligate you to
     collect a royalty for further conveying from those to whom you
     convey the Program, the only way you could satisfy both those
     terms and this License would be to refrain entirely from conveying
     the Program.

 13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

 14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.
     Such new versions will be similar in spirit to the present
     version, but may differ in detail to address new problems or
     concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the
     Free Software Foundation.  If the Program does not specify a
     version number of the GNU General Public License, you may choose
     any version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

 15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

 16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU
     FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

 17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.


END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see `http://www.gnu.org/licenses/'.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see `http://www.gnu.org/licenses/'.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read `http://www.gnu.org/philosophy/why-not-lgpl.html'.


File: calc,  Node: GNU Free Documentation License,  Next: Customizing Calc,  Prev: Copying,  Up: Top

Appendix B GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
     `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, receipt of a copy of some or all of
     the same material does not give you any rights to use it.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.  If the Document specifies that a proxy
     can decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

 11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: calc,  Node: Customizing Calc,  Next: Reporting Bugs,  Prev: GNU Free Documentation License,  Up: Top

Appendix C Customizing Calc
***************************

The usual prefix for Calc is the key sequence `C-x *'.  If you wish to
use a different prefix, you can put

     (global-set-key "NEWPREFIX" 'calc-dispatch)

in your .emacs file.  (*Note Customizing Key Bindings: (emacs)Key
Bindings, for more information on binding keys.)  A convenient way to
start Calc is with `C-x * *'; to make it equally convenient for users
who use a different prefix, the prefix can be followed by  `=', `&',
`#', `\', `/', `+' or `-' as well as `*' to start Calc, and so in many
cases the last character of the prefix can simply be typed twice.

   Calc is controlled by many variables, most of which can be reset
from within Calc.  Some variables are less involved with actual
calculation and can be set outside of Calc using Emacs'ss customization
facilities.  These variables are listed below.  Typing `M-x
customize-variable RET VARIABLE-NAME RET' will bring up a buffer in
which the variable's value can be redefined.  Typing `M-x
customize-group RET calc RET' will bring up a buffer which contains all
of Calc's customizable variables.  (These variables can also be reset
by putting the appropriate lines in your .emacs file; *Note Init File:
(emacs)Init File.)

   Some of the customizable variables are regular expressions.  A
regular expression is basically a pattern that Calc can search for.
See *note Regular Expression Search: (emacs)Regexp Search.  to see how
regular expressions work.

 -- Variable: calc-settings-file
     The variable `calc-settings-file' holds the file name in which
     commands like `m m' and `Z P' store "permanent" definitions.  If
     `calc-settings-file' is not your user init file (typically
     `~/.emacs') and if the variable `calc-loaded-settings-file' is
     `nil', then Calc will automatically load your settings file (if it
     exists) the first time Calc is invoked.

     The default value for this variable is `"~/.emacs.d/calc.el"'
     unless the file `~/.calc.el' exists, in which case the default
     value will be `"~/.calc.el"'.

 -- Variable: calc-gnuplot-name
     See *note Graphics::.
     The variable `calc-gnuplot-name' should be the name of the GNUPLOT
     program (a string).  If you have GNUPLOT installed on your system
     but Calc is unable to find it, you may need to set this variable.
     You may also need to set some Lisp variables to show Calc how to
     run GNUPLOT on your system, see *note Graphical Devices: Devices .
     The default value of `calc-gnuplot-name' is `"gnuplot"'.

 -- Variable: calc-gnuplot-plot-command
 -- Variable: calc-gnuplot-print-command
     See *note Graphical Devices: Devices.
     The variables `calc-gnuplot-plot-command' and
     `calc-gnuplot-print-command' represent system commands to display
     and print the output of GNUPLOT, respectively.  These may be `nil'
     if no command is necessary, or strings which can include `%s' to
     signify the name of the file to be displayed or printed.  Or,
     these variables may contain Lisp expressions which are evaluated
     to display or print the output.

     The default value of `calc-gnuplot-plot-command' is `nil', and the
     default value of `calc-gnuplot-print-command' is `"lp %s"'.

 -- Variable: calc-language-alist
     See *note Basic Embedded Mode::.
     The variable `calc-language-alist' controls the languages that
     Calc will associate with major modes.  When Calc embedded mode is
     enabled, it will try to use the current major mode to determine
     what language should be used.  (This can be overridden using
     Calc's mode changing commands, *Note Mode Settings in Embedded
     Mode::.)  The variable `calc-language-alist' consists of a list of
     pairs of the form  `(MAJOR-MODE . LANGUAGE)'; for example,
     `(latex-mode . latex)' is one such pair.  If Calc embedded is
     activated in a buffer whose major mode is MAJOR-MODE, it will set
     itself to use the language LANGUAGE.

     The default value of `calc-language-alist' is
             ((latex-mode . latex)
              (tex-mode   . tex)
              (plain-tex-mode . tex)
              (context-mode . tex)
              (nroff-mode . eqn)
              (pascal-mode . pascal)
              (c-mode . c)
              (c++-mode . c)
              (fortran-mode . fortran)
              (f90-mode . fortran))

 -- Variable: calc-embedded-announce-formula
 -- Variable: calc-embedded-announce-formula-alist
     See *note Customizing Embedded Mode::.
     The variable `calc-embedded-announce-formula' helps determine what
     formulas `C-x * a' will activate in a buffer.  It is a regular
     expression, and when activating embedded formulas with `C-x * a',
     it will tell Calc that what follows is a formula to be activated.
     (Calc also uses other patterns to find formulas, such as `=>' and
     `:='.)

     The default pattern is `"%Embed\n\\(% .*\n\\)*"', which checks for
     `%Embed' followed by any number of lines beginning with `%' and a
     space.

     The variable `calc-embedded-announce-formula-alist' is used to set
     `calc-embedded-announce-formula' to different regular expressions
     depending on the major mode of the editing buffer.  It consists of
     a list of pairs of the form `(MAJOR-MODE .  REGEXP)', and its
     default value is
             ((c++-mode     . "//Embed\n\\(// .*\n\\)*")
              (c-mode       . "/\\*Embed\\*/\n\\(/\\* .*\\*/\n\\)*")
              (f90-mode     . "!Embed\n\\(! .*\n\\)*")
              (fortran-mode . "C Embed\n\\(C .*\n\\)*")
              (html-helper-mode . "<!-- Embed -->\n\\(<!-- .* -->\n\\)*")
              (html-mode    . "<!-- Embed -->\n\\(<!-- .* -->\n\\)*")
              (nroff-mode   . "\\\\\"Embed\n\\(\\\\\" .*\n\\)*")
              (pascal-mode  . "{Embed}\n\\({.*}\n\\)*")
              (sgml-mode    . "<!-- Embed -->\n\\(<!-- .* -->\n\\)*")
              (xml-mode     . "<!-- Embed -->\n\\(<!-- .* -->\n\\)*")
              (texinfo-mode . "@c Embed\n\\(@c .*\n\\)*"))
     Any major modes added to `calc-embedded-announce-formula-alist'
     should also be added to `calc-embedded-open-close-plain-alist' and
     `calc-embedded-open-close-mode-alist'.

 -- Variable: calc-embedded-open-formula
 -- Variable: calc-embedded-close-formula
 -- Variable: calc-embedded-open-close-formula-alist
     See *note Customizing Embedded Mode::.
     The variables `calc-embedded-open-formula' and
     `calc-embedded-close-formula' control the region that Calc will
     activate as a formula when Embedded mode is entered with `C-x * e'.
     They are regular expressions; Calc normally scans backward and
     forward in the buffer for the nearest text matching these regular
     expressions to be the "formula delimiters".

     The simplest delimiters are blank lines.  Other delimiters that
     Embedded mode understands by default are:
       1. The TeX and LaTeX math delimiters `$ $', `$$ $$', `\[ \]',
          and `\( \)';

       2. Lines beginning with `\begin' and `\end' (except matrix
          delimiters);

       3. Lines beginning with `@' (Texinfo delimiters).

       4. Lines beginning with `.EQ' and `.EN' ("eqn" delimiters);

       5. Lines containing a single `%' or `.\"' symbol and nothing
          else.

     The variable `calc-embedded-open-close-formula-alist' is used to
     set `calc-embedded-open-formula' and `calc-embedded-close-formula'
     to different regular expressions depending on the major mode of
     the editing buffer.  It consists of a list of lists of the form
     `(MAJOR-MODE  OPEN-FORMULA-REGEXP CLOSE-FORMULA-REGEXP)', and its
     default value is `nil'.

 -- Variable: calc-embedded-word-regexp
 -- Variable: calc-embedded-word-regexp-alist
     See *note Customizing Embedded Mode::.
     The variable `calc-embedded-word-regexp' determines the expression
     that Calc will activate when Embedded mode is entered with `C-x *
     w'.  It is a regular expressions.

     The default value of `calc-embedded-word-regexp' is
     `"[-+]?[0-9]+\\(\\.[0-9]+\\)?\\([eE][-+]?[0-9]+\\)?"'.

     The variable `calc-embedded-word-regexp-alist' is used to set
     `calc-embedded-word-regexp' to a different regular expression
     depending on the major mode of the editing buffer.  It consists of
     a list of lists of the form `(MAJOR-MODE  WORD-REGEXP)', and its
     default value is `nil'.

 -- Variable: calc-embedded-open-plain
 -- Variable: calc-embedded-close-plain
 -- Variable: calc-embedded-open-close-plain-alist
     See *note Customizing Embedded Mode::.
     The variables `calc-embedded-open-plain' and
     `calc-embedded-open-plain' are used to delimit "plain" formulas.
     Note that these are actual strings, not regular expressions,
     because Calc must be able to write these string into a buffer as
     well as to recognize them.

     The default string for `calc-embedded-open-plain' is `"%%% "',
     note the trailing space.  The default string for
     `calc-embedded-close-plain' is `" %%%\n"', without the trailing
     newline here, the first line of a Big mode formula that followed
     might be shifted over with respect to the other lines.

     The variable `calc-embedded-open-close-plain-alist' is used to set
     `calc-embedded-open-plain' and `calc-embedded-close-plain' to
     different strings depending on the major mode of the editing
     buffer.  It consists of a list of lists of the form `(MAJOR-MODE
     OPEN-PLAIN-STRING CLOSE-PLAIN-STRING)', and its default value is
             ((c++-mode     "// %% "   " %%\n")
              (c-mode       "/* %% "   " %% */\n")
              (f90-mode     "! %% "    " %%\n")
              (fortran-mode "C %% "    " %%\n")
              (html-helper-mode "<!-- %% " " %% -->\n")
              (html-mode "<!-- %% " " %% -->\n")
              (nroff-mode   "\\\" %% " " %%\n")
              (pascal-mode  "{%% "    " %%}\n")
              (sgml-mode     "<!-- %% " " %% -->\n")
              (xml-mode     "<!-- %% " " %% -->\n")
              (texinfo-mode "@c %% "   " %%\n"))
     Any major modes added to `calc-embedded-open-close-plain-alist'
     should also be added to `calc-embedded-announce-formula-alist' and
     `calc-embedded-open-close-mode-alist'.

 -- Variable: calc-embedded-open-new-formula
 -- Variable: calc-embedded-close-new-formula
 -- Variable: calc-embedded-open-close-new-formula-alist
     See *note Customizing Embedded Mode::.
     The variables `calc-embedded-open-new-formula' and
     `calc-embedded-close-new-formula' are strings which are inserted
     before and after a new formula when you type `C-x * f'.

     The default value of `calc-embedded-open-new-formula' is `"\n\n"'.
     If this string begins with a newline character and the `C-x * f'
     is typed at the beginning of a line, `C-x * f' will skip this
     first newline to avoid introducing unnecessary blank lines in the
     file.  The default value of `calc-embedded-close-new-formula' is
     also `"\n\n"'.  The final newline is omitted by `C-x * f' if typed
     at the end of a line.  (It follows that if `C-x * f' is typed on a
     blank line, both a leading opening newline and a trailing closing
     newline are omitted.)

     The variable `calc-embedded-open-close-new-formula-alist' is used
     to set `calc-embedded-open-new-formula' and
     `calc-embedded-close-new-formula' to different strings depending
     on the major mode of the editing buffer.  It consists of a list of
     lists of the form `(MAJOR-MODE  OPEN-NEW-FORMULA-STRING
     CLOSE-NEW-FORMULA-STRING)', and its default value is `nil'.

 -- Variable: calc-embedded-open-mode
 -- Variable: calc-embedded-close-mode
 -- Variable: calc-embedded-open-close-mode-alist
     See *note Customizing Embedded Mode::.
     The variables `calc-embedded-open-mode' and
     `calc-embedded-close-mode' are strings which Calc will place before
     and after any mode annotations that it inserts.  Calc never scans
     for these strings; Calc always looks for the annotation itself, so
     it is not necessary to add them to user-written annotations.

     The default value of `calc-embedded-open-mode' is `"% "' and the
     default value of `calc-embedded-close-mode' is `"\n"'.  If you
     change the value of `calc-embedded-close-mode', it is a good idea
     still to end with a newline so that mode annotations will appear on
     lines by themselves.

     The variable `calc-embedded-open-close-mode-alist' is used to set
     `calc-embedded-open-mode' and `calc-embedded-close-mode' to
     different strings expressions depending on the major mode of the
     editing buffer.  It consists of a list of lists of the form
     `(MAJOR-MODE  OPEN-MODE-STRING CLOSE-MODE-STRING)', and its
     default value is
             ((c++-mode     "// "   "\n")
              (c-mode       "/* "   " */\n")
              (f90-mode     "! "    "\n")
              (fortran-mode "C "    "\n")
              (html-helper-mode "<!-- " " -->\n")
              (html-mode    "<!-- " " -->\n")
              (nroff-mode   "\\\" " "\n")
              (pascal-mode  "{ "    " }\n")
              (sgml-mode    "<!-- " " -->\n")
              (xml-mode     "<!-- " " -->\n")
              (texinfo-mode "@c "   "\n"))
     Any major modes added to `calc-embedded-open-close-mode-alist'
     should also be added to `calc-embedded-announce-formula-alist' and
     `calc-embedded-open-close-plain-alist'.

 -- Variable: calc-lu-power-reference
 -- Variable: calc-lu-field-reference
     See *note Logarithmic Units::.
     The variables `calc-lu-power-reference' and
     `calc-lu-field-reference' are unit expressions (written as
     strings) which Calc will use as reference quantities for
     logarithmic units.

     The default value of `calc-lu-power-reference' is `"mW"' and the
     default value of `calc-lu-field-reference' is `"20 uPa"'.

 -- Variable: calc-note-threshold
     See *note Musical Notes::.
     The variable `calc-note-threshold' is a number (written as a
     string) which determines how close (in cents) a frequency needs to
     be to a note to be recognized as that note.

     The default value of `calc-note-threshold' is 1.

 -- Variable: calc-highlight-selections-with-faces
 -- Variable: calc-selected-face
 -- Variable: calc-nonselected-face
     See *note Displaying Selections::.
     The variable `calc-highlight-selections-with-faces' determines how
     selected sub-formulas are distinguished.  If
     `calc-highlight-selections-with-faces' is nil, then a selected
     sub-formula is distinguished either by changing every character
     not part of the sub-formula with a dot or by changing every
     character in the sub-formula with a `#' sign.  If
     `calc-highlight-selections-with-faces' is t, then a selected
     sub-formula is distinguished either by displaying the non-selected
     portion of the formula with `calc-nonselected-face' or by
     displaying the selected sub-formula with `calc-nonselected-face'.

 -- Variable: calc-multiplication-has-precedence
     The variable `calc-multiplication-has-precedence' determines
     whether multiplication has precedence over division in algebraic
     formulas in normal language modes.  If
     `calc-multiplication-has-precedence' is non-`nil', then
     multiplication has precedence (and, for certain obscure reasons, is
     right associative), and so for example `a/b*c' will be interpreted
     as `a/(b*c)'. If `calc-multiplication-has-precedence' is `nil',
     then multiplication has the same precedence as division (and, like
     division, is left associative), and so for example `a/b*c' will be
     interpreted as `(a/b)*c'.  The default value of
     `calc-multiplication-has-precedence' is `t'.

 -- Variable: calc-undo-length
     The variable `calc-undo-length' determines the number of undo
     steps that Calc will keep track of when `calc-quit' is called.  If
     `calc-undo-length' is a non-negative integer, then this is the
     number of undo steps that will be preserved; if `calc-undo-length'
     has any other value, then all undo steps will be preserved.  The
     default value of `calc-undo-length' is `100'.


File: calc,  Node: Reporting Bugs,  Next: Summary,  Prev: Customizing Calc,  Up: Top

Appendix D Reporting Bugs
*************************

If you find a bug in Calc, send e-mail to Jay Belanger,

     jay.p.belanger@gmail.com

There is an automatic command `M-x report-calc-bug' which helps you to
report bugs.  This command prompts you for a brief subject line, then
leaves you in a mail editing buffer.  Type `C-c C-c' to send your mail.
Make sure your subject line indicates that you are reporting a Calc
bug; this command sends mail to the maintainer's regular mailbox.

   If you have suggestions for additional features for Calc, please send
them.  Some have dared to suggest that Calc is already top-heavy with
features; this obviously cannot be the case, so if you have ideas, send
them right in.

   At the front of the source file, `calc.el', is a list of ideas for
future work.  If any enthusiastic souls wish to take it upon themselves
to work on these, please send a message (using `M-x report-calc-bug')
so any efforts can be coordinated.

   The latest version of Calc is available from Savannah, in the Emacs
repository.  See `http://savannah.gnu.org/projects/emacs'.


File: calc,  Node: Summary,  Next: Key Index,  Prev: Reporting Bugs,  Up: Top

Appendix E Calc Summary
***********************

This section includes a complete list of Calc keystroke commands.  Each
line lists the stack entries used by the command (top-of-stack last),
the keystrokes themselves, the prompts asked by the command, and the
result of the command (also with top-of-stack last).  The result is
expressed using the equivalent algebraic function.  Commands which put
no results on the stack show the full `M-x' command name in that
position.  Numbers preceding the result or command name refer to notes
at the end.

   Algebraic functions and `M-x' commands that don't have corresponding
keystrokes are not listed in this summary.  *Note Command Index::.
*Note Function Index::.

            C-x * a                   33  calc-embedded-activate
            C-x * b                       calc-big-or-small
            C-x * c                       calc
            C-x * d                       calc-embedded-duplicate
            C-x * e                   34  calc-embedded
            C-x * f  formula              calc-embedded-new-formula
            C-x * g                   35  calc-grab-region
            C-x * i                       calc-info
            C-x * j                       calc-embedded-select
            C-x * k                       calc-keypad
            C-x * l                       calc-load-everything
            C-x * m                       read-kbd-macro
            C-x * n                    4  calc-embedded-next
            C-x * o                       calc-other-window
            C-x * p                    4  calc-embedded-previous
            C-x * q  formula              quick-calc
            C-x * r                   36  calc-grab-rectangle
            C-x * s                       calc-info-summary
            C-x * t                       calc-tutorial
            C-x * u                       calc-embedded-update-formula
            C-x * w                       calc-embedded-word
            C-x * x                       calc-quit
            C-x * y              1,28,49  calc-copy-to-buffer
            C-x * z                       calc-user-invocation
            C-x * :                   36  calc-grab-sum-down
            C-x * _                   36  calc-grab-sum-across
            C-x * `  editing          30  calc-embedded-edit
            C-x * 0  (zero)               calc-reset

             0-9   number               number
             .     number               0.number
             _     number               -number
             e     number               1e number
             #     number               current-radix#number
             P     (in number)          +/-
             M     (in number)          mod
             @ ' "   (in number)        HMS form
             h m s   (in number)        HMS form

             '     formula       37,46  formula
             $     formula       37,46  $formula
             "     string        37,46  string

    a b      +                       2  add(a,b)  a+b
    a b      -                       2  sub(a,b)  a-b
    a b      *                       2  mul(a,b)  a b, a*b
    a b      /                       2  div(a,b)  a/b
    a b      ^                       2  pow(a,b)  a^b
    a b    I ^                       2  nroot(a,b)  a^(1/b)
    a b      %                       2  mod(a,b)  a%b
    a b      \                       2  idiv(a,b)  a\b
    a b      :                       2  fdiv(a,b)
    a b      |                       2  vconcat(a,b)  a|b
    a b    I |                          vconcat(b,a)  b|a
    a b    H |                       2  append(a,b)
    a b  I H |                          append(b,a)
      a      &                       1  inv(a)  1/a
      a      !                       1  fact(a)  a!
      a      =                       1  evalv(a)
      a      M-%                        percent(a)  a%

  ... a      RET                     1  ... a a
  ... a      SPC                     1  ... a a
... a b      TAB                     3  ... b a
. a b c      M-TAB                   3  ... b c a
... a b      LFD                     1  ... a b a
  ... a      DEL                     1  ...
... a b      M-DEL                   1  ... b
             M-RET                   4  calc-last-args
      a      `     editing        1,30  calc-edit

  ... a      C-d                     1  ...
             C-k                    27  calc-kill
             C-w                    27  calc-kill-region
             C-y                        calc-yank
             C-_                     4  calc-undo
             M-k                    27  calc-copy-as-kill
             M-w                    27  calc-copy-region-as-kill

             [                          [...
[.. a b      ]                          [a,b]
             (                          (...
(.. a b      )                          (a,b)
             ,                          vector or rect complex
             ;                          matrix or polar complex
             ..                         interval

             ~                          calc-num-prefix
             <                       4  calc-scroll-left
             >                       4  calc-scroll-right
             {                       4  calc-scroll-down
             }                       4  calc-scroll-up
             ?                          calc-help

      a      n                       1  neg(a)  -a
             o                       4  calc-realign
             p     precision        31  calc-precision
             q                          calc-quit
             w                          calc-why
             x     command              M-x calc-command
      a      y                 1,28,49  calc-copy-to-buffer

      a      A                       1  abs(a)
    a b      B                       2  log(a,b)
    a b    I B                       2  alog(a,b)  b^a
      a      C                       1  cos(a)
      a    I C                       1  arccos(a)
      a    H C                       1  cosh(a)
      a  I H C                       1  arccosh(a)
             D                       4  calc-redo
      a      E                       1  exp(a)
      a    H E                       1  exp10(a)  10.^a
      a      F                    1,11  floor(a,d)
      a    I F                    1,11  ceil(a,d)
      a    H F                    1,11  ffloor(a,d)
      a  I H F                    1,11  fceil(a,d)
      a      G                       1  arg(a)
             H     command          32  Hyperbolic
             I     command          32  Inverse
      a      J                       1  conj(a)
             K     command          32  Keep-args
      a      L                       1  ln(a)
      a    H L                       1  log10(a)
             M                          calc-more-recursion-depth
           I M                          calc-less-recursion-depth
      a      N                       5  evalvn(a)
             O     command          32  Option
             P                          pi
           I P                          gamma
           H P                          e
         I H P                          phi
      a      Q                       1  sqrt(a)
      a    I Q                       1  sqr(a)  a^2
      a      R                    1,11  round(a,d)
      a    I R                    1,11  trunc(a,d)
      a    H R                    1,11  fround(a,d)
      a  I H R                    1,11  ftrunc(a,d)
      a      S                       1  sin(a)
      a    I S                       1  arcsin(a)
      a    H S                       1  sinh(a)
      a  I H S                       1  arcsinh(a)
      a      T                       1  tan(a)
      a    I T                       1  arctan(a)
      a    H T                       1  tanh(a)
      a  I H T                       1  arctanh(a)
             U                       4  calc-undo
             X                       4  calc-call-last-kbd-macro

    a b      a =                     2  eq(a,b)  a=b
    a b      a #                     2  neq(a,b)  a!=b
    a b      a <                     2  lt(a,b)  a<b
    a b      a >                     2  gt(a,b)  a>b
    a b      a [                     2  leq(a,b)  a<=b
    a b      a ]                     2  geq(a,b)  a>=b
    a b      a {                     2  in(a,b)
    a b      a &                  2,45  land(a,b)  a&&b
    a b      a |                  2,45  lor(a,b)  a||b
      a      a !                  1,45  lnot(a)  !a
  a b c      a :                    45  if(a,b,c)  a?b:c
      a      a .                     1  rmeq(a)
      a      a "                   7,8  calc-expand-formula

      a      a +   i, l, h        6,38  sum(a,i,l,h)
      a      a -   i, l, h        6,38  asum(a,i,l,h)
      a      a *   i, l, h        6,38  prod(a,i,l,h)
    a b      a _                     2  subscr(a,b)  a_b

    a b      a \                     2  pdiv(a,b)
    a b      a %                     2  prem(a,b)
    a b      a /                     2  pdivrem(a,b)  [q,r]
    a b    H a /                     2  pdivide(a,b)  q+r/b

      a      a a                     1  apart(a)
      a      a b   old, new         38  subst(a,old,new)
      a      a c   v                38  collect(a,v)
      a      a d   v              4,38  deriv(a,v)
      a    H a d   v              4,38  tderiv(a,v)
      a      a e                        esimplify(a)
      a      a f                     1  factor(a)
      a    H a f                     1  factors(a)
    a b      a g                     2  pgcd(a,b)
      a      a i   v                38  integ(a,v)
      a      a m   pats             38  match(a,pats)
      a    I a m   pats             38  matchnot(a,pats)
 data x      a p                    28  polint(data,x)
 data x    H a p                    28  ratint(data,x)
      a      a n                     1  nrat(a)
      a      a r   rules        4,8,38  rewrite(a,rules,n)
      a      a s                        simplify(a)
      a      a t   v, n          31,39  taylor(a,v,n)
      a      a v                   7,8  calc-alg-evaluate
      a      a x                   4,8  expand(a)

   data      a F   model, vars      48  fit(m,iv,pv,data)
   data    I a F   model, vars      48  xfit(m,iv,pv,data)
   data    H a F   model, vars      48  efit(m,iv,pv,data)
      a      a I   v, l, h          38  ninteg(a,v,l,h)
    a b      a M   op               22  mapeq(op,a,b)
    a b    I a M   op               22  mapeqr(op,a,b)
    a b    H a M   op               22  mapeqp(op,a,b)
    a g      a N   v                38  minimize(a,v,g)
    a g    H a N   v                38  wminimize(a,v,g)
      a      a P   v                38  roots(a,v)
    a g      a R   v                38  root(a,v,g)
    a g    H a R   v                38  wroot(a,v,g)
      a      a S   v                38  solve(a,v)
      a    I a S   v                38  finv(a,v)
      a    H a S   v                38  fsolve(a,v)
      a  I H a S   v                38  ffinv(a,v)
      a      a T   i, l, h        6,38  table(a,i,l,h)
    a g      a X   v                38  maximize(a,v,g)
    a g    H a X   v                38  wmaximize(a,v,g)

    a b      b a                     9  and(a,b,w)
      a      b c                     9  clip(a,w)
    a b      b d                     9  diff(a,b,w)
      a      b l                    10  lsh(a,n,w)
    a n    H b l                     9  lsh(a,n,w)
      a      b n                     9  not(a,w)
    a b      b o                     9  or(a,b,w)
      v      b p                     1  vpack(v)
      a      b r                    10  rsh(a,n,w)
    a n    H b r                     9  rsh(a,n,w)
      a      b t                    10  rot(a,n,w)
    a n    H b t                     9  rot(a,n,w)
      a      b u                     1  vunpack(a)
             b w   w              9,50  calc-word-size
    a b      b x                     9  xor(a,b,w)

c s l p      b D                        ddb(c,s,l,p)
  r n p      b F                        fv(r,n,p)
  r n p    I b F                        fvb(r,n,p)
  r n p    H b F                        fvl(r,n,p)
      v      b I                    19  irr(v)
      v    I b I                    19  irrb(v)
      a      b L                    10  ash(a,n,w)
    a n    H b L                     9  ash(a,n,w)
  r n a      b M                        pmt(r,n,a)
  r n a    I b M                        pmtb(r,n,a)
  r n a    H b M                        pmtl(r,n,a)
    r v      b N                    19  npv(r,v)
    r v    I b N                    19  npvb(r,v)
  r n p      b P                        pv(r,n,p)
  r n p    I b P                        pvb(r,n,p)
  r n p    H b P                        pvl(r,n,p)
      a      b R                    10  rash(a,n,w)
    a n    H b R                     9  rash(a,n,w)
  c s l      b S                        sln(c,s,l)
  n p a      b T                        rate(n,p,a)
  n p a    I b T                        rateb(n,p,a)
  n p a    H b T                        ratel(n,p,a)
c s l p      b Y                        syd(c,s,l,p)

  r p a      b #                        nper(r,p,a)
  r p a    I b #                        nperb(r,p,a)
  r p a    H b #                        nperl(r,p,a)
    a b      b %                        relch(a,b)

      a      c c                     5  pclean(a,p)
      a      c 0-9                      pclean(a,p)
      a    H c c                     5  clean(a,p)
      a    H c 0-9                      clean(a,p)
      a      c d                     1  deg(a)
      a      c f                     1  pfloat(a)
      a    H c f                     1  float(a)
      a      c h                     1  hms(a)
      a      c p                        polar(a)
      a    I c p                        rect(a)
      a      c r                     1  rad(a)

      a      c F                     5  pfrac(a,p)
      a    H c F                     5  frac(a,p)

      a      c %                        percent(a*100)

             d .   char             50  calc-point-char
             d ,   char             50  calc-group-char
             d <                 13,50  calc-left-justify
             d =                 13,50  calc-center-justify
             d >                 13,50  calc-right-justify
             d {   label            50  calc-left-label
             d }   label            50  calc-right-label
             d [                     4  calc-truncate-up
             d ]                     4  calc-truncate-down
             d "                 12,50  calc-display-strings
             d SPC                      calc-refresh
             d RET                   1  calc-refresh-top

             d 0                    50  calc-decimal-radix
             d 2                    50  calc-binary-radix
             d 6                    50  calc-hex-radix
             d 8                    50  calc-octal-radix

             d b              12,13,50  calc-line-breaking
             d c                    50  calc-complex-notation
             d d   format           50  calc-date-notation
             d e                  5,50  calc-eng-notation
             d f   num           31,50  calc-fix-notation
             d g              12,13,50  calc-group-digits
             d h   format           50  calc-hms-notation
             d i                    50  calc-i-notation
             d j                    50  calc-j-notation
             d l                 12,50  calc-line-numbering
             d n                  5,50  calc-normal-notation
             d o   format           50  calc-over-notation
             d p                 12,50  calc-show-plain
             d r   radix         31,50  calc-radix
             d s                  5,50  calc-sci-notation
             d t                    27  calc-truncate-stack
             d w                 12,13  calc-auto-why
             d z                 12,50  calc-leading-zeros

             d B                    50  calc-big-language
             d C                    50  calc-c-language
             d E                    50  calc-eqn-language
             d F                    50  calc-fortran-language
             d M                    50  calc-mathematica-language
             d N                    50  calc-normal-language
             d O                    50  calc-flat-language
             d P                    50  calc-pascal-language
             d T                    50  calc-tex-language
             d L                    50  calc-latex-language
             d U                    50  calc-unformatted-language
             d W                    50  calc-maple-language

      a      f [                     4  decr(a,n)
      a      f ]                     4  incr(a,n)

    a b      f b                     2  beta(a,b)
      a      f e                     1  erf(a)
      a    I f e                     1  erfc(a)
      a      f g                     1  gamma(a)
    a b      f h                     2  hypot(a,b)
      a      f i                     1  im(a)
    n a      f j                     2  besJ(n,a)
    a b      f n                     2  min(a,b)
      a      f r                     1  re(a)
      a      f s                     1  sign(a)
    a b      f x                     2  max(a,b)
    n a      f y                     2  besY(n,a)

      a      f A                     1  abssqr(a)
  x a b      f B                        betaI(x,a,b)
  x a b    H f B                        betaB(x,a,b)
      a      f E                     1  expm1(a)
    a x      f G                     2  gammaP(a,x)
    a x    I f G                     2  gammaQ(a,x)
    a x    H f G                     2  gammag(a,x)
    a x  I H f G                     2  gammaG(a,x)
    a b      f I                     2  ilog(a,b)
    a b    I f I                     2  alog(a,b)  b^a
      a      f L                     1  lnp1(a)
      a      f M                     1  mant(a)
      a      f Q                     1  isqrt(a)
      a    I f Q                     1  sqr(a)  a^2
    a n      f S                     2  scf(a,n)
    y x      f T                        arctan2(y,x)
      a      f X                     1  xpon(a)

    x y      g a                 28,40  calc-graph-add
             g b                    12  calc-graph-border
             g c                        calc-graph-clear
             g d                    41  calc-graph-delete
    x y      g f                 28,40  calc-graph-fast
             g g                    12  calc-graph-grid
             g h   title                calc-graph-header
             g j                     4  calc-graph-juggle
             g k                    12  calc-graph-key
             g l                    12  calc-graph-log-x
             g n   name                 calc-graph-name
             g p                    42  calc-graph-plot
             g q                        calc-graph-quit
             g r   range                calc-graph-range-x
             g s                 12,13  calc-graph-line-style
             g t   title                calc-graph-title-x
             g v                        calc-graph-view-commands
             g x   display              calc-graph-display
             g z                    12  calc-graph-zero-x

  x y z      g A                 28,40  calc-graph-add-3d
             g C   command              calc-graph-command
             g D   device        43,44  calc-graph-device
  x y z      g F                 28,40  calc-graph-fast-3d
             g H                    12  calc-graph-hide
             g K                        calc-graph-kill
             g L                    12  calc-graph-log-y
             g N   number        43,51  calc-graph-num-points
             g O   filename      43,44  calc-graph-output
             g P                    42  calc-graph-print
             g R   range                calc-graph-range-y
             g S                 12,13  calc-graph-point-style
             g T   title                calc-graph-title-y
             g V                        calc-graph-view-trail
             g X   format               calc-graph-geometry
             g Z                    12  calc-graph-zero-y

             g C-l                  12  calc-graph-log-z
             g C-r range                calc-graph-range-z
             g C-t title                calc-graph-title-z

             h b                        calc-describe-bindings
             h c   key                  calc-describe-key-briefly
             h f   function             calc-describe-function
             h h                        calc-full-help
             h i                        calc-info
             h k   key                  calc-describe-key
             h n                        calc-view-news
             h s                        calc-info-summary
             h t                        calc-tutorial
             h v   var                  calc-describe-variable

             j 1-9                      calc-select-part
             j RET                  27  calc-copy-selection
             j DEL                  27  calc-del-selection
             j '   formula          27  calc-enter-selection
             j `   editing       27,30  calc-edit-selection
             j "                  7,27  calc-sel-expand-formula

             j +   formula          27  calc-sel-add-both-sides
             j -   formula          27  calc-sel-sub-both-sides
             j *   formula          27  calc-sel-mul-both-sides
             j /   formula          27  calc-sel-div-both-sides
             j &                    27  calc-sel-invert

             j a                    27  calc-select-additional
             j b                    12  calc-break-selections
             j c                        calc-clear-selections
             j d                 12,50  calc-show-selections
             j e                    12  calc-enable-selections
             j l                  4,27  calc-select-less
             j m                  4,27  calc-select-more
             j n                     4  calc-select-next
             j o                  4,27  calc-select-once
             j p                     4  calc-select-previous
             j r   rules        4,8,27  calc-rewrite-selection
             j s                  4,27  calc-select-here
             j u                    27  calc-unselect
             j v                  7,27  calc-sel-evaluate

             j C                    27  calc-sel-commute
             j D                  4,27  calc-sel-distribute
             j E                    27  calc-sel-jump-equals
             j I                    27  calc-sel-isolate
           H j I                    27  calc-sel-isolate (full)
             j L                  4,27  calc-commute-left
             j M                    27  calc-sel-merge
             j N                    27  calc-sel-negate
             j O                  4,27  calc-select-once-maybe
             j R                  4,27  calc-commute-right
             j S                  4,27  calc-select-here-maybe
             j U                    27  calc-sel-unpack

             k a                        calc-random-again
      n      k b                     1  bern(n)
    n x    H k b                     2  bern(n,x)
    n m      k c                     2  choose(n,m)
    n m    H k c                     2  perm(n,m)
      n      k d                     1  dfact(n)  n!!
      n      k e                     1  euler(n)
    n x    H k e                     2  euler(n,x)
      n      k f                     4  prfac(n)
    n m      k g                     2  gcd(n,m)
    m n      k h                    14  shuffle(n,m)
    n m      k l                     2  lcm(n,m)
      n      k m                     1  moebius(n)
      n      k n                     4  nextprime(n)
      n    I k n                     4  prevprime(n)
      n      k p                  4,28  calc-prime-test
      m      k r                    14  random(m)
    n m      k s                     2  stir1(n,m)
    n m    H k s                     2  stir2(n,m)
      n      k t                     1  totient(n)

  n p x      k B                        utpb(x,n,p)
  n p x    I k B                        ltpb(x,n,p)
    v x      k C                        utpc(x,v)
    v x    I k C                        ltpc(x,v)
    n m      k E                        egcd(n,m)
v1 v2 x      k F                        utpf(x,v1,v2)
v1 v2 x    I k F                        ltpf(x,v1,v2)
  m s x      k N                        utpn(x,m,s)
  m s x    I k N                        ltpn(x,m,s)
    m x      k P                        utpp(x,m)
    m x    I k P                        ltpp(x,m)
    v x      k T                        utpt(x,v)
    v x    I k T                        ltpt(x,v)

    a b      l +                        lupadd(a,b)
    a b    H l +                        lufadd(a,b)
    a b      l -                        lupsub(a,b)
    a b    H l -                        lufsub(a,b)
    a b      l *                        lupmul(a,b)
    a b    H l *                        lufmul(a,b)
    a b      l /                        lupdiv(a,b)
    a b    H l /                        lufdiv(a,b)
      a      l d                        dbpower(a)
    a b    O l d                        dbpower(a,b)
      a    H l d                        dbfield(a)
    a b  O H l d                        dbfield(a,b)
      a      l n                        nppower(a)
    a b    O l n                        nppower(a,b)
      a    H l n                        npfield(a)
    a b  O H l n                        npfield(a,b)
      a      l q                        lupquant(a)
    a b    O l q                        lupquant(a,b)
      a    H l q                        lufquant(a)
    a b  O H l q                        lufquant(a,b)
      a      l s                        spn(a)
      a      l m                        midi(a)
      a      l f                        freq(a)

             m a                 12,13  calc-algebraic-mode
             m d                        calc-degrees-mode
             m e                        calc-embedded-preserve-modes
             m f                    12  calc-frac-mode
             m g                    52  calc-get-modes
             m h                        calc-hms-mode
             m i                 12,13  calc-infinite-mode
             m m                        calc-save-modes
             m p                    12  calc-polar-mode
             m r                        calc-radians-mode
             m s                    12  calc-symbolic-mode
             m t                    12  calc-total-algebraic-mode
             m v                 12,13  calc-matrix-mode
             m w                    13  calc-working
             m x                        calc-always-load-extensions

             m A                    12  calc-alg-simplify-mode
             m B                    12  calc-bin-simplify-mode
             m C                    12  calc-auto-recompute
             m D                        calc-default-simplify-mode
             m E                    12  calc-ext-simplify-mode
             m F   filename         13  calc-settings-file-name
             m N                    12  calc-num-simplify-mode
             m O                    12  calc-no-simplify-mode
             m R                 12,13  calc-mode-record-mode
             m S                    12  calc-shift-prefix
             m U                    12  calc-units-simplify-mode

             r s   register         27  calc-copy-to-register
             r i   register             calc-insert-register

             s c   var1, var2       29  calc-copy-variable
             s d   var, decl            calc-declare-variable
             s e   var, editing  29,30  calc-edit-variable
             s i   buffer               calc-insert-variables
             s k   const, var       29  calc-copy-special-constant
    a b      s l   var              29  a  (letting var=b)
  a ...      s m   op, var       22,29  calc-store-map
             s n   var           29,47  calc-store-neg  (v/-1)
             s p   var              29  calc-permanent-variable
             s r   var              29  v  (recalled value)
             r 0-9                      calc-recall-quick
      a      s s   var           28,29  calc-store
      a      s 0-9                      calc-store-quick
      a      s t   var              29  calc-store-into
      a      t 0-9                      calc-store-into-quick
             s u   var              29  calc-unstore
      a      s x   var              29  calc-store-exchange

             s A   editing          30  calc-edit-AlgSimpRules
             s D   editing          30  calc-edit-Decls
             s E   editing          30  calc-edit-EvalRules
             s F   editing          30  calc-edit-FitRules
             s G   editing          30  calc-edit-GenCount
             s H   editing          30  calc-edit-Holidays
             s I   editing          30  calc-edit-IntegLimit
             s L   editing          30  calc-edit-LineStyles
             s P   editing          30  calc-edit-PointStyles
             s R   editing          30  calc-edit-PlotRejects
             s T   editing          30  calc-edit-TimeZone
             s U   editing          30  calc-edit-Units
             s X   editing          30  calc-edit-ExtSimpRules

      a      s +   var           29,47  calc-store-plus  (v+a)
      a      s -   var           29,47  calc-store-minus  (v-a)
      a      s *   var           29,47  calc-store-times  (v*a)
      a      s /   var           29,47  calc-store-div  (v/a)
      a      s ^   var           29,47  calc-store-power  (v^a)
      a      s |   var           29,47  calc-store-concat  (v|a)
             s &   var           29,47  calc-store-inv  (v^-1)
             s [   var           29,47  calc-store-decr  (v-1)
             s ]   var           29,47  calc-store-incr  (v-(-1))
    a b      s :                     2  assign(a,b)  a := b
      a      s =                     1  evalto(a,b)  a =>

             t [                     4  calc-trail-first
             t ]                     4  calc-trail-last
             t <                     4  calc-trail-scroll-left
             t >                     4  calc-trail-scroll-right
             t .                    12  calc-full-trail-vectors

             t b                     4  calc-trail-backward
             t d                 12,50  calc-trail-display
             t f                     4  calc-trail-forward
             t h                        calc-trail-here
             t i                        calc-trail-in
             t k                     4  calc-trail-kill
             t m   string               calc-trail-marker
             t n                     4  calc-trail-next
             t o                        calc-trail-out
             t p                     4  calc-trail-previous
             t r   string               calc-trail-isearch-backward
             t s   string               calc-trail-isearch-forward
             t y                     4  calc-trail-yank

      d      t C   oz, nz               tzconv(d,oz,nz)
d oz nz      t C   $                    tzconv(d,oz,nz)
      d      t D                    15  date(d)
      d      t I                     4  incmonth(d,n)
      d      t J                    16  julian(d,z)
      d      t M                    17  newmonth(d,n)
             t N                    16  now(z)
      d      t P   1                31  year(d)
      d      t P   2                31  month(d)
      d      t P   3                31  day(d)
      d      t P   4                31  hour(d)
      d      t P   5                31  minute(d)
      d      t P   6                31  second(d)
      d      t P   7                31  weekday(d)
      d      t P   8                31  yearday(d)
      d      t P   9                31  time(d)
      d      t U                    16  unixtime(d,z)
      d      t W                    17  newweek(d,w)
      d      t Y                    17  newyear(d,n)

    a b      t +                     2  badd(a,b)
    a b      t -                     2  bsub(a,b)

             u a                    12  calc-autorange-units
      a      u b                        calc-base-units
      a      u c   units            18  calc-convert-units
   defn      u d   unit, descr          calc-define-unit
             u e                        calc-explain-units
             u g   unit                 calc-get-unit-definition
             u p                        calc-permanent-units
      a      u r                        calc-remove-units
      a      u s                        usimplify(a)
      a      u t   units            18  calc-convert-temperature
             u u   unit                 calc-undefine-unit
             u v                        calc-enter-units-table
      a      u x                        calc-extract-units
      a      u 0-9                      calc-quick-units

  v1 v2      u C                    20  vcov(v1,v2)
  v1 v2    I u C                    20  vpcov(v1,v2)
  v1 v2    H u C                    20  vcorr(v1,v2)
      v      u G                    19  vgmean(v)
    a b    H u G                     2  agmean(a,b)
      v      u M                    19  vmean(v)
      v    I u M                    19  vmeane(v)
      v    H u M                    19  vmedian(v)
      v  I H u M                    19  vhmean(v)
      v      u N                    19  vmin(v)
      v      u S                    19  vsdev(v)
      v    I u S                    19  vpsdev(v)
      v    H u S                    19  vvar(v)
      v  I H u S                    19  vpvar(v)
             u V                        calc-view-units-table
      v      u X                    19  vmax(v)

      v      u +                    19  vsum(v)
      v      u *                    19  vprod(v)
      v      u #                    19  vcount(v)

             V (                    50  calc-vector-parens
             V {                    50  calc-vector-braces
             V [                    50  calc-vector-brackets
             V ]   ROCP             50  calc-matrix-brackets
             V ,                    50  calc-vector-commas
             V <                    50  calc-matrix-left-justify
             V =                    50  calc-matrix-center-justify
             V >                    50  calc-matrix-right-justify
             V /                 12,50  calc-break-vectors
             V .                 12,50  calc-full-vectors

    s t      V ^                     2  vint(s,t)
    s t      V -                     2  vdiff(s,t)
      s      V ~                     1  vcompl(s)
      s      V #                     1  vcard(s)
      s      V :                     1  vspan(s)
      s      V +                     1  rdup(s)

      m      V &                     1  inv(m)  1/m

      v      v a   n                    arrange(v,n)
      a      v b   n                    cvec(a,n)
      v      v c   n >0          21,31  mcol(v,n)
      v      v c   n <0             31  mrcol(v,-n)
      m      v c   0                31  getdiag(m)
      v      v d                    25  diag(v,n)
    v m      v e                     2  vexp(v,m)
  v m f    H v e                     2  vexp(v,m,f)
    v a      v f                    26  find(v,a,n)
      v      v h                     1  head(v)
      v    I v h                     1  tail(v)
      v    H v h                     1  rhead(v)
      v  I H v h                     1  rtail(v)
             v i   n                31  idn(1,n)
             v i   0                31  idn(1)
    h t      v k                     2  cons(h,t)
    h t    H v k                     2  rcons(h,t)
      v      v l                     1  vlen(v)
      v    H v l                     1  mdims(v)
    v m      v m                     2  vmask(v,m)
      v      v n                     1  rnorm(v)
  a b c      v p                    24  calc-pack
      v      v r   n >0          21,31  mrow(v,n)
      v      v r   n <0             31  mrrow(v,-n)
      m      v r   0                31  getdiag(m)
  v i j      v s                        subvec(v,i,j)
  v i j    I v s                        rsubvec(v,i,j)
      m      v t                     1  trn(m)
      v      v u                    24  calc-unpack
      v      v v                     1  rev(v)
             v x   n                31  index(n)
  n s i  C-u v x                        index(n,s,i)

      v      V A   op               22  apply(op,v)
  v1 v2      V C                     2  cross(v1,v2)
      m      V D                     1  det(m)
      s      V E                     1  venum(s)
      s      V F                     1  vfloor(s)
      v      V G                        grade(v)
      v    I V G                        rgrade(v)
      v      V H   n                31  histogram(v,n)
    v w    H V H   n                31  histogram(v,w,n)
  v1 v2      V I   mop aop          22  inner(mop,aop,v1,v2)
      m      V J                     1  ctrn(m)
  m1 m2      V K                        kron(m1,m2)
      m      V L                     1  lud(m)
      v      V M   op            22,23  map(op,v)
      v      V N                     1  cnorm(v)
  v1 v2      V O   op               22  outer(op,v1,v2)
      v      V R   op            22,23  reduce(op,v)
      v    I V R   op            22,23  rreduce(op,v)
    a n    H V R   op               22  nest(op,a,n)
      a  I H V R   op               22  fixp(op,a)
      v      V S                        sort(v)
      v    I V S                        rsort(v)
      m      V T                     1  tr(m)
      v      V U   op               22  accum(op,v)
      v    I V U   op               22  raccum(op,v)
    a n    H V U   op               22  anest(op,a,n)
      a  I H V U   op               22  afixp(op,a)
    s t      V V                     2  vunion(s,t)
    s t      V X                     2  vxor(s,t)

             Y                          user commands

             z                          user commands

      c      Z [                    45  calc-kbd-if
      c      Z |                    45  calc-kbd-else-if
             Z :                        calc-kbd-else
             Z ]                        calc-kbd-end-if

             Z {                     4  calc-kbd-loop
      c      Z /                    45  calc-kbd-break
             Z }                        calc-kbd-end-loop
      n      Z <                        calc-kbd-repeat
             Z >                        calc-kbd-end-repeat
    n m      Z (                        calc-kbd-for
      s      Z )                        calc-kbd-end-for

             Z C-g                      cancel if/loop command

             Z `                        calc-kbd-push
             Z '                        calc-kbd-pop
             Z #                        calc-kbd-query

   comp      Z C   func, args       50  calc-user-define-composition
             Z D   key, command         calc-user-define
             Z E   key, editing     30  calc-user-define-edit
   defn      Z F   k, c, f, a, n    28  calc-user-define-formula
             Z G   key                  calc-get-user-defn
             Z I                        calc-user-define-invocation
             Z K   key, command         calc-user-define-kbd-macro
             Z P   key                  calc-user-define-permanent
             Z S                    30  calc-edit-user-syntax
             Z T                    12  calc-timing
             Z U   key                  calc-user-undefine

NOTES

  1. Positive prefix arguments apply to `n' stack entries.  Negative
     prefix arguments apply to the `-n'th stack entry.  A prefix of
     zero applies to the entire stack.  (For <LFD> and `M-<DEL>', the
     meaning of the sign is reversed.)

  2. Positive prefix arguments apply to `n' stack entries.  Negative
     prefix arguments apply to the top stack entry and the next `-n'
     stack entries.

  3. Positive prefix arguments rotate top `n' stack entries by one.
     Negative prefix arguments rotate the entire stack by `-n'.  A
     prefix of zero reverses the entire stack.

  4. Prefix argument specifies a repeat count or distance.

  5. Positive prefix arguments specify a precision `p'.  Negative
     prefix arguments reduce the current precision by `-p'.

  6. A prefix argument is interpreted as an additional step-size
     parameter.  A plain `C-u' prefix means to prompt for the step size.

  7. A prefix argument specifies simplification level and depth.
     1=Default, 2=like `a s', 3=like `a e'.

  8. A negative prefix operates only on the top level of the input
     formula.

  9. Positive prefix arguments specify a word size of `w' bits,
     unsigned.  Negative prefix arguments specify a word size of `w'
     bits, signed.

 10. Prefix arguments specify the shift amount `n'.  The `w' argument
     cannot be specified in the keyboard version of this command.

 11. From the keyboard, `d' is omitted and defaults to zero.

 12. Mode is toggled; a positive prefix always sets the mode, and a
     negative prefix always clears the mode.

 13. Some prefix argument values provide special variations of the mode.

 14. A prefix argument, if any, is used for `m' instead of taking `m'
     from the stack.  `M' may take any of these values:
    Integer
          Random integer in the interval `[0 .. m)'.

    Float
          Random floating-point number in the interval `[0 .. m)'.

    0.0
          Gaussian with mean 1 and standard deviation 0.

    Error form
          Gaussian with specified mean and standard deviation.

    Interval
          Random integer or floating-point number in that interval.

    Vector
          Random element from the vector.

 15. A prefix argument from 1 to 6 specifies number of date components
     to remove from the stack.  *Note Date Conversions::.

 16. A prefix argument specifies a time zone; `C-u' says to take the
     time zone number or name from the top of the stack.  *Note Time
     Zones::.

 17. A prefix argument specifies a day number (0-6, 0-31, or 0-366).

 18. If the input has no units, you will be prompted for both the old
     and the new units.

 19. With a prefix argument, collect that many stack entries to form the
     input data set.  Each entry may be a single value or a vector of
     values.

 20. With a prefix argument of 1, take a single Nx2 matrix from the
     stack instead of two separate data vectors.

 21. The row or column number `n' may be given as a numeric prefix
     argument instead.  A plain `C-u' prefix says to take `n' from the
     top of the stack.  If `n' is a vector or interval, a
     subvector/submatrix of the input is created.

 22. The `op' prompt can be answered with the key sequence for the
     desired function, or with `x' or `z' followed by a function name,
     or with `$' to take a formula from the top of the stack, or with
     `'' and a typed formula.  In the last two cases, the formula may
     be a nameless function like `<#1+#2>' or `<x, y : x+y>', or it may
     include `$', `$$', etc. (where `$' will correspond to the last
     argument of the created function), or otherwise you will be
     prompted for an argument list.  The number of vectors popped from
     the stack by `V M' depends on the number of arguments of the
     function.

 23. One of the mapping direction keys `_' (horizontal, i.e., map by
     rows or reduce across), `:' (vertical, i.e., map by columns or
     reduce down), or `=' (map or reduce by rows) may be used before
     entering `op'; these modify the function name by adding the letter
     `r' for "rows," `c' for "columns," `a' for "across," or `d' for
     "down."

 24. The prefix argument specifies a packing mode.  A nonnegative mode
     is the number of items (for `v p') or the number of levels (for `v
     u').  A negative mode is as described below.  With no prefix
     argument, the mode is taken from the top of the stack and may be
     an integer or a vector of integers.
    `-1'
          (2)  Rectangular complex number.

    `-2'
          (2)  Polar complex number.

    `-3'
          (3)  HMS form.

    `-4'
          (2)  Error form.

    `-5'
          (2)  Modulo form.

    `-6'
          (2)  Closed interval.

    `-7'
          (2)  Closed .. open interval.

    `-8'
          (2)  Open .. closed interval.

    `-9'
          (2)  Open interval.

    `-10'
          (2)  Fraction.

    `-11'
          (2)  Float with integer mantissa.

    `-12'
          (2)  Float with mantissa in `[1 .. 10)'.

    `-13'
          (1)  Date form (using date numbers).

    `-14'
          (3)  Date form (using year, month, day).

    `-15'
          (6)  Date form (using year, month, day, hour, minute, second).

 25. A prefix argument specifies the size `n' of the matrix.  With no
     prefix argument, `n' is omitted and the size is inferred from the
     input vector.

 26. The prefix argument specifies the starting position `n' (default
     1).

 27. Cursor position within stack buffer affects this command.

 28. Arguments are not actually removed from the stack by this command.

 29. Variable name may be a single digit or a full name.

 30. Editing occurs in a separate buffer.  Press `C-c C-c' (or <LFD>,
     or in some cases <RET>) to finish the edit, or kill the buffer
     with `C-x k' to cancel the edit.  The <LFD> key prevents evaluation
     of the result of the edit.

 31. The number prompted for can also be provided as a prefix argument.

 32. Press this key a second time to cancel the prefix.

 33. With a negative prefix, deactivate all formulas.  With a positive
     prefix, deactivate and then reactivate from scratch.

 34. Default is to scan for nearest formula delimiter symbols.  With a
     prefix of zero, formula is delimited by mark and point.  With a
     non-zero prefix, formula is delimited by scanning forward or
     backward by that many lines.

 35. Parse the region between point and mark as a vector.  A nonzero
     prefix parses N lines before or after point as a vector.  A zero
     prefix parses the current line as a vector.  A `C-u' prefix parses
     the region between point and mark as a single formula.

 36. Parse the rectangle defined by point and mark as a matrix.  A
     positive prefix N divides the rectangle into columns of width N.
     A zero or `C-u' prefix parses each line as one formula.  A negative
     prefix suppresses special treatment of bracketed portions of a
     line.

 37. A numeric prefix causes the current language mode to be ignored.

 38. Responding to a prompt with a blank line answers that and all
     later prompts by popping additional stack entries.

 39. Answer for `v' may also be of the form `v = v_0' or `v - v_0'.

 40. With a positive prefix argument, stack contains many `y''s and one
     common `x'.  With a zero prefix, stack contains a vector of `y's
     and a common `x'.  With a negative prefix, stack contains many
     `[x,y]' vectors.  (For 3D plots, substitute `z' for `y' and `x,y'
     for `x'.)

 41. With any prefix argument, all curves in the graph are deleted.

 42. With a positive prefix, refines an existing plot with more data
     points.  With a negative prefix, forces recomputation of the plot
     data.

 43. With any prefix argument, set the default value instead of the
     value for this graph.

 44. With a negative prefix argument, set the value for the printer.

 45. Condition is considered "true" if it is a nonzero real or complex
     number, or a formula whose value is known to be nonzero; it is
     "false" otherwise.

 46. Several formulas separated by commas are pushed as multiple stack
     entries.  Trailing `)', `]', `}', `>', and `"' delimiters may be
     omitted.  The notation `$$$' refers to the value in stack level
     three, and causes the formula to replace the top three stack
     levels.  The notation `$3' refers to stack level three without
     causing that value to be removed from the stack.  Use <LFD> in
     place of <RET> to prevent evaluation; use `M-=' in place of <RET>
     to evaluate variables.

 47. The variable is replaced by the formula shown on the right.  The
     Inverse flag reverses the order of the operands, e.g., `I s - x'
     assigns `x := a-x'.

 48. Press `?' repeatedly to see how to choose a model.  Answer the
     variables prompt with `iv' or `iv;pv' to specify independent and
     parameter variables.  A positive prefix argument takes N+1 vectors
     from the stack; a zero prefix takes a matrix and a vector from the
     stack.

 49. With a plain `C-u' prefix, replace the current region of the
     destination buffer with the yanked text instead of inserting.

 50. All stack entries are reformatted; the `H' prefix inhibits this.
     The `I' prefix sets the mode temporarily, redraws the top stack
     entry, then restores the original setting of the mode.

 51. A negative prefix sets the default 3D resolution instead of the
     default 2D resolution.

 52. This grabs a vector of the form [PREC, WSIZE, SSIZE, RADIX, FLFMT,
     ANG, FRAC, SYMB, POLAR, MATRIX, SIMP, INF].  A prefix argument
     from 1 to 12 grabs the Nth mode value only.


File: calc,  Node: Key Index,  Next: Command Index,  Prev: Summary,  Up: Top

Index of Key Sequences
**********************

 [index ]
* Menu:

* !:                                     Combinatorial Functions.
                                                              (line  24)
* ":                                     Strings.             (line   6)
* " (HMS forms):                         HMS Forms.           (line  13)
* #:                                     Integers.            (line  18)
* $:                                     Algebraic Entry.     (line  57)
* %:                                     Basic Arithmetic.    (line 146)
* &:                                     Basic Arithmetic.    (line 184)
* & (matrices):                          Vector and Matrix Arithmetic.
                                                              (line  42)
* ':                                     Algebraic Entry.     (line   6)
* ' (HMS forms):                         HMS Forms.           (line  13)
* (:                                     Incomplete Objects.  (line   6)
* ):                                     Incomplete Objects.  (line   6)
* *:                                     Basic Arithmetic.    (line  70)
* +:                                     Basic Arithmetic.    (line   6)
* ,:                                     Incomplete Objects.  (line   6)
* -:                                     Basic Arithmetic.    (line  65)
* .:                                     Numeric Entry.       (line   6)
* ..:                                    Incomplete Objects.  (line  32)
* /:                                     Basic Arithmetic.    (line  89)
* 0-9:                                   Numeric Entry.       (line   6)
* ::                                     Basic Arithmetic.    (line 153)
* ;:                                     Incomplete Objects.  (line  27)
* <:                                     Basic Commands.      (line  95)
* <DEL>:                                 Stack Manipulation.  (line  23)
* <LFD>:                                 Stack Manipulation.  (line  16)
* <RET>:                                 Stack Manipulation.  (line   6)
* <SPC>:                                 Stack Manipulation.  (line   6)
* <TAB>:                                 Stack Manipulation.  (line  39)
* =:                                     Variables.           (line  30)
* >:                                     Basic Commands.      (line  95)
* ?:                                     Help Commands.       (line   6)
* @:                                     HMS Forms.           (line  13)
* [:                                     Incomplete Objects.  (line   6)
* \:                                     Basic Arithmetic.    (line 139)
* ]:                                     Incomplete Objects.  (line   6)
* ^:                                     Basic Arithmetic.    (line 128)
* _:                                     Numeric Entry.       (line  12)
* `:                                     Editing Stack Entries.
                                                              (line   6)
* A:                                     Basic Arithmetic.    (line 165)
* a !:                                   Logical Operations.  (line  86)
* a ":                                   Algebraic Manipulation.
                                                              (line  59)
* a #:                                   Logical Operations.  (line  46)
* a %:                                   Polynomials.         (line 133)
* a &:                                   Logical Operations.  (line  75)
* A (vectors):                           Vector and Matrix Arithmetic.
                                                              (line  19)
* a *:                                   Summations.          (line 116)
* a +:                                   Summations.          (line   6)
* a -:                                   Summations.          (line 104)
* a .:                                   Logical Operations.  (line  65)
* a /:                                   Polynomials.         (line 139)
* a ::                                   Logical Operations.  (line  90)
* a <:                                   Logical Operations.  (line  51)
* a =:                                   Logical Operations.  (line  20)
* a >:                                   Logical Operations.  (line  51)
* a ?:                                   Help Commands.       (line   6)
* a [:                                   Logical Operations.  (line  51)
* a \:                                   Polynomials.         (line 119)
* a ]:                                   Logical Operations.  (line  51)
* a _:                                   Extracting Elements. (line  24)
* a a:                                   Polynomials.         (line 105)
* a b:                                   Algebraic Manipulation.
                                                              (line 109)
* a c:                                   Polynomials.         (line  68)
* a d:                                   Differentiation.     (line   6)
* a e:                                   Unsafe Simplifications.
                                                              (line   6)
* a F:                                   Linear Fits.         (line   6)
* a f:                                   Polynomials.         (line  13)
* a g:                                   Polynomials.         (line 145)
* a I:                                   Numerical Integration.
                                                              (line   6)
* a i:                                   Integration.         (line   6)
* a m:                                   Matching Commands.   (line   6)
* a M:                                   Algebraic Manipulation.
                                                              (line  73)
* a N:                                   Minimization.        (line   6)
* a n:                                   Polynomials.         (line 112)
* a p:                                   Interpolation.       (line   6)
* a P:                                   Multiple Solutions.  (line  63)
* a r:                                   Rewrite Rules.       (line   6)
* a R:                                   Root Finding.        (line   6)
* a S:                                   Solving Equations.   (line   6)
* a s:                                   Simplifying Formulas.
                                                              (line   6)
* a T:                                   Summations.          (line 122)
* a t:                                   Taylor Series.       (line   6)
* a v:                                   Algebraic Manipulation.
                                                              (line  15)
* a X:                                   Minimization.        (line   6)
* a x:                                   Polynomials.         (line  83)
* a {:                                   Logical Operations.  (line 109)
* a |:                                   Logical Operations.  (line  81)
* B:                                     Logarithmic Functions.
                                                              (line  22)
* b #:                                   Related Financial Functions.
                                                              (line  21)
* b %:                                   Percentages.         (line  44)
* b ?:                                   Help Commands.       (line   6)
* b a:                                   Binary Functions.    (line  57)
* b c:                                   Binary Functions.    (line  26)
* b d:                                   Binary Functions.    (line  71)
* b D:                                   Depreciation Functions.
                                                              (line  29)
* b F:                                   Future Value.        (line   6)
* b I:                                   Related Financial Functions.
                                                              (line  50)
* b L:                                   Binary Functions.    (line  97)
* b l:                                   Binary Functions.    (line  78)
* b M:                                   Related Financial Functions.
                                                              (line   9)
* b n:                                   Binary Functions.    (line  75)
* b N:                                   Present Value.       (line  46)
* b o:                                   Binary Functions.    (line  63)
* b p:                                   Set Operations.      (line 111)
* b P:                                   Present Value.       (line   6)
* b R:                                   Binary Functions.    (line 102)
* b r:                                   Binary Functions.    (line  93)
* b S:                                   Depreciation Functions.
                                                              (line  16)
* b t:                                   Binary Functions.    (line 111)
* b T:                                   Related Financial Functions.
                                                              (line  38)
* b u:                                   Set Operations.      (line 111)
* b w:                                   Binary Functions.    (line  35)
* b x:                                   Binary Functions.    (line  67)
* b Y:                                   Depreciation Functions.
                                                              (line  22)
* C:                                     Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* c %:                                   Percentages.         (line  34)
* c 0-9:                                 Conversions.         (line 101)
* c ?:                                   Help Commands.       (line   6)
* c c:                                   Conversions.         (line  81)
* c d:                                   Conversions.         (line  56)
* c F:                                   Conversions.         (line  40)
* c f:                                   Conversions.         (line   9)
* c h:                                   Conversions.         (line  64)
* c p:                                   Conversions.         (line  73)
* c r:                                   Conversions.         (line  61)
* C-_:                                   Undo.                (line   6)
* C-d:                                   Stack Manipulation.  (line  23)
* C-k:                                   Killing From Stack.  (line   6)
* C-w:                                   Killing From Stack.  (line   6)
* C-x * ':                               More About Embedded Mode.
                                                              (line 115)
* C-x * *:                               Basic Commands.      (line  19)
* C-x * 0:                               Basic Commands.      (line 105)
* C-x * ::                               Grabbing From Buffers.
                                                              (line  77)
* C-x * _:                               Grabbing From Buffers.
                                                              (line  77)
* C-x * `:                               More About Embedded Mode.
                                                              (line 134)
* C-x * a:                               Assignments in Embedded Mode.
                                                              (line  93)
* C-x * b:                               Basic Commands.      (line  53)
* C-x * c:                               Basic Commands.      (line  19)
* C-x * d:                               More About Embedded Mode.
                                                              (line  84)
* C-x * e:                               Basic Embedded Mode. (line   6)
* C-x * f:                               More About Embedded Mode.
                                                              (line 115)
* C-x * g:                               Grabbing From Buffers.
                                                              (line   6)
* C-x * i:                               Help Commands.       (line  20)
* C-x * j:                               Assignments in Embedded Mode.
                                                              (line  51)
* C-x * k:                               Keypad Mode.         (line   6)
* C-x * L:                               Autoloading Problems.
                                                              (line  12)
* C-x * m:                               Naming Keyboard Macros.
                                                              (line  39)
* C-x * n:                               More About Embedded Mode.
                                                              (line 123)
* C-x * o:                               Basic Commands.      (line  61)
* C-x * p:                               More About Embedded Mode.
                                                              (line 123)
* C-x * q:                               Quick Calculator.    (line   6)
* C-x * r:                               Grabbing From Buffers.
                                                              (line  37)
* C-x * s:                               Help Commands.       (line  37)
* C-x * t:                               Help Commands.       (line  29)
* C-x * u:                               Assignments in Embedded Mode.
                                                              (line  64)
* C-x * w:                               Basic Embedded Mode. (line  53)
* C-x * x:                               Basic Commands.      (line  84)
* C-x * y:                               Yanking Into Buffers.
                                                              (line  50)
* C-x * z:                               Invocation Macros.   (line   6)
* C-xC-t:                                Stack Manipulation.  (line  72)
* C-y:                                   Yanking Into Stack.  (line   6)
* D:                                     Undo.                (line  23)
* d ":                                   Strings.             (line  25)
* d ,:                                   Grouping Digits.     (line  20)
* d .:                                   Float Formats.       (line  50)
* d 0:                                   Radix Modes.         (line  12)
* d 2:                                   Radix Modes.         (line  12)
* d 6:                                   Radix Modes.         (line  12)
* d 8:                                   Radix Modes.         (line  12)
* d <:                                   Justification.       (line   6)
* d <RET>:                               Display Modes.       (line  19)
* d <SPC>:                               Basic Commands.      (line  88)
* d =:                                   Justification.       (line   6)
* d >:                                   Justification.       (line   6)
* d ?:                                   Help Commands.       (line   6)
* d [:                                   Truncating the Stack.
                                                              (line  25)
* d ]:                                   Truncating the Stack.
                                                              (line  25)
* d A:                                   Giac Language Mode.  (line   6)
* d B:                                   Normal Language Modes.
                                                              (line  24)
* d b:                                   Normal Language Modes.
                                                              (line  16)
* d C:                                   C FORTRAN Pascal.    (line   6)
* d c:                                   Complex Formats.     (line   6)
* d d:                                   Date Formats.        (line   6)
* d E:                                   Eqn Language Mode.   (line   6)
* d e:                                   Float Formats.       (line  34)
* d F:                                   C FORTRAN Pascal.    (line  40)
* d f:                                   Float Formats.       (line  20)
* d g:                                   Grouping Digits.     (line   6)
* d h:                                   HMS Formats.         (line   6)
* d i:                                   Complex Formats.     (line  11)
* d j:                                   Complex Formats.     (line  11)
* d L:                                   TeX and LaTeX Language Modes.
                                                              (line   6)
* d l:                                   Stack Basics.        (line  24)
* d M:                                   Mathematica Language Mode.
                                                              (line   6)
* d N:                                   Normal Language Modes.
                                                              (line   6)
* d n:                                   Float Formats.       (line  12)
* d O:                                   Normal Language Modes.
                                                              (line  11)
* d o:                                   Fraction Formats.    (line   6)
* d p:                                   More About Embedded Mode.
                                                              (line  19)
* d P:                                   C FORTRAN Pascal.    (line  30)
* d r:                                   Radix Modes.         (line  19)
* d s:                                   Float Formats.       (line  28)
* d T:                                   TeX and LaTeX Language Modes.
                                                              (line   6)
* d t:                                   Truncating the Stack.
                                                              (line   6)
* d U:                                   Normal Language Modes.
                                                              (line  67)
* d W:                                   Maple Language Mode. (line   6)
* d w:                                   Error Messages.      (line  20)
* d X:                                   Maxima Language Mode.
                                                              (line   6)
* d Y:                                   Yacas Language Mode. (line   6)
* d z:                                   Radix Modes.         (line  23)
* d {:                                   Labels.              (line   6)
* d }:                                   Labels.              (line  16)
* E:                                     Logarithmic Functions.
                                                              (line  11)
* e:                                     Numeric Entry.       (line   6)
* F:                                     Integer Truncation.  (line  15)
* f ?:                                   Help Commands.       (line   6)
* f [:                                   Basic Arithmetic.    (line 227)
* f ]:                                   Basic Arithmetic.    (line 227)
* f A:                                   Basic Arithmetic.    (line 175)
* f B:                                   Advanced Math Functions.
                                                              (line  47)
* f b:                                   Advanced Math Functions.
                                                              (line  42)
* f e:                                   Advanced Math Functions.
                                                              (line  53)
* f E:                                   Logarithmic Functions.
                                                              (line  37)
* f G:                                   Advanced Math Functions.
                                                              (line  25)
* f g:                                   Advanced Math Functions.
                                                              (line  18)
* f h:                                   Basic Arithmetic.    (line 192)
* f I:                                   Logarithmic Functions.
                                                              (line  29)
* f i:                                   Complex Number Functions.
                                                              (line  29)
* f j:                                   Advanced Math Functions.
                                                              (line  58)
* f L:                                   Logarithmic Functions.
                                                              (line  41)
* f M:                                   Basic Arithmetic.    (line 210)
* f n:                                   Basic Arithmetic.    (line 204)
* f Q:                                   Basic Arithmetic.    (line 197)
* f r:                                   Complex Number Functions.
                                                              (line  24)
* f S:                                   Basic Arithmetic.    (line 221)
* f s:                                   Basic Arithmetic.    (line 178)
* f T:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  49)
* f X:                                   Basic Arithmetic.    (line 210)
* f x:                                   Basic Arithmetic.    (line 204)
* f y:                                   Advanced Math Functions.
                                                              (line  58)
* G:                                     Complex Number Functions.
                                                              (line  12)
* g ?:                                   Help Commands.       (line   6)
* g A:                                   Managing Curves.     (line  62)
* g a:                                   Managing Curves.     (line  11)
* g b:                                   Graphics Options.    (line  13)
* g C:                                   Devices.             (line 111)
* g c:                                   Basic Graphics.      (line  68)
* g C-l:                                 Graphics Options.    (line  78)
* g C-r:                                 Graphics Options.    (line  78)
* g C-t:                                 Graphics Options.    (line  78)
* g D:                                   Devices.             (line   6)
* g d:                                   Managing Curves.     (line  78)
* g F:                                   Three Dimensional Graphics.
                                                              (line   6)
* g f:                                   Basic Graphics.      (line   6)
* g g:                                   Graphics Options.    (line   6)
* g h:                                   Graphics Options.    (line  45)
* g H:                                   Managing Curves.     (line  83)
* g j:                                   Managing Curves.     (line  88)
* g K:                                   Devices.             (line 149)
* g k:                                   Graphics Options.    (line  17)
* g L:                                   Graphics Options.    (line  74)
* g l:                                   Graphics Options.    (line  74)
* g n:                                   Graphics Options.    (line  49)
* g N:                                   Graphics Options.    (line  22)
* g O:                                   Devices.             (line  45)
* g P:                                   Managing Curves.     (line 126)
* g p:                                   Managing Curves.     (line  95)
* g q:                                   Devices.             (line 142)
* g R:                                   Graphics Options.    (line  65)
* g r:                                   Graphics Options.    (line  65)
* g S:                                   Graphics Options.    (line  98)
* g s:                                   Graphics Options.    (line  89)
* g T:                                   Graphics Options.    (line  57)
* g t:                                   Graphics Options.    (line  57)
* g V:                                   Devices.             (line 117)
* g v:                                   Devices.             (line 117)
* g X:                                   Devices.             (line  97)
* g x:                                   Devices.             (line  92)
* g Z:                                   Graphics Options.    (line  82)
* g z:                                   Graphics Options.    (line  82)
* H:                                     Inverse and Hyperbolic.
                                                              (line  12)
* h (HMS forms):                         HMS Forms.           (line  13)
* H a /:                                 Polynomials.         (line 139)
* H a d:                                 Differentiation.     (line   6)
* H a F:                                 Error Estimates for Fits.
                                                              (line   6)
* H a f:                                 Polynomials.         (line  56)
* H a M:                                 Algebraic Manipulation.
                                                              (line  98)
* H a N:                                 Minimization.        (line   6)
* H a p:                                 Interpolation.       (line  35)
* H a R:                                 Root Finding.        (line  52)
* H a S:                                 Multiple Solutions.  (line   6)
* H a s:                                 Simplifying Formulas.
                                                              (line   6)
* H a X:                                 Minimization.        (line   6)
* h b:                                   Help Commands.       (line  77)
* H b #:                                 Related Financial Functions.
                                                              (line  32)
* H b F:                                 Future Value.        (line  24)
* H b L:                                 Binary Functions.    (line  86)
* H b l:                                 Binary Functions.    (line  86)
* H b M:                                 Related Financial Functions.
                                                              (line  18)
* H b P:                                 Present Value.       (line  34)
* H b R:                                 Binary Functions.    (line  86)
* H b r:                                 Binary Functions.    (line  86)
* H b t:                                 Binary Functions.    (line  86)
* H b T:                                 Related Financial Functions.
                                                              (line  43)
* H C:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* h c:                                   Help Commands.       (line  52)
* H c 0-9:                               Conversions.         (line 126)
* H c c:                                 Conversions.         (line 126)
* H c F:                                 Conversions.         (line  52)
* H c f:                                 Conversions.         (line  30)
* h C-c:                                 Help Commands.       (line  84)
* h C-d:                                 Help Commands.       (line  84)
* h C-w:                                 Help Commands.       (line  84)
* H E:                                   Logarithmic Functions.
                                                              (line  16)
* H F:                                   Integer Truncation.  (line  15)
* h f:                                   Help Commands.       (line  67)
* H f B:                                 Advanced Math Functions.
                                                              (line  47)
* H f G:                                 Advanced Math Functions.
                                                              (line  25)
* h h:                                   Help Commands.       (line  12)
* h i:                                   Help Commands.       (line  20)
* H I a S:                               Multiple Solutions.  (line  56)
* H I C:                                 Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* H I E:                                 Logarithmic Functions.
                                                              (line  16)
* H I F:                                 Integer Truncation.  (line  19)
* H I f G:                               Advanced Math Functions.
                                                              (line  25)
* H I L:                                 Logarithmic Functions.
                                                              (line  16)
* H I P:                                 Scientific Functions.
                                                              (line  12)
* H I R:                                 Integer Truncation.  (line  29)
* H I S:                                 Trigonometric and Hyperbolic Functions.
                                                              (line  39)
* H I T:                                 Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* H I u M:                               Single-Variable Statistics.
                                                              (line  99)
* H I u S:                               Single-Variable Statistics.
                                                              (line 143)
* H I V h:                               Building Vectors.    (line  98)
* H I v h:                               Building Vectors.    (line  98)
* H I V R:                               Nesting and Fixed Points.
                                                              (line  18)
* H I v R:                               Nesting and Fixed Points.
                                                              (line  18)
* H I V U:                               Nesting and Fixed Points.
                                                              (line  22)
* H I v U:                               Nesting and Fixed Points.
                                                              (line  22)
* H I |:                                 Building Vectors.    (line  28)
* H j I:                                 Rearranging with Selections.
                                                              (line 109)
* h k:                                   Help Commands.       (line  41)
* H k b:                                 Combinatorial Functions.
                                                              (line  52)
* H k c:                                 Combinatorial Functions.
                                                              (line  49)
* H k e:                                 Combinatorial Functions.
                                                              (line  60)
* H k s:                                 Combinatorial Functions.
                                                              (line  64)
* H L:                                   Logarithmic Functions.
                                                              (line  16)
* h n:                                   Help Commands.       (line  80)
* H P:                                   Scientific Functions.
                                                              (line  12)
* H R:                                   Integer Truncation.  (line  23)
* H S:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  39)
* h s:                                   Help Commands.       (line  37)
* H T:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* h t:                                   Help Commands.       (line  29)
* H u C:                                 Paired-Sample Statistics.
                                                              (line  28)
* H u G:                                 Single-Variable Statistics.
                                                              (line 108)
* H u M:                                 Single-Variable Statistics.
                                                              (line  85)
* H u S:                                 Single-Variable Statistics.
                                                              (line 143)
* h v:                                   Help Commands.       (line  74)
* H V e:                                 Manipulating Vectors.
                                                              (line 138)
* H v e:                                 Manipulating Vectors.
                                                              (line 138)
* H V H:                                 Manipulating Vectors.
                                                              (line 102)
* H v H:                                 Manipulating Vectors.
                                                              (line 102)
* H V h:                                 Building Vectors.    (line  98)
* H v h:                                 Building Vectors.    (line  98)
* H V k:                                 Building Vectors.    (line  98)
* H v k:                                 Building Vectors.    (line  98)
* H V l:                                 Manipulating Vectors.
                                                              (line  11)
* H v l:                                 Manipulating Vectors.
                                                              (line  11)
* H V R:                                 Nesting and Fixed Points.
                                                              (line   6)
* H v R:                                 Nesting and Fixed Points.
                                                              (line   6)
* H V U:                                 Nesting and Fixed Points.
                                                              (line  13)
* H v U:                                 Nesting and Fixed Points.
                                                              (line  13)
* H |:                                   Building Vectors.    (line  22)
* I:                                     Inverse and Hyperbolic.
                                                              (line   6)
* i:                                     Help Commands.       (line  20)
* I ^:                                   Basic Arithmetic.    (line 135)
* I a F:                                 Error Estimates for Fits.
                                                              (line  50)
* I a m:                                 Matching Commands.   (line  26)
* I a M:                                 Algebraic Manipulation.
                                                              (line 104)
* I a S:                                 Multiple Solutions.  (line  56)
* I a s:                                 Simplifying Formulas.
                                                              (line   6)
* I B:                                   Logarithmic Functions.
                                                              (line  22)
* I b #:                                 Related Financial Functions.
                                                              (line  27)
* I b F:                                 Future Value.        (line  15)
* I b I:                                 Related Financial Functions.
                                                              (line  55)
* I b M:                                 Related Financial Functions.
                                                              (line  14)
* I b N:                                 Present Value.       (line  65)
* I b P:                                 Present Value.       (line  28)
* I b T:                                 Related Financial Functions.
                                                              (line  43)
* I C:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* I c p:                                 Conversions.         (line  73)
* I E:                                   Logarithmic Functions.
                                                              (line   6)
* I F:                                   Integer Truncation.  (line  19)
* I f e:                                 Advanced Math Functions.
                                                              (line  53)
* I f G:                                 Advanced Math Functions.
                                                              (line  25)
* I k B:                                 Probability Distribution Functions.
                                                              (line  22)
* I k C:                                 Probability Distribution Functions.
                                                              (line  40)
* I k F:                                 Probability Distribution Functions.
                                                              (line  44)
* I k N:                                 Probability Distribution Functions.
                                                              (line  49)
* I k n:                                 Combinatorial Functions.
                                                              (line 115)
* I k P:                                 Probability Distribution Functions.
                                                              (line  53)
* I k T:                                 Probability Distribution Functions.
                                                              (line  57)
* I L:                                   Logarithmic Functions.
                                                              (line  11)
* I M:                                   Recursion Depth.     (line   6)
* I P:                                   Scientific Functions.
                                                              (line  12)
* I Q:                                   Scientific Functions.
                                                              (line  23)
* I R:                                   Integer Truncation.  (line  29)
* I S:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  34)
* I T:                                   Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* I u C:                                 Paired-Sample Statistics.
                                                              (line  24)
* I u M:                                 Single-Variable Statistics.
                                                              (line  73)
* I u S:                                 Single-Variable Statistics.
                                                              (line 130)
* I V G:                                 Manipulating Vectors.
                                                              (line  53)
* I v G:                                 Manipulating Vectors.
                                                              (line  53)
* I V h:                                 Building Vectors.    (line  87)
* I v h:                                 Building Vectors.    (line  87)
* I V R:                                 Reducing.            (line  15)
* I v R:                                 Reducing.            (line  15)
* I V S:                                 Manipulating Vectors.
                                                              (line  39)
* I v S:                                 Manipulating Vectors.
                                                              (line  39)
* I V s:                                 Extracting Elements. (line  73)
* I v s:                                 Extracting Elements. (line  73)
* I V U:                                 Reducing.            (line  27)
* I v U:                                 Reducing.            (line  27)
* I |:                                   Building Vectors.    (line  28)
* J:                                     Complex Number Functions.
                                                              (line   6)
* j ":                                   Rearranging with Selections.
                                                              (line 189)
* j &:                                   Rearranging with Selections.
                                                              (line  98)
* j ':                                   Operating on Selections.
                                                              (line  43)
* j *:                                   Rearranging with Selections.
                                                              (line 116)
* j +:                                   Rearranging with Selections.
                                                              (line 161)
* j -:                                   Rearranging with Selections.
                                                              (line 161)
* j /:                                   Rearranging with Selections.
                                                              (line 116)
* j 1-9:                                 Changing Selections. (line  35)
* j <DEL>:                               Operating on Selections.
                                                              (line  77)
* j <RET>:                               Operating on Selections.
                                                              (line  83)
* j ?:                                   Help Commands.       (line   6)
* j `:                                   Operating on Selections.
                                                              (line  53)
* j a:                                   Making Selections.   (line  70)
* j b:                                   Making Selections.   (line 100)
* j C:                                   Rearranging with Selections.
                                                              (line  74)
* j c:                                   Making Selections.   (line 122)
* j D:                                   Rearranging with Selections.
                                                              (line  41)
* j d:                                   Displaying Selections.
                                                              (line   6)
* j E:                                   Rearranging with Selections.
                                                              (line 103)
* j e:                                   Operating on Selections.
                                                              (line  11)
* j I:                                   Rearranging with Selections.
                                                              (line 109)
* j L:                                   Rearranging with Selections.
                                                              (line  32)
* j l:                                   Changing Selections. (line  29)
* j M:                                   Rearranging with Selections.
                                                              (line  68)
* j m:                                   Changing Selections. (line   6)
* j N:                                   Rearranging with Selections.
                                                              (line  90)
* j n:                                   Changing Selections. (line  49)
* j O:                                   Making Selections.   (line  87)
* j o:                                   Making Selections.   (line  77)
* j p:                                   Changing Selections. (line  49)
* j r:                                   Selections with Rewrite Rules.
                                                              (line  12)
* j R:                                   Rearranging with Selections.
                                                              (line   6)
* j S:                                   Making Selections.   (line  87)
* j s:                                   Making Selections.   (line   6)
* j U:                                   Rearranging with Selections.
                                                              (line 167)
* j u:                                   Making Selections.   (line 117)
* j v:                                   Rearranging with Selections.
                                                              (line 173)
* K:                                     Keep Arguments.      (line   6)
* k ?:                                   Help Commands.       (line   6)
* k a:                                   Random Numbers.      (line  63)
* k B:                                   Probability Distribution Functions.
                                                              (line  22)
* k b:                                   Combinatorial Functions.
                                                              (line  52)
* k C:                                   Probability Distribution Functions.
                                                              (line  40)
* k c:                                   Combinatorial Functions.
                                                              (line  42)
* k d:                                   Combinatorial Functions.
                                                              (line  34)
* k e:                                   Combinatorial Functions.
                                                              (line  60)
* k E:                                   Combinatorial Functions.
                                                              (line  20)
* k F:                                   Probability Distribution Functions.
                                                              (line  44)
* k f:                                   Combinatorial Functions.
                                                              (line  93)
* k g:                                   Combinatorial Functions.
                                                              (line   9)
* k h:                                   Random Numbers.      (line  67)
* k l:                                   Combinatorial Functions.
                                                              (line  16)
* k m:                                   Combinatorial Functions.
                                                              (line 122)
* k N:                                   Probability Distribution Functions.
                                                              (line  49)
* k n:                                   Combinatorial Functions.
                                                              (line 103)
* k P:                                   Probability Distribution Functions.
                                                              (line  53)
* k p:                                   Combinatorial Functions.
                                                              (line  71)
* k r:                                   Random Numbers.      (line   6)
* k s:                                   Combinatorial Functions.
                                                              (line  64)
* k T:                                   Probability Distribution Functions.
                                                              (line  57)
* k t:                                   Combinatorial Functions.
                                                              (line 118)
* L:                                     Logarithmic Functions.
                                                              (line   6)
* l *:                                   Logarithmic Units.   (line  71)
* l +:                                   Logarithmic Units.   (line  71)
* l -:                                   Logarithmic Units.   (line  71)
* l /:                                   Logarithmic Units.   (line  71)
* l d:                                   Logarithmic Units.   (line  63)
* l f:                                   Musical Notes.       (line  34)
* l m:                                   Musical Notes.       (line  30)
* l n:                                   Logarithmic Units.   (line  63)
* l q:                                   Logarithmic Units.   (line  53)
* l s:                                   Musical Notes.       (line  26)
* M:                                     Recursion Depth.     (line   6)
* m (HMS forms):                         HMS Forms.           (line  13)
* M (modulo forms):                      Modulo Forms.        (line  12)
* m ?:                                   Help Commands.       (line   6)
* m A:                                   Simplification Modes.
                                                              (line  48)
* m a:                                   Algebraic Entry.     (line  28)
* m B:                                   Simplification Modes.
                                                              (line  41)
* m C <1>:                               Evaluates-To Operator.
                                                              (line  41)
* m C:                                   Automatic Recomputation.
                                                              (line  11)
* m D:                                   Simplification Modes.
                                                              (line  36)
* m d:                                   Angular Modes.       (line  20)
* m e:                                   Mode Settings in Embedded Mode.
                                                              (line   6)
* m E:                                   Simplification Modes.
                                                              (line  53)
* m f:                                   Fraction Mode.       (line  13)
* m F:                                   General Mode Commands.
                                                              (line  27)
* m g:                                   Modes Variable.      (line   6)
* m h:                                   Angular Modes.       (line  20)
* m i:                                   Infinite Mode.       (line  10)
* m m:                                   General Mode Commands.
                                                              (line   6)
* m N:                                   Simplification Modes.
                                                              (line  26)
* m O:                                   Simplification Modes.
                                                              (line  21)
* m p:                                   Polar Mode.          (line  12)
* m r:                                   Angular Modes.       (line  20)
* m R:                                   General Mode Commands.
                                                              (line  18)
* m s:                                   Symbolic Mode.       (line  12)
* m S:                                   General Mode Commands.
                                                              (line  57)
* m t:                                   Algebraic Entry.     (line  42)
* m U:                                   Simplification Modes.
                                                              (line  57)
* m v:                                   Matrix Mode.         (line  11)
* m w:                                   Working Message.     (line  14)
* m x:                                   General Mode Commands.
                                                              (line  48)
* M-%:                                   Percentages.         (line   6)
* M-<DEL>:                               Stack Manipulation.  (line  33)
* M-<RET>:                               Undo.                (line  31)
* M-<TAB>:                               Stack Manipulation.  (line  49)
* M-C-w:                                 Killing From Stack.  (line   6)
* M-k:                                   Killing From Stack.  (line   6)
* M-w:                                   Killing From Stack.  (line   6)
* M-x:                                   Basic Commands.      (line  23)
* n:                                     Basic Arithmetic.    (line 161)
* N:                                     Symbolic Mode.       (line  17)
* O:                                     Inverse and Hyperbolic.
                                                              (line  23)
* o:                                     Stack Basics.        (line  30)
* o (HMS forms):                         HMS Forms.           (line  13)
* P:                                     Scientific Functions.
                                                              (line  12)
* p:                                     Precision.           (line   6)
* p (error forms):                       Error Forms.         (line  47)
* Q:                                     Basic Arithmetic.    (line 188)
* q:                                     Basic Commands.      (line  77)
* R:                                     Integer Truncation.  (line  23)
* r 0-9:                                 Recalling Variables. (line  18)
* r ?:                                   Help Commands.       (line   6)
* r i:                                   Inserting From Registers.
                                                              (line   6)
* r s:                                   Saving Into Registers.
                                                              (line   6)
* S:                                     Trigonometric and Hyperbolic Functions.
                                                              (line   6)
* s &:                                   Storing Variables.   (line  41)
* s (HMS forms):                         HMS Forms.           (line  13)
* s *:                                   Storing Variables.   (line  41)
* s +:                                   Storing Variables.   (line  41)
* s -:                                   Storing Variables.   (line  41)
* s /:                                   Storing Variables.   (line  41)
* s 0-9:                                 Storing Variables.   (line  37)
* s ::                                   Evaluates-To Operator.
                                                              (line  90)
* s =:                                   Evaluates-To Operator.
                                                              (line  22)
* s ?:                                   Help Commands.       (line   6)
* s [:                                   Storing Variables.   (line  41)
* s ]:                                   Storing Variables.   (line  41)
* s ^:                                   Storing Variables.   (line  41)
* s A:                                   Operations on Variables.
                                                              (line  25)
* s c:                                   Storing Variables.   (line 115)
* s D:                                   Operations on Variables.
                                                              (line  25)
* s d:                                   Declaration Basics.  (line   6)
* s E:                                   Operations on Variables.
                                                              (line  25)
* s e:                                   Operations on Variables.
                                                              (line   6)
* s F:                                   Operations on Variables.
                                                              (line  25)
* s G:                                   Operations on Variables.
                                                              (line  25)
* s H:                                   Operations on Variables.
                                                              (line  25)
* s i:                                   Operations on Variables.
                                                              (line  87)
* s I:                                   Operations on Variables.
                                                              (line  25)
* s k:                                   Storing Variables.   (line 137)
* s l:                                   Let Command.         (line   6)
* s L:                                   Operations on Variables.
                                                              (line  25)
* s m:                                   Storing Variables.   (line  84)
* s n:                                   Storing Variables.   (line  41)
* s p:                                   Operations on Variables.
                                                              (line  70)
* s P:                                   Operations on Variables.
                                                              (line  25)
* s R:                                   Operations on Variables.
                                                              (line  25)
* s r:                                   Recalling Variables. (line   6)
* s s:                                   Storing Variables.   (line   6)
* s T:                                   Operations on Variables.
                                                              (line  25)
* s t:                                   Storing Variables.   (line  12)
* s U:                                   Operations on Variables.
                                                              (line  25)
* s u:                                   Storing Variables.   (line 110)
* s X:                                   Operations on Variables.
                                                              (line  25)
* s x:                                   Storing Variables.   (line 102)
* s |:                                   Storing Variables.   (line  41)
* T:                                     Trigonometric and Hyperbolic Functions.
                                                              (line  44)
* t +:                                   Business Days.       (line  13)
* t -:                                   Business Days.       (line  13)
* t .:                                   Vector and Matrix Formats.
                                                              (line  78)
* t 0-9:                                 Storing Variables.   (line  37)
* t <:                                   Trail Commands.      (line  36)
* t >:                                   Trail Commands.      (line  36)
* t ?:                                   Help Commands.       (line   6)
* t [:                                   Trail Commands.      (line  47)
* t ]:                                   Trail Commands.      (line  47)
* t b:                                   Trail Commands.      (line  40)
* t C:                                   Date Conversions.    (line  60)
* t D:                                   Date Conversions.    (line   6)
* t d:                                   Trail Commands.      (line   9)
* t f:                                   Trail Commands.      (line  40)
* t h:                                   Trail Commands.      (line  47)
* t I:                                   Date Functions.      (line  98)
* t i:                                   Trail Commands.      (line  19)
* t J:                                   Date Conversions.    (line  35)
* t k:                                   Trail Commands.      (line  66)
* t M:                                   Date Functions.      (line  51)
* t m:                                   Trail Commands.      (line  60)
* t N:                                   Date Functions.      (line   6)
* t n:                                   Trail Commands.      (line  40)
* t o:                                   Trail Commands.      (line  19)
* t P:                                   Date Functions.      (line  11)
* t p:                                   Trail Commands.      (line  40)
* t r:                                   Trail Commands.      (line  53)
* t s:                                   Trail Commands.      (line  53)
* t U:                                   Date Conversions.    (line  50)
* t W:                                   Date Functions.      (line  68)
* t Y:                                   Date Functions.      (line  59)
* t y:                                   Trail Commands.      (line  30)
* U:                                     Undo.                (line   6)
* u #:                                   Single-Variable Statistics.
                                                              (line  36)
* u *:                                   Single-Variable Statistics.
                                                              (line  42)
* u +:                                   Single-Variable Statistics.
                                                              (line  42)
* u 0-9:                                 User-Defined Units.  (line   9)
* u ?:                                   Help Commands.       (line   6)
* u a:                                   Basic Operations on Units.
                                                              (line 140)
* u b:                                   Basic Operations on Units.
                                                              (line 125)
* u c:                                   Basic Operations on Units.
                                                              (line  51)
* u C:                                   Paired-Sample Statistics.
                                                              (line  13)
* u d:                                   User-Defined Units.  (line  27)
* u e:                                   The Units Table.     (line  45)
* u g:                                   The Units Table.     (line  35)
* u G:                                   Single-Variable Statistics.
                                                              (line 103)
* u M:                                   Single-Variable Statistics.
                                                              (line  55)
* u N:                                   Single-Variable Statistics.
                                                              (line  48)
* u p:                                   User-Defined Units.  (line  63)
* u r:                                   Basic Operations on Units.
                                                              (line 133)
* u s:                                   Basic Operations on Units.
                                                              (line  31)
* u S:                                   Single-Variable Statistics.
                                                              (line 116)
* u t:                                   Basic Operations on Units.
                                                              (line  60)
* u u:                                   User-Defined Units.  (line  40)
* u V:                                   The Units Table.     (line  27)
* u v:                                   The Units Table.     (line   6)
* u x:                                   Basic Operations on Units.
                                                              (line 133)
* u X:                                   Single-Variable Statistics.
                                                              (line  48)
* V #:                                   Set Operations.      (line  95)
* v #:                                   Set Operations.      (line  95)
* V (:                                   Vector and Matrix Formats.
                                                              (line  17)
* v (:                                   Vector and Matrix Formats.
                                                              (line  17)
* v ):                                   Vector and Matrix Formats.
                                                              (line  28)
* V ):                                   Vector and Matrix Formats.
                                                              (line  28)
* V +:                                   Set Operations.      (line  34)
* v +:                                   Set Operations.      (line  34)
* V ,:                                   Vector and Matrix Formats.
                                                              (line  59)
* v ,:                                   Vector and Matrix Formats.
                                                              (line  59)
* V -:                                   Set Operations.      (line  55)
* v -:                                   Set Operations.      (line  55)
* V .:                                   Vector and Matrix Formats.
                                                              (line  71)
* v .:                                   Vector and Matrix Formats.
                                                              (line  71)
* V /:                                   Vector and Matrix Formats.
                                                              (line  86)
* v /:                                   Vector and Matrix Formats.
                                                              (line  86)
* V ::                                   Set Operations.      (line  89)
* v ::                                   Set Operations.      (line  89)
* V <:                                   Vector and Matrix Formats.
                                                              (line  12)
* v <:                                   Vector and Matrix Formats.
                                                              (line  12)
* V =:                                   Vector and Matrix Formats.
                                                              (line  12)
* v =:                                   Vector and Matrix Formats.
                                                              (line  12)
* V >:                                   Vector and Matrix Formats.
                                                              (line  12)
* v >:                                   Vector and Matrix Formats.
                                                              (line  12)
* V ?:                                   Help Commands.       (line   6)
* v ?:                                   Help Commands.       (line   6)
* V [:                                   Vector and Matrix Formats.
                                                              (line  17)
* v [:                                   Vector and Matrix Formats.
                                                              (line  17)
* v ]:                                   Vector and Matrix Formats.
                                                              (line  28)
* V ]:                                   Vector and Matrix Formats.
                                                              (line  28)
* V ^:                                   Set Operations.      (line  47)
* v ^:                                   Set Operations.      (line  47)
* V A:                                   Reducing and Mapping.
                                                              (line   9)
* v A:                                   Reducing and Mapping.
                                                              (line   9)
* V a:                                   Manipulating Vectors.
                                                              (line  23)
* v a:                                   Manipulating Vectors.
                                                              (line  23)
* V b:                                   Building Vectors.    (line  80)
* v b:                                   Building Vectors.    (line  80)
* V C:                                   Vector and Matrix Arithmetic.
                                                              (line  38)
* v C:                                   Vector and Matrix Arithmetic.
                                                              (line  38)
* V c:                                   Extracting Elements. (line  44)
* v c:                                   Extracting Elements. (line  44)
* V D:                                   Vector and Matrix Arithmetic.
                                                              (line  53)
* v D:                                   Vector and Matrix Arithmetic.
                                                              (line  53)
* V d:                                   Building Vectors.    (line  32)
* v d:                                   Building Vectors.    (line  32)
* V E:                                   Set Operations.      (line  84)
* v E:                                   Set Operations.      (line  84)
* V e:                                   Manipulating Vectors.
                                                              (line 128)
* v e:                                   Manipulating Vectors.
                                                              (line 128)
* V F:                                   Set Operations.      (line  75)
* v F:                                   Set Operations.      (line  75)
* V f:                                   Manipulating Vectors.
                                                              (line  16)
* v f:                                   Manipulating Vectors.
                                                              (line  16)
* V G:                                   Manipulating Vectors.
                                                              (line  53)
* v G:                                   Manipulating Vectors.
                                                              (line  53)
* V H:                                   Manipulating Vectors.
                                                              (line  79)
* v H:                                   Manipulating Vectors.
                                                              (line  79)
* V h:                                   Building Vectors.    (line  87)
* v h:                                   Building Vectors.    (line  87)
* V I:                                   Generalized Products.
                                                              (line  14)
* v I:                                   Generalized Products.
                                                              (line  14)
* V i:                                   Building Vectors.    (line  45)
* v i:                                   Building Vectors.    (line  45)
* V J:                                   Vector and Matrix Arithmetic.
                                                              (line  16)
* v J:                                   Vector and Matrix Arithmetic.
                                                              (line  16)
* V K:                                   Vector and Matrix Arithmetic.
                                                              (line  67)
* v K:                                   Vector and Matrix Arithmetic.
                                                              (line  67)
* V k:                                   Building Vectors.    (line  92)
* v k:                                   Building Vectors.    (line  92)
* V L:                                   Vector and Matrix Arithmetic.
                                                              (line  56)
* v L:                                   Vector and Matrix Arithmetic.
                                                              (line  56)
* V l:                                   Manipulating Vectors.
                                                              (line   6)
* v l:                                   Manipulating Vectors.
                                                              (line   6)
* V M:                                   Mapping.             (line   6)
* v M:                                   Mapping.             (line   6)
* V m:                                   Manipulating Vectors.
                                                              (line 120)
* v m:                                   Manipulating Vectors.
                                                              (line 120)
* V N:                                   Vector and Matrix Arithmetic.
                                                              (line  31)
* v N:                                   Vector and Matrix Arithmetic.
                                                              (line  31)
* V n:                                   Vector and Matrix Arithmetic.
                                                              (line  25)
* v n:                                   Vector and Matrix Arithmetic.
                                                              (line  25)
* V O:                                   Generalized Products.
                                                              (line   6)
* v O:                                   Generalized Products.
                                                              (line   6)
* V p:                                   Packing and Unpacking.
                                                              (line  11)
* v p:                                   Packing and Unpacking.
                                                              (line  11)
* V p (complex):                         Complex Number Functions.
                                                              (line  33)
* v p (complex):                         Complex Number Functions.
                                                              (line  33)
* V R:                                   Reducing.            (line   6)
* v R:                                   Reducing.            (line   6)
* V r:                                   Extracting Elements. (line   6)
* v r:                                   Extracting Elements. (line   6)
* V S:                                   Manipulating Vectors.
                                                              (line  39)
* v S:                                   Manipulating Vectors.
                                                              (line  39)
* V s:                                   Extracting Elements. (line  57)
* v s:                                   Extracting Elements. (line  57)
* V T:                                   Vector and Matrix Arithmetic.
                                                              (line  63)
* v T:                                   Vector and Matrix Arithmetic.
                                                              (line  63)
* V t:                                   Manipulating Vectors.
                                                              (line 109)
* v t:                                   Manipulating Vectors.
                                                              (line 109)
* V U:                                   Reducing.            (line  21)
* v U:                                   Reducing.            (line  21)
* V u:                                   Packing and Unpacking.
                                                              (line 124)
* v u:                                   Packing and Unpacking.
                                                              (line 124)
* V u (complex):                         Complex Number Functions.
                                                              (line  39)
* v u (complex):                         Complex Number Functions.
                                                              (line  39)
* V V:                                   Set Operations.      (line  42)
* v V:                                   Set Operations.      (line  42)
* V v:                                   Manipulating Vectors.
                                                              (line 114)
* v v:                                   Manipulating Vectors.
                                                              (line 114)
* V X:                                   Set Operations.      (line  65)
* v X:                                   Set Operations.      (line  65)
* V x:                                   Building Vectors.    (line  61)
* v x:                                   Building Vectors.    (line  61)
* V {:                                   Vector and Matrix Formats.
                                                              (line  17)
* v {:                                   Vector and Matrix Formats.
                                                              (line  17)
* v }:                                   Vector and Matrix Formats.
                                                              (line  28)
* V }:                                   Vector and Matrix Formats.
                                                              (line  28)
* V ~:                                   Set Operations.      (line  70)
* v ~:                                   Set Operations.      (line  70)
* w:                                     Error Messages.      (line   6)
* X:                                     Keyboard Macros.     (line   6)
* x:                                     Basic Commands.      (line  23)
* Y:                                     Defining Simple Commands.
                                                              (line  87)
* y:                                     Yanking Into Buffers.
                                                              (line   6)
* Y ?:                                   Defining Simple Commands.
                                                              (line  87)
* z:                                     Programming.         (line  30)
* Z #:                                   Queries in Macros.   (line   6)
* Z ':                                   Local Values in Macros.
                                                              (line  11)
* Z (:                                   Loops in Macros.     (line  33)
* Z ):                                   Loops in Macros.     (line  33)
* Z /:                                   Loops in Macros.     (line  26)
* Z ::                                   Conditionals in Macros.
                                                              (line  31)
* Z <:                                   Loops in Macros.     (line   6)
* Z >:                                   Loops in Macros.     (line   6)
* Z ?:                                   Help Commands.       (line   6)
* z ?:                                   Help Commands.       (line   6)
* Z [:                                   Conditionals in Macros.
                                                              (line   6)
* Z ]:                                   Conditionals in Macros.
                                                              (line   6)
* Z `:                                   Local Values in Macros.
                                                              (line  11)
* Z C:                                   User-Defined Compositions.
                                                              (line   6)
* Z C-g:                                 Conditionals in Macros.
                                                              (line  60)
* Z D:                                   Creating User Keys.  (line   6)
* Z E:                                   Creating User Keys.  (line  60)
* Z F:                                   Algebraic Definitions.
                                                              (line   6)
* Z G:                                   Algebraic Definitions.
                                                              (line  75)
* Z I:                                   Invocation Macros.   (line   6)
* Z K:                                   Naming Keyboard Macros.
                                                              (line   6)
* Z P:                                   Creating User Keys.  (line  36)
* Z S:                                   Syntax Tables.       (line  13)
* Z T:                                   Debugging Calc.      (line  10)
* Z U:                                   Creating User Keys.  (line  32)
* Z {:                                   Loops in Macros.     (line  56)
* Z |:                                   Conditionals in Macros.
                                                              (line  38)
* Z }:                                   Loops in Macros.     (line  56)
* {:                                     Basic Commands.      (line 101)
* |:                                     Building Vectors.    (line   9)
* }:                                     Basic Commands.      (line 101)
* ~:                                     Prefix Arguments.    (line  39)

