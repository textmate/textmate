This is ../../info/calc, produced by makeinfo version 4.13 from
calc.texi.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990-1991, 2001-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being just "GNU GENERAL
     PUBLIC LICENSE", with the Front-Cover texts being "A GNU Manual,"
     and with the Back-Cover Texts as in (a) below.  A copy of the
     license is included in the section entitled "GNU Free
     Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs misc features
START-INFO-DIR-ENTRY
* Calc: (calc).                 Advanced desk calculator and mathematical tool.
END-INFO-DIR-ENTRY


File: calc,  Node: Introduction,  Next: Data Types,  Prev: Tutorial,  Up: Top

5 Introduction
**************

This chapter is the beginning of the Calc reference manual.  It covers
basic concepts such as the stack, algebraic and numeric entry, undo,
numeric prefix arguments, etc.

* Menu:

* Basic Commands::
* Help Commands::
* Stack Basics::
* Numeric Entry::
* Algebraic Entry::
* Quick Calculator::
* Prefix Arguments::
* Undo::
* Error Messages::
* Multiple Calculators::
* Troubleshooting Commands::


File: calc,  Node: Basic Commands,  Next: Help Commands,  Prev: Introduction,  Up: Introduction

5.1 Basic Commands
==================

To start the Calculator in its standard interface, type `M-x calc'.  By
default this creates a pair of small windows, `*Calculator*' and `*Calc
Trail*'.  The former displays the contents of the Calculator stack and
is manipulated exclusively through Calc commands.  It is possible
(though not usually necessary) to create several Calc mode buffers each
of which has an independent stack, undo list, and mode settings.  There
is exactly one Calc Trail buffer; it records a list of the results of
all calculations that have been done.  The Calc Trail buffer uses a
variant of Calc mode, so Calculator commands still work when the trail
buffer's window is selected.  It is possible to turn the trail window
off, but the `*Calc Trail*' buffer itself still exists and is updated
silently.  *Note Trail Commands::.

   In most installations, the `C-x * c' key sequence is a more
convenient way to start the Calculator.  Also, `C-x * *' is a synonym
for `C-x * c' unless you last used Calc in its Keypad mode.

   Most Calc commands use one or two keystrokes.  Lower- and upper-case
letters are distinct.  Commands may also be entered in full `M-x' form;
for some commands this is the only form.  As a convenience, the `x' key
(`calc-execute-extended-command') is like `M-x' except that it enters
the initial string `calc-' for you.  For example, the following key
sequences are equivalent: `S', `M-x calc-sin <RET>', `x sin <RET>'.

   Although Calc is designed to be used from the keyboard, some of
Calc's more common commands are available from a menu.  In the menu, the
arguments to the functions are given by referring to their stack level
numbers.

   The Calculator exists in many parts.  When you type `C-x * c', the
Emacs "auto-load" mechanism will bring in only the first part, which
contains the basic arithmetic functions.  The other parts will be
auto-loaded the first time you use the more advanced commands like trig
functions or matrix operations.  This is done to improve the response
time of the Calculator in the common case when all you need to do is a
little arithmetic.  If for some reason the Calculator fails to load an
extension module automatically, you can force it to load all the
extensions by using the `C-x * L' (`calc-load-everything') command.
*Note Mode Settings::.

   If you type `M-x calc' or `C-x * c' with any numeric prefix argument,
the Calculator is loaded if necessary, but it is not actually started.
If the argument is positive, the `calc-ext' extensions are also loaded
if necessary.  User-written Lisp code that wishes to make use of Calc's
arithmetic routines can use `(calc 0)' or `(calc 1)' to auto-load the
Calculator.

   If you type `C-x * b', then next time you use `C-x * c' you will get
a Calculator that uses the full height of the Emacs screen.  When
full-screen mode is on, `C-x * c' runs the `full-calc' command instead
of `calc'.  From the Unix shell you can type `emacs -f full-calc' to
start a new Emacs specifically for use as a calculator.  When Calc is
started from the Emacs command line like this, Calc's normal "quit"
commands actually quit Emacs itself.

   The `C-x * o' command is like `C-x * c' except that the Calc window
is not actually selected.  If you are already in the Calc window, `C-x
* o' switches you out of it.  (The regular Emacs `C-x o' command would
also work for this, but it has a tendency to drop you into the Calc
Trail window instead, which `C-x * o' takes care not to do.)

   For one quick calculation, you can type `C-x * q' (`quick-calc')
which prompts you for a formula (like `2+3/4').  The result is
displayed at the bottom of the Emacs screen without ever creating any
special Calculator windows.  *Note Quick Calculator::.

   Finally, if you are using the X window system you may want to try
`C-x * k' (`calc-keypad') which runs Calc with a "calculator keypad"
picture as well as a stack display.  Click on the keys with the mouse
to operate the calculator.  *Note Keypad Mode::.

   The `q' key (`calc-quit') exits Calc mode and closes the
Calculator's window(s).  It does not delete the Calculator buffers.  If
you type `M-x calc' again, the Calculator will reappear with the
contents of the stack intact.  Typing `C-x * c' or `C-x * *' again from
inside the Calculator buffer is equivalent to executing `calc-quit';
you can think of `C-x * *' as toggling the Calculator on and off.

   The `C-x * x' command also turns the Calculator off, no matter which
user interface (standard, Keypad, or Embedded) is currently active.  It
also cancels `calc-edit' mode if used from there.

   The `d <SPC>' key sequence (`calc-refresh') redraws the contents of
the Calculator buffer from memory.  Use this if the contents of the
buffer have been damaged somehow.

   The `o' key (`calc-realign') moves the cursor back to its "home"
position at the bottom of the Calculator buffer.

   The `<' and `>' keys are bound to `calc-scroll-left' and
`calc-scroll-right'.  These are just like the normal horizontal
scrolling commands except that they scroll one half-screen at a time by
default.  (Calc formats its output to fit within the bounds of the
window whenever it can.)

   The `{' and `}' keys are bound to `calc-scroll-down' and
`calc-scroll-up'.  They scroll up or down by one-half the height of the
Calc window.

   The `C-x * 0' command (`calc-reset'; that's `C-x *' followed by a
zero) resets the Calculator to its initial state.  This clears the
stack, resets all the modes to their initial values (the values that
were saved with `m m' (`calc-save-modes')), clears the caches (*note
Caches::), and so on.  (It does _not_ erase the values of any
variables.) With an argument of 0, Calc will be reset to its default
state; namely, the modes will be given their default values.  With a
positive prefix argument, `C-x * 0' preserves the contents of the stack
but resets everything else to its initial state; with a negative prefix
argument, `C-x * 0' preserves the contents of the stack but resets
everything else to its default state.


File: calc,  Node: Help Commands,  Next: Stack Basics,  Prev: Basic Commands,  Up: Introduction

5.2 Help Commands
=================

The `?' key (`calc-help') displays a series of brief help messages.
Some keys (such as `b' and `d') are prefix keys, like Emacs's <ESC> and
`C-x' prefixes.  You can type `?' after a prefix to see a list of
commands beginning with that prefix.  (If the message includes
`[MORE]', press `?' again to see additional commands for that prefix.)

   The `h h' (`calc-full-help') command displays all the `?' responses
at once.  When printed, this makes a nice, compact (three pages)
summary of Calc keystrokes.

   In general, the `h' key prefix introduces various commands that
provide help within Calc.  Many of the `h' key functions are
Calc-specific analogues to the `C-h' functions for Emacs help.

   The `h i' (`calc-info') command runs the Emacs Info system to read
this manual on-line.  This is basically the same as typing `C-h i' (the
regular way to run the Info system), then, if Info is not already in
the Calc manual, selecting the beginning of the manual.  The `C-x * i'
command is another way to read the Calc manual; it is different from `h
i' in that it works any time, not just inside Calc.  The plain `i' key
is also equivalent to `h i', though this key is obsolete and may be
replaced with a different command in a future version of Calc.

   The `h t' (`calc-tutorial') command runs the Info system on the
Tutorial section of the Calc manual.  It is like `h i', except that it
selects the starting node of the tutorial rather than the beginning of
the whole manual.  (It actually selects the node "Interactive Tutorial"
which tells a few things about using the Info system before going on to
the actual tutorial.)  The `C-x * t' key is equivalent to `h t' (but it
works at all times).

   The `h s' (`calc-info-summary') command runs the Info system on the
Summary node of the Calc manual.  *Note Summary::.  The `C-x * s' key
is equivalent to `h s'.

   The `h k' (`calc-describe-key') command looks up a key sequence in
the Calc manual.  For example, `h k H a S' looks up the documentation
on the `H a S' (`calc-solve-for') command.  This works by looking up
the textual description of the key(s) in the Key Index of the manual,
then jumping to the node indicated by the index.

   Most Calc commands do not have traditional Emacs documentation
strings, since the `h k' command is both more convenient and more
instructive.  This means the regular Emacs `C-h k' (`describe-key')
command will not be useful for Calc keystrokes.

   The `h c' (`calc-describe-key-briefly') command reads a key sequence
and displays a brief one-line description of it at the bottom of the
screen.  It looks for the key sequence in the Summary node of the Calc
manual; if it doesn't find the sequence there, it acts just like its
regular Emacs counterpart `C-h c' (`describe-key-briefly').  For
example, `h c H a S' gives the description:

     H a S runs calc-solve-for:  a `H a S' v  => fsolve(a,v)  (?=notes)

which means the command `H a S' or `H M-x calc-solve-for' takes a value
`a' from the stack, prompts for a value `v', then applies the algebraic
function `fsolve' to these values.  The `?=notes' message means you can
now type `?' to see additional notes from the summary that apply to
this command.

   The `h f' (`calc-describe-function') command looks up an algebraic
function or a command name in the Calc manual.  Enter an algebraic
function name to look up that function in the Function Index or enter a
command name beginning with `calc-' to look it up in the Command Index.
This command will also look up operator symbols that can appear in
algebraic formulas, like `%' and `=>'.

   The `h v' (`calc-describe-variable') command looks up a variable in
the Calc manual.  Enter a variable name like `pi' or `PlotRejects'.

   The `h b' (`calc-describe-bindings') command is just like `C-h b',
except that only local (Calc-related) key bindings are listed.

   The `h n' or `h C-n' (`calc-view-news') command displays the "news"
or change history of Calc.  This is kept in the file `README', which
Calc looks for in the same directory as the Calc source files.

   The `h C-c', `h C-d', and `h C-w' keys display copying,
distribution, and warranty information about Calc.  These work by
pulling up the appropriate parts of the "Copying" or "Reporting Bugs"
sections of the manual.


File: calc,  Node: Stack Basics,  Next: Numeric Entry,  Prev: Help Commands,  Up: Introduction

5.3 Stack Basics
================

Calc uses RPN notation.  If you are not familiar with RPN, *note RPN
Tutorial::.

   To add the numbers 1 and 2 in Calc you would type the keys: `1 <RET>
2 +'.  (<RET> corresponds to the <ENTER> key on most calculators.)  The
first three keystrokes "push" the numbers 1 and 2 onto the stack.  The
`+' key always "pops" the top two numbers from the stack, adds them,
and pushes the result (3) back onto the stack.  This number is ready for
further calculations:  `5 -' pushes 5 onto the stack, then pops the 3
and 5, subtracts them, and pushes the result (-2).

   Note that the "top" of the stack actually appears at the _bottom_ of
the buffer.  A line containing a single `.' character signifies the end
of the buffer; Calculator commands operate on the number(s) directly
above this line.  The `d t' (`calc-truncate-stack') command allows you
to move the `.' marker up and down in the stack; *note Truncating the
Stack::.

   Stack elements are numbered consecutively, with number 1 being the
top of the stack.  These line numbers are ordinarily displayed on the
lefthand side of the window.  The `d l' (`calc-line-numbering') command
controls whether these numbers appear.  (Line numbers may be turned off
since they slow the Calculator down a bit and also clutter the display.)

   The unshifted letter `o' (`calc-realign') command repositions the
cursor to its top-of-stack "home" position.  It also undoes any
horizontal scrolling in the window.  If you give it a numeric prefix
argument, it instead moves the cursor to the specified stack element.

   The <RET> (or equivalent <SPC>) key is only required to separate two
consecutive numbers.  (After all, if you typed `1 2' by themselves the
Calculator would enter the number 12.)  If you press <RET> or <SPC>
_not_ right after typing a number, the key duplicates the number on the
top of the stack.  `<RET> *' is thus a handy way to square a number.

   The <DEL> key pops and throws away the top number on the stack.  The
<TAB> key swaps the top two objects on the stack.  *Note Stack and
Trail::, for descriptions of these and other stack-related commands.


File: calc,  Node: Numeric Entry,  Next: Algebraic Entry,  Prev: Stack Basics,  Up: Introduction

5.4 Numeric Entry
=================

Pressing a digit or other numeric key begins numeric entry using the
minibuffer.  The number is pushed on the stack when you press the <RET>
or <SPC> keys.  If you press any other non-numeric key, the number is
pushed onto the stack and the appropriate operation is performed.  If
you press a numeric key which is not valid, the key is ignored.

   There are three different concepts corresponding to the word "minus,"
typified by `a-b' (subtraction), `-x' (change-sign), and `-5' (negative
number).  Calc uses three different keys for these operations,
respectively: `-', `n', and `_' (the underscore).  The `-' key subtracts
the two numbers on the top of the stack.  The `n' key changes the sign
of the number on the top of the stack or the number currently being
entered.  The `_' key begins entry of a negative number or changes the
sign of the number currently being entered.  The following sequences
all enter the number -5 onto the stack:  `0 <RET> 5 -', `5 n <RET>', `5
<RET> n', `_ 5 <RET>', `5 _ <RET>'.

   Some other keys are active during numeric entry, such as `#' for
non-decimal numbers, `:' for fractions, and `@' for HMS forms.  These
notations are described later in this manual with the corresponding
data types.  *Note Data Types::.

   During numeric entry, the only editing key available is <DEL>.


File: calc,  Node: Algebraic Entry,  Next: Quick Calculator,  Prev: Numeric Entry,  Up: Introduction

5.5 Algebraic Entry
===================

The `'' (`calc-algebraic-entry') command can be used to enter
calculations in algebraic form.  This is accomplished by typing the
apostrophe key, ', followed by the expression in standard format:

     ' 2+3*4 <RET>.

This will compute `2+(3*4) = 14' and push it on the stack.  If you wish
you can ignore the RPN aspect of Calc altogether and simply enter
algebraic expressions in this way.  You may want to use <DEL> every so
often to clear previous results off the stack.

   You can press the apostrophe key during normal numeric entry to
switch the half-entered number into Algebraic entry mode.  One reason
to do this would be to fix a typo, as the full Emacs cursor motion and
editing keys are available during algebraic entry but not during
numeric entry.

   In the same vein, during either numeric or algebraic entry you can
press ``' (backquote) to switch to `calc-edit' mode, where you complete
your half-finished entry in a separate buffer.  *Note Editing Stack
Entries::.

   If you prefer algebraic entry, you can use the command `m a'
(`calc-algebraic-mode') to set Algebraic mode.  In this mode, digits
and other keys that would normally start numeric entry instead start
full algebraic entry; as long as your formula begins with a digit you
can omit the apostrophe.  Open parentheses and square brackets also
begin algebraic entry.  You can still do RPN calculations in this mode,
but you will have to press <RET> to terminate every number: `2 <RET> 3
<RET> * 4 <RET> +' would accomplish the same thing as `2*3+4 <RET>'.

   If you give a numeric prefix argument like `C-u' to the `m a'
command, it enables Incomplete Algebraic mode; this is like regular
Algebraic mode except that it applies to the `(' and `[' keys only.
Numeric keys still begin a numeric entry in this mode.

   The `m t' (`calc-total-algebraic-mode') gives you an even stronger
algebraic-entry mode, in which _all_ regular letter and punctuation
keys begin algebraic entry.  Use this if you prefer typing `sqrt( )'
instead of `Q', `factor( )' instead of `a f', and so on.  To type
regular Calc commands when you are in Total Algebraic mode, hold down
the <META> key.  Thus `M-q' is the command to quit Calc, `M-p' sets the
precision, and `M-m t' (or `M-m M-t', if you prefer) turns Total
Algebraic mode back off again.  Meta keys also terminate algebraic
entry, so that `2+3 M-S' is equivalent to `2+3 <RET> M-S'.  The symbol
`Alg*' will appear in the mode line whenever you are in this mode.

   Pressing `'' (the apostrophe) a second time re-enters the previous
algebraic formula.  You can then use the normal Emacs editing keys to
modify this formula to your liking before pressing <RET>.

   Within a formula entered from the keyboard, the symbol `$'
represents the number on the top of the stack.  If an entered formula
contains any `$' characters, the Calculator replaces the top of stack
with that formula rather than simply pushing the formula onto the
stack.  Thus, `' 1+2 <RET>' pushes 3 on the stack, and `$*2 <RET>'
replaces it with 6.  Note that the `$' key always initiates algebraic
entry; the `'' is unnecessary if `$' is the first character in the new
formula.

   Higher stack elements can be accessed from an entered formula with
the symbols `$$', `$$$', and so on.  The number of stack elements
removed (to be replaced by the entered values) equals the number of
dollar signs in the longest such symbol in the formula.  For example,
`$$+$$$' adds the second and third stack elements, replacing the top
three elements with the answer.  (All information about the top stack
element is thus lost since no single `$' appears in this formula.)

   A slightly different way to refer to stack elements is with a dollar
sign followed by a number:  `$1', `$2', and so on are much like `$',
`$$', etc., except that stack entries referred to numerically are not
replaced by the algebraic entry.  That is, while `$+1' replaces 5 on
the stack with 6, `$1+1' leaves the 5 on the stack and pushes an
additional 6.

   If a sequence of formulas are entered separated by commas, each
formula is pushed onto the stack in turn.  For example, `1,2,3' pushes
those three numbers onto the stack (leaving the 3 at the top), and
`$+1,$-1' replaces a 5 on the stack with 4 followed by 6.  Also, `$,$$'
exchanges the top two elements of the stack, just like the <TAB> key.

   You can finish an algebraic entry with `M-=' or `M-<RET>' instead of
<RET>.  This uses `=' to evaluate the variables in each formula that
goes onto the stack.  (Thus `' pi <RET>' pushes the variable `pi', but
`' pi M-<RET>' pushes 3.1415.)

   If you finish your algebraic entry by pressing <LFD> (or `C-j')
instead of <RET>, Calc disables the default simplifications (as if by
`m O'; *note Simplification Modes::) while the entry is being pushed on
the stack.  Thus `' 1+2 <RET>' pushes 3 on the stack, but `' 1+2 <LFD>'
pushes the formula `1+2'; you might then press `=' when it is time to
evaluate this formula.


File: calc,  Node: Quick Calculator,  Next: Prefix Arguments,  Prev: Algebraic Entry,  Up: Introduction

5.6 "Quick Calculator" Mode
===========================

There is another way to invoke the Calculator if all you need to do is
make one or two quick calculations.  Type `C-x * q' (or `M-x
quick-calc'), then type any formula as an algebraic entry.  The
Calculator will compute the result and display it in the echo area,
without ever actually putting up a Calc window.

   You can use the `$' character in a Quick Calculator formula to refer
to the previous Quick Calculator result.  Older results are not
retained; the Quick Calculator has no effect on the full Calculator's
stack or trail.  If you compute a result and then forget what it was,
just run `C-x * q' again and enter `$' as the formula.

   If this is the first time you have used the Calculator in this Emacs
session, the `C-x * q' command will create the `*Calculator*' buffer
and perform all the usual initializations; it simply will refrain from
putting that buffer up in a new window.  The Quick Calculator refers to
the `*Calculator*' buffer for all mode settings.  Thus, for example, to
set the precision that the Quick Calculator uses, simply run the full
Calculator momentarily and use the regular `p' command.

   If you use `C-x * q' from inside the Calculator buffer, the effect
is the same as pressing the apostrophe key (algebraic entry).

   The result of a Quick calculation is placed in the Emacs "kill ring"
as well as being displayed.  A subsequent `C-y' command will yank the
result into the editing buffer.  You can also use this to yank the
result into the next `C-x * q' input line as a more explicit
alternative to `$' notation, or to yank the result into the Calculator
stack after typing `C-x * c'.

   If you finish your formula by typing <LFD> (or `C-j') instead of
<RET>, the result is inserted immediately into the current buffer
rather than going into the kill ring.

   Quick Calculator results are actually evaluated as if by the `=' key
(which replaces variable names by their stored values, if any).  If the
formula you enter is an assignment to a variable using the `:='
operator, say, `foo := 2 + 3' or `foo := foo + 1', then the result of
the evaluation is stored in that Calc variable.  *Note Store and
Recall::.

   If the result is an integer and the current display radix is decimal,
the number will also be displayed in hex, octal and binary formats.  If
the integer is in the range from 1 to 126, it will also be displayed as
an ASCII character.

   For example, the quoted character `"x"' produces the vector result
`[120]' (because 120 is the ASCII code of the lower-case `x'; *note
Strings::).  Since this is a vector, not an integer, it is displayed
only according to the current mode settings.  But running Quick Calc
again and entering `120' will produce the result `120 (16#78, 8#170,
x)' which shows the number in its decimal, hexadecimal, octal, and
ASCII forms.

   Please note that the Quick Calculator is not any faster at loading
or computing the answer than the full Calculator; the name "quick"
merely refers to the fact that it's much less hassle to use for small
calculations.


File: calc,  Node: Prefix Arguments,  Next: Undo,  Prev: Quick Calculator,  Up: Introduction

5.7 Numeric Prefix Arguments
============================

Many Calculator commands use numeric prefix arguments.  Some, such as
`d s' (`calc-sci-notation'), set a parameter to the value of the prefix
argument or use a default if you don't use a prefix.  Others (like `d
f' (`calc-fix-notation')) require an argument and prompt for a number
if you don't give one as a prefix.

   As a rule, stack-manipulation commands accept a numeric prefix
argument which is interpreted as an index into the stack.  A positive
argument operates on the top N stack entries; a negative argument
operates on the Nth stack entry in isolation; and a zero argument
operates on the entire stack.

   Most commands that perform computations (such as the arithmetic and
scientific functions) accept a numeric prefix argument that allows the
operation to be applied across many stack elements.  For unary
operations (that is, functions of one argument like absolute value or
complex conjugate), a positive prefix argument applies that function to
the top N stack entries simultaneously, and a negative argument applies
it to the Nth stack entry only.  For binary operations (functions of
two arguments like addition, GCD, and vector concatenation), a positive
prefix argument "reduces" the function across the top N stack elements
(for example, `C-u 5 +' sums the top 5 stack entries; *note Reducing
and Mapping::), and a negative argument maps the next-to-top N stack
elements with the top stack element as a second argument (for example,
`7 c-u -5 +' adds 7 to the top 5 stack elements).  This feature is not
available for operations which use the numeric prefix argument for some
other purpose.

   Numeric prefixes are specified the same way as always in Emacs:
Press a sequence of <META>-digits, or press <ESC> followed by digits,
or press `C-u' followed by digits.  Some commands treat plain `C-u'
(without any actual digits) specially.

   You can type `~' (`calc-num-prefix') to pop an integer from the top
of the stack and enter it as the numeric prefix for the next command.
For example, `C-u 16 p' sets the precision to 16 digits; an alternate
(silly) way to do this would be `2 <RET> 4 ^ ~ p', i.e., compute 2 to
the fourth power and set the precision to that value.

   Conversely, if you have typed a numeric prefix argument the `~' key
pushes it onto the stack in the form of an integer.


File: calc,  Node: Undo,  Next: Error Messages,  Prev: Prefix Arguments,  Up: Introduction

5.8 Undoing Mistakes
====================

The shift-`U' key (`calc-undo') undoes the most recent operation.  If
that operation added or dropped objects from the stack, those objects
are removed or restored.  If it was a "store" operation, you are
queried whether or not to restore the variable to its original value.
The `U' key may be pressed any number of times to undo successively
farther back in time; with a numeric prefix argument it undoes a
specified number of operations.  When the Calculator is quit, as with
the `q' (`calc-quit') command, the undo history will be truncated to
the length of the customizable variable `calc-undo-length' (*note
Customizing Calc::), which by default is `100'. (Recall that `C-x * c'
is synonymous with `calc-quit' while inside the Calculator; this also
truncates the undo history.)

   Currently the mode-setting commands (like `calc-precision') are not
undoable.  You can undo past a point where you changed a mode, but you
will need to reset the mode yourself.

   The shift-`D' key (`calc-redo') redoes an operation that was
mistakenly undone.  Pressing `U' with a negative prefix argument is
equivalent to executing `calc-redo'.  You can redo any number of times,
up to the number of recent consecutive undo commands.  Redo information
is cleared whenever you give any command that adds new undo
information, i.e., if you undo, then enter a number on the stack or make
any other change, then it will be too late to redo.

   The `M-<RET>' key (`calc-last-args') is like undo in that it
restores the arguments of the most recent command onto the stack;
however, it does not remove the result of that command.  Given a numeric
prefix argument, this command applies to the `n'th most recent command
which removed items from the stack; it pushes those items back onto the
stack.

   The `K' (`calc-keep-args') command provides a related function to
`M-<RET>'.  *Note Stack and Trail::.

   It is also possible to recall previous results or inputs using the
trail.  *Note Trail Commands::.

   The standard Emacs `C-_' undo key is recognized as a synonym for `U'.


File: calc,  Node: Error Messages,  Next: Multiple Calculators,  Prev: Undo,  Up: Introduction

5.9 Error Messages
==================

Many situations that would produce an error message in other calculators
simply create unsimplified formulas in the Emacs Calculator.  For
example, `1 <RET> 0 /' pushes the formula `1 / 0'; `0 L' pushes the
formula `ln(0)'.  Floating-point overflow and underflow are also
reasons for this to happen.

   When a function call must be left in symbolic form, Calc usually
produces a message explaining why.  Messages that are probably
surprising or indicative of user errors are displayed automatically.
Other messages are simply kept in Calc's memory and are displayed only
if you type `w' (`calc-why').  You can also press `w' if the same
computation results in several messages.  (The first message will end
with `[w=more]' in this case.)

   The `d w' (`calc-auto-why') command controls when error messages are
displayed automatically.  (Calc effectively presses `w' for you after
your computation finishes.)  By default, this occurs only for
"important" messages.  The other possible modes are to report _all_
messages automatically, or to report none automatically (so that you
must always press `w' yourself to see the messages).


File: calc,  Node: Multiple Calculators,  Next: Troubleshooting Commands,  Prev: Error Messages,  Up: Introduction

5.10 Multiple Calculators
=========================

It is possible to have any number of Calc mode buffers at once.
Usually this is done by executing `M-x another-calc', which is similar
to `C-x * c' except that if a `*Calculator*' buffer already exists, a
new, independent one with a name of the form `*Calculator*<N>' is
created.  You can also use the command `calc-mode' to put any buffer
into Calculator mode, but this would ordinarily never be done.

   The `q' (`calc-quit') command does not destroy a Calculator buffer;
it only closes its window.  Use `M-x kill-buffer' to destroy a
Calculator buffer.

   Each Calculator buffer keeps its own stack, undo list, and mode
settings such as precision, angular mode, and display formats.  In
Emacs terms, variables such as `calc-stack' are buffer-local variables.
The global default values of these variables are used only when a new
Calculator buffer is created.  The `calc-quit' command saves the stack
and mode settings of the buffer being quit as the new defaults.

   There is only one trail buffer, `*Calc Trail*', used by all
Calculator buffers.


File: calc,  Node: Troubleshooting Commands,  Prev: Multiple Calculators,  Up: Introduction

5.11 Troubleshooting Commands
=============================

This section describes commands you can use in case a computation
incorrectly fails or gives the wrong answer.

   *Note Reporting Bugs::, if you find a problem that appears to be due
to a bug or deficiency in Calc.

* Menu:

* Autoloading Problems::
* Recursion Depth::
* Caches::
* Debugging Calc::


File: calc,  Node: Autoloading Problems,  Next: Recursion Depth,  Prev: Troubleshooting Commands,  Up: Troubleshooting Commands

5.11.1 Autoloading Problems
---------------------------

The Calc program is split into many component files; components are
loaded automatically as you use various commands that require them.
Occasionally Calc may lose track of when a certain component is
necessary; typically this means you will type a command and it won't
work because some function you've never heard of was undefined.

   If this happens, the easiest workaround is to type `C-x * L'
(`calc-load-everything') to force all the parts of Calc to be loaded
right away.  This will cause Emacs to take up a lot more memory than it
would otherwise, but it's guaranteed to fix the problem.


File: calc,  Node: Recursion Depth,  Next: Caches,  Prev: Autoloading Problems,  Up: Troubleshooting Commands

5.11.2 Recursion Depth
----------------------

Calc uses recursion in many of its calculations.  Emacs Lisp keeps a
variable `max-lisp-eval-depth' which limits the amount of recursion
possible in an attempt to recover from program bugs.  If a calculation
ever halts incorrectly with the message "Computation got stuck or ran
too long," use the `M' command (`calc-more-recursion-depth') to
increase this limit.  (Of course, this will not help if the calculation
really did get stuck due to some problem inside Calc.)

   The limit is always increased (multiplied) by a factor of two.  There
is also an `I M' (`calc-less-recursion-depth') command which decreases
this limit by a factor of two, down to a minimum value of 200.  The
default value is 1000.

   These commands also double or halve `max-specpdl-size', another
internal Lisp recursion limit.  The minimum value for this limit is 600.


File: calc,  Node: Caches,  Next: Debugging Calc,  Prev: Recursion Depth,  Up: Troubleshooting Commands

5.11.3 Caches
-------------

Calc saves certain values after they have been computed once.  For
example, the `P' (`calc-pi') command initially "knows" the constant
`pi' to about 20 decimal places; if the current precision is greater
than this, it will recompute `pi' using a series approximation.  This
value will not need to be recomputed ever again unless you raise the
precision still further.  Many operations such as logarithms and sines
make use of similarly cached values such as `pi/4' and `ln(2)'.  The
visible effect of caching is that high-precision computations may seem
to do extra work the first time.  Other things cached include powers of
two (for the binary arithmetic functions), matrix inverses and
determinants, symbolic integrals, and data points computed by the
graphing commands.

   If you suspect a Calculator cache has become corrupt, you can use the
`calc-flush-caches' command to reset all caches to the empty state.
(This should only be necessary in the event of bugs in the Calculator.)
The `C-x * 0' (with the zero key) command also resets caches along with
all other aspects of the Calculator's state.


File: calc,  Node: Debugging Calc,  Prev: Caches,  Up: Troubleshooting Commands

5.11.4 Debugging Calc
---------------------

A few commands exist to help in the debugging of Calc commands.  *Note
Programming::, to see the various ways that you can write your own Calc
commands.

   The `Z T' (`calc-timing') command turns on and off a mode in which
the timing of slow commands is reported in the Trail.  Any Calc command
that takes two seconds or longer writes a line to the Trail showing how
many seconds it took.  This value is accurate only to within one second.

   All steps of executing a command are included; in particular, time
taken to format the result for display in the stack and trail is
counted.  Some prompts also count time taken waiting for them to be
answered, while others do not; this depends on the exact implementation
of the command.  For best results, if you are timing a sequence that
includes prompts or multiple commands, define a keyboard macro to run
the whole sequence at once.  Calc's `X' command (*note Keyboard
Macros::) will then report the time taken to execute the whole macro.

   Another advantage of the `X' command is that while it is executing,
the stack and trail are not updated from step to step.  So if you
expect the output of your test sequence to leave a result that may take
a long time to format and you don't wish to count this formatting time,
end your sequence with a <DEL> keystroke to clear the result from the
stack.  When you run the sequence with `X', Calc will never bother to
format the large result.

   Another thing `Z T' does is to increase the Emacs variable
`gc-cons-threshold' to a much higher value (two million; the usual
default in Calc is 250,000) for the duration of each command.  This
generally prevents garbage collection during the timing of the command,
though it may cause your Emacs process to grow abnormally large.
(Garbage collection time is a major unpredictable factor in the timing
of Emacs operations.)

   Another command that is useful when debugging your own Lisp
extensions to Calc is `M-x calc-pass-errors', which disables the error
handler that changes the "`max-lisp-eval-depth' exceeded" message to
the much more friendly "Computation got stuck or ran too long."  This
handler interferes with the Emacs Lisp debugger's `debug-on-error'
mode.  Errors are reported in the handler itself rather than at the
true location of the error.  After you have executed
`calc-pass-errors', Lisp errors will be reported correctly but the
user-friendly message will be lost.


File: calc,  Node: Data Types,  Next: Stack and Trail,  Prev: Introduction,  Up: Top

6 Data Types
************

This chapter discusses the various types of objects that can be placed
on the Calculator stack, how they are displayed, and how they are
entered.  (*Note Data Type Formats::, for information on how these data
types are represented as underlying Lisp objects.)

   Integers, fractions, and floats are various ways of describing real
numbers.  HMS forms also for many purposes act as real numbers.  These
types can be combined to form complex numbers, modulo forms, error
forms, or interval forms.  (But these last four types cannot be combined
arbitrarily: error forms may not contain modulo forms, for example.)
Finally, all these types of numbers may be combined into vectors,
matrices, or algebraic formulas.

* Menu:

* Integers::                The most basic data type.
* Fractions::               This and above are called "rationals".
* Floats::                  This and above are called "reals".
* Complex Numbers::         This and above are called "numbers".
* Infinities::
* Vectors and Matrices::
* Strings::
* HMS Forms::
* Date Forms::
* Modulo Forms::
* Error Forms::
* Interval Forms::
* Incomplete Objects::
* Variables::
* Formulas::


File: calc,  Node: Integers,  Next: Fractions,  Prev: Data Types,  Up: Data Types

6.1 Integers
============

The Calculator stores integers to arbitrary precision.  Addition,
subtraction, and multiplication of integers always yields an exact
integer result.  (If the result of a division or exponentiation of
integers is not an integer, it is expressed in fractional or
floating-point form according to the current Fraction mode.  *Note
Fraction Mode::.)

   A decimal integer is represented as an optional sign followed by a
sequence of digits.  Grouping (*note Grouping Digits::) can be used to
insert a comma at every third digit for display purposes, but you must
not type commas during the entry of numbers.

   A non-decimal integer is represented as an optional sign, a radix
between 2 and 36, a `#' symbol, and one or more digits.  For radix 11
and above, the letters A through Z (upper- or lower-case) count as
digits and do not terminate numeric entry mode.  *Note Radix Modes::,
for how to set the default radix for display of integers.  Numbers of
any radix may be entered at any time.  If you press `#' at the
beginning of a number, the current display radix is used.


File: calc,  Node: Fractions,  Next: Floats,  Prev: Integers,  Up: Data Types

6.2 Fractions
=============

A "fraction" is a ratio of two integers.  Fractions are traditionally
written "2/3" but Calc uses the notation `2:3'.  (The `/' key performs
RPN division; the following two sequences push the number `2:3' on the
stack:  `2 : 3 <RET>', or `2 <RET> 3 /' assuming Fraction mode has been
enabled.)  When the Calculator produces a fractional result it always
reduces it to simplest form, which may in fact be an integer.

   Fractions may also be entered in a three-part form, where `2:3:4'
represents two-and-three-quarters.  *Note Fraction Formats::, for
fraction display formats.

   Non-decimal fractions are entered and displayed as `RADIX#NUM:DENOM'
(or in the analogous three-part form).  The numerator and denominator
always use the same radix.


File: calc,  Node: Floats,  Next: Complex Numbers,  Prev: Fractions,  Up: Data Types

6.3 Floats
==========

A floating-point number or "float" is a number stored in scientific
notation.  The number of significant digits in the fractional part is
governed by the current floating precision (*note Precision::).  The
range of acceptable values is from `10^-3999999' (inclusive) to
`10^4000000' (exclusive), plus the corresponding negative values and
zero.

   Calculations that would exceed the allowable range of values (such
as `exp(exp(20))') are left in symbolic form by Calc.  The messages
"floating-point overflow" or "floating-point underflow" indicate that
during the calculation a number would have been produced that was too
large or too close to zero, respectively, to be represented by Calc.
This does not necessarily mean the final result would have overflowed,
just that an overflow occurred while computing the result.  (In fact,
it could report an underflow even though the final result would have
overflowed!)

   If a rational number and a float are mixed in a calculation, the
result will in general be expressed as a float.  Commands that require
an integer value (such as `k g' [`gcd']) will also accept integer-valued
floats, i.e., floating-point numbers with nothing after the decimal
point.

   Floats are identified by the presence of a decimal point and/or an
exponent.  In general a float consists of an optional sign, digits
including an optional decimal point, and an optional exponent consisting
of an `e', an optional sign, and up to seven exponent digits.  For
example, `23.5e-2' is 23.5 times ten to the minus-second power, or
0.235.

   Floating-point numbers are normally displayed in decimal notation
with all significant figures shown.  Exceedingly large or small numbers
are displayed in scientific notation.  Various other display options are
available.  *Note Float Formats::.

   Floating-point numbers are stored in decimal, not binary.  The result
of each operation is rounded to the nearest value representable in the
number of significant digits specified by the current precision,
rounding away from zero in the case of a tie.  Thus (in the default
display mode) what you see is exactly what you get.  Some operations
such as square roots and transcendental functions are performed with
several digits of extra precision and then rounded down, in an effort
to make the final result accurate to the full requested precision.
However, accuracy is not rigorously guaranteed.  If you suspect the
validity of a result, try doing the same calculation in a higher
precision.  The Calculator's arithmetic is not intended to be
IEEE-conformant in any way.

   While floats are always _stored_ in decimal, they can be entered and
displayed in any radix just like integers and fractions.  Since a float
that is entered in a radix other that 10 will be converted to decimal,
the number that Calc stores may not be exactly the number that was
entered, it will be the closest decimal approximation given the current
precision.  The notation `RADIX#DDD.DDD' is a floating-point number
whose digits are in the specified radix.  Note that the `.'  is more
aptly referred to as a "radix point" than as a decimal point in this
case.  The number `8#123.4567' is defined as `8#1234567 * 8^-4'.  If
the radix is 14 or less, you can use `e' notation to write a
non-decimal number in scientific notation.  The exponent is written in
decimal, and is considered to be a power of the radix: `8#1234567e-4'.
If the radix is 15 or above, the letter `e' is a digit, so scientific
notation must be written out, e.g., `16#123.4567*16^2'.  The first two
exercises of the Modes Tutorial explore some of the properties of
non-decimal floats.


File: calc,  Node: Complex Numbers,  Next: Infinities,  Prev: Floats,  Up: Data Types

6.4 Complex Numbers
===================

There are two supported formats for complex numbers: rectangular and
polar.  The default format is rectangular, displayed in the form
`(REAL,IMAG)' where REAL is the real part and IMAG is the imaginary
part, each of which may be any real number.  Rectangular complex
numbers can also be displayed in `A+Bi' notation; *note Complex
Formats::.

   Polar complex numbers are displayed in the form `(R;THETA)' where R
is the nonnegative magnitude and THETA is the argument or phase angle.
The range of THETA depends on the current angular mode (*note Angular
Modes::); it is generally between -180 and +180 degrees or the
equivalent range in radians.

   Complex numbers are entered in stages using incomplete objects.
*Note Incomplete Objects::.

   Operations on rectangular complex numbers yield rectangular complex
results, and similarly for polar complex numbers.  Where the two types
are mixed, or where new complex numbers arise (as for the square root of
a negative real), the current "Polar mode" is used to determine the
type.  *Note Polar Mode::.

   A complex result in which the imaginary part is zero (or the phase
angle is 0 or 180 degrees or `pi' radians) is automatically converted
to a real number.


File: calc,  Node: Infinities,  Next: Vectors and Matrices,  Prev: Complex Numbers,  Up: Data Types

6.5 Infinities
==============

The word `inf' represents the mathematical concept of "infinity".  Calc
actually has three slightly different infinity-like values: `inf',
`uinf', and `nan'.  These are just regular variable names (*note
Variables::); you should avoid using these names for your own variables
because Calc gives them special treatment.  Infinities, like all
variable names, are normally entered using algebraic entry.

   Mathematically speaking, it is not rigorously correct to treat
"infinity" as if it were a number, but mathematicians often do so
informally.  When they say that `1 / inf = 0', what they really mean is
that `1 / x', as `x' becomes larger and larger, becomes arbitrarily
close to zero.  So you can imagine that if `x' got "all the way to
infinity," then `1 / x' would go all the way to zero.  Similarly, when
they say that `exp(inf) = inf', they mean that `exp(x)' grows without
bound as `x' grows.  The symbol `-inf' likewise stands for an
infinitely negative real value; for example, we say that `exp(-inf) =
0'.  You can have an infinity pointing in any direction on the complex
plane:  `sqrt(-inf) = i inf'.

   The same concept of limits can be used to define `1 / 0'.  We really
want the value that `1 / x' approaches as `x' approaches zero.  But if
all we have is `1 / 0', we can't tell which direction `x' was coming
from.  If `x' was positive and decreasing toward zero, then we should
say that `1 / 0 = inf'.  But if `x' was negative and increasing toward
zero, the answer is `1 / 0 = -inf'.  In fact, `x' could be an imaginary
number, giving the answer `i inf' or `-i inf'.  Calc uses the special
symbol `uinf' to mean "undirected infinity", i.e., a value which is
infinitely large but with an unknown sign (or direction on the complex
plane).

   Calc actually has three modes that say how infinities are handled.
Normally, infinities never arise from calculations that didn't already
have them.  Thus, `1 / 0' is treated simply as an error and left
unevaluated.  The `m i' (`calc-infinite-mode') command (*note Infinite
Mode::) enables a mode in which `1 / 0' evaluates to `uinf' instead.
There is also an alternative type of infinite mode which says to treat
zeros as if they were positive, so that `1 / 0 = inf'.  While this is
less mathematically correct, it may be the answer you want in some
cases.

   Since all infinities are "as large" as all others, Calc simplifies,
e.g., `5 inf' to `inf'.  Another example is `5 - inf = -inf', where the
`-inf' is so large that adding a finite number like five to it does not
affect it.  Note that `a - inf' also results in `-inf'; Calc assumes
that variables like `a' always stand for finite quantities.  Just to
show that infinities really are all the same size, note that `sqrt(inf)
= inf^2 = exp(inf) = inf' in Calc's notation.

   It's not so easy to define certain formulas like `0 * inf' and `inf
/ inf'.  Depending on where these zeros and infinities came from, the
answer could be literally anything.  The latter formula could be the
limit of `x / x' (giving a result of one), or `2 x / x' (giving two),
or `x^2 / x' (giving `inf'), or `x / x^2' (giving zero).  Calc uses the
symbol `nan' to represent such an "indeterminate" value.  (The name
"nan" comes from analogy with the "NAN" concept of IEEE standard
arithmetic; it stands for "Not A Number."  This is somewhat of a
misnomer, since `nan' _does_ stand for some number or infinity, it's
just that _which_ number it stands for cannot be determined.)  In
Calc's notation, `0 * inf = nan' and `inf / inf = nan'.  A few other
common indeterminate expressions are `inf - inf' and `inf ^ 0'.  Also,
`0 / 0 = nan' if you have turned on Infinite mode (as described above).

   Infinities are especially useful as parts of "intervals".  *Note
Interval Forms::.


File: calc,  Node: Vectors and Matrices,  Next: Strings,  Prev: Infinities,  Up: Data Types

6.6 Vectors and Matrices
========================

The "vector" data type is flexible and general.  A vector is simply a
list of zero or more data objects.  When these objects are numbers, the
whole is a vector in the mathematical sense.  When these objects are
themselves vectors of equal (nonzero) length, the whole is a "matrix".
A vector which is not a matrix is referred to here as a "plain vector".

   A vector is displayed as a list of values separated by commas and
enclosed in square brackets:  `[1, 2, 3]'.  Thus the following is a 2
row by 3 column matrix:  `[[1, 2, 3], [4, 5, 6]]'.  Vectors, like
complex numbers, are entered as incomplete objects.  *Note Incomplete
Objects::.  During algebraic entry, vectors are entered all at once in
the usual brackets-and-commas form.  Matrices may be entered
algebraically as nested vectors, or using the shortcut notation
`[1, 2, 3; 4, 5, 6]', with rows separated by semicolons.  The commas
may usually be omitted when entering vectors:  `[1 2 3]'.  Curly braces
may be used in place of brackets: `{1, 2, 3}', but the commas are
required in this case.

   Traditional vector and matrix arithmetic is also supported; *note
Basic Arithmetic:: and *note Matrix Functions::.  Many other operations
are applied to vectors element-wise.  For example, the complex
conjugate of a vector is a vector of the complex conjugates of its
elements.

   Algebraic functions for building vectors include `vec(a, b, c)' to
build `[a, b, c]', `cvec(a, n, m)' to build an NxM matrix of `a's, and
`index(n)' to build a vector of integers from 1 to `n'.


File: calc,  Node: Strings,  Next: HMS Forms,  Prev: Vectors and Matrices,  Up: Data Types

6.7 Strings
===========

Character strings are not a special data type in the Calculator.
Rather, a string is represented simply as a vector all of whose
elements are integers in the range 0 to 255 (ASCII codes).  You can
enter a string at any time by pressing the `"' key.  Quotation marks
and backslashes are written `\"' and `\\', respectively, inside
strings.  Other notations introduced by backslashes are:

     \a     7          \^@    0
     \b     8          \^a-z  1-26
     \e     27         \^[    27
     \f     12         \^\\   28
     \n     10         \^]    29
     \r     13         \^^    30
     \t     9          \^_    31
                       \^?    127

Finally, a backslash followed by three octal digits produces any
character from its ASCII code.

   Strings are normally displayed in vector-of-integers form.  The
`d "' (`calc-display-strings') command toggles a mode in which any
vectors of small integers are displayed as quoted strings instead.

   The backslash notations shown above are also used for displaying
strings.  Characters 128 and above are not translated by Calc; unless
you have an Emacs modified for 8-bit fonts, these will show up in
backslash-octal-digits notation.  For characters below 32, and for
character 127, Calc uses the backslash-letter combination if there is
one, or otherwise uses a `\^' sequence.

   The only Calc feature that uses strings is "compositions"; *note
Compositions::.  Strings also provide a convenient way to do
conversions between ASCII characters and integers.

   There is a `string' function which provides a different display
format for strings.  Basically, `string(S)', where S is a vector of
integers in the proper range, is displayed as the corresponding string
of characters with no surrounding quotation marks or other
modifications.  Thus `string("ABC")' (or `string([65 66 67])') will
look like `ABC' on the stack.  This happens regardless of whether `d "'
has been used.  The only way to turn it off is to use `d U'
(unformatted language mode) which will display `string("ABC")' instead.

   Control characters are displayed somewhat differently by `string'.
Characters below 32, and character 127, are shown using `^' notation
(same as shown above, but without the backslash).  The quote and
backslash characters are left alone, as are characters 128 and above.

   The `bstring' function is just like `string' except that the
resulting string is breakable across multiple lines if it doesn't fit
all on one line.  Potential break points occur at every space character
in the string.


File: calc,  Node: HMS Forms,  Next: Date Forms,  Prev: Strings,  Up: Data Types

6.8 HMS Forms
=============

"HMS" stands for Hours-Minutes-Seconds; when used as an angular
argument, the interpretation is Degrees-Minutes-Seconds.  All functions
that operate on angles accept HMS forms.  These are interpreted as
degrees regardless of the current angular mode.  It is also possible to
use HMS as the angular mode so that calculated angles are expressed in
degrees, minutes, and seconds.

   The default format for HMS values is `HOURS@ MINS' SECS"'.  During
entry, the letters `h' (for "hours") or `o' (approximating the
"degrees" symbol) are accepted as well as `@', `m' is accepted in place
of `'', and `s' is accepted in place of `"'.  The HOURS value is an
integer (or integer-valued float).  The MINS value is an integer or
integer-valued float between 0 and 59.  The SECS value is a real number
between 0 (inclusive) and 60 (exclusive).  A positive HMS form is
interpreted as HOURS + MINS/60 + SECS/3600.  A negative HMS form is
interpreted as - HOURS - MINS/60 - SECS/3600.  Display format for HMS
forms is quite flexible.  *Note HMS Formats::.

   HMS forms can be added and subtracted.  When they are added to
numbers, the numbers are interpreted according to the current angular
mode.  HMS forms can also be multiplied and divided by real numbers.
Dividing two HMS forms produces a real-valued ratio of the two angles.

   Just for kicks, `M-x calc-time' pushes the current time of day on
the stack as an HMS form.


File: calc,  Node: Date Forms,  Next: Modulo Forms,  Prev: HMS Forms,  Up: Data Types

6.9 Date Forms
==============

A "date form" represents a date and possibly an associated time.
Simple date arithmetic is supported:  Adding a number to a date
produces a new date shifted by that many days; adding an HMS form to a
date shifts it by that many hours.  Subtracting two date forms computes
the number of days between them (represented as a simple number).  Many
other operations, such as multiplying two date forms, are nonsensical
and are not allowed by Calc.

   Date forms are entered and displayed enclosed in `< >' brackets.
The default format is, e.g., `<Wed Jan 9, 1991>' for dates, or
`<3:32:20pm Wed Jan 9, 1991>' for dates with times.  Input is flexible;
date forms can be entered in any of the usual notations for dates and
times.  *Note Date Formats::.

   Date forms are stored internally as numbers, specifically the number
of days since midnight on the morning of January 1 of the year 1 AD.
If the internal number is an integer, the form represents a date only;
if the internal number is a fraction or float, the form represents a
date and time.  For example, `<6:00am Wed Jan 9, 1991>' is represented
by the number 726842.25.  The standard precision of 12 decimal digits
is enough to ensure that a (reasonable) date and time can be stored
without roundoff error.

   If the current precision is greater than 12, date forms will keep
additional digits in the seconds position.  For example, if the
precision is 15, the seconds will keep three digits after the decimal
point.  Decreasing the precision below 12 may cause the time part of a
date form to become inaccurate.  This can also happen if astronomically
high years are used, though this will not be an issue in everyday (or
even everymillennium) use.  Note that date forms without times are
stored as exact integers, so roundoff is never an issue for them.

   You can use the `v p' (`calc-pack') and `v u' (`calc-unpack')
commands to get at the numerical representation of a date form.  *Note
Packing and Unpacking::.

   Date forms can go arbitrarily far into the future or past.  Negative
year numbers represent years BC.  Calc uses a combination of the
Gregorian and Julian calendars, following the history of Great Britain
and the British colonies.  This is the same calendar that is used by
the `cal' program in most Unix implementations.

   Some historical background:  The Julian calendar was created by
Julius Caesar in the year 46 BC as an attempt to fix the gradual drift
caused by the lack of leap years in the calendar used until that time.
The Julian calendar introduced an extra day in all years divisible by
four.  After some initial confusion, the calendar was adopted around
the year we call 8 AD.  Some centuries later it became apparent that
the Julian year of 365.25 days was itself not quite right.  In 1582
Pope Gregory XIII introduced the Gregorian calendar, which added the
new rule that years divisible by 100, but not by 400, were not to be
considered leap years despite being divisible by four.  Many countries
delayed adoption of the Gregorian calendar because of religious
differences; in Britain it was put off until the year 1752, by which
time the Julian calendar had fallen eleven days behind the true
seasons.  So the switch to the Gregorian calendar in early September
1752 introduced a discontinuity:  The day after Sep 2, 1752 is Sep 14,
1752.  Calc follows this convention.  To take another example, Russia
waited until 1918 before adopting the new calendar, and thus needed to
remove thirteen days (between Feb 1, 1918 and Feb 14, 1918).  This
means that Calc's reckoning will be inconsistent with Russian history
between 1752 and 1918, and similarly for various other countries.

   Today's timekeepers introduce an occasional "leap second" as well,
but Calc does not take these minor effects into account.  (If it did,
it would have to report a non-integer number of days between, say,
`<12:00am Mon Jan 1, 1900>' and `<12:00am Sat Jan 1, 2000>'.)

   Calc uses the Julian calendar for all dates before the year 1752,
including dates BC when the Julian calendar technically had not yet
been invented.  Thus the claim that day number -10000 is called "August
16, 28 BC" should be taken with a grain of salt.

   Please note that there is no "year 0"; the day before `<Sat Jan 1,
+1>' is `<Fri Dec 31, -1>'.  These are days 0 and -1 respectively in
Calc's internal numbering scheme.

   Another day counting system in common use is, confusingly, also
called "Julian."  The Julian day number is the numbers of days since
12:00 noon (GMT) on Jan 1, 4713 BC, which in Calc's scheme (in GMT) is
-1721423.5 (recall that Calc starts at midnight instead of noon).  Thus
to convert a Calc date code obtained by unpacking a date form into a
Julian day number, simply add 1721423.5 after compensating for the time
zone difference.  The built-in `t J' command performs this conversion
for you.

   The Julian day number is based on the Julian cycle, which was
invented in 1583 by Joseph Justus Scaliger.  Scaliger named it the
Julian cycle since it involves the Julian calendar, but some have
suggested that Scaliger named it in honor of his father, Julius Caesar
Scaliger.  The Julian cycle is based on three other cycles: the
indiction cycle, the Metonic cycle, and the solar cycle.  The indiction
cycle is a 15 year cycle originally used by the Romans for tax purposes
but later used to date medieval documents.  The Metonic cycle is a 19
year cycle; 19 years is close to being a common multiple of a solar
year and a lunar month, and so every 19 years the phases of the moon
will occur on the same days of the year.  The solar cycle is a 28 year
cycle; the Julian calendar repeats itself every 28 years.  The smallest
time period which contains multiples of all three cycles is the least
common multiple of 15 years, 19 years and 28 years, which (since they're
pairwise relatively prime) is 15*19*28 = 7980 years.  This is the
length of a Julian cycle.  Working backwards, the previous year in
which all three cycles began was 4713 BC, and so Scaliger chose that
year as the beginning of a Julian cycle.  Since at the time there were
no historical records from before 4713 BC, using this year as a
starting point had the advantage of avoiding negative year numbers.  In
1849, the astronomer John Herschel (son of William Herschel) suggested
using the number of days since the beginning of the Julian cycle as an
astronomical dating system; this idea was taken up by other
astronomers.  (At the time, noon was the start of the astronomical day.
Herschel originally suggested counting the days since Jan 1, 4713 BC at
noon Alexandria time; this was later amended to noon GMT.)  Julian day
numbering is largely used in astronomy.

   The Unix operating system measures time as an integer number of
seconds since midnight, Jan 1, 1970.  To convert a Calc date value into
a Unix time stamp, first subtract 719164 (the code for `<Jan 1,
1970>'), then multiply by 86400 (the number of seconds in a day) and
press `R' to round to the nearest integer.  If you have a date form,
you can simply subtract the day `<Jan 1, 1970>' instead of unpacking
and subtracting 719164.  Likewise, divide by 86400 and add `<Jan 1,
1970>' to convert from Unix time to a Calc date form.  (Note that Unix
normally maintains the time in the GMT time zone; you may need to
subtract five hours to get New York time, or eight hours for California
time.  The same is usually true of Julian day counts.)  The built-in `t
U' command performs these conversions.


File: calc,  Node: Modulo Forms,  Next: Error Forms,  Prev: Date Forms,  Up: Data Types

6.10 Modulo Forms
=================

A "modulo form" is a real number which is taken modulo (i.e., within an
integer multiple of) some value M.  Arithmetic modulo M often arises in
number theory.  Modulo forms are written `A mod M', where A and M are
real numbers or HMS forms, and `0 <= a < M'.  In many applications `a'
and `M' will be integers but this is not required.

   To create a modulo form during numeric entry, press the shift-`M'
key to enter the word `mod'.  As a special convenience, pressing
shift-`M' a second time automatically enters the value of `M' that was
most recently used before.  During algebraic entry, either type `mod'
by hand or press `M-m' (that's `<META>-m').  Once again, pressing this
a second time enters the current modulo.

   Modulo forms are not to be confused with the modulo operator `%'.
The expression `27 % 10' means to compute 27 modulo 10 to produce the
result 7.  Further computations treat this 7 as just a regular integer.
The expression `27 mod 10' produces the result `7 mod 10'; further
computations with this value are again reduced modulo 10 so that the
result always lies in the desired range.

   When two modulo forms with identical `M''s are added or multiplied,
the Calculator simply adds or multiplies the values, then reduces modulo
`M'.  If one argument is a modulo form and the other a plain number,
the plain number is treated like a compatible modulo form.  It is also
possible to raise modulo forms to powers; the result is the value raised
to the power, then reduced modulo `M'.  (When all values involved are
integers, this calculation is done much more efficiently than actually
computing the power and then reducing.)

   Two modulo forms `A mod M' and `B mod M' can be divided if `a', `b',
and `M' are all integers.  The result is the modulo form which, when
multiplied by `B mod M', produces `A mod M'.  If there is no solution
to this equation (which can happen only when `M' is non-prime), or if
any of the arguments are non-integers, the division is left in symbolic
form.  Other operations, such as square roots, are not yet supported
for modulo forms.  (Note that, although `(A mod M)^.5' will compute a
"modulo square root" in the sense of reducing `sqrt(a)' modulo `M',
this is not a useful definition from the number-theoretical point of
view.)

   It is possible to mix HMS forms and modulo forms.  For example, an
HMS form modulo 24 could be used to manipulate clock times; an HMS form
modulo 360 would be suitable for angles.  Making the modulo `M' also be
an HMS form eliminates troubles that would arise if the angular mode
were inadvertently set to Radians, in which case `2@ 0' 0" mod 24'
would be interpreted as two degrees modulo 24 radians!

   Modulo forms cannot have variables or formulas for components.  If
you enter the formula `(x + 2) mod 5', Calc propagates the modulus to
each of the coefficients:  `(1 mod 5) x + (2 mod 5)'.

   You can use `v p' and `%' to modify modulo forms.  *Note Packing and
Unpacking::.  *Note Basic Arithmetic::.

   The algebraic function `makemod(a, m)' builds the modulo form
`a mod m'.


File: calc,  Node: Error Forms,  Next: Interval Forms,  Prev: Modulo Forms,  Up: Data Types

6.11 Error Forms
================

An "error form" is a number with an associated standard deviation, as
in `2.3 +/- 0.12'.  The notation `X +/- sigma' stands for an uncertain
value which follows a normal or Gaussian distribution of mean `x' and
standard deviation or "error" `sigma'.  Both the mean and the error can
be either numbers or formulas.  Generally these are real numbers but
the mean may also be complex.  If the error is negative or complex, it
is changed to its absolute value.  An error form with zero error is
converted to a regular number by the Calculator.

   All arithmetic and transcendental functions accept error forms as
input.  Operations on the mean-value part work just like operations on
regular numbers.  The error part for any function `f(x)' (such as
`sin(x)') is defined by the error of `x' times the derivative of `f'
evaluated at the mean value of `x'.  For a two-argument function
`f(x,y)' (such as addition) the error is the square root of the sum of
the squares of the errors due to `x' and `y'.  Note that this
definition assumes the errors in `x' and `y' are uncorrelated.  A side
effect of this definition is that `(2 +/- 1) * (2 +/- 1)' is not the
same as `(2 +/- 1)^2'; the former represents the product of two
independent values which happen to have the same probability
distributions, and the latter is the product of one random value with
itself.  The former will produce an answer with less error, since on
the average the two independent errors can be expected to cancel out.

   Consult a good text on error analysis for a discussion of the proper
use of standard deviations.  Actual errors often are neither
Gaussian-distributed nor uncorrelated, and the above formulas are valid
only when errors are small.  As an example, the error arising from
`sin(X +/- SIGMA)' is `SIGMA abs(cos(X))'.  When `x' is close to zero,
`cos(x)' is close to one so the error in the sine is close to `sigma';
this makes sense, since `sin(x)' is approximately `x' near zero, so a
given error in `x' will produce about the same error in the sine.
Likewise, near 90 degrees `cos(x)' is nearly zero and so the computed
error is small:  The sine curve is nearly flat in that region, so an
error in `x' has relatively little effect on the value of `sin(x)'.
However, consider `sin(90 +/- 1000)'.  The cosine of 90 is zero, so
Calc will report zero error!  We get an obviously wrong result because
we have violated the small-error approximation underlying the error
analysis.  If the error in `x' had been small, the error in `sin(x)'
would indeed have been negligible.

   To enter an error form during regular numeric entry, use the `p'
("plus-or-minus") key to type the `+/-' symbol.  (If you try actually
typing `+/-' the `+' key will be interpreted as the Calculator's `+'
command!)  Within an algebraic formula, you can press `M-+' to type the
`+/-' symbol, or type it out by hand.

   Error forms and complex numbers can be mixed; the formulas shown
above are used for complex numbers, too; note that if the error part
evaluates to a complex number its absolute value (or the square root of
the sum of the squares of the absolute values of the two error
contributions) is used.  Mathematically, this corresponds to a radially
symmetric Gaussian distribution of numbers on the complex plane.
However, note that Calc considers an error form with real components to
represent a real number, not a complex distribution around a real mean.

   Error forms may also be composed of HMS forms.  For best results,
both the mean and the error should be HMS forms if either one is.

   The algebraic function `sdev(a, b)' builds the error form `a +/- b'.


File: calc,  Node: Interval Forms,  Next: Incomplete Objects,  Prev: Error Forms,  Up: Data Types

6.12 Interval Forms
===================

An "interval" is a subset of consecutive real numbers.  For example,
the interval `[2 .. 4]' represents all the numbers from 2 to 4,
inclusive.  If you multiply it by the interval `[0.5 .. 2]' you obtain
`[1 .. 8]'.  This calculation represents the fact that if you multiply
some number in the range `[2 .. 4]' by some other number in the range
`[0.5 .. 2]', your result will lie in the range from 1 to 8.  Interval
arithmetic is used to get a worst-case estimate of the possible range
of values a computation will produce, given the set of possible values
of the input.

   Calc supports several varieties of intervals, including "closed"
intervals of the type shown above, "open" intervals such as `(2 .. 4)',
which represents the range of numbers from 2 to 4 _exclusive_, and
"semi-open" intervals in which one end uses a round parenthesis and the
other a square bracket.  In mathematical terms, `[2 .. 4]' means `2 <=
x <= 4', whereas `[2 .. 4)' represents `2 <= x < 4', `(2 .. 4]'
represents `2 < x <= 4', and `(2 .. 4)' represents `2 < x < 4'.

   The lower and upper limits of an interval must be either real numbers
(or HMS or date forms), or symbolic expressions which are assumed to be
real-valued, or `-inf' and `inf'.  In general the lower limit must be
less than the upper limit.  A closed interval containing only one
value, `[3 .. 3]', is converted to a plain number (3) automatically.
An interval containing no values at all (such as `[3 .. 2]' or `[2 ..
2)') can be represented but is not guaranteed to behave well when used
in arithmetic.  Note that the interval `[3 .. inf)' represents all real
numbers greater than or equal to 3, and `(-inf .. inf)' represents all
real numbers.  In fact, `[-inf .. inf]' represents all real numbers
including the real infinities.

   Intervals are entered in the notation shown here, either as algebraic
formulas, or using incomplete forms.  (*Note Incomplete Objects::.)  In
algebraic formulas, multiple periods in a row are collected from left
to right, so that `1...1e2' is interpreted as `1.0 .. 1e2' rather than
`1 .. 0.1e2'.  Add spaces or zeros if you want to get the other
interpretation.  If you omit the lower or upper limit, a default of
`-inf' or `inf' (respectively) is furnished.

   Infinite mode also affects operations on intervals (*note
Infinities::).  Calc will always introduce an open infinity, as in `1 /
(0 .. 2] = [0.5 .. inf)'.  But closed infinities,
`1 / [0 .. 2] = [0.5 .. inf]', arise only in Infinite mode; otherwise
they are left unevaluated.  Note that the "direction" of a zero is not
an issue in this case since the zero is always assumed to be continuous
with the rest of the interval.  For intervals that contain zero inside
them Calc is forced to give the result, `1 / (-2 .. 2) = [-inf .. inf]'.

   While it may seem that intervals and error forms are similar, they
are based on entirely different concepts of inexact quantities.  An
error form `X +/- SIGMA' means a variable is random, and its value could
be anything but is "probably" within one SIGMA of the mean value `x'.
An interval `[A .. B]' means a variable's value is unknown, but
guaranteed to lie in the specified range.  Error forms are statistical
or "average case" approximations; interval arithmetic tends to produce
"worst case" bounds on an answer.

   Intervals may not contain complex numbers, but they may contain HMS
forms or date forms.

   *Note Set Operations::, for commands that interpret interval forms
as subsets of the set of real numbers.

   The algebraic function `intv(n, a, b)' builds an interval form from
`a' to `b'; `n' is an integer code which must be 0 for `(..)', 1 for
`(..]', 2 for `[..)', or 3 for `[..]'.

   Please note that in fully rigorous interval arithmetic, care would be
taken to make sure that the computation of the lower bound rounds toward
minus infinity, while upper bound computations round toward plus
infinity.  Calc's arithmetic always uses a round-to-nearest mode, which
means that roundoff errors could creep into an interval calculation to
produce intervals slightly smaller than they ought to be.  For example,
entering `[1..2]' and pressing `Q 2 ^' should yield the interval
`[1..2]' again, but in fact it yields the (slightly too small) interval
`[1..1.9999999]' due to roundoff error.


File: calc,  Node: Incomplete Objects,  Next: Variables,  Prev: Interval Forms,  Up: Data Types

6.13 Incomplete Objects
=======================

When `(' or `[' is typed to begin entering a complex number or vector,
respectively, the effect is to push an "incomplete" complex number or
vector onto the stack.  The `,' key adds the value(s) at the top of the
stack onto the current incomplete object.  The `)' and `]' keys "close"
the incomplete object after adding any values on the top of the stack
in front of the incomplete object.

   As a result, the sequence of keystrokes `[ 2 , 3 <RET> 2 * , 9 ]'
pushes the vector `[2, 6, 9]' onto the stack.  Likewise, `( 1 , 2 Q )'
pushes the complex number `(1, 1.414)' (approximately).

   If several values lie on the stack in front of the incomplete object,
all are collected and appended to the object.  Thus the `,' key is
redundant:  `[ 2 <RET> 3 <RET> 2 * 9 ]'.  Some people prefer the
equivalent <SPC> key to <RET>.

   As a special case, typing `,' immediately after `(', `[', or `,'
adds a zero or duplicates the preceding value in the list being formed.
Typing <DEL> during incomplete entry removes the last item from the
list.

   The `;' key is used in the same way as `,' to create polar complex
numbers:  `( 1 ; 2 )'.  When entering a vector, `;' is useful for
creating a matrix.  In particular, `[ [ 1 , 2 ; 3 , 4 ; 5 , 6 ] ]' is
equivalent to `[ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ]'.

   Incomplete entry is also used to enter intervals.  For example, `[ 2
.. 4 )' enters a semi-open interval.  Note that when you type the first
period, it will be interpreted as a decimal point, but when you type a
second period immediately afterward, it is re-interpreted as part of
the interval symbol.  Typing `..' corresponds to executing the
`calc-dots' command.

   If you find incomplete entry distracting, you may wish to enter
vectors and complex numbers as algebraic formulas by pressing the
apostrophe key.


File: calc,  Node: Variables,  Next: Formulas,  Prev: Incomplete Objects,  Up: Data Types

6.14 Variables
==============

A "variable" is somewhere between a storage register on a conventional
calculator, and a variable in a programming language.  (In fact, a Calc
variable is really just an Emacs Lisp variable that contains a Calc
number or formula.)  A variable's name is normally composed of letters
and digits.  Calc also allows apostrophes and `#' signs in variable
names.  (The Calc variable `foo' corresponds to the Emacs Lisp variable
`var-foo', but unless you access the variable from within Emacs Lisp,
you don't need to worry about it.  Variable names in algebraic formulas
implicitly have `var-' prefixed to their names.  The `#' character in
variable names used in algebraic formulas corresponds to a dash `-' in
the Lisp variable name.  If the name contains any dashes, the prefix
`var-' is _not_ automatically added.  Thus the two formulas `foo + 1'
and `var#foo + 1' both refer to the same variable.)

   In a command that takes a variable name, you can either type the full
name of a variable, or type a single digit to use one of the special
convenience variables `q0' through `q9'.  For example, `3 s s 2' stores
the number 3 in variable `q2', and `3 s s foo <RET>' stores that number
in variable `foo'.

   To push a variable itself (as opposed to the variable's value) on the
stack, enter its name as an algebraic expression using the apostrophe
(<'>) key.

   The `=' (`calc-evaluate') key "evaluates" a formula by replacing all
variables in the formula which have been given values by a `calc-store'
or `calc-let' command by their stored values.  Other variables are left
alone.  Thus a variable that has not been stored acts like an abstract
variable in algebra; a variable that has been stored acts more like a
register in a traditional calculator.  With a positive numeric prefix
argument, `=' evaluates the top N stack entries; with a negative
argument, `=' evaluates the Nth stack entry.

   A few variables are called "special constants".  Their names are
`e', `pi', `i', `phi', and `gamma'.  (*Note Scientific Functions::.)
When they are evaluated with `=', their values are calculated if
necessary according to the current precision or complex polar mode.  If
you wish to use these symbols for other purposes, simply undefine or
redefine them using `calc-store'.

   The variables `inf', `uinf', and `nan' stand for infinite or
indeterminate values.  It's best not to use them as regular variables,
since Calc uses special algebraic rules when it manipulates them.  Calc
displays a warning message if you store a value into any of these
special variables.

   *Note Store and Recall::, for a discussion of commands dealing with
variables.


File: calc,  Node: Formulas,  Prev: Variables,  Up: Data Types

6.15 Formulas
=============

When you press the apostrophe key you may enter any expression or
formula in algebraic form.  (Calc uses the terms "expression" and
"formula" interchangeably.)  An expression is built up of numbers,
variable names, and function calls, combined with various arithmetic
operators.  Parentheses may be used to indicate grouping.  Spaces are
ignored within formulas, except that spaces are not permitted within
variable names or numbers.  Arithmetic operators, in order from highest
to lowest precedence, and with their equivalent function names, are:

   `_' [`subscr'] (subscripts);

   postfix `%' [`percent'] (as in `25% = 0.25');

   prefix `!' [`lnot'] (logical "not," as in `!x');

   `+/-' [`sdev'] (the standard deviation symbol) and `mod' [`makemod']
(the symbol for modulo forms);

   postfix `!' [`fact'] (factorial, as in `n!') and postfix `!!'
[`dfact'] (double factorial);

   `^' [`pow'] (raised-to-the-power-of);

   prefix `+' and `-' [`neg'] (as in `-x');

   `*' [`mul'];

   `/' [`div'], `%' [`mod'] (modulo), and `\' [`idiv'] (integer
division);

   infix `+' [`add'] and `-' [`sub'] (as in `x-y');

   `|' [`vconcat'] (vector concatenation);

   relations `=' [`eq'], `!=' [`neq'], `<' [`lt'], `>' [`gt'], `<='
[`leq'], and `>=' [`geq'];

   `&&' [`land'] (logical "and");

   `||' [`lor'] (logical "or");

   the C-style "if" operator `a?b:c' [`if'];

   `!!!' [`pnot'] (rewrite pattern "not");

   `&&&' [`pand'] (rewrite pattern "and");

   `|||' [`por'] (rewrite pattern "or");

   `:=' [`assign'] (for assignments and rewrite rules);

   `::' [`condition'] (rewrite pattern condition);

   `=>' [`evalto'].

   Note that, unlike in usual computer notation, multiplication binds
more strongly than division:  `a*b/c*d' is equivalent to `(a*b)/(c*d)'.

   The multiplication sign `*' may be omitted in many cases.  In
particular, if the righthand side is a number, variable name, or
parenthesized expression, the `*' may be omitted.  Implicit
multiplication has the same precedence as the explicit `*' operator.
The one exception to the rule is that a variable name followed by a
parenthesized expression, as in `f(x)', is interpreted as a function
call, not an implicit `*'.  In many cases you must use a space if you
omit the `*':  `2a' is the same as `2*a', and `a b' is the same as
`a*b', but `ab' is a variable called `ab', _not_ the product of `a' and
`b'!  Also note that `f (x)' is still a function call.

   The rules are slightly different for vectors written with square
brackets.  In vectors, the space character is interpreted (like the
comma) as a separator of elements of the vector.  Thus `[ 2a b+c d ]' is
equivalent to `[2*a, b+c, d]', whereas `2a b+c d' is equivalent to
`2*a*b + c*d'.  Note that spaces around the brackets, and around
explicit commas, are ignored.  To force spaces to be interpreted as
multiplication you can enclose a formula in parentheses as in `[(a b)
2(c d)]', which is interpreted as `[a*b, 2*c*d]'.  An implicit comma is
also inserted between `][', as in the matrix `[[1 2][3 4]]'.

   Vectors that contain commas (not embedded within nested parentheses
or brackets) do not treat spaces specially:  `[a b, 2 c d]' is a vector
of two elements.  Also, if it would be an error to treat spaces as
separators, but not otherwise, then Calc will ignore spaces: `[a - b]'
is a vector of one element, but `[a -b]' is a vector of two elements.
Finally, vectors entered with curly braces instead of square brackets
do not give spaces any special treatment.  When Calc displays a vector
that does not contain any commas, it will insert parentheses if
necessary to make the meaning clear: `[(a b)]'.

   The expression `5%-2' is ambiguous; is this five-percent minus two,
or five modulo minus-two?  Calc always interprets the leftmost symbol as
an infix operator preferentially (modulo, in this case), so you would
need to write `(5%)-2' to get the former interpretation.

   A function call is, e.g., `sin(1+x)'.  (The Calc algebraic function
`foo' corresponds to the Emacs Lisp function `calcFunc-foo', but unless
you access the function from within Emacs Lisp, you don't need to worry
about it.)  Most mathematical Calculator commands like `calc-sin' have
function equivalents like `sin'.  If no Lisp function is defined for a
function called by a formula, the call is left as it is during
algebraic manipulation: `f(x+y)' is left alone.  Beware that many
innocent-looking short names like `in' and `re' have predefined
meanings which could surprise you; however, single letters or single
letters followed by digits are always safe to use for your own function
names.  *Note Function Index::.

   In the documentation for particular commands, the notation `H S'
(`calc-sinh') [`sinh'] means that the key sequence `H S', the command
`M-x calc-sinh', and the algebraic function `sinh(x)' all represent the
same operation.

   Commands that interpret ("parse") text as algebraic formulas include
algebraic entry (`''), editing commands like ``' which parse the
contents of the editing buffer when you finish, the `C-x * g' and
`C-x * r' commands, the `C-y' command, the X window system "paste"
mouse operation, and Embedded mode.  All of these operations use the
same rules for parsing formulas; in particular, language modes (*note
Language Modes::) affect them all in the same way.

   When you read a large amount of text into the Calculator (say a
vector which represents a big set of rewrite rules; *note Rewrite
Rules::), you may wish to include comments in the text.  Calc's formula
parser ignores the symbol `%%' and anything following it on a line:

     [ a + b,   %% the sum of "a" and "b"
       c + d,
       %% last line is coming up:
       e + f ]

This is parsed exactly the same as `[ a + b, c + d, e + f ]'.

   *Note Syntax Tables::, for a way to create your own operators and
other input notations.  *Note Compositions::, for a way to create new
display formats.

   *Note Algebra::, for commands for manipulating formulas symbolically.


File: calc,  Node: Stack and Trail,  Next: Mode Settings,  Prev: Data Types,  Up: Top

7 Stack and Trail Commands
**************************

This chapter describes the Calc commands for manipulating objects on the
stack and in the trail buffer.  (These commands operate on objects of
any type, such as numbers, vectors, formulas, and incomplete objects.)

* Menu:

* Stack Manipulation::
* Editing Stack Entries::
* Trail Commands::
* Keep Arguments::


File: calc,  Node: Stack Manipulation,  Next: Editing Stack Entries,  Prev: Stack and Trail,  Up: Stack and Trail

7.1 Stack Manipulation Commands
===============================

To duplicate the top object on the stack, press <RET> or <SPC> (two
equivalent keys for the `calc-enter' command).  Given a positive
numeric prefix argument, these commands duplicate several elements at
the top of the stack.  Given a negative argument, these commands
duplicate the specified element of the stack.  Given an argument of
zero, they duplicate the entire stack.  For example, with `10 20 30' on
the stack, <RET> creates `10 20 30 30', `C-u 2 <RET>' creates `10 20 30
20 30', `C-u - 2 <RET>' creates `10 20 30 20', and `C-u 0 <RET>'
creates `10 20 30 10 20 30'.

   The <LFD> (`calc-over') command (on a key marked Line-Feed if you
have it, else on `C-j') is like `calc-enter' except that the sign of
the numeric prefix argument is interpreted oppositely.  Also, with no
prefix argument the default argument is 2.  Thus with `10 20 30' on the
stack, <LFD> and `C-u 2 <LFD>' are both equivalent to `C-u - 2 <RET>',
producing `10 20 30 20'.

   To remove the top element from the stack, press <DEL> (`calc-pop').
The `C-d' key is a synonym for <DEL>.  (If the top element is an
incomplete object with at least one element, the last element is
removed from it.)  Given a positive numeric prefix argument, several
elements are removed.  Given a negative argument, the specified element
of the stack is deleted.  Given an argument of zero, the entire stack
is emptied.  For example, with `10 20 30' on the stack, <DEL> leaves
`10 20', `C-u 2 <DEL>' leaves `10', `C-u - 2 <DEL>' leaves `10 30', and
`C-u 0 <DEL>' leaves an empty stack.

   The `M-<DEL>' (`calc-pop-above') command is to <DEL> what <LFD> is
to <RET>:  It interprets the sign of the numeric prefix argument in the
opposite way, and the default argument is 2.  Thus `M-<DEL>' by itself
removes the second-from-top stack element, leaving the first, third,
fourth, and so on; `M-3 M-<DEL>' deletes the third stack element.

   To exchange the top two elements of the stack, press <TAB>
(`calc-roll-down').  Given a positive numeric prefix argument, the
specified number of elements at the top of the stack are rotated
downward.  Given a negative argument, the entire stack is rotated
downward the specified number of times.  Given an argument of zero, the
entire stack is reversed top-for-bottom.  For example, with `10 20 30
40 50' on the stack, <TAB> creates `10 20 30 50 40', `C-u 3 <TAB>'
creates `10 20 50 30 40', `C-u - 2 <TAB>' creates `40 50 10 20 30', and
`C-u 0 <TAB>' creates `50 40 30 20 10'.

   The command `M-<TAB>' (`calc-roll-up') is analogous to <TAB> except
that it rotates upward instead of downward.  Also, the default with no
prefix argument is to rotate the top 3 elements.  For example, with `10
20 30 40 50' on the stack, `M-<TAB>' creates `10 20 40 50 30', `C-u 4
M-<TAB>' creates `10 30 40 50 20', `C-u - 2 M-<TAB>' creates `30 40 50
10 20', and `C-u 0 M-<TAB>' creates `50 40 30 20 10'.

   A good way to view the operation of <TAB> and `M-<TAB>' is in terms
of moving a particular element to a new position in the stack.  With a
positive argument N, <TAB> moves the top stack element down to level N,
making room for it by pulling all the intervening stack elements toward
the top.  `M-<TAB>' moves the element at level N up to the top.
(Compare with <LFD>, which copies instead of moving the element in
level N.)

   With a negative argument -N, <TAB> rotates the stack to move the
object in level N to the deepest place in the stack, and the object in
level N+1 to the top.  `M-<TAB>' rotates the deepest stack element to
be in level N, also putting the top stack element in level N+1.

   *Note Selecting Subformulas::, for a way to apply these commands to
any portion of a vector or formula on the stack.

   The command `C-x C-t' (`calc-transpose-lines') will transpose the
stack object determined by the point with the stack object at the next
higher level. For example, with `10 20 30 40 50' on the stack and the
point on the line containing `30', `C-x C-t' creates `10 20 40 30 50'.
More generally, `C-x C-t' acts on the stack objects determined by the
current point (and mark) similar to how the text-mode command
`transpose-lines' acts on lines.  With argument N, `C-x C-t' will move
the stack object at the level above the current point and move it past
N other objects; for example, with `10 20 30 40 50' on the stack and
the point on the line containing `30', `C-u 2 C-x C-t' creates `10 40
20 30 50'. With an argument of 0, `C-x C-t' will switch the stack
objects at the levels determined by the point and the mark.


File: calc,  Node: Editing Stack Entries,  Next: Trail Commands,  Prev: Stack Manipulation,  Up: Stack and Trail

7.2 Editing Stack Entries
=========================

The ``' (`calc-edit') command creates a temporary buffer (`*Calc
Edit*') for editing the top-of-stack value using regular Emacs
commands.  Note that ``' is a backquote, not a quote. With a numeric
prefix argument, it edits the specified number of stack entries at
once.  (An argument of zero edits the entire stack; a negative argument
edits one specific stack entry.)

   When you are done editing, press `C-c C-c' to finish and return to
Calc.  The <RET> and <LFD> keys also work to finish most sorts of
editing, though in some cases Calc leaves <RET> with its usual meaning
("insert a newline") if it's a situation where you might want to insert
new lines into the editing buffer.

   When you finish editing, the Calculator parses the lines of text in
the `*Calc Edit*' buffer as numbers or formulas, replaces the original
stack elements in the original buffer with these new values, then kills
the `*Calc Edit*' buffer.  The original Calculator buffer continues to
exist during editing, but for best results you should be careful not to
change it until you have finished the edit.  You can also cancel the
edit by killing the buffer with `C-x k'.

   The formula is normally reevaluated as it is put onto the stack.
For example, editing `a + 2' to `3 + 2' and pressing `C-c C-c' will
push 5 on the stack.  If you use <LFD> to finish, Calc will put the
result on the stack without evaluating it.

   If you give a prefix argument to `C-c C-c', Calc will not kill the
`*Calc Edit*' buffer.  You can switch back to that buffer and continue
editing if you wish.  However, you should understand that if you
initiated the edit with ``', the `C-c C-c' operation will be programmed
to replace the top of the stack with the new edited value, and it will
do this even if you have rearranged the stack in the meanwhile.  This
is not so much of a problem with other editing commands, though, such
as `s e' (`calc-edit-variable'; *note Operations on Variables::).

   If the `calc-edit' command involves more than one stack entry, each
line of the `*Calc Edit*' buffer is interpreted as a separate formula.
Otherwise, the entire buffer is interpreted as one formula, with line
breaks ignored.  (You can use `C-o' or `C-q C-j' to insert a newline in
the buffer without pressing <RET>.)

   The ``' key also works during numeric or algebraic entry.  The text
entered so far is moved to the `*Calc Edit*' buffer for more extensive
editing than is convenient in the minibuffer.


File: calc,  Node: Trail Commands,  Next: Keep Arguments,  Prev: Editing Stack Entries,  Up: Stack and Trail

7.3 Trail Commands
==================

The commands for manipulating the Calc Trail buffer are two-key
sequences beginning with the `t' prefix.

   The `t d' (`calc-trail-display') command turns display of the trail
on and off.  Normally the trail display is toggled on if it was off,
off if it was on.  With a numeric prefix of zero, this command always
turns the trail off; with a prefix of one, it always turns the trail on.
The other trail-manipulation commands described here automatically turn
the trail on.  Note that when the trail is off values are still recorded
there; they are simply not displayed.  To set Emacs to turn the trail
off by default, type `t d' and then save the mode settings with `m m'
(`calc-save-modes').

   The `t i' (`calc-trail-in') and `t o' (`calc-trail-out') commands
switch the cursor into and out of the Calc Trail window.  In practice
they are rarely used, since the commands shown below are a more
convenient way to move around in the trail, and they work "by remote
control" when the cursor is still in the Calculator window.

   There is a "trail pointer" which selects some entry of the trail at
any given time.  The trail pointer looks like a `>' symbol right before
the selected number.  The following commands operate on the trail
pointer in various ways.

   The `t y' (`calc-trail-yank') command reads the selected value in
the trail and pushes it onto the Calculator stack.  It allows you to
re-use any previously computed value without retyping.  With a numeric
prefix argument N, it yanks the value N lines above the current trail
pointer.

   The `t <' (`calc-trail-scroll-left') and `t >'
(`calc-trail-scroll-right') commands horizontally scroll the trail
window left or right by one half of its width.

   The `t n' (`calc-trail-next') and `t p' (`calc-trail-previous)'
commands move the trail pointer down or up one line.  The `t f'
(`calc-trail-forward') and `t b' (`calc-trail-backward') commands move
the trail pointer down or up one screenful at a time.  All of these
commands accept numeric prefix arguments to move several lines or
screenfuls at a time.

   The `t [' (`calc-trail-first') and `t ]' (`calc-trail-last')
commands move the trail pointer to the first or last line of the trail.
The `t h' (`calc-trail-here') command moves the trail pointer to the
cursor position; unlike the other trail commands, `t h' works only when
Calc Trail is the selected window.

   The `t s' (`calc-trail-isearch-forward') and `t r'
(`calc-trail-isearch-backward') commands perform an incremental search
forward or backward through the trail.  You can press <RET> to
terminate the search; the trail pointer moves to the current line.  If
you cancel the search with `C-g', the trail pointer stays where it was
when the search began.

   The `t m' (`calc-trail-marker') command allows you to enter a line
of text of your own choosing into the trail.  The text is inserted
after the line containing the trail pointer; this usually means it is
added to the end of the trail.  Trail markers are useful mainly as the
targets for later incremental searches in the trail.

   The `t k' (`calc-trail-kill') command removes the selected line from
the trail.  The line is saved in the Emacs kill ring suitable for
yanking into another buffer, but it is not easy to yank the text back
into the trail buffer.  With a numeric prefix argument, this command
kills the N lines below or above the selected one.

   The `t .' (`calc-full-trail-vectors') command is described
elsewhere; *note Vector and Matrix Formats::.


File: calc,  Node: Keep Arguments,  Prev: Trail Commands,  Up: Stack and Trail

7.4 Keep Arguments
==================

The `K' (`calc-keep-args') command acts like a prefix for the following
command.  It prevents that command from removing its arguments from the
stack.  For example, after `2 <RET> 3 +', the stack contains the sole
number 5, but after `2 <RET> 3 K +', the stack contains the arguments
and the result: `2 3 5'.

   With the exception of keyboard macros, this works for all commands
that take arguments off the stack. (To avoid potentially unpleasant
behavior, a `K' prefix before a keyboard macro will be ignored.  A `K'
prefix called _within_ the keyboard macro will still take effect.)  As
another example, `K a s' simplifies a formula, pushing the simplified
version of the formula onto the stack after the original formula
(rather than replacing the original formula).  Note that you could get
the same effect by typing `<RET> a s', copying the formula and then
simplifying the copy. One difference is that for a very large formula
the time taken to format the intermediate copy in `<RET> a s' could be
noticeable; `K a s' would avoid this extra work.

   Even stack manipulation commands are affected.  <TAB> works by
popping two values and pushing them back in the opposite order, so `2
<RET> 3 K <TAB>' produces `2 3 3 2'.

   A few Calc commands provide other ways of doing the same thing.  For
example, `' sin($)' replaces the number on the stack with its sine
using algebraic entry; to push the sine and keep the original argument
you could use either `' sin($1)' or `K ' sin($)'.  *Note Algebraic
Entry::.  Also, the `s s' command is effectively the same as `K s t'.
*Note Storing Variables::.

   If you execute a command and then decide you really wanted to keep
the argument, you can press `M-<RET>' (`calc-last-args').  This command
pushes the last arguments that were popped by any command onto the
stack.  Note that the order of things on the stack will be different
than with `K':  `2 <RET> 3 + M-<RET>' leaves `5 2 3' on the stack
instead of `2 3 5'.  *Note Undo::.


File: calc,  Node: Mode Settings,  Next: Arithmetic,  Prev: Stack and Trail,  Up: Top

8 Mode Settings
***************

This chapter describes commands that set modes in the Calculator.  They
do not affect the contents of the stack, although they may change the
_appearance_ or _interpretation_ of the stack's contents.

* Menu:

* General Mode Commands::
* Precision::
* Inverse and Hyperbolic::
* Calculation Modes::
* Simplification Modes::
* Declarations::
* Display Modes::
* Language Modes::
* Modes Variable::
* Calc Mode Line::


File: calc,  Node: General Mode Commands,  Next: Precision,  Prev: Mode Settings,  Up: Mode Settings

8.1 General Mode Commands
=========================

You can save all of the current mode settings in your Calc init file
(the file given by the variable `calc-settings-file', typically
`~/.emacs.d/calc.el') with the `m m' (`calc-save-modes') command.  This
will cause Emacs to reestablish these modes each time it starts up.
The modes saved in the file include everything controlled by the `m'
and `d' prefix keys, the current precision and binary word size,
whether or not the trail is displayed, the current height of the Calc
window, and more.  The current interface (used when you type `C-x * *')
is also saved.  If there were already saved mode settings in the file,
they are replaced.  Otherwise, the new mode information is appended to
the end of the file.

   The `m R' (`calc-mode-record-mode') command tells Calc to record all
the mode settings (as if by pressing `m m') every time a mode setting
changes.  If the modes are saved this way, then this "automatic mode
recording" mode is also saved.  Type `m R' again to disable this method
of recording the mode settings.  To turn it off permanently, the `m m'
command will also be necessary.   (If Embedded mode is enabled, other
options for recording the modes are available; *note Mode Settings in
Embedded Mode::.)

   The `m F' (`calc-settings-file-name') command allows you to choose a
different file than the current value of `calc-settings-file' for `m
m', `Z P', and similar commands to save permanent information.  You are
prompted for a file name.  All Calc modes are then reset to their
default values, then settings from the file you named are loaded if
this file exists, and this file becomes the one that Calc will use in
the future for commands like `m m'.  The default settings file name is
`~/.emacs.d/calc.el'.  You can see the current file name by giving a
blank response to the `m F' prompt.  See also the discussion of the
`calc-settings-file' variable; *note Customizing Calc::.

   If the file name you give is your user init file (typically
`~/.emacs'), `m F' will not automatically load the new file.  This is
because your user init file may contain other things you don't want to
reread.  You can give a numeric prefix argument of 1 to `m F' to force
it to read the file no matter what.  Conversely, an argument of -1 tells
`m F' _not_ to read the new file.  An argument of 2 or -2 tells `m F'
not to reset the modes to their defaults beforehand, which is useful if
you intend your new file to have a variant of the modes present in the
file you were using before.

   The `m x' (`calc-always-load-extensions') command enables a mode in
which the first use of Calc loads the entire program, including all
extensions modules.  Otherwise, the extensions modules will not be
loaded until the various advanced Calc features are used.  Since this
mode only has effect when Calc is first loaded, `m x' is usually
followed by `m m' to make the mode-setting permanent.  To load all of
Calc just once, rather than always in the future, you can press `C-x *
L'.

   The `m S' (`calc-shift-prefix') command enables a mode in which all
of Calc's letter prefix keys may be typed shifted as well as unshifted.
If you are typing, say, `a S' (`calc-solve-for') quite often you might
find it easier to turn this mode on so that you can type `A S' instead.
When this mode is enabled, the commands that used to be on those single
shifted letters (e.g., `A' (`calc-abs')) can now be invoked by pressing
the shifted letter twice: `A A'.  Note that the `v' prefix key always
works both shifted and unshifted, and the `z' and `Z' prefix keys are
always distinct.  Also, the `h' prefix is not affected by this mode.
Press `m S' again to disable shifted-prefix mode.


File: calc,  Node: Precision,  Next: Inverse and Hyperbolic,  Prev: General Mode Commands,  Up: Mode Settings

8.2 Precision
=============

The `p' (`calc-precision') command controls the precision to which
floating-point calculations are carried.  The precision must be at
least 3 digits and may be arbitrarily high, within the limits of memory
and time.  This affects only floats:  Integer and rational calculations
are always carried out with as many digits as necessary.

   The `p' key prompts for the current precision.  If you wish you can
instead give the precision as a numeric prefix argument.

   Many internal calculations are carried to one or two digits higher
precision than normal.  Results are rounded down afterward to the
current precision.  Unless a special display mode has been selected,
floats are always displayed with their full stored precision, i.e.,
what you see is what you get.  Reducing the current precision does not
round values already on the stack, but those values will be rounded
down before being used in any calculation.  The `c 0' through `c 9'
commands (*note Conversions::) can be used to round an existing value
to a new precision.

   It is important to distinguish the concepts of "precision" and
"accuracy".  In the normal usage of these words, the number 123.4567
has a precision of 7 digits but an accuracy of 4 digits.  The precision
is the total number of digits not counting leading or trailing zeros
(regardless of the position of the decimal point).  The accuracy is
simply the number of digits after the decimal point (again not counting
trailing zeros).  In Calc you control the precision, not the accuracy
of computations.  If you were to set the accuracy instead, then
calculations like `exp(100)' would generate many more digits than you
would typically need, while `exp(-100)' would probably round to zero!
In Calc, both these computations give you exactly 12 (or the requested
number of) significant digits.

   The only Calc features that deal with accuracy instead of precision
are fixed-point display mode for floats (`d f'; *note Float Formats::),
and the rounding functions like `floor' and `round' (*note Integer
Truncation::).  Also, `c 0' through `c 9' deal with both precision and
accuracy depending on the magnitudes of the numbers involved.

   If you need to work with a particular fixed accuracy (say, dollars
and cents with two digits after the decimal point), one solution is to
work with integers and an "implied" decimal point.  For example, $8.99
divided by 6 would be entered `899 <RET> 6 /', yielding 149.833
(actually $1.49833 with our implied decimal point); pressing `R' would
round this to 150 cents, i.e., $1.50.

   *Note Floats::, for still more on floating-point precision and
related issues.


File: calc,  Node: Inverse and Hyperbolic,  Next: Calculation Modes,  Prev: Precision,  Up: Mode Settings

8.3 Inverse and Hyperbolic Flags
================================

There is no single-key equivalent to the `calc-arcsin' function.
Instead, you must first press `I' (`calc-inverse') to set the "Inverse
Flag", then press `S' (`calc-sin').  The `I' key actually toggles the
Inverse Flag.  When this flag is set, the word `Inv' appears in the
mode line.

   Likewise, the `H' key (`calc-hyperbolic') sets or clears the
Hyperbolic Flag, which transforms `calc-sin' into `calc-sinh'.  If both
of these flags are set at once, the effect will be `calc-arcsinh'.
(The Hyperbolic flag is also used by some non-trigonometric commands;
for example `H L' computes a base-10, instead of base-e, logarithm.)

   Command names like `calc-arcsin' are provided for completeness, and
may be executed with `x' or `M-x'.  Their effect is simply to toggle
the Inverse and/or Hyperbolic flags and then execute the corresponding
base command (`calc-sin' in this case).

   The `O' key (`calc-option') sets another flag, the "Option Flag",
which also can alter the subsequent Calc command in various ways.

   The Inverse, Hyperbolic and Option flags apply only to the next
Calculator command, after which they are automatically cleared.  (They
are also cleared if the next keystroke is not a Calc command.)  Digits
you type after `I', `H' or `O' (or `K') are treated as prefix arguments
for the next command, not as numeric entries.  The same is true of
`C-u', but not of the minus sign (`K -' means to subtract and keep
arguments).

   Another Calc prefix flag, `K' (keep-arguments), is discussed
elsewhere.  *Note Keep Arguments::.


File: calc,  Node: Calculation Modes,  Next: Simplification Modes,  Prev: Inverse and Hyperbolic,  Up: Mode Settings

8.4 Calculation Modes
=====================

The commands in this section are two-key sequences beginning with the
`m' prefix.  (That's the letter `m', not the <META> key.)  The `m a'
(`calc-algebraic-mode') command is described elsewhere (*note Algebraic
Entry::).

* Menu:

* Angular Modes::
* Polar Mode::
* Fraction Mode::
* Infinite Mode::
* Symbolic Mode::
* Matrix Mode::
* Automatic Recomputation::
* Working Message::


File: calc,  Node: Angular Modes,  Next: Polar Mode,  Prev: Calculation Modes,  Up: Calculation Modes

8.4.1 Angular Modes
-------------------

The Calculator supports three notations for angles: radians, degrees,
and degrees-minutes-seconds.  When a number is presented to a function
like `sin' that requires an angle, the current angular mode is used to
interpret the number as either radians or degrees.  If an HMS form is
presented to `sin', it is always interpreted as degrees-minutes-seconds.

   Functions that compute angles produce a number in radians, a number
in degrees, or an HMS form depending on the current angular mode.  If
the result is a complex number and the current mode is HMS, the number
is instead expressed in degrees.  (Complex-number calculations would
normally be done in Radians mode, though.  Complex numbers are converted
to degrees by calculating the complex result in radians and then
multiplying by 180 over `pi'.)

   The `m r' (`calc-radians-mode'), `m d' (`calc-degrees-mode'), and `m
h' (`calc-hms-mode') commands control the angular mode.  The current
angular mode is displayed on the Emacs mode line.  The default angular
mode is Degrees.


File: calc,  Node: Polar Mode,  Next: Fraction Mode,  Prev: Angular Modes,  Up: Calculation Modes

8.4.2 Polar Mode
----------------

The Calculator normally "prefers" rectangular complex numbers in the
sense that rectangular form is used when the proper form can not be
decided from the input.  This might happen by multiplying a rectangular
number by a polar one, by taking the square root of a negative real
number, or by entering `( 2 <SPC> 3 )'.

   The `m p' (`calc-polar-mode') command toggles complex-number
preference between rectangular and polar forms.  In Polar mode, all of
the above example situations would produce polar complex numbers.


File: calc,  Node: Fraction Mode,  Next: Infinite Mode,  Prev: Polar Mode,  Up: Calculation Modes

8.4.3 Fraction Mode
-------------------

Division of two integers normally yields a floating-point number if the
result cannot be expressed as an integer.  In some cases you would
rather get an exact fractional answer.  One way to accomplish this is
to use the `:' (`calc-fdiv') [`fdiv'] command, which divides the two
integers on the top of the stack to produce a fraction: `6 <RET> 4 :'
produces `3:2' even though `6 <RET> 4 /' produces `1.5'.

   To set the Calculator to produce fractional results for normal
integer divisions, use the `m f' (`calc-frac-mode') command.  For
example, `8/4' produces `2' in either mode, but `6/4' produces `3:2' in
Fraction mode, `1.5' in Float mode.

   At any time you can use `c f' (`calc-float') to convert a fraction
to a float, or `c F' (`calc-fraction') to convert a float to a
fraction.  *Note Conversions::.


File: calc,  Node: Infinite Mode,  Next: Symbolic Mode,  Prev: Fraction Mode,  Up: Calculation Modes

8.4.4 Infinite Mode
-------------------

The Calculator normally treats results like `1 / 0' as errors; formulas
like this are left in unsimplified form.  But Calc can be put into a
mode where such calculations instead produce "infinite" results.

   The `m i' (`calc-infinite-mode') command turns this mode on and off.
When the mode is off, infinities do not arise except in calculations
that already had infinities as inputs.  (One exception is that infinite
open intervals like `[0 .. inf)' can be generated; however, intervals
closed at infinity (`[0 .. inf]') will not be generated when Infinite
mode is off.)

   With Infinite mode turned on, `1 / 0' will generate `uinf', an
undirected infinity.  *Note Infinities::, for a discussion of the
difference between `inf' and `uinf'.  Also, `0 / 0' evaluates to `nan',
the "indeterminate" symbol.  Various other functions can also return
infinities in this mode; for example, `ln(0) = -inf', and `gamma(-7) =
uinf'.  Once again, note that `exp(inf) = inf' regardless of Infinite
mode because this calculation has infinity as an input.

   The `m i' command with a numeric prefix argument of zero, i.e., `C-u
0 m i', turns on a Positive Infinite mode in which zero is treated as
positive instead of being directionless.  Thus, `1 / 0 = inf' and `-1 /
0 = -inf' in this mode.  Note that zero never actually has a sign in
Calc; there are no separate representations for +0 and -0.  Positive
Infinite mode merely changes the interpretation given to the single
symbol, `0'.  One consequence of this is that, while you might expect
`1 / -0 = -inf', actually `1 / -0' is equivalent to `1 / 0', which is
equal to positive `inf'.


File: calc,  Node: Symbolic Mode,  Next: Matrix Mode,  Prev: Infinite Mode,  Up: Calculation Modes

8.4.5 Symbolic Mode
-------------------

Calculations are normally performed numerically wherever possible.  For
example, the `calc-sqrt' command, or `sqrt' function in an algebraic
expression, produces a numeric answer if the argument is a number or a
symbolic expression if the argument is an expression: `2 Q' pushes
1.4142 but `<'> x+1 <RET> Q' pushes `sqrt(x+1)'.

   In "Symbolic mode", controlled by the `m s' (`calc-symbolic-mode')
command, functions which would produce inexact, irrational results are
left in symbolic form.  Thus `16 Q' pushes 4, but `2 Q' pushes
`sqrt(2)'.

   The shift-`N' (`calc-eval-num') command evaluates numerically the
expression at the top of the stack, by temporarily disabling
`calc-symbolic-mode' and executing `=' (`calc-evaluate').  Given a
numeric prefix argument, it also sets the floating-point precision to
the specified value for the duration of the command.

   To evaluate a formula numerically without expanding the variables it
contains, you can use the key sequence `m s a v m s' (this uses
`calc-alg-evaluate', which resimplifies but doesn't evaluate variables.)


File: calc,  Node: Matrix Mode,  Next: Automatic Recomputation,  Prev: Symbolic Mode,  Up: Calculation Modes

8.4.6 Matrix and Scalar Modes
-----------------------------

Calc sometimes makes assumptions during algebraic manipulation that are
awkward or incorrect when vectors and matrices are involved.  Calc has
two modes, "Matrix mode" and "Scalar mode", which modify its behavior
around vectors in useful ways.

   Press `m v' (`calc-matrix-mode') once to enter Matrix mode.  In this
mode, all objects are assumed to be matrices unless provably otherwise.
One major effect is that Calc will no longer consider multiplication to
be commutative.  (Recall that in matrix arithmetic, `A*B' is not the
same as `B*A'.)  This assumption affects rewrite rules and algebraic
simplification.  Another effect of this mode is that calculations that
would normally produce constants like 0 and 1 (e.g., `a - a' and `a /
a', respectively) will now produce function calls that represent
"generic" zero or identity matrices: `idn(0)', `idn(1)'.  The `idn'
function `idn(A,N)' returns A times an NxN identity matrix; if N is
omitted, it doesn't know what dimension to use and so the `idn' call
remains in symbolic form.  However, if this generic identity matrix is
later combined with a matrix whose size is known, it will be converted
into a true identity matrix of the appropriate size.  On the other hand,
if it is combined with a scalar (as in `idn(1) + 2'), Calc will assume
it really was a scalar after all and produce, e.g., 3.

   Press `m v' a second time to get Scalar mode.  Here, objects are
assumed _not_ to be vectors or matrices unless provably so.  For
example, normally adding a variable to a vector, as in `[x, y, z] + a',
will leave the sum in symbolic form because as far as Calc knows, `a'
could represent either a number or another 3-vector.  In Scalar mode,
`a' is assumed to be a non-vector, and the addition is evaluated to
`[x+a, y+a, z+a]'.

   Press `m v' a third time to return to the normal mode of operation.

   If you press `m v' with a numeric prefix argument N, you get a
special "dimensioned" Matrix mode in which matrices of unknown size are
assumed to be NxN square matrices.  Then, the function call `idn(1)'
will expand into an actual matrix rather than representing a "generic"
matrix.  Simply typing `C-u m v' will get you a square Matrix mode, in
which matrices of unknown size are assumed to be square matrices of
unspecified size.

   Of course these modes are approximations to the true state of
affairs, which is probably that some quantities will be matrices and
others will be scalars.  One solution is to "declare" certain variables
or functions to be scalar-valued.  *Note Declarations::, to see how to
make declarations in Calc.

   There is nothing stopping you from declaring a variable to be scalar
and then storing a matrix in it; however, if you do, the results you
get from Calc may not be valid.  Suppose you let Calc get the result
`[x+a, y+a, z+a]' shown above, and then stored `[1, 2, 3]' in `a'.  The
result would not be the same as for `[x, y, z] + [1, 2, 3]', but that's
because you have broken your earlier promise to Calc that `a' would be
scalar.

   Another way to mix scalars and matrices is to use selections (*note
Selecting Subformulas::).  Use Matrix mode when operating on your
formula normally; then, to apply Scalar mode to a certain part of the
formula without affecting the rest just select that part, change into
Scalar mode and press `=' to resimplify the part under this mode, then
change back to Matrix mode before deselecting.


File: calc,  Node: Automatic Recomputation,  Next: Working Message,  Prev: Matrix Mode,  Up: Calculation Modes

8.4.7 Automatic Recomputation
-----------------------------

The "evaluates-to" operator, `=>', has the special property that any
`=>' formulas on the stack are recomputed whenever variable values or
mode settings that might affect them are changed.  *Note Evaluates-To
Operator::.

   The `m C' (`calc-auto-recompute') command turns this automatic
recomputation on and off.  If you turn it off, Calc will not update
`=>' operators on the stack (nor those in the attached Embedded mode
buffer, if there is one).  They will not be updated unless you
explicitly do so by pressing `=' or until you press `m C' to turn
recomputation back on.  (While automatic recomputation is off, you can
think of `m C m C' as a command to update all `=>' operators while
leaving recomputation off.)

   To update `=>' operators in an Embedded buffer while automatic
recomputation is off, use `C-x * u'.  *Note Embedded Mode::.


File: calc,  Node: Working Message,  Prev: Automatic Recomputation,  Up: Calculation Modes

8.4.8 Working Messages
----------------------

Since the Calculator is written entirely in Emacs Lisp, which is not
designed for heavy numerical work, many operations are quite slow.  The
Calculator normally displays the message `Working...' in the echo area
during any command that may be slow.  In addition, iterative operations
such as square roots and trigonometric functions display the
intermediate result at each step.  Both of these types of messages can
be disabled if you find them distracting.

   Type `m w' (`calc-working') with a numeric prefix of 0 to disable
all "working" messages.  Use a numeric prefix of 1 to enable only the
plain `Working...' message.  Use a numeric prefix of 2 to see
intermediate results as well.  With no numeric prefix this displays the
current mode.

   While it may seem that the "working" messages will slow Calc down
considerably, experiments have shown that their impact is actually
quite small.  But if your terminal is slow you may find that it helps
to turn the messages off.


File: calc,  Node: Simplification Modes,  Next: Declarations,  Prev: Calculation Modes,  Up: Mode Settings

8.5 Simplification Modes
========================

The current "simplification mode" controls how numbers and formulas are
"normalized" when being taken from or pushed onto the stack.  Some
normalizations are unavoidable, such as rounding floating-point results
to the current precision, and reducing fractions to simplest form.
Others, such as simplifying a formula like `a+a' (or `2+3'), are done
by default but can be turned off when necessary.

   When you press a key like `+' when `2' and `3' are on the stack,
Calc pops these numbers, normalizes them, creates the formula `2+3',
normalizes it, and pushes the result.  Of course the standard rules for
normalizing `2+3' will produce the result `5'.

   Simplification mode commands consist of the lower-case `m' prefix key
followed by a shifted letter.

   The `m O' (`calc-no-simplify-mode') command turns off all optional
simplifications.  These would leave a formula like `2+3' alone.  In
fact, nothing except simple numbers are ever affected by normalization
in this mode.

   The `m N' (`calc-num-simplify-mode') command turns off simplification
of any formulas except those for which all arguments are constants.  For
example, `1+2' is simplified to `3', and `a+(2-2)' is simplified to
`a+0' but no further, since one argument of the sum is not a constant.
Unfortunately, `(a+2)-2' is _not_ simplified because the top-level `-'
operator's arguments are not both constant numbers (one of them is the
formula `a+2').  A constant is a number or other numeric object (such
as a constant error form or modulo form), or a vector all of whose
elements are constant.

   The `m D' (`calc-default-simplify-mode') command restores the
default simplifications for all formulas.  This includes many easy and
fast algebraic simplifications such as `a+0' to `a', and `a + 2 a' to
`3 a', as well as evaluating functions like `deriv(x^2, x)' to `2 x'.

   The `m B' (`calc-bin-simplify-mode') mode applies the default
simplifications to a result and then, if the result is an integer, uses
the `b c' (`calc-clip') command to clip the integer according to the
current binary word size.  *Note Binary Functions::.  Real numbers are
rounded to the nearest integer and then clipped; other kinds of results
(after the default simplifications) are left alone.

   The `m A' (`calc-alg-simplify-mode') mode does algebraic
simplification; it applies all the default simplifications, and also
the more powerful (and slower) simplifications made by `a s'
(`calc-simplify').  *Note Algebraic Simplifications::.

   The `m E' (`calc-ext-simplify-mode') mode does "extended" algebraic
simplification, as by the `a e' (`calc-simplify-extended') command.
*Note Unsafe Simplifications::.

   The `m U' (`calc-units-simplify-mode') mode does units
simplification; it applies the command `u s' (`calc-simplify-units'),
which in turn is a superset of `a s'.  In this mode, variable names
which are identifiable as unit names (like `mm' for "millimeters") are
simplified with their unit definitions in mind.

   A common technique is to set the simplification mode down to the
lowest amount of simplification you will allow to be applied
automatically, then use manual commands like `a s' and `c c'
(`calc-clean') to perform higher types of simplifications on demand.
*Note Algebraic Definitions::, for another sample use of
No-Simplification mode.


File: calc,  Node: Declarations,  Next: Display Modes,  Prev: Simplification Modes,  Up: Mode Settings

8.6 Declarations
================

A "declaration" is a statement you make that promises you will use a
certain variable or function in a restricted way.  This may give Calc
the freedom to do things that it couldn't do if it had to take the
fully general situation into account.

* Menu:

* Declaration Basics::
* Kinds of Declarations::
* Functions for Declarations::


File: calc,  Node: Declaration Basics,  Next: Kinds of Declarations,  Prev: Declarations,  Up: Declarations

8.6.1 Declaration Basics
------------------------

The `s d' (`calc-declare-variable') command is the easiest way to make
a declaration for a variable.  This command prompts for the variable
name, then prompts for the declaration.  The default at the declaration
prompt is the previous declaration, if any.  You can edit this
declaration, or press `C-k' to erase it and type a new declaration.
(Or, erase it and press <RET> to clear the declaration, effectively
"undeclaring" the variable.)

   A declaration is in general a vector of "type symbols" and "range"
values.  If there is only one type symbol or range value, you can write
it directly rather than enclosing it in a vector.  For example, `s d
foo <RET> real <RET>' declares `foo' to be a real number, and `s d bar
<RET> [int, const, [1..6]] <RET>' declares `bar' to be a constant
integer between 1 and 6.  (Actually, you can omit the outermost
brackets and Calc will provide them for you: `s d bar <RET> int, const,
[1..6] <RET>'.)

   Declarations in Calc are kept in a special variable called `Decls'.
This variable encodes the set of all outstanding declarations in the
form of a matrix.  Each row has two elements:  A variable or vector of
variables declared by that row, and the declaration specifier as
described above.  You can use the `s D' command to edit this variable
if you wish to see all the declarations at once.  *Note Operations on
Variables::, for a description of this command and the `s p' command
that allows you to save your declarations permanently if you wish.

   Items being declared can also be function calls.  The arguments in
the call are ignored; the effect is to say that this function returns
values of the declared type for any valid arguments.  The `s d' command
declares only variables, so if you wish to make a function declaration
you will have to edit the `Decls' matrix yourself.

   For example, the declaration matrix

     [ [ foo,       real       ]
       [ [j, k, n], int        ]
       [ f(1,2,3),  [0 .. inf) ] ]

declares that `foo' represents a real number, `j', `k' and `n'
represent integers, and the function `f' always returns a real number
in the interval shown.

   If there is a declaration for the variable `All', then that
declaration applies to all variables that are not otherwise declared.
It does not apply to function names.  For example, using the row `[All,
real]' says that all your variables are real unless they are explicitly
declared without `real' in some other row.  The `s d' command declares
`All' if you give a blank response to the variable-name prompt.


File: calc,  Node: Kinds of Declarations,  Next: Functions for Declarations,  Prev: Declaration Basics,  Up: Declarations

8.6.2 Kinds of Declarations
---------------------------

The type-specifier part of a declaration (that is, the second prompt in
the `s d' command) can be a type symbol, an interval, or a vector
consisting of zero or more type symbols followed by zero or more
intervals or numbers that represent the set of possible values for the
variable.

     [ [ a, [1, 2, 3, 4, 5] ]
       [ b, [1 .. 5]        ]
       [ c, [int, 1 .. 5]   ] ]

   Here `a' is declared to contain one of the five integers shown; `b'
is any number in the interval from 1 to 5 (any real number since we
haven't specified), and `c' is any integer in that interval.  Thus the
declarations for `a' and `c' are nearly equivalent (see below).

   The type-specifier can be the empty vector `[]' to say that nothing
is known about a given variable's value.  This is the same as not
declaring the variable at all except that it overrides any `All'
declaration which would otherwise apply.

   The initial value of `Decls' is the empty vector `[]'.  If `Decls'
has no stored value or if the value stored in it is not valid, it is
ignored and there are no declarations as far as Calc is concerned.
(The `s d' command will replace such a malformed value with a fresh
empty matrix, `[]', before recording the new declaration.)
Unrecognized type symbols are ignored.

   The following type symbols describe what sorts of numbers will be
stored in a variable:

`int'
     Integers.

`numint'
     Numerical integers.  (Integers or integer-valued floats.)

`frac'
     Fractions.  (Rational numbers which are not integers.)

`rat'
     Rational numbers.  (Either integers or fractions.)

`float'
     Floating-point numbers.

`real'
     Real numbers.  (Integers, fractions, or floats.  Actually,
     intervals and error forms with real components also count as reals
     here.)

`pos'
     Positive real numbers.  (Strictly greater than zero.)

`nonneg'
     Nonnegative real numbers.  (Greater than or equal to zero.)

`number'
     Numbers.  (Real or complex.)

   Calc uses this information to determine when certain simplifications
of formulas are safe.  For example, `(x^y)^z' cannot be simplified to
`x^(y z)' in general; for example, `((-3)^2)^1:2' is 3, but
`(-3)^(2*1:2) = (-3)^1' is -3.  However, this simplification _is_ safe
if `z' is known to be an integer, or if `x' is known to be a nonnegative
real number.  If you have given declarations that allow Calc to deduce
either of these facts, Calc will perform this simplification of the
formula.

   Calc can apply a certain amount of logic when using declarations.
For example, `(x^y)^(2n+1)' will be simplified if `n' has been declared
`int'; Calc knows that an integer times an integer, plus an integer,
must always be an integer.  (In fact, Calc would simplify `(-x)^(2n+1)'
to `-(x^(2n+1))' since it is able to determine that `2n+1' must be an
odd integer.)

   Similarly, `(abs(x)^y)^z' will be simplified to `abs(x)^(y z)'
because Calc knows that the `abs' function always returns a nonnegative
real.  If you had a `myabs' function that also had this property, you
could get Calc to recognize it by adding the row `[myabs(), nonneg]' to
the `Decls' matrix.

   One instance of this simplification is `sqrt(x^2)' (since the `sqrt'
function is effectively a one-half power).  Normally Calc leaves this
formula alone.  After the command `s d x <RET> real <RET>', however, it
can simplify the formula to `abs(x)'.  And after `s d x <RET> nonneg
<RET>', Calc can simplify this formula all the way to `x'.

   If there are any intervals or real numbers in the type specifier,
they comprise the set of possible values that the variable or function
being declared can have.  In particular, the type symbol `real' is
effectively the same as the range `[-inf .. inf]' (note that infinity
is included in the range of possible values); `pos' is the same as `(0
.. inf]', and `nonneg' is the same as `[0 .. inf]'.  Saying `[real, [-5
.. 5]]' is redundant because the fact that the variable is real can be
deduced just from the interval, but `[int, [-5 .. 5]]' and `[rat, [-5
.. 5]]' are useful combinations.

   Note that the vector of intervals or numbers is in the same format
used by Calc's set-manipulation commands.  *Note Set Operations::.

   The type specifier `[1, 2, 3]' is equivalent to `[numint, 1, 2, 3]',
_not_ to `[int, 1, 2, 3]'.  In other words, the range of possible
values means only that the variable's value must be numerically equal
to a number in that range, but not that it must be equal in type as
well.  Calc's set operations act the same way; `in(2, [1., 2., 3.])'
and `in(1.5, [1:2, 3:2, 5:2])' both report "true."

   If you use a conflicting combination of type specifiers, the results
are unpredictable.  An example is `[pos, [0 .. 5]]', where the interval
does not lie in the range described by the type symbol.

   "Real" declarations mostly affect simplifications involving powers
like the one described above.  Another case where they are used is in
the `a P' command which returns a list of all roots of a polynomial; if
the variable has been declared real, only the real roots (if any) will
be included in the list.

   "Integer" declarations are used for simplifications which are valid
only when certain values are integers (such as `(x^y)^z' shown above).

   Another command that makes use of declarations is `a s', when
simplifying equations and inequalities.  It will cancel `x' from both
sides of `a x = b x' only if it is sure `x' is non-zero, say, because
it has a `pos' declaration.  To declare specifically that `x' is real
and non-zero, use `[[-inf .. 0), (0 .. inf]]'.  (There is no way in the
current notation to say that `x' is nonzero but not necessarily real.)
The `a e' command does "unsafe" simplifications, including canceling
`x' from the equation when `x' is not known to be nonzero.

   Another set of type symbols distinguish between scalars and vectors.

`scalar'
     The value is not a vector.

`vector'
     The value is a vector.

`matrix'
     The value is a matrix (a rectangular vector of vectors).

`sqmatrix'
     The value is a square matrix.

   These type symbols can be combined with the other type symbols
described above; `[int, matrix]' describes an object which is a matrix
of integers.

   Scalar/vector declarations are used to determine whether certain
algebraic operations are safe.  For example, `[a, b, c] + x' is
normally not simplified to `[a + x, b + x, c + x]', but it will be if
`x' has been declared `scalar'.  On the other hand, multiplication is
usually assumed to be commutative, but the terms in `x y' will never be
exchanged if both `x' and `y' are known to be vectors or matrices.
(Calc currently never distinguishes between `vector' and `matrix'
declarations.)

   *Note Matrix Mode::, for a discussion of Matrix mode and Scalar
mode, which are similar to declaring `[All, matrix]' or `[All, scalar]'
but much more convenient.

   One more type symbol that is recognized is used with the `H a d'
command for taking total derivatives of a formula.  *Note Calculus::.

`const'
     The value is a constant with respect to other variables.

   Calc does not check the declarations for a variable when you store a
value in it.  However, storing -3.5 in a variable that has been
declared `pos', `int', or `matrix' may have unexpected effects; Calc
may evaluate `sqrt(x^2)' to `3.5' if it substitutes the value first, or
to `-3.5' if `x' was declared `pos' and the formula `sqrt(x^2)' is
simplified to `x' before the value is substituted.  Before using a
variable for a new purpose, it is best to use `s d' or `s D' to check
to make sure you don't still have an old declaration for the variable
that will conflict with its new meaning.


File: calc,  Node: Functions for Declarations,  Prev: Kinds of Declarations,  Up: Declarations

8.6.3 Functions for Declarations
--------------------------------

Calc has a set of functions for accessing the current declarations in a
convenient manner.  These functions return 1 if the argument can be
shown to have the specified property, or 0 if the argument can be shown
_not_ to have that property; otherwise they are left unevaluated.
These functions are suitable for use with rewrite rules (*note
Conditional Rewrite Rules::) or programming constructs (*note
Conditionals in Macros::).  They can be entered only using algebraic
notation.  *Note Logical Operations::, for functions that perform other
tests not related to declarations.

   For example, `dint(17)' returns 1 because 17 is an integer, as do
`dint(n)' and `dint(2 n - 3)' if `n' has been declared `int', but
`dint(2.5)' and `dint(n + 0.5)' return 0.  Calc consults knowledge of
its own built-in functions as well as your own declarations:
`dint(floor(x))' returns 1.

   The `dint' function checks if its argument is an integer.  The
`dnatnum' function checks if its argument is a natural number, i.e., a
nonnegative integer.  The `dnumint' function checks if its argument is
numerically an integer, i.e., either an integer or an integer-valued
float.  Note that these and the other data type functions also accept
vectors or matrices composed of suitable elements, and that real
infinities `inf' and `-inf' are considered to be integers for the
purposes of these functions.

   The `drat' function checks if its argument is rational, i.e., an
integer or fraction.  Infinities count as rational, but intervals and
error forms do not.

   The `dreal' function checks if its argument is real.  This includes
integers, fractions, floats, real error forms, and intervals.

   The `dimag' function checks if its argument is imaginary, i.e., is
mathematically equal to a real number times `i'.

   The `dpos' function checks for positive (but nonzero) reals.  The
`dneg' function checks for negative reals.  The `dnonneg' function
checks for nonnegative reals, i.e., reals greater than or equal to
zero.  Note that the `a s' command can simplify an expression like `x >
0' to 1 or 0 using `dpos', and that `a s' is effectively applied to all
conditions in rewrite rules, so the actual functions `dpos', `dneg',
and `dnonneg' are rarely necessary.

   The `dnonzero' function checks that its argument is nonzero.  This
includes all nonzero real or complex numbers, all intervals that do not
include zero, all nonzero modulo forms, vectors all of whose elements
are nonzero, and variables or formulas whose values can be deduced to
be nonzero.  It does not include error forms, since they represent
values which could be anything including zero.  (This is also the set
of objects considered "true" in conditional contexts.)

   The `deven' function returns 1 if its argument is known to be an
even integer (or integer-valued float); it returns 0 if its argument is
known not to be even (because it is known to be odd or a non-integer).
The `a s' command uses this to simplify a test of the form `x % 2 = 0'.
There is also an analogous `dodd' function.

   The `drange' function returns a set (an interval or a vector of
intervals and/or numbers; *note Set Operations::) that describes the
set of possible values of its argument.  If the argument is a variable
or a function with a declaration, the range is copied from the
declaration.  Otherwise, the possible signs of the expression are
determined using a method similar to `dpos', etc., and a suitable set
like `[0 .. inf]' is returned.  If the expression is not provably real,
the `drange' function remains unevaluated.

   The `dscalar' function returns 1 if its argument is provably scalar,
or 0 if its argument is provably non-scalar.  It is left unevaluated if
this cannot be determined.  (If Matrix mode or Scalar mode is in
effect, this function returns 1 or 0, respectively, if it has no other
information.)  When Calc interprets a condition (say, in a rewrite
rule) it considers an unevaluated formula to be "false."  Thus,
`dscalar(a)' is "true" only if `a' is provably scalar, and
`!dscalar(a)' is "true" only if `a' is provably non-scalar; both are
"false" if there is insufficient information to tell.


File: calc,  Node: Display Modes,  Next: Language Modes,  Prev: Declarations,  Up: Mode Settings

8.7 Display Modes
=================

The commands in this section are two-key sequences beginning with the
`d' prefix.  The `d l' (`calc-line-numbering') and `d b'
(`calc-line-breaking') commands are described elsewhere; *note Stack
Basics:: and *note Normal Language Modes::, respectively.  Display
formats for vectors and matrices are also covered elsewhere; *note
Vector and Matrix Formats::.

   One thing all display modes have in common is their treatment of the
`H' prefix.  This prefix causes any mode command that would normally
refresh the stack to leave the stack display alone.  The word "Dirty"
will appear in the mode line when Calc thinks the stack display may not
reflect the latest mode settings.

   The `d <RET>' (`calc-refresh-top') command reformats the top stack
entry according to all the current modes.  Positive prefix arguments
reformat the top N entries; negative prefix arguments reformat the
specified entry, and a prefix of zero is equivalent to `d <SPC>'
(`calc-refresh'), which reformats the entire stack.  For example, `H d
s M-2 d <RET>' changes to scientific notation but reformats only the
top two stack entries in the new mode.

   The `I' prefix has another effect on the display modes.  The mode is
set only temporarily; the top stack entry is reformatted according to
that mode, then the original mode setting is restored.  In other words,
`I d s' is equivalent to `H d s d <RET> H d (OLD MODE)'.

* Menu:

* Radix Modes::
* Grouping Digits::
* Float Formats::
* Complex Formats::
* Fraction Formats::
* HMS Formats::
* Date Formats::
* Truncating the Stack::
* Justification::
* Labels::


File: calc,  Node: Radix Modes,  Next: Grouping Digits,  Prev: Display Modes,  Up: Display Modes

8.7.1 Radix Modes
-----------------

Calc normally displays numbers in decimal ("base-10" or "radix-10")
notation.  Calc can actually display in any radix from two (binary) to
36.  When the radix is above 10, the letters `A' to `Z' are used as
digits.  When entering such a number, letter keys are interpreted as
potential digits rather than terminating numeric entry mode.

   The key sequences `d 2', `d 8', `d 6', and `d 0' select binary,
octal, hexadecimal, and decimal as the current display radix,
respectively.  Numbers can always be entered in any radix, though the
current radix is used as a default if you press `#' without any initial
digits.  A number entered without a `#' is _always_ interpreted as
decimal.

   To set the radix generally, use `d r' (`calc-radix') and enter an
integer from 2 to 36.  You can specify the radix as a numeric prefix
argument; otherwise you will be prompted for it.

   Integers normally are displayed with however many digits are
necessary to represent the integer and no more.  The `d z'
(`calc-leading-zeros') command causes integers to be padded out with
leading zeros according to the current binary word size.  (*Note Binary
Functions::, for a discussion of word size.)  If the absolute value of
the word size is `w', all integers are displayed with at least enough
digits to represent `(2^w)-1' in the current radix.  (Larger integers
will still be displayed in their entirety.)

   Calc can display `w'-bit integers using two's complement notation,
although this is most useful with the binary, octal and hexadecimal
display modes.  This option is selected by using the `O' option prefix
before setting the display radix, and a negative word size might be
appropriate (*note Binary Functions::). In two's complement notation,
the integers in the (nearly) symmetric interval from `-2^(w-1)' to
`2^(w-1)-1' are represented by the integers from `0' to `2^w-1': the
integers from `0' to `2^(w-1)-1' are represented by themselves and the
integers from `-2^(w-1)' to `-1' are represented by the integers from
`2^(w-1)' to `2^w-1' (the integer `k' is represented by `k+2^w').  Calc
will display a two's complement integer by the radix (either `2', `8'
or `16'), two `#' symbols, and then its representation (including any
leading zeros necessary to include all `w' bits).  In a two's
complement display mode, numbers that are not displayed in two's
complement notation (i.e., that aren't integers from `-2^(w-1)' to
`2^(w-1)-1') will be represented using Calc's usual notation (in the
appropriate radix).


File: calc,  Node: Grouping Digits,  Next: Float Formats,  Prev: Radix Modes,  Up: Display Modes

8.7.2 Grouping Digits
---------------------

Long numbers can be hard to read if they have too many digits.  For
example, the factorial of 30 is 33 digits long!  Press `d g'
(`calc-group-digits') to enable "Grouping" mode, in which digits are
displayed in clumps of 3 or 4 (depending on the current radix)
separated by commas.

   The `d g' command toggles grouping on and off.  With a numeric
prefix of 0, this command displays the current state of the grouping
flag; with an argument of minus one it disables grouping; with a
positive argument `N' it enables grouping on every `N' digits.  For
floating-point numbers, grouping normally occurs only before the
decimal point.  A negative prefix argument `-N' enables grouping every
`N' digits both before and after the decimal point.

   The `d ,' (`calc-group-char') command allows you to choose any
character as the grouping separator.  The default is the comma
character.  If you find it difficult to read vectors of large integers
grouped with commas, you may wish to use spaces or some other character
instead.  This command takes the next character you type, whatever it
is, and uses it as the digit separator.  As a special case, `d , \'
selects `\,' (TeX's thin-space symbol) as the digit separator.

   Please note that grouped numbers will not generally be parsed
correctly if re-read in textual form, say by the use of `C-x * y' and
`C-x * g'.  (*Note Kill and Yank::, for details on these commands.)
One exception is the `\,' separator, which doesn't interfere with
parsing because it is ignored by TeX language mode.


File: calc,  Node: Float Formats,  Next: Complex Formats,  Prev: Grouping Digits,  Up: Display Modes

8.7.3 Float Formats
-------------------

Floating-point quantities are normally displayed in standard decimal
form, with scientific notation used if the exponent is especially high
or low.  All significant digits are normally displayed.  The commands
in this section allow you to choose among several alternative display
formats for floats.

   The `d n' (`calc-normal-notation') command selects the normal
display format.  All significant figures in a number are displayed.
With a positive numeric prefix, numbers are rounded if necessary to
that number of significant digits.  With a negative numerix prefix, the
specified number of significant digits less than the current precision
is used.  (Thus `C-u -2 d n' displays 10 digits if the current
precision is 12.)

   The `d f' (`calc-fix-notation') command selects fixed-point
notation.  The numeric argument is the number of digits after the
decimal point, zero or more.  This format will relax into scientific
notation if a nonzero number would otherwise have been rounded all the
way to zero.  Specifying a negative number of digits is the same as for
a positive number, except that small nonzero numbers will be rounded to
zero rather than switching to scientific notation.

   The `d s' (`calc-sci-notation') command selects scientific notation.
A positive argument sets the number of significant figures displayed,
of which one will be before and the rest after the decimal point.  A
negative argument works the same as for `d n' format.  The default is
to display all significant digits.

   The `d e' (`calc-eng-notation') command selects engineering
notation.  This is similar to scientific notation except that the
exponent is rounded down to a multiple of three, with from one to three
digits before the decimal point.  An optional numeric prefix sets the
number of significant digits to display, as for `d s'.

   It is important to distinguish between the current _precision_ and
the current _display format_.  After the commands `C-u 10 p' and `C-u 6
d n' the Calculator computes all results to ten significant figures but
displays only six.  (In fact, intermediate calculations are often
carried to one or two more significant figures, but values placed on
the stack will be rounded down to ten figures.)  Numbers are never
actually rounded to the display precision for storage, except by
commands like `C-k' and `C-x * y' which operate on the actual displayed
text in the Calculator buffer.

   The `d .' (`calc-point-char') command selects the character used as
a decimal point.  Normally this is a period; users in some countries
may wish to change this to a comma.  Note that this is only a display
style; on entry, periods must always be used to denote floating-point
numbers, and commas to separate elements in a list.


File: calc,  Node: Complex Formats,  Next: Fraction Formats,  Prev: Float Formats,  Up: Display Modes

8.7.4 Complex Formats
---------------------

There are three supported notations for complex numbers in rectangular
form.  The default is as a pair of real numbers enclosed in parentheses
and separated by a comma: `(a,b)'.  The `d c' (`calc-complex-notation')
command selects this style.

   The other notations are `d i' (`calc-i-notation'), in which numbers
are displayed in `a+bi' form, and `d j' (`calc-j-notation') which
displays the form `a+bj' preferred in some disciplines.

   Complex numbers are normally entered in `(a,b)' format.  If you
enter `2+3i' as an algebraic formula, it will be stored as the formula
`2 + 3 * i'.  However, if you use `=' to evaluate this formula and you
have not changed the variable `i', the `i' will be interpreted as
`(0,1)' and the formula will be simplified to `(2,3)'.  Other commands
(like `calc-sin') will _not_ interpret the formula `2 + 3 * i' as a
complex number.  *Note Variables::, under "special constants."


File: calc,  Node: Fraction Formats,  Next: HMS Formats,  Prev: Complex Formats,  Up: Display Modes

8.7.5 Fraction Formats
----------------------

Display of fractional numbers is controlled by the `d o'
(`calc-over-notation') command.  By default, a number like eight thirds
is displayed in the form `8:3'.  The `d o' command prompts for a one-
or two-character format.  If you give one character, that character is
used as the fraction separator.  Common separators are `:' and `/'.
(During input of numbers, the `:' key must be used regardless of the
display format; in particular, the `/' is used for RPN-style division,
_not_ for entering fractions.)

   If you give two characters, fractions use
"integer-plus-fractional-part" notation.  For example, the format `+/'
would display eight thirds as `2+2/3'.  If two colons are present in a
number being entered, the number is interpreted in this form (so that
the entries `2:2:3' and `8:3' are equivalent).

   It is also possible to follow the one- or two-character format with
a number.  For example:  `:10' or `+/3'.  In this case, Calc adjusts
all fractions that are displayed to have the specified denominator, if
possible.  Otherwise it adjusts the denominator to be a multiple of the
specified value.  For example, in `:6' mode the fraction `1:6' will be
unaffected, but `2:3' will be displayed as `4:6', `1:2' will be
displayed as `3:6', and `1:8' will be displayed as `3:24'.  Integers
are also affected by this mode:  3 is displayed as `18:6'.  Note that
the format `:1' writes fractions the same as `:', but it writes
integers as `n:1'.

   The fraction format does not affect the way fractions or integers are
stored, only the way they appear on the screen.  The fraction format
never affects floats.


File: calc,  Node: HMS Formats,  Next: Date Formats,  Prev: Fraction Formats,  Up: Display Modes

8.7.6 HMS Formats
-----------------

The `d h' (`calc-hms-notation') command controls the display of HMS
(hours-minutes-seconds) forms.  It prompts for a string which consists
basically of an "hours" marker, optional punctuation, a "minutes"
marker, more optional punctuation, and a "seconds" marker.  Punctuation
is zero or more spaces, commas, or semicolons.  The hours marker is one
or more non-punctuation characters.  The minutes and seconds markers
must be single non-punctuation characters.

   The default HMS format is `@ ' "', producing HMS values of the form
`23@ 30' 15.75"'.  The format `deg, ms' would display this same value
as `23deg, 30m15.75s'.  During numeric entry, the `h' or `o' keys are
recognized as synonyms for `@' regardless of display format.  The `m'
and `s' keys are recognized as synonyms for `'' and `"', respectively,
but only if an `@' (or `h' or `o') has already been typed; otherwise,
they have their usual meanings (`m-' prefix and `s-' prefix).  Thus, `5
"', `0 @ 5 "', and `0 h 5 s' are some of the ways to enter the quantity
"five seconds."  The `'' key is recognized as "minutes" only if `@' (or
`h' or `o') has already been pressed; otherwise it means to switch to
algebraic entry.


File: calc,  Node: Date Formats,  Next: Truncating the Stack,  Prev: HMS Formats,  Up: Display Modes

8.7.7 Date Formats
------------------

The `d d' (`calc-date-notation') command controls the display of date
forms (*note Date Forms::).  It prompts for a string which contains
letters that represent the various parts of a date and time.  To show
which parts should be omitted when the form represents a pure date with
no time, parts of the string can be enclosed in `< >' marks.  If you
don't include `< >' markers in the format, Calc guesses at which parts,
if any, should be omitted when formatting pure dates.

   The default format is:  `<H:mm:SSpp >Www Mmm D, YYYY'.  An example
string in this format is `3:32pm Wed Jan 9, 1991'.  If you enter a
blank format string, this default format is reestablished.

   Calc uses `< >' notation for nameless functions as well as for
dates.  *Note Specifying Operators::.  To avoid confusion with nameless
functions, your date formats should avoid using the `#' character.

* Menu:

* Date Formatting Codes::
* Free-Form Dates::
* Standard Date Formats::


File: calc,  Node: Date Formatting Codes,  Next: Free-Form Dates,  Prev: Date Formats,  Up: Date Formats

8.7.7.1 Date Formatting Codes
.............................

When displaying a date, the current date format is used.  All
characters except for letters and `<' and `>' are copied literally when
dates are formatted.  The portion between `< >' markers is omitted for
pure dates, or included for date/time forms.  Letters are interpreted
according to the table below.

   When dates are read in during algebraic entry, Calc first tries to
match the input string to the current format either with or without the
time part.  The punctuation characters (including spaces) must match
exactly; letter fields must correspond to suitable text in the input.
If this doesn't work, Calc checks if the input is a simple number; if
so, the number is interpreted as a number of days since Jan 1, 1 AD.
Otherwise, Calc tries a much more relaxed and flexible algorithm which
is described in the next section.

   Weekday names are ignored during reading.

   Two-digit year numbers are interpreted as lying in the range from
1941 to 2039.  Years outside that range are always entered and
displayed in full.  Year numbers with a leading `+' sign are always
interpreted exactly, allowing the entry and display of the years 1
through 99 AD.

   Here is a complete list of the formatting codes for dates:

Y
     Year:  "91" for 1991, "7" for 2007, "+23" for 23 AD.

YY
     Year:  "91" for 1991, "07" for 2007, "+23" for 23 AD.

BY
     Year:  "91" for 1991, " 7" for 2007, "+23" for 23 AD.

YYY
     Year:  "1991" for 1991, "23" for 23 AD.

YYYY
     Year:  "1991" for 1991, "+23" for 23 AD.

aa
     Year:  "ad" or blank.

AA
     Year:  "AD" or blank.

aaa
     Year:  "ad " or blank.  (Note trailing space.)

AAA
     Year:  "AD " or blank.

aaaa
     Year:  "a.d." or blank.

AAAA
     Year:  "A.D." or blank.

bb
     Year:  "bc" or blank.

BB
     Year:  "BC" or blank.

bbb
     Year:  " bc" or blank.  (Note leading space.)

BBB
     Year:  " BC" or blank.

bbbb
     Year:  "b.c." or blank.

BBBB
     Year:  "B.C." or blank.

M
     Month:  "8" for August.

MM
     Month:  "08" for August.

BM
     Month:  " 8" for August.

MMM
     Month:  "AUG" for August.

Mmm
     Month:  "Aug" for August.

mmm
     Month:  "aug" for August.

MMMM
     Month:  "AUGUST" for August.

Mmmm
     Month:  "August" for August.

D
     Day:  "7" for 7th day of month.

DD
     Day:  "07" for 7th day of month.

BD
     Day:  " 7" for 7th day of month.

W
     Weekday:  "0" for Sunday, "6" for Saturday.

WWW
     Weekday:  "SUN" for Sunday.

Www
     Weekday:  "Sun" for Sunday.

www
     Weekday:  "sun" for Sunday.

WWWW
     Weekday:  "SUNDAY" for Sunday.

Wwww
     Weekday:  "Sunday" for Sunday.

d
     Day of year:  "34" for Feb. 3.

ddd
     Day of year:  "034" for Feb. 3.

bdd
     Day of year:  " 34" for Feb. 3.

h
     Hour:  "5" for 5 AM; "17" for 5 PM.

hh
     Hour:  "05" for 5 AM; "17" for 5 PM.

bh
     Hour:  " 5" for 5 AM; "17" for 5 PM.

H
     Hour:  "5" for 5 AM and 5 PM.

HH
     Hour:  "05" for 5 AM and 5 PM.

BH
     Hour:  " 5" for 5 AM and 5 PM.

p
     AM/PM:  "a" or "p".

P
     AM/PM:  "A" or "P".

pp
     AM/PM:  "am" or "pm".

PP
     AM/PM:  "AM" or "PM".

pppp
     AM/PM:  "a.m." or "p.m.".

PPPP
     AM/PM:  "A.M." or "P.M.".

m
     Minutes:  "7" for 7.

mm
     Minutes:  "07" for 7.

bm
     Minutes:  " 7" for 7.

s
     Seconds:  "7" for 7;  "7.23" for 7.23.

ss
     Seconds:  "07" for 7;  "07.23" for 7.23.

bs
     Seconds:  " 7" for 7;  " 7.23" for 7.23.

SS
     Optional seconds:  "07" for 7;  blank for 0.

BS
     Optional seconds:  " 7" for 7;  blank for 0.

N
     Numeric date/time:  "726842.25" for 6:00am Wed Jan 9, 1991.

n
     Numeric date:  "726842" for any time on Wed Jan 9, 1991.

J
     Julian date/time:  "2448265.75" for 6:00am Wed Jan 9, 1991.

j
     Julian date:  "2448266" for any time on Wed Jan 9, 1991.

U
     Unix time:  "663400800" for 6:00am Wed Jan 9, 1991.

X
     Brackets suppression.  An "X" at the front of the format causes
     the surrounding `< >' delimiters to be omitted when formatting
     dates.  Note that the brackets are still required for algebraic
     entry.

   If "SS" or "BS" (optional seconds) is preceded by a colon, the colon
is also omitted if the seconds part is zero.

   If "bb," "bbb" or "bbbb" or their upper-case equivalents appear in
the format, then negative year numbers are displayed without a minus
sign.  Note that "aa" and "bb" are mutually exclusive.  Some typical
usages would be `YYYY AABB'; `AAAYYYYBBB'; `YYYYBBB'.

   The formats "YY," "YYYY," "MM," "DD," "ddd," "hh," "HH," "mm," "ss,"
and "SS" actually match any number of digits during reading unless
several of these codes are strung together with no punctuation in
between, in which case the input must have exactly as many digits as
there are letters in the format.

   The "j," "J," and "U" formats do not make any time zone adjustment.
They effectively use `julian(x,0)' and `unixtime(x,0)' to make the
conversion; *note Date Arithmetic::.


File: calc,  Node: Free-Form Dates,  Next: Standard Date Formats,  Prev: Date Formatting Codes,  Up: Date Formats

8.7.7.2 Free-Form Dates
.......................

When reading a date form during algebraic entry, Calc falls back on the
algorithm described here if the input does not exactly match the
current date format.  This algorithm generally "does the right thing"
and you don't have to worry about it, but it is described here in full
detail for the curious.

   Calc does not distinguish between upper- and lower-case letters
while interpreting dates.

   First, the time portion, if present, is located somewhere in the
text and then removed.  The remaining text is then interpreted as the
date.

   A time is of the form `hh:mm:ss', possibly with the seconds part
omitted and possibly with an AM/PM indicator added to indicate 12-hour
time.  If the AM/PM is present, the minutes may also be omitted.  The
AM/PM part may be any of the words `am', `pm', `noon', or `midnight';
each of these may be abbreviated to one letter, and the alternate forms
`a.m.', `p.m.', and `mid' are also understood.  Obviously `noon' and
`midnight' are allowed only on 12:00:00.  The words `noon', `mid', and
`midnight' are also recognized with no number attached.

   If there is no AM/PM indicator, the time is interpreted in 24-hour
format.

   To read the date portion, all words and numbers are isolated from
the string; other characters are ignored.  All words must be either
month names or day-of-week names (the latter of which are ignored).
Names can be written in full or as three-letter abbreviations.

   Large numbers, or numbers with `+' or `-' signs, are interpreted as
years.  If one of the other numbers is greater than 12, then that must
be the day and the remaining number in the input is therefore the
month.  Otherwise, Calc assumes the month, day and year are in the same
order that they appear in the current date format.  If the year is
omitted, the current year is taken from the system clock.

   If there are too many or too few numbers, or any unrecognizable
words, then the input is rejected.

   If there are any large numbers (of five digits or more) other than
the year, they are ignored on the assumption that they are something
like Julian dates that were included along with the traditional date
components when the date was formatted.

   One of the words `ad', `a.d.', `bc', or `b.c.' may optionally be
used; the latter two are equivalent to a minus sign on the year value.

   If you always enter a four-digit year, and use a name instead of a
number for the month, there is no danger of ambiguity.


File: calc,  Node: Standard Date Formats,  Prev: Free-Form Dates,  Up: Date Formats

8.7.7.3 Standard Date Formats
.............................

There are actually ten standard date formats, numbered 0 through 9.
Entering a blank line at the `d d' command's prompt gives you format
number 1, Calc's usual format.  You can enter any digit to select the
other formats.

   To create your own standard date formats, give a numeric prefix
argument from 0 to 9 to the `d d' command.  The format you enter will
be recorded as the new standard format of that number, as well as
becoming the new current date format.  You can save your formats
permanently with the `m m' command (*note Mode Settings::).

0
     `N'  (Numerical format)

1
     `<H:mm:SSpp >Www Mmm D, YYYY'  (American format)

2
     `D Mmm YYYY<, h:mm:SS>'  (European format)

3
     `Www Mmm BD< hh:mm:ss> YYYY'  (Unix written date format)

4
     `M/D/Y< H:mm:SSpp>'  (American slashed format)

5
     `D.M.Y< h:mm:SS>'  (European dotted format)

6
     `M-D-Y< H:mm:SSpp>'  (American dashed format)

7
     `D-M-Y< h:mm:SS>'  (European dashed format)

8
     `j<, h:mm:ss>'  (Julian day plus time)

9
     `YYddd< hh:mm:ss>'  (Year-day format)


File: calc,  Node: Truncating the Stack,  Next: Justification,  Prev: Date Formats,  Up: Display Modes

8.7.8 Truncating the Stack
--------------------------

The `d t' (`calc-truncate-stack') command moves the `.' line that marks
the top-of-stack up or down in the Calculator buffer.  The number right
above that line is considered to the be at the top of the stack.  Any
numbers below that line are "hidden" from all stack operations
(although still visible to the user).  This is similar to the Emacs
"narrowing" feature, except that the values below the `.' are
_visible_, just temporarily frozen.  This feature allows you to keep
several independent calculations running at once in different parts of
the stack, or to apply a certain command to an element buried deep in
the stack.

   Pressing `d t' by itself moves the `.' to the line the cursor is on.
Thus, this line and all those below it become hidden.  To un-hide these
lines, move down to the end of the buffer and press `d t'.  With a
positive numeric prefix argument `n', `d t' hides the bottom `n' values
in the buffer.  With a negative argument, it hides all but the top `n'
values.  With an argument of zero, it hides zero values, i.e., moves
the `.' all the way down to the bottom.

   The `d [' (`calc-truncate-up') and `d ]' (`calc-truncate-down')
commands move the `.' up or down one line at a time (or several lines
with a prefix argument).


File: calc,  Node: Justification,  Next: Labels,  Prev: Truncating the Stack,  Up: Display Modes

8.7.9 Justification
-------------------

Values on the stack are normally left-justified in the window.  You can
control this arrangement by typing `d <' (`calc-left-justify'), `d >'
(`calc-right-justify'), or `d =' (`calc-center-justify').  For example,
in Right-Justification mode, stack entries are displayed flush-right
against the right edge of the window.

   If you change the width of the Calculator window you may have to type
`d <SPC>' (`calc-refresh') to re-align right-justified or centered text.

   Right-justification is especially useful together with fixed-point
notation (see `d f'; `calc-fix-notation').  With these modes together,
the decimal points on numbers will always line up.

   With a numeric prefix argument, the justification commands give you
a little extra control over the display.  The argument specifies the
horizontal "origin" of a display line.  It is also possible to specify
a maximum line width using the `d b' command (*note Normal Language
Modes::).  For reference, the precise rules for formatting and breaking
lines are given below.  Notice that the interaction between origin and
line width is slightly different in each justification mode.

   In Left-Justified mode, the line is indented by a number of spaces
given by the origin (default zero).  If the result is longer than the
maximum line width, if given, or too wide to fit in the Calc window
otherwise, then it is broken into lines which will fit; each broken
line is indented to the origin.

   In Right-Justified mode, lines are shifted right so that the
rightmost character is just before the origin, or just before the
current window width if no origin was specified.  If the line is too
long for this, then it is broken; the current line width is used, if
specified, or else the origin is used as a width if that is specified,
or else the line is broken to fit in the window.

   In Centering mode, the origin is the column number of the center of
each stack entry.  If a line width is specified, lines will not be
allowed to go past that width; Calc will either indent less or break
the lines if necessary.  If no origin is specified, half the line width
or Calc window width is used.

   Note that, in each case, if line numbering is enabled the display is
indented an additional four spaces to make room for the line number.
The width of the line number is taken into account when positioning
according to the current Calc window width, but not when positioning by
explicit origins and widths.  In the latter case, the display is
formatted as specified, and then uniformly shifted over four spaces to
fit the line numbers.


File: calc,  Node: Labels,  Prev: Justification,  Up: Display Modes

8.7.10 Labels
-------------

The `d {' (`calc-left-label') command prompts for a string, then
displays that string to the left of every stack entry.  If the entries
are left-justified (*note Justification::), then they will appear
immediately after the label (unless you specified an origin greater
than the length of the label).  If the entries are centered or
right-justified, the label appears on the far left and does not affect
the horizontal position of the stack entry.

   Give a blank string (with `d { <RET>') to turn the label off.

   The `d }' (`calc-right-label') command similarly adds a label on the
righthand side.  It does not affect positioning of the stack entries
unless they are right-justified.  Also, if both a line width and an
origin are given in Right-Justified mode, the stack entry is justified
to the origin and the righthand label is justified to the line width.

   One application of labels would be to add equation numbers to
formulas you are manipulating in Calc and then copying into a document
(possibly using Embedded mode).  The equations would typically be
centered, and the equation numbers would be on the left or right as you
prefer.


File: calc,  Node: Language Modes,  Next: Modes Variable,  Prev: Display Modes,  Up: Mode Settings

8.8 Language Modes
==================

The commands in this section change Calc to use a different notation for
entry and display of formulas, corresponding to the conventions of some
other common language such as Pascal or LaTeX.  Objects displayed on the
stack or yanked from the Calculator to an editing buffer will be
formatted in the current language; objects entered in algebraic entry
or yanked from another buffer will be interpreted according to the
current language.

   The current language has no effect on things written to or read from
the trail buffer, nor does it affect numeric entry.  Only algebraic
entry is affected.  You can make even algebraic entry ignore the
current language and use the standard notation by giving a numeric
prefix, e.g., `C-u ''.

   For example, suppose the formula `2*a[1] + atan(a[2])' occurs in a C
program; elsewhere in the program you need the derivatives of this
formula with respect to `a[1]' and `a[2]'.  First, type `d C' to switch
to C notation.  Now use `C-u C-x * g' to grab the formula into the
Calculator, `a d a[1] <RET>' to differentiate with respect to the first
variable, and `C-x * y' to yank the formula for the derivative back
into your C program.  Press `U' to undo the differentiation and repeat
with `a d a[2] <RET>' for the other derivative.

   Without being switched into C mode first, Calc would have
misinterpreted the brackets in `a[1]' and `a[2]', would not have known
that `atan' was equivalent to Calc's built-in `arctan' function, and
would have written the formula back with notations (like implicit
multiplication) which would not have been valid for a C program.

   As another example, suppose you are maintaining a C program and a
LaTeX document, each of which needs a copy of the same formula.  You
can grab the formula from the program in C mode, switch to LaTeX mode,
and yank the formula into the document in LaTeX math-mode format.

   Language modes are selected by typing the letter `d' followed by a
shifted letter key.

* Menu:

* Normal Language Modes::
* C FORTRAN Pascal::
* TeX and LaTeX Language Modes::
* Eqn Language Mode::
* Yacas Language Mode::
* Maxima Language Mode::
* Giac Language Mode::
* Mathematica Language Mode::
* Maple Language Mode::
* Compositions::
* Syntax Tables::


File: calc,  Node: Normal Language Modes,  Next: C FORTRAN Pascal,  Prev: Language Modes,  Up: Language Modes

8.8.1 Normal Language Modes
---------------------------

The `d N' (`calc-normal-language') command selects the usual notation
for Calc formulas, as described in the rest of this manual.  Matrices
are displayed in a multi-line tabular format, but all other objects are
written in linear form, as they would be typed from the keyboard.

   The `d O' (`calc-flat-language') command selects a language
identical with the normal one, except that matrices are written in
one-line form along with everything else.  In some applications this
form may be more suitable for yanking data into other buffers.

   Even in one-line mode, long formulas or vectors will still be split
across multiple lines if they exceed the width of the Calculator window.
The `d b' (`calc-line-breaking') command turns this line-breaking
feature on and off.  (It works independently of the current language.)
If you give a numeric prefix argument of five or greater to the `d b'
command, that argument will specify the line width used when breaking
long lines.

   The `d B' (`calc-big-language') command selects a language which
uses textual approximations to various mathematical notations, such as
powers, quotients, and square roots:

       ____________
      | a + 1    2
      | ----- + c
     \|   b

in place of `sqrt((a+1)/b + c^2)'.

   Subscripts like `a_i' are displayed as actual subscripts in Big
mode.  Double subscripts, `a_i_j' (`subscr(subscr(a, i), j)') are
displayed as `a' with subscripts separated by commas: `i, j'.  They
must still be entered in the usual underscore notation.

   One slight ambiguity of Big notation is that

       3
     - -
       4

can represent either the negative rational number `-3:4', or the actual
expression `-(3/4)'; but the latter formula would normally never be
displayed because it would immediately be evaluated to `-3:4' or
`-0.75', so this ambiguity is not a problem in typical use.

   Non-decimal numbers are displayed with subscripts.  Thus there is no
way to tell the difference between `16#C2' and `C2_16', though
generally you will know which interpretation is correct.  Logarithms
`log(x,b)' and `log10(x)' also use subscripts in Big mode.

   In Big mode, stack entries often take up several lines.  To aid
readability, stack entries are separated by a blank line in this mode.
You may find it useful to expand the Calc window's height using `C-x ^'
(`enlarge-window') or to make the Calc window the only one on the
screen with `C-x 1' (`delete-other-windows').

   Long lines are currently not rearranged to fit the window width in
Big mode, so you may need to use the `<' and `>' keys to scroll across
a wide formula.  For really big formulas, you may even need to use `{'
and `}' to scroll up and down.

   The `d U' (`calc-unformatted-language') command altogether disables
the use of operator notation in formulas.  In this mode, the formula
shown above would be displayed:

     sqrt(add(div(add(a, 1), b), pow(c, 2)))

   These four modes differ only in display format, not in the format
expected for algebraic entry.  The standard Calc operators work in all
four modes, and unformatted notation works in any language mode (except
that Mathematica mode expects square brackets instead of parentheses).


File: calc,  Node: C FORTRAN Pascal,  Next: TeX and LaTeX Language Modes,  Prev: Normal Language Modes,  Up: Language Modes

8.8.2 C, FORTRAN, and Pascal Modes
----------------------------------

The `d C' (`calc-c-language') command selects the conventions of the C
language for display and entry of formulas.  This differs from the
normal language mode in a variety of (mostly minor) ways.  In
particular, C language operators and operator precedences are used in
place of Calc's usual ones.  For example, `a^b' means `xor(a,b)' in C
mode; a value raised to a power is written as a function call,
`pow(a,b)'.

   In C mode, vectors and matrices use curly braces instead of brackets.
Octal and hexadecimal values are written with leading `0' or `0x'
rather than using the `#' symbol.  Array subscripting is translated
into `subscr' calls, so that `a[i]' in C mode is the same as `a_i' in
Normal mode.  Assignments turn into the `assign' function, which Calc
normally displays using the `:=' symbol.

   The variables `pi' and `e' would be displayed `pi' and `e' in Normal
mode, but in C mode they are displayed as `M_PI' and `M_E',
corresponding to the names of constants typically provided in the
`<math.h>' header.  Functions whose names are different in C are
translated automatically for entry and display purposes.  For example,
entering `asin(x)' will push the formula `arcsin(x)' onto the stack;
this formula will be displayed as `asin(x)' as long as C mode is in
effect.

   The `d P' (`calc-pascal-language') command selects Pascal
conventions.  Like C mode, Pascal mode interprets array brackets and
uses a different table of operators.  Hexadecimal numbers are entered
and displayed with a preceding dollar sign.  (Thus the regular meaning
of `$2' during algebraic entry does not work in Pascal mode, though `$'
(and `$$', etc.) not followed by digits works the same as always.)  No
special provisions are made for other non-decimal numbers, vectors, and
so on, since there is no universally accepted standard way of handling
these in Pascal.

   The `d F' (`calc-fortran-language') command selects FORTRAN
conventions.  Various function names are transformed into FORTRAN
equivalents.  Vectors are written as `/1, 2, 3/', and may be entered
this way or using square brackets.  Since FORTRAN uses round
parentheses for both function calls and array subscripts, Calc displays
both in the same way; `a(i)' is interpreted as a function call upon
reading, and subscripts must be entered as `subscr(a, i)'.  If the
variable `a' has been declared to have type `vector' or `matrix',
however,  then `a(i)' will be parsed as a subscript.  (*Note
Declarations::.)  Usually it doesn't matter, though; if you enter the
subscript expression `a(i)' and Calc interprets it as a function call,
you'll never know the difference unless you switch to another language
mode or replace `a' with an actual vector (or unless `a' happens to be
the name of a built-in function!).

   Underscores are allowed in variable and function names in all of
these language modes.  The underscore here is equivalent to the `#' in
Normal mode, or to hyphens in the underlying Emacs Lisp variable names.

   FORTRAN and Pascal modes normally do not adjust the case of letters
in formulas.  Most built-in Calc names use lower-case letters.  If you
use a positive numeric prefix argument with `d P' or `d F', these modes
will use upper-case letters exclusively for display, and will convert
to lower-case on input.  With a negative prefix, these modes convert to
lower-case for display and input.


File: calc,  Node: TeX and LaTeX Language Modes,  Next: Eqn Language Mode,  Prev: C FORTRAN Pascal,  Up: Language Modes

8.8.3 TeX and LaTeX Language Modes
----------------------------------

The `d T' (`calc-tex-language') command selects the conventions of
"math mode" in Donald Knuth's TeX typesetting language, and the `d L'
(`calc-latex-language') command selects the conventions of "math mode"
in LaTeX, a typesetting language that uses TeX as its formatting
engine.  Calc's LaTeX language mode can read any formula that the TeX
language mode can, although LaTeX mode may display it differently.

   Formulas are entered and displayed in the appropriate notation;
`sin(a/b)' will appear as `\sin\left( {a \over b} \right)' in TeX mode
and `\sin\left(\frac{a}{b}\right)' in LaTeX mode.  Math formulas are
often enclosed by `$ $' signs in TeX and LaTeX; these should be omitted
when interfacing with Calc.  To Calc, the `$' sign has the same meaning
it always does in algebraic formulas (a reference to an existing entry
on the stack).

   Complex numbers are displayed as in `3 + 4i'.  Fractions and
quotients are written using `\over' in TeX mode (as in `{a \over b}')
and `\frac' in LaTeX mode (as in `\frac{a}{b}');  binomial coefficients
are written with `\choose' in TeX mode (as in `{a \choose b}') and
`\binom' in LaTeX mode (as in `\binom{a}{b}').  Interval forms are
written with `\ldots', and error forms are written with `\pm'. Absolute
values are written as in `|x + 1|', and the floor and ceiling functions
are written with `\lfloor', `\rfloor', etc. The words `\left' and
`\right' are ignored when reading formulas in TeX and LaTeX modes.
Both `inf' and `uinf' are written as `\infty'; when read, `\infty'
always translates to `inf'.

   Function calls are written the usual way, with the function name
followed by the arguments in parentheses.  However, functions for which
TeX and LaTeX have special names (like `\sin') will use curly braces
instead of parentheses for very simple arguments.  During input, curly
braces and parentheses work equally well for grouping, but when the
document is formatted the curly braces will be invisible.  Thus the
printed result is `sin 2x' but `sin(2 + x)'.

   The TeX specific unit names (*note Predefined Units::) will not use
the `tex' prefix;  the unit name for a TeX point will be `pt' instead
of `texpt', for example.

   Function and variable names not treated specially by TeX and LaTeX
are simply written out as-is, which will cause them to come out in
italic letters in the printed document.  If you invoke `d T' or `d L'
with a positive numeric prefix argument, names of more than one
character will instead be enclosed in a protective commands that will
prevent them from being typeset in the math italics; they will be
written `\hbox{NAME}' in TeX mode and `\text{NAME}' in LaTeX mode.  The
`\hbox{ }' and `\text{ }' notations are ignored during reading.  If you
use a negative prefix argument, such function names are written
`\NAME', and function names that begin with `\' during reading have the
`\' removed.  (Note that in this mode, long variable names are still
written with `\hbox' or `\text'.  However, you can always make an
actual variable name like `\bar' in any TeX mode.)

   During reading, text of the form `\matrix{ ... }' is replaced by `[
... ]'.  The same also applies to `\pmatrix' and `\bmatrix'.  In LaTeX
mode this also applies to `\begin{matrix} ... \end{matrix}',
`\begin{bmatrix} ... \end{bmatrix}', `\begin{pmatrix} ...
\end{pmatrix}', as well as `\begin{smallmatrix} ... \end{smallmatrix}'.
The symbol `&' is interpreted as a comma, and the symbols `\cr' and
`\\' are interpreted as semicolons.  During output, matrices are
displayed in `\matrix{ a & b \\ c & d}' format in TeX mode and in
`\begin{pmatrix} a & b \\ c & d \end{pmatrix}' format in LaTeX mode;
you may need to edit this afterwards to change to your preferred matrix
form.  If you invoke `d T' or `d L' with an argument of 2 or -2, then
matrices will be displayed in two-dimensional form, such as

     \begin{pmatrix}
     a & b \\
     c & d
     \end{pmatrix}

This may be convenient for isolated matrices, but could lead to
expressions being displayed like

     \begin{pmatrix} \times x
     a & b \\
     c & d
     \end{pmatrix}

While this wouldn't bother Calc, it is incorrect LaTeX.  (Similarly for
TeX.)

   Accents like `\tilde' and `\bar' translate into function calls
internally (`tilde(x)', `bar(x)').  The `\underline' sequence is
treated as an accent.  The `\vec' accent corresponds to the function
name `Vec', because `vec' is the name of a built-in Calc function.  The
following table shows the accents in Calc, TeX, LaTeX and "eqn"
(described in the next section):

     Calc      TeX           LaTeX         eqn
     ----      ---           -----         ---
     acute     \acute        \acute
     Acute                   \Acute
     bar       \bar          \bar          bar
     Bar                     \Bar
     breve     \breve        \breve
     Breve                   \Breve
     check     \check        \check
     Check                   \Check
     dddot                   \dddot
     ddddot                  \ddddot
     dot       \dot          \dot          dot
     Dot                     \Dot
     dotdot    \ddot         \ddot         dotdot
     DotDot                  \Ddot
     dyad                                  dyad
     grave     \grave        \grave
     Grave                   \Grave
     hat       \hat          \hat          hat
     Hat                     \Hat
     Prime                                 prime
     tilde     \tilde        \tilde        tilde
     Tilde                   \Tilde
     under     \underline    \underline    under
     Vec       \vec          \vec          vec
     VEC                     \Vec

   The `=>' (evaluates-to) operator appears as a `\to' symbol: `{A \to
B}'.  TeX defines `\to' as an alias for `\rightarrow'.  However, if the
`=>' is the top-level expression being formatted, a slightly different
notation is used:  `\evalto A \to B'.  The `\evalto' word is ignored by
Calc's input routines, and is undefined in TeX.  You will typically
want to include one of the following definitions at the top of a TeX
file that uses `\evalto':

     \def\evalto{}
     \def\evalto#1\to{}

   The first definition formats evaluates-to operators in the usual
way.  The second causes only the B part to appear in the printed
document; the A part and the arrow are hidden.  Another definition you
may wish to use is `\let\to=\Rightarrow' which causes `\to' to appear
more like Calc's `=>' symbol.  *Note Evaluates-To Operator::, for a
discussion of `evalto'.

   The complete set of TeX control sequences that are ignored during
reading is:

     \hbox  \mbox  \text  \left  \right
     \,  \>  \:  \;  \!  \quad  \qquad  \hfil  \hfill
     \displaystyle  \textstyle  \dsize  \tsize
     \scriptstyle  \scriptscriptstyle  \ssize  \ssize
     \rm  \bf  \it  \sl  \roman  \bold  \italic  \slanted
     \cal  \mit  \Cal  \Bbb  \frak  \goth
     \evalto

   Note that, because these symbols are ignored, reading a TeX or LaTeX
formula into Calc and writing it back out may lose spacing and font
information.

   Also, the "discretionary multiplication sign" `\*' is read the same
as `*'.

   The TeX version of this manual includes some printed examples at the
end of this section.


File: calc,  Node: Eqn Language Mode,  Next: Yacas Language Mode,  Prev: TeX and LaTeX Language Modes,  Up: Language Modes

8.8.4 Eqn Language Mode
-----------------------

"Eqn" is another popular formatter for math formulas.  It is designed
for use with the TROFF text formatter, and comes standard with many
versions of Unix.  The `d E' (`calc-eqn-language') command selects
"eqn" notation.

   The "eqn" language's main idiosyncrasy is that whitespace plays a
significant part in the parsing of the language.  For example, `sqrt
x+1 + y' treats `x+1' as the argument of the `sqrt' operator.  "Eqn"
also understands more conventional grouping using curly braces:
`sqrt{x+1} + y'.  Braces are required only when the argument contains
spaces.

   In Calc's "eqn" mode, however, curly braces are required to delimit
arguments of operators like `sqrt'.  The first of the above examples
would treat only the `x' as the argument of `sqrt', and in fact `sin
x+1' would be interpreted as `sin * x + 1', because `sin' is not a
special operator in the "eqn" language.  If you always surround the
argument with curly braces, Calc will never misunderstand.

   Calc also understands parentheses as grouping characters.  Another
peculiarity of "eqn"'s syntax makes it advisable to separate words with
spaces from any surrounding characters that aren't curly braces, so
Calc writes `sin ( x + y )' in "eqn" mode.  (The spaces around `sin'
are important to make "eqn" recognize that `sin' should be typeset in a
roman font, and the spaces around `x' and `y' are a good idea just in
case the "eqn" document has defined special meanings for these names,
too.)

   Powers and subscripts are written with the `sub' and `sup'
operators, respectively.  Note that the caret symbol `^' is treated the
same as a space in "eqn" mode, as is the `~' symbol (these are used to
introduce spaces of various widths into the typeset output of "eqn").

   As in LaTeX mode, Calc's formatter omits parentheses around the
arguments of functions like `ln' and `sin' if they are
"simple-looking"; in this case Calc surrounds the argument with braces,
separated by a `~' from the function name: `sin~{x}'.

   Font change codes (like `roman X') and positioning codes (like `~'
and `down N X') are ignored by the "eqn" reader.  Also ignored are the
words `left', `right', `mark', and `lineup'.  Quotation marks in "eqn"
mode input are treated the same as curly braces: `sqrt "1+x"' is
equivalent to `sqrt {1+x}'; this is only an approximation to the true
meaning of quotes in "eqn", but it is good enough for most uses.

   Accent codes (`X dot') are handled by treating them as function
calls (`dot(X)') internally.  *Note TeX and LaTeX Language Modes::, for
a table of these accent functions.  The `prime' accent is treated
specially if it occurs on a variable or function name: `f prime prime
( x prime )' is stored internally as `f''(x')'.  For example, taking the
derivative of `f(2 x)' with `a d x' will produce `2 f'(2 x)', which
"eqn" mode will display as `2 f prime ( 2 x )'.

   Assignments are written with the `<-' (left-arrow) symbol, and
`evalto' operators are written with `->' or `evalto ... ->' (*note TeX
and LaTeX Language Modes::, for a discussion of this).  The regular
Calc symbols `:=' and `=>' are also recognized for these operators
during reading.

   Vectors in "eqn" mode use regular Calc square brackets, but matrices
are formatted as `matrix { ccol { a above b } ... }'.  The words `lcol'
and `rcol' are recognized as synonyms for `ccol' during input, and are
generated instead of `ccol' if the matrix justification mode so
specifies.


File: calc,  Node: Yacas Language Mode,  Next: Maxima Language Mode,  Prev: Eqn Language Mode,  Up: Language Modes

8.8.5 Yacas Language Mode
-------------------------

The `d Y' (`calc-yacas-language') command selects the conventions of
Yacas, a free computer algebra system.  While the operators and
functions in Yacas are similar to those of Calc, the names of built-in
functions in Yacas are capitalized.  The Calc formula `sin(2 x)', for
example, is entered and displayed `Sin(2 x)' in Yacas mode,  and
``arcsin(x^2)' is `ArcSin(x^2)' in Yacas mode.  Complex numbers are
written  are written `3 + 4 I'.  The standard special constants are
written `Pi', `E', `I', `GoldenRatio' and `Gamma'.  `Infinity'
represents both `inf' and `uinf', and `Undefined' represents `nan'.

   Certain operators on functions, such as `D' for differentiation and
`Integrate' for integration, take a prefix form in Yacas.  For example,
the derivative of `e^x sin(x)' can be computed with
`D(x) Exp(x)*Sin(x)'.

   Other notable differences between Yacas and standard Calc expressions
are that vectors and matrices use curly braces in Yacas, and subscripts
use square brackets.  If, for example, `A' represents the list
`{a,2,c,4}', then `A[3]' would equal `c'.


File: calc,  Node: Maxima Language Mode,  Next: Giac Language Mode,  Prev: Yacas Language Mode,  Up: Language Modes

8.8.6 Maxima Language Mode
--------------------------

The `d X' (`calc-maxima-language') command selects the conventions of
Maxima, another free computer algebra system.  The function names in
Maxima are similar, but not always identical, to Calc.  For example,
instead of `arcsin(x)', Maxima will use `asin(x)'.  Complex numbers are
written `3 + 4 %i'.  The standard special constants are written `%pi',
`%e', `%i', `%phi' and `%gamma'.  In Maxima,  `inf' means the same as
in Calc, but `infinity' represents Calc's `uinf'.

   Underscores as well as percent signs are allowed in function and
variable names in Maxima mode.  The underscore again is equivalent to
the `#' in Normal mode, and the percent sign is equivalent to `o'o'.

   Maxima uses square brackets for lists and vectors, and matrices are
written as calls to the function `matrix', given the row vectors of the
matrix as arguments.  Square brackets are also used as subscripts.


File: calc,  Node: Giac Language Mode,  Next: Mathematica Language Mode,  Prev: Maxima Language Mode,  Up: Language Modes

8.8.7 Giac Language Mode
------------------------

The `d A' (`calc-giac-language') command selects the conventions of
Giac, another free computer algebra system.  The function names in Giac
are similar to Maxima.  Complex numbers are written `3 + 4 i'.  The
standard special constants in Giac are the same as in Calc, except that
`infinity' represents both Calc's `inf' and `uinf'.

   Underscores are allowed in function and variable names in Giac mode.
Brackets are used for subscripts.  In Giac, indexing of lists begins at
0, instead of 1 as in Calc.  So if  `A' represents the list
`[a,2,c,4]', then `A[2]' would equal `c'.  In general, `A[n]' in Giac
mode corresponds to `A_(n+1)' in Normal mode.

   The Giac interval notation `2 .. 3' has no surrounding brackets;
Calc reads `2 .. 3' as the closed interval `[2 .. 3]' and writes any
kind of interval as `2 .. 3'.  This means you cannot see the difference
between an open and a closed interval while in Giac mode.


File: calc,  Node: Mathematica Language Mode,  Next: Maple Language Mode,  Prev: Giac Language Mode,  Up: Language Modes

8.8.8 Mathematica Language Mode
-------------------------------

The `d M' (`calc-mathematica-language') command selects the conventions
of Mathematica.  Notable differences in Mathematica mode are that the
names of built-in functions are capitalized, and function calls use
square brackets instead of parentheses.  Thus the Calc formula `sin(2
x)' is entered and displayed `Sin[2 x]' in Mathematica mode.

   Vectors and matrices use curly braces in Mathematica.  Complex
numbers are written `3 + 4 I'.  The standard special constants in Calc
are written `Pi', `E', `I', `GoldenRatio', `EulerGamma', `Infinity',
`ComplexInfinity', and `Indeterminate' in Mathematica mode.
Non-decimal numbers are written, e.g., `16^^7fff'.  Floating-point
numbers in scientific notation are written `1.23*10.^3'.  Subscripts
use double square brackets: `a[[i]]'.


File: calc,  Node: Maple Language Mode,  Next: Compositions,  Prev: Mathematica Language Mode,  Up: Language Modes

8.8.9 Maple Language Mode
-------------------------

The `d W' (`calc-maple-language') command selects the conventions of
Maple.

   Maple's language is much like C.  Underscores are allowed in symbol
names; square brackets are used for subscripts; explicit `*'s for
multiplications are required.  Use either `^' or `**' to denote powers.

   Maple uses square brackets for lists and curly braces for sets.  Calc
interprets both notations as vectors, and displays vectors with square
brackets.  This means Maple sets will be converted to lists when they
pass through Calc.  As a special case, matrices are written as calls to
the function `matrix', given a list of lists as the argument, and can
be read in this form or with all-capitals `MATRIX'.

   The Maple interval notation `2 .. 3' is like Giac's interval
notation, and is handled the same by Calc.

   Maple writes complex numbers as `3 + 4*I'.  Its special constants
are `Pi', `E', `I', and `infinity' (all three of `inf', `uinf', and
`nan' display as `infinity').  Floating-point numbers are written
`1.23*10.^3'.

   Among things not currently handled by Calc's Maple mode are the
various quote symbols, procedures and functional operators, and inert
(`&') operators.


File: calc,  Node: Compositions,  Next: Syntax Tables,  Prev: Maple Language Mode,  Up: Language Modes

8.8.10 Compositions
-------------------

There are several "composition functions" which allow you to get
displays in a variety of formats similar to those in Big language mode.
Most of these functions do not evaluate to anything; they are
placeholders which are left in symbolic form by Calc's evaluator but
are recognized by Calc's display formatting routines.

   Two of these, `string' and `bstring', are described elsewhere.
*Note Strings::.  For example, `string("ABC")' is displayed as `ABC'.
When viewed on the stack it will be indistinguishable from the variable
`ABC', but internally it will be stored as `string([65, 66, 67])' and
can still be manipulated this way; for example, the selection and
vector commands `j 1 v v j u' would select the vector portion of this
object and reverse the elements, then deselect to reveal a string whose
characters had been reversed.

   The composition functions do the same thing in all language modes
(although their components will of course be formatted in the current
language mode).  The one exception is Unformatted mode (`d U'), which
does not give the composition functions any special treatment.  The
functions are discussed here because of their relationship to the
language modes.

* Menu:

* Composition Basics::
* Horizontal Compositions::
* Vertical Compositions::
* Other Compositions::
* Information about Compositions::
* User-Defined Compositions::


File: calc,  Node: Composition Basics,  Next: Horizontal Compositions,  Prev: Compositions,  Up: Compositions

8.8.10.1 Composition Basics
...........................

Compositions are generally formed by stacking formulas together
horizontally or vertically in various ways.  Those formulas are
themselves compositions.  TeX users will find this analogous to TeX's
"boxes."  Each multi-line composition has a "baseline"; horizontal
compositions use the baselines to decide how formulas should be
positioned relative to one another.  For example, in the Big mode
formula

               2
          a + b
     17 + ------
            c

the second term of the sum is four lines tall and has line three as its
baseline.  Thus when the term is combined with 17, line three is placed
on the same level as the baseline of 17.

   Another important composition concept is "precedence".  This is an
integer that represents the binding strength of various operators.  For
example, `*' has higher precedence (195) than `+' (180), which means
that `(a * b) + c' will be formatted without the parentheses, but `a *
(b + c)' will keep the parentheses.

   The operator table used by normal and Big language modes has the
following precedences:

     _     1200    (subscripts)
     %     1100    (as in n%)
     !     1000    (as in !n)
     mod    400
     +/-    300
     !!     210    (as in n!!)
     !      210    (as in n!)
     ^      200
     -      197    (as in -n)
     *      195    (or implicit multiplication)
     / % \  190
     + -    180    (as in a+b)
     |      170
     < =    160    (and other relations)
     &&     110
     ||     100
     ? :     90
     !!!     85
     &&&     80
     |||     75
     :=      50
     ::      45
     =>      40

   The general rule is that if an operator with precedence `n' occurs
as an argument to an operator with precedence `m', then the argument is
enclosed in parentheses if `n < m'.  Top-level expressions and
expressions which are function arguments, vector components, etc., are
formatted with precedence zero (so that they normally never get
additional parentheses).

   For binary left-associative operators like `+', the righthand
argument is actually formatted with one-higher precedence than shown in
the table.  This makes sure `(a + b) + c' omits the parentheses, but
the unnatural form `a + (b + c)' keeps its parentheses.
Right-associative operators like `^' format the lefthand argument with
one-higher precedence.

   The `cprec' function formats an expression with an arbitrary
precedence.  For example, `cprec(abc, 185)' will combine into sums and
products as follows:  `7 + abc', `7 (abc)' (because this `cprec' form
has higher precedence than addition, but lower precedence than
multiplication).

   A final composition issue is "line breaking".  Calc uses two
different strategies for "flat" and "non-flat" compositions.  A
non-flat composition is anything that appears on multiple lines (not
counting line breaking).  Examples would be matrices and Big mode
powers and quotients.  Non-flat compositions are displayed exactly as
specified.  If they come out wider than the current window, you must
use horizontal scrolling (`<' and `>') to view them.

   Flat compositions, on the other hand, will be broken across several
lines if they are too wide to fit the window.  Certain points in a
composition are noted internally as "break points".  Calc's general
strategy is to fill each line as much as possible, then to move down to
the next line starting at the first break point that didn't fit.
However, the line breaker understands the hierarchical structure of
formulas.  It will not break an "inner" formula if it can use an
earlier break point from an "outer" formula instead.  For example, a
vector of sums might be formatted as:

     [ a + b + c, d + e + f,
       g + h + i, j + k + l, m ]

If the `m' can fit, then so, it seems, could the `g'.  But Calc prefers
to break at the comma since the comma is part of a "more outer"
formula.  Calc would break at a plus sign only if it had to, say, if
the very first sum in the vector had itself been too large to fit.

   Of the composition functions described below, only `choriz'
generates break points.  The `bstring' function (*note Strings::) also
generates breakable items:  A break point is added after every space
(or group of spaces) except for spaces at the very beginning or end of
the string.

   Composition functions themselves count as levels in the formula
hierarchy, so a `choriz' that is a component of a larger `choriz' will
be less likely to be broken.  As a special case, if a `bstring' occurs
as a component of a `choriz' or `choriz'-like object (such as a vector
or a list of arguments in a function call), then the break points in
that `bstring' will be on the same level as the break points of the
surrounding object.


File: calc,  Node: Horizontal Compositions,  Next: Vertical Compositions,  Prev: Composition Basics,  Up: Compositions

8.8.10.2 Horizontal Compositions
................................

The `choriz' function takes a vector of objects and composes them
horizontally.  For example, `choriz([17, a b/c, d])' formats as
`17a b / cd' in Normal language mode, or as

       a b
     17---d
        c

in Big language mode.  This is actually one case of the general
function `choriz(VEC, SEP, PREC)', where either or both of SEP and PREC
may be omitted.  PREC gives the "precedence" to use when formatting
each of the components of VEC.  The default precedence is the
precedence from the surrounding environment.

   SEP is a string (i.e., a vector of character codes as might be
entered with `" "' notation) which should separate components of the
composition.  Also, if SEP is given, the line breaker will allow lines
to be broken after each occurrence of SEP.  If SEP is omitted, the
composition will not be breakable (unless any of its component
compositions are breakable).

   For example, `2 choriz([a, b c, d = e], " + ", 180)' is formatted as
`2 a + b c + (d = e)'.  To get the `choriz' to have precedence 180
"outwards" as well as "inwards," enclose it in a `cprec' form:  `2
cprec(choriz(...), 180)' formats as `2 (a + b c + (d = e))'.

   The baseline of a horizontal composition is the same as the
baselines of the component compositions, which are all aligned.


File: calc,  Node: Vertical Compositions,  Next: Other Compositions,  Prev: Horizontal Compositions,  Up: Compositions

8.8.10.3 Vertical Compositions
..............................

The `cvert' function makes a vertical composition.  Each component of
the vector is centered in a column.  The baseline of the result is by
default the top line of the resulting composition.  For example,
`f(cvert([a, bb, ccc]), cvert([a^2 + 1, b^2]))' formats in Big mode as

     f( a ,  2    )
       bb   a  + 1
       ccc     2
              b

   There are several special composition functions that work only as
components of a vertical composition.  The `cbase' function controls
the baseline of the vertical composition; the baseline will be the same
as the baseline of whatever component is enclosed in `cbase'.  Thus
`f(cvert([a, cbase(bb), ccc]), cvert([a^2 + 1, cbase(b^2)]))' displays
as

             2
            a  + 1
        a      2
     f(bb ,   b   )
       ccc

   There are also `ctbase' and `cbbase' functions which make the
baseline of the vertical composition equal to the top or bottom line
(rather than the baseline) of that component.  Thus `cvert([cbase(a /
b)]) + cvert([ctbase(a / b)]) + cvert([cbbase(a / b)])' gives

             a
     a       -
     - + a + b
     b   -
         b

   There should be only one `cbase', `ctbase', or `cbbase' function in
a given vertical composition.  These functions can also be written with
no arguments:  `ctbase()' is a zero-height object which means the
baseline is the top line of the following item, and `cbbase()' means
the baseline is the bottom line of the preceding item.

   The `crule' function builds a "rule," or horizontal line, across a
vertical composition.  By itself `crule()' uses `-' characters to build
the rule.  You can specify any other character, e.g., `crule("=")'.
The argument must be a character code or vector of exactly one
character code.  It is repeated to match the width of the widest item
in the stack.  For example, a quotient with a thick line is `cvert([a +
1, cbase(crule("=")), b^2])':

     a + 1
     =====
       2
      b

   Finally, the functions `clvert' and `crvert' act exactly like
`cvert' except that the items are left- or right-justified in the
stack.  Thus `clvert([a, bb, ccc]) + crvert([a, bb, ccc])' gives:

     a   +   a
     bb     bb
     ccc   ccc

   Like `choriz', the vertical compositions accept a second argument
which gives the precedence to use when formatting the components.
Vertical compositions do not support separator strings.


File: calc,  Node: Other Compositions,  Next: Information about Compositions,  Prev: Vertical Compositions,  Up: Compositions

8.8.10.4 Other Compositions
...........................

The `csup' function builds a superscripted expression.  For example,
`csup(a, b)' looks the same as `a^b' does in Big language mode.  This
is essentially a horizontal composition of `a' and `b', where `b' is
shifted up so that its bottom line is one above the baseline.

   Likewise, the `csub' function builds a subscripted expression.  This
shifts `b' down so that its top line is one below the bottom line of
`a' (note that this is not quite analogous to `csup').  Other
arrangements can be obtained by using `choriz' and `cvert' directly.

   The `cflat' function formats its argument in "flat" mode, as
obtained by `d O', if the current language mode is normal or Big.  It
has no effect in other language modes.  For example, `a^(b/c)' is
formatted by Big mode like `csup(a, cflat(b/c))' to improve its
readability.

   The `cspace' function creates horizontal space.  For example,
`cspace(4)' is effectively the same as `string("    ")'.  A second
string (i.e., vector of characters) argument is repeated instead of the
space character.  For example, `cspace(4, "ab")' looks like `abababab'.
If the second argument is not a string, it is formatted in the normal
way and then several copies of that are composed together:  `cspace(4,
a^2)' yields

      2 2 2 2
     a a a a

If the number argument is zero, this is a zero-width object.

   The `cvspace' function creates vertical space, or a vertical stack
of copies of a certain string or formatted object.  The baseline is the
center line of the resulting stack.  A numerical argument of zero will
produce an object which contributes zero height if used in a vertical
composition.

   There are also `ctspace' and `cbspace' functions which create
vertical space with the baseline the same as the baseline of the top or
bottom copy, respectively, of the second argument.  Thus `cvspace(2,
a/b) + ctspace(2, a/b) + cbspace(2, a/b)' displays as:

             a
             -
     a       b
     -   a   a
     b + - + -
     a   b   b
     -   a
     b   -
         b


File: calc,  Node: Information about Compositions,  Next: User-Defined Compositions,  Prev: Other Compositions,  Up: Compositions

8.8.10.5 Information about Compositions
.......................................

The functions in this section are actual functions; they compose their
arguments according to the current language and other display modes,
then return a certain measurement of the composition as an integer.

   The `cwidth' function measures the width, in characters, of a
composition.  For example, `cwidth(a + b)' is 5, and `cwidth(a / b)' is
5 in Normal mode, 1 in Big mode, and 11 in TeX mode (for `{a \over
b}').  The argument may involve the composition functions described in
this section.

   The `cheight' function measures the height of a composition.  This
is the total number of lines in the argument's printed form.

   The functions `cascent' and `cdescent' measure the amount of the
height that is above (and including) the baseline, or below the
baseline, respectively.  Thus `cascent(X) + cdescent(X)' always equals
`cheight(X)'.  For a one-line formula like `a + b', `cascent' returns 1
and `cdescent' returns 0.  For `a / b' in Big mode, `cascent' returns 2
and `cdescent' returns 1.  The only formula for which `cascent' will
return zero is `cvspace(0)' or equivalents.


File: calc,  Node: User-Defined Compositions,  Prev: Information about Compositions,  Up: Compositions

8.8.10.6 User-Defined Compositions
..................................

The `Z C' (`calc-user-define-composition') command lets you define the
display format for any algebraic function.  You provide a formula
containing a certain number of argument variables on the stack.  Any
time Calc formats a call to the specified function in the current
language mode and with that number of arguments, Calc effectively
replaces the function call with that formula with the arguments
replaced.

   Calc builds the default argument list by sorting all the variable
names that appear in the formula into alphabetical order.  You can edit
this argument list before pressing <RET> if you wish.  Any variables in
the formula that do not appear in the argument list will be displayed
literally; any arguments that do not appear in the formula will not
affect the display at all.

   You can define formats for built-in functions, for functions you have
defined with `Z F' (*note Algebraic Definitions::), or for functions
which have no definitions but are being used as purely syntactic
objects.  You can define different formats for each language mode, and
for each number of arguments, using a succession of `Z C' commands.
When Calc formats a function call, it first searches for a format
defined for the current language mode (and number of arguments); if
there is none, it uses the format defined for the Normal language mode.
If neither format exists, Calc uses its built-in standard format for
that function (usually just `FUNC(ARGS)').

   If you execute `Z C' with the number 0 on the stack instead of a
formula, any defined formats for the function in the current language
mode will be removed.  The function will revert to its standard format.

   For example, the default format for the binomial coefficient function
`choose(n, m)' in the Big language mode is

      n
     ( )
      m

You might prefer the notation,

      C
     n m

To define this notation, first make sure you are in Big mode, then put
the formula

     choriz([cvert([cvspace(1), n]), C, cvert([cvspace(1), m])])

on the stack and type `Z C'.  Answer the first prompt with `choose'.
The second prompt will be the default argument list of `(C m n)'.  Edit
this list to be `(n m)' and press <RET>.  Now, try it out:  For
example, turn simplification off with `m O' and enter `choose(a,b) +
choose(7,3)' as an algebraic entry.

      C  +  C
     a b   7 3

   As another example, let's define the usual notation for Stirling
numbers of the first kind, `stir1(n, m)'.  This is just like the
regular format for binomial coefficients but with square brackets
instead of parentheses.

     choriz([string("["), cvert([n, cbase(cvspace(1)), m]), string("]")])

   Now type `Z C stir1 <RET>', edit the argument list to `(n m)', and
type <RET>.

   The formula provided to `Z C' usually will involve composition
functions, but it doesn't have to.  Putting the formula `a + b + c'
onto the stack and typing `Z C foo <RET> <RET>' would define the
function `foo(x,y,z)' to display like `x + y + z'.  This "sum" will act
exactly like a real sum for all formatting purposes (it will be
parenthesized the same, and so on).  However it will be computationally
unrelated to a sum.  For example, the formula `2 * foo(1, 2, 3)' will
display as `2 (1 + 2 + 3)'.  Operator precedences have caused the "sum"
to be written in parentheses, but the arguments have not actually been
summed.  (Generally a display format like this would be undesirable,
since it can easily be confused with a real sum.)

   The special function `eval' can be used inside a `Z C' composition
formula to cause all or part of the formula to be evaluated at display
time.  For example, if the formula is `a + eval(b + c)', then `foo(1,
2, 3)' will be displayed as `1 + 5'.  Evaluation will use the default
simplifications, regardless of the current simplification mode.  There
are also `evalsimp' and `evalextsimp' which simplify as if by `a s' and
`a e' (respectively).  Note that these "functions" operate only in the
context of composition formulas (and also in rewrite rules, where they
serve a similar purpose; *note Rewrite Rules::).  On the stack, a call
to `eval' will be left in symbolic form.

   It is not a good idea to use `eval' except as a last resort.  It can
cause the display of formulas to be extremely slow.  For example, while
`eval(a + b)' might seem quite fast and simple, there are several
situations where it could be slow.  For example, `a' and/or `b' could
be polar complex numbers, in which case doing the sum requires
trigonometry.  Or, `a' could be the factorial `fact(100)' which is
unevaluated because you have typed `m O'; `eval' will evaluate it
anyway to produce a large, unwieldy integer.

   You can save your display formats permanently using the `Z P'
command (*note Creating User Keys::).


File: calc,  Node: Syntax Tables,  Prev: Compositions,  Up: Language Modes

8.8.11 Syntax Tables
--------------------

Syntax tables do for input what compositions do for output:  They allow
you to teach custom notations to Calc's formula parser.  Calc keeps a
separate syntax table for each language mode.

   (Note that the Calc "syntax tables" discussed here are completely
unrelated to the syntax tables described in the Emacs manual.)

   The `Z S' (`calc-edit-user-syntax') command edits the syntax table
for the current language mode.  If you want your syntax to work in any
language, define it in the Normal language mode.  Type `C-c C-c' to
finish editing the syntax table, or `C-x k' to cancel the edit.  The `m
m' command saves all the syntax tables along with the other mode
settings; *note General Mode Commands::.

* Menu:

* Syntax Table Basics::
* Precedence in Syntax Tables::
* Advanced Syntax Patterns::
* Conditional Syntax Rules::


File: calc,  Node: Syntax Table Basics,  Next: Precedence in Syntax Tables,  Prev: Syntax Tables,  Up: Syntax Tables

8.8.11.1 Syntax Table Basics
............................

"Parsing" is the process of converting a raw string of characters, such
as you would type in during algebraic entry, into a Calc formula.
Calc's parser works in two stages.  First, the input is broken down
into "tokens", such as words, numbers, and punctuation symbols like
`+', `:=', and `+/-'.  Space between tokens is ignored (except when it
serves to separate adjacent words).  Next, the parser matches this
string of tokens against various built-in syntactic patterns, such as
"an expression followed by `+' followed by another expression" or "a
name followed by `(', zero or more expressions separated by commas, and
`)'."

   A "syntax table" is a list of user-defined "syntax rules", which
allow you to specify new patterns to define your own favorite input
notations.  Calc's parser always checks the syntax table for the
current language mode, then the table for the Normal language mode,
before it uses its built-in rules to parse an algebraic formula you
have entered.  Each syntax rule should go on its own line; it consists
of a "pattern", a `:=' symbol, and a Calc formula with an optional
"condition".  (Syntax rules resemble algebraic rewrite rules, but the
notation for patterns is completely different.)

   A syntax pattern is a list of tokens, separated by spaces.  Except
for a few special symbols, tokens in syntax patterns are matched
literally, from left to right.  For example, the rule,

     foo ( ) := 2+3

would cause Calc to parse the formula `4+foo()*5' as if it were
`4+(2+3)*5'.  Notice that the parentheses were written as two separate
tokens in the rule.  As a result, the rule works for both `foo()' and
`foo (  )'.  If we had written the rule as `foo () := 2+3', then Calc
would treat `()' as a single, indivisible token, so that `foo( )' would
not be recognized by the rule.  (It would be parsed as a regular
zero-argument function call instead.)  In fact, this rule would also
make trouble for the rest of Calc's parser:  An unrelated formula like
`bar()' would now be tokenized into `bar ()' instead of `bar ( )', so
that the standard parser for function calls would no longer recognize
it!

   While it is possible to make a token with a mixture of letters and
punctuation symbols, this is not recommended.  It is better to break it
into several tokens, as we did with `foo()' above.

   The symbol `#' in a syntax pattern matches any Calc expression.  On
the righthand side, the things that matched the `#'s can be referred to
as `#1', `#2', and so on (where `#1' matches the leftmost `#' in the
pattern).  For example, these rules match a user-defined function,
prefix operator, infix operator, and postfix operator, respectively:

     foo ( # ) := myfunc(#1)
     foo # := myprefix(#1)
     # foo # := myinfix(#1,#2)
     # foo := mypostfix(#1)

   Thus `foo(3)' will parse as `myfunc(3)', and `2+3 foo' will parse as
`mypostfix(2+3)'.

   It is important to write the first two rules in the order shown,
because Calc tries rules in order from first to last.  If the pattern
`foo #' came first, it would match anything that could match the `foo (
# )' rule, since an expression in parentheses is itself a valid
expression.  Thus the `foo ( # )' rule would never get to match
anything.  Likewise, the last two rules must be written in the order
shown or else `3 foo 4' will be parsed as `mypostfix(3) * 4'.  (Of
course, the best way to avoid these ambiguities is not to use the same
symbol in more than one way at the same time!  In case you're not
convinced, try the following exercise:  How will the above rules parse
the input `foo(3,4)', if at all?  Work it out for yourself, then try it
in Calc and see.)

   Calc is quite flexible about what sorts of patterns are allowed.
The only rule is that every pattern must begin with a literal token
(like `foo' in the first two patterns above), or with a `#' followed by
a literal token (as in the last two patterns).  After that, any mixture
is allowed, although putting two `#'s in a row will not be very useful
since two expressions with nothing between them will be parsed as one
expression that uses implicit multiplication.

   As a more practical example, Maple uses the notation `sum(a(i),
i=1..10)' for sums, which Calc's Maple mode doesn't recognize at
present.  To handle this syntax, we simply add the rule,

     sum ( # , # = # .. # ) := sum(#1,#2,#3,#4)

to the Maple mode syntax table.  As another example, C mode can't read
assignment operators like `++' and `*='.  We can define these operators
quite easily:

     # *= # := muleq(#1,#2)
     # ++ := postinc(#1)
     ++ # := preinc(#1)

To complete the job, we would use corresponding composition functions
and `Z C' to cause these functions to display in their respective Maple
and C notations.  (Note that the C example ignores issues of operator
precedence, which are discussed in the next section.)

   You can enclose any token in quotes to prevent its usual
interpretation in syntax patterns:

     # ":=" # := becomes(#1,#2)

   Quotes also allow you to include spaces in a token, although once
again it is generally better to use two tokens than one token with an
embedded space.  To include an actual quotation mark in a quoted token,
precede it with a backslash.  (This also works to include backslashes
in tokens.)

     # "bad token" # "/\"\\" # := silly(#1,#2,#3)

This will parse `3 bad token 4 /"\ 5' to `silly(3,4,5)'.

   The token `#' has a predefined meaning in Calc's formula parser; it
is not valid to use `"#"' in a syntax rule.  However, longer tokens
that include the `#' character are allowed.  Also, while `"$"' and
`"\""' are allowed as tokens, their presence in the syntax table will
prevent those characters from working in their usual ways (referring to
stack entries and quoting strings, respectively).

   Finally, the notation `%%' anywhere in a syntax table causes the
rest of the line to be ignored as a comment.


File: calc,  Node: Precedence in Syntax Tables,  Next: Advanced Syntax Patterns,  Prev: Syntax Table Basics,  Up: Syntax Tables

8.8.11.2 Precedence
...................

Different operators are generally assigned different "precedences".  By
default, an operator defined by a rule like

     # foo # := foo(#1,#2)

will have an extremely low precedence, so that `2*3+4 foo 5 == 6' will
be parsed as `(2*3+4) foo (5 == 6)'.  To change the precedence of an
operator, use the notation `#/P' in place of `#', where P is an integer
precedence level.  For example, 185 lies between the precedences for
`+' and `*', so if we change this rule to

     #/185 foo #/186 := foo(#1,#2)

then `2+3 foo 4*5' will be parsed as `2+(3 foo (4*5))'.  Also, because
we've given the righthand expression slightly higher precedence, our
new operator will be left-associative: `1 foo 2 foo 3' will be parsed
as `(1 foo 2) foo 3'.  By raising the precedence of the lefthand
expression instead, we can create a right-associative operator.

   *Note Composition Basics::, for a table of precedences of the
standard Calc operators.  For the precedences of operators in other
language modes, look in the Calc source file `calc-lang.el'.


File: calc,  Node: Advanced Syntax Patterns,  Next: Conditional Syntax Rules,  Prev: Precedence in Syntax Tables,  Up: Syntax Tables

8.8.11.3 Advanced Syntax Patterns
.................................

To match a function with a variable number of arguments, you could write

     foo ( # ) := myfunc(#1)
     foo ( # , # ) := myfunc(#1,#2)
     foo ( # , # , # ) := myfunc(#1,#2,#3)

but this isn't very elegant.  To match variable numbers of items, Calc
uses some notations inspired regular expressions and the "extended BNF"
style used by some language designers.

     foo ( { # }*, ) := apply(myfunc,#1)

   The token `{' introduces a repeated or optional portion.  One of the
three tokens `}*', `}+', or `}?' ends the portion.  These will match
zero or more, one or more, or zero or one copies of the enclosed
pattern, respectively.  In addition, `}*' and `}+' can be followed by a
separator token (with no space in between, as shown above).  Thus `{ #
}*,' matches nothing, or one expression, or several expressions
separated by commas.

   A complete `{ ... }' item matches as a vector of the items that
matched inside it.  For example, the above rule will match `foo(1,2,3)'
to get `apply(myfunc,[1,2,3])'.  The Calc `apply' function takes a
function name and a vector of arguments and builds a call to the
function with those arguments, so the net result is the formula
`myfunc(1,2,3)'.

   If the body of a `{ ... }' contains several `#'s (or nested `{ ...
}' constructs), then the items will be strung together into the
resulting vector.  If the body does not contain anything but literal
tokens, the result will always be an empty vector.

     foo ( { # , # }+, ) := bar(#1)
     foo ( { { # }*, }*; ) := matrix(#1)

will parse `foo(1, 2, 3, 4)' as `bar([1, 2, 3, 4])', and `foo(1, 2; 3,
4)' as `matrix([[1, 2], [3, 4]])'.  Also, after some thought it's easy
to see how this pair of rules will parse `foo(1, 2, 3)' as `matrix([[1,
2, 3]])', since the first rule will only match an even number of
arguments.  The rule

     foo ( # { , # , # }? ) := bar(#1,#2)

will parse `foo(2,3,4)' as `bar(2,[3,4])', and `foo(2)' as `bar(2,[])'.

   The notation `{ ... }?.' (note the trailing period) works just the
same as regular `{ ... }?', except that it does not count as an
argument; the following two rules are equivalent:

     foo ( # , { also }? # ) := bar(#1,#3)
     foo ( # , { also }?. # ) := bar(#1,#2)

Note that in the first case the optional text counts as `#2', which
will always be an empty vector, but in the second case no empty vector
is produced.

   Another variant is `{ ... }?$', which means the body is optional
only at the end of the input formula.  All built-in syntax rules in
Calc use this for closing delimiters, so that during algebraic entry
you can type `[sqrt(2), sqrt(3 <RET>', omitting the closing parenthesis
and bracket.  Calc does this automatically for trailing `)', `]', and
`>' tokens in syntax rules, but you can use `{ ... }?$' explicitly to
get this effect with any token (such as `"}"' or `end').  Like `{ ...
}?.', this notation does not count as an argument.  Conversely, you can
use quotes, as in `")"', to prevent a closing-delimiter token from
being automatically treated as optional.

   Calc's parser does not have full backtracking, which means some
patterns will not work as you might expect:

     foo ( { # , }? # , # ) := bar(#1,#2,#3)

Here we are trying to make the first argument optional, so that
`foo(2,3)' parses as `bar([],2,3)'.  Unfortunately, Calc first tries to
match `2,' against the optional part of the pattern, finds a match, and
so goes ahead to match the rest of the pattern.  Later on it will fail
to match the second comma, but it doesn't know how to go back and try
the other alternative at that point.  One way to get around this would
be to use two rules:

     foo ( # , # , # ) := bar([#1],#2,#3)
     foo ( # , # ) := bar([],#1,#2)

   More precisely, when Calc wants to match an optional or repeated
part of a pattern, it scans forward attempting to match that part.  If
it reaches the end of the optional part without failing, it "finalizes"
its choice and proceeds.  If it fails, though, it backs up and tries
the other alternative.  Thus Calc has "partial" backtracking.  A fully
backtracking parser would go on to make sure the rest of the pattern
matched before finalizing the choice.


File: calc,  Node: Conditional Syntax Rules,  Prev: Advanced Syntax Patterns,  Up: Syntax Tables

8.8.11.4 Conditional Syntax Rules
.................................

It is possible to attach a "condition" to a syntax rule.  For example,
the rules

     foo ( # ) := ifoo(#1) :: integer(#1)
     foo ( # ) := gfoo(#1)

will parse `foo(3)' as `ifoo(3)', but will parse `foo(3.5)' and
`foo(x)' as calls to `gfoo'.  Any number of conditions may be attached;
all must be true for the rule to succeed.  A condition is "true" if it
evaluates to a nonzero number.  *Note Logical Operations::, for a list
of Calc functions like `integer' that perform logical tests.

   The exact sequence of events is as follows:  When Calc tries a rule,
it first matches the pattern as usual.  It then substitutes `#1', `#2',
etc., in the conditions, if any.  Next, the conditions are simplified
and evaluated in order from left to right, as if by the `a s' algebra
command (*note Simplifying Formulas::).  Each result is true if it is a
nonzero number, or an expression that can be proven to be nonzero
(*note Declarations::).  If the results of all conditions are true, the
expression (such as `ifoo(#1)') has its `#'s substituted, and that is
the result of the parse.  If the result of any condition is false, Calc
goes on to try the next rule in the syntax table.

   Syntax rules also support `let' conditions, which operate in exactly
the same way as they do in algebraic rewrite rules.  *Note Other
Features of Rewrite Rules::, for details.  A `let' condition is always
true, but as a side effect it defines a variable which can be used in
later conditions, and also in the expression after the `:=' sign:

     foo ( # ) := hifoo(x) :: let(x := #1 + 0.5) :: dnumint(x)

The `dnumint' function tests if a value is numerically an integer,
i.e., either a true integer or an integer-valued float.  This rule will
parse `foo' with a half-integer argument, like `foo(3.5)', to a call
like `hifoo(4.)'.

   The lefthand side of a syntax rule `let' must be a simple variable,
not the arbitrary pattern that is allowed in rewrite rules.

   The `matches' function is also treated specially in syntax rule
conditions (again, in the same way as in rewrite rules).  *Note
Matching Commands::.  If the matching pattern contains meta-variables,
then those meta-variables may be used in later conditions and in the
result expression.  The arguments to `matches' are not evaluated in
this situation.

     sum ( # , # ) := sum(#1,a,b,c) :: matches(#2, a=[b..c])

This is another way to implement the Maple mode `sum' notation.  In
this approach, we allow `#2' to equal the whole expression `i=1..10'.
Then, we use `matches' to break it apart into its components.  If the
expression turns out not to match the pattern, the syntax rule will
fail.  Note that `Z S' always uses Calc's Normal language mode for
editing expressions in syntax rules, so we must use regular Calc
notation for the interval `[b..c]' that will correspond to the Maple
mode interval `1..10'.


File: calc,  Node: Modes Variable,  Next: Calc Mode Line,  Prev: Language Modes,  Up: Mode Settings

8.9 The `Modes' Variable
========================

The `m g' (`calc-get-modes') command pushes onto the stack a vector of
numbers that describes the various mode settings that are in effect.
With a numeric prefix argument, it pushes only the Nth mode, i.e., the
Nth element of this vector.  Keyboard macros can use the `m g' command
to modify their behavior based on the current mode settings.

   The modes vector is also available in the special variable `Modes'.
In other words, `m g' is like `s r Modes <RET>'.  It will not work to
store into this variable; in fact, if you do, `Modes' will cease to
track the current modes.  (The `m g' command will continue to work,
however.)

   In general, each number in this vector is suitable as a numeric
prefix argument to the associated mode-setting command.  (Recall that
the `~' key takes a number from the stack and gives it as a numeric
prefix to the next command.)

   The elements of the modes vector are as follows:

  1. Current precision.  Default is 12; associated command is `p'.

  2. Binary word size.  Default is 32; associated command is `b w'.

  3. Stack size (not counting the value about to be pushed by `m g').
     This is zero if `m g' is executed with an empty stack.

  4. Number radix.  Default is 10; command is `d r'.

  5. Floating-point format.  This is the number of digits, plus the
     constant 0 for normal notation, 10000 for scientific notation,
     20000 for engineering notation, or 30000 for fixed-point notation.
     These codes are acceptable as prefix arguments to the `d n'
     command, but note that this may lose information:  For example, `d
     s' and `C-u 12 d s' have similar (but not quite identical) effects
     if the current precision is 12, but they both produce a code of
     10012, which will be treated by `d n' as `C-u 12 d s'.  If the
     precision then changes, the float format will still be frozen at
     12 significant figures.

  6. Angular mode.  Default is 1 (degrees).  Other values are 2
     (radians) and 3 (HMS).  The `m d' command accepts these prefixes.

  7. Symbolic mode.  Value is 0 or 1; default is 0.  Command is `m s'.

  8. Fraction mode.  Value is 0 or 1; default is 0.  Command is `m f'.

  9. Polar mode.  Value is 0 (rectangular) or 1 (polar); default is 0.
     Command is `m p'.

 10. Matrix/Scalar mode.  Default value is -1.  Value is 0 for Scalar
     mode, -2 for Matrix mode, -3 for square Matrix mode, or N for NxN
     Matrix mode.  Command is `m v'.

 11. Simplification mode.  Default is 1.  Value is -1 for off (`m O'),
     0 for `m N', 2 for `m B', 3 for `m A', 4 for `m E', or 5 for
     `m U'.  The `m D' command accepts these prefixes.

 12. Infinite mode.  Default is -1 (off).  Value is 1 if the mode is on,
     or 0 if the mode is on with positive zeros.  Command is `m i'.

   For example, the sequence `M-1 m g <RET> 2 + ~ p' increases the
precision by two, leaving a copy of the old precision on the stack.
Later, `~ p' will restore the original precision using that stack
value.  (This sequence might be especially useful inside a keyboard
macro.)

   As another example, `M-3 m g 1 - ~ <DEL>' deletes all but the oldest
(bottommost) stack entry.

   Yet another example:  The HP-48 "round" command rounds a number to
the current displayed precision.  You could roughly emulate this in
Calc with the sequence `M-5 m g 10000 % ~ c c'.  (This would not work
for fixed-point mode, but it wouldn't be hard to do a full emulation
with the help of the `Z [' and `Z ]' programming commands.  *Note
Conditionals in Macros::.)


File: calc,  Node: Calc Mode Line,  Prev: Modes Variable,  Up: Mode Settings

8.10 The Calc Mode Line
=======================

This section is a summary of all symbols that can appear on the Calc
mode line, the highlighted bar that appears under the Calc stack window
(or under an editing window in Embedded mode).

   The basic mode line format is:

     --%*-Calc: 12 Deg OTHER MODES       (Calculator)

   The `%*' indicates that the buffer is "read-only"; it shows that
regular Emacs commands are not allowed to edit the stack buffer as if
it were text.

   The word `Calc:' changes to `CalcEmbed:' if Embedded mode is
enabled.  The words after this describe the various Calc modes that are
in effect.

   The first mode is always the current precision, an integer.  The
second mode is always the angular mode, either `Deg', `Rad', or `Hms'.

   Here is a complete list of the remaining symbols that can appear on
the mode line:

`Alg'
     Algebraic mode (`m a'; *note Algebraic Entry::).

`Alg[('
     Incomplete algebraic mode (`C-u m a').

`Alg*'
     Total algebraic mode (`m t').

`Symb'
     Symbolic mode (`m s'; *note Symbolic Mode::).

`Matrix'
     Matrix mode (`m v'; *note Matrix Mode::).

`MatrixN'
     Dimensioned Matrix mode (`C-u N m v'; *note Matrix Mode::).

`SqMatrix'
     Square Matrix mode (`C-u m v'; *note Matrix Mode::).

`Scalar'
     Scalar mode (`m v'; *note Matrix Mode::).

`Polar'
     Polar complex mode (`m p'; *note Polar Mode::).

`Frac'
     Fraction mode (`m f'; *note Fraction Mode::).

`Inf'
     Infinite mode (`m i'; *note Infinite Mode::).

`+Inf'
     Positive Infinite mode (`C-u 0 m i').

`NoSimp'
     Default simplifications off (`m O'; *note Simplification Modes::).

`NumSimp'
     Default simplifications for numeric arguments only (`m N').

`BinSimpW'
     Binary-integer simplification mode; word size W (`m B', `b w').

`AlgSimp'
     Algebraic simplification mode (`m A').

`ExtSimp'
     Extended algebraic simplification mode (`m E').

`UnitSimp'
     Units simplification mode (`m U').

`Bin'
     Current radix is 2 (`d 2'; *note Radix Modes::).

`Oct'
     Current radix is 8 (`d 8').

`Hex'
     Current radix is 16 (`d 6').

`RadixN'
     Current radix is N (`d r').

`Zero'
     Leading zeros (`d z'; *note Radix Modes::).

`Big'
     Big language mode (`d B'; *note Normal Language Modes::).

`Flat'
     One-line normal language mode (`d O').

`Unform'
     Unformatted language mode (`d U').

`C'
     C language mode (`d C'; *note C FORTRAN Pascal::).

`Pascal'
     Pascal language mode (`d P').

`Fortran'
     FORTRAN language mode (`d F').

`TeX'
     TeX language mode (`d T'; *note TeX and LaTeX Language Modes::).

`LaTeX'
     LaTeX language mode (`d L'; *note TeX and LaTeX Language Modes::).

`Eqn'
     "Eqn" language mode (`d E'; *note Eqn Language Mode::).

`Math'
     Mathematica language mode (`d M'; *note Mathematica Language
     Mode::).

`Maple'
     Maple language mode (`d W'; *note Maple Language Mode::).

`NormN'
     Normal float mode with N digits (`d n'; *note Float Formats::).

`FixN'
     Fixed point mode with N digits after the point (`d f').

`Sci'
     Scientific notation mode (`d s').

`SciN'
     Scientific notation with N digits (`d s').

`Eng'
     Engineering notation mode (`d e').

`EngN'
     Engineering notation with N digits (`d e').

`LeftN'
     Left-justified display indented by N (`d <'; *note
     Justification::).

`Right'
     Right-justified display (`d >').

`RightN'
     Right-justified display with width N (`d >').

`Center'
     Centered display (`d =').

`CenterN'
     Centered display with center column N (`d =').

`WidN'
     Line breaking with width N (`d b'; *note Normal Language Modes::).

`Wide'
     No line breaking (`d b').

`Break'
     Selections show deep structure (`j b'; *note Making Selections::).

`Save'
     Record modes in `~/.emacs.d/calc.el' (`m R'; *note General Mode
     Commands::).

`Local'
     Record modes in Embedded buffer (`m R').

`LocEdit'
     Record modes as editing-only in Embedded buffer (`m R').

`LocPerm'
     Record modes as permanent-only in Embedded buffer (`m R').

`Global'
     Record modes as global in Embedded buffer (`m R').

`Manual'
     Automatic recomputation turned off (`m C'; *note Automatic
     Recomputation::).

`Graph'
     GNUPLOT process is alive in background (*note Graphics::).

`Sel'
     Top-of-stack has a selection (Embedded only; *note Making
     Selections::).

`Dirty'
     The stack display may not be up-to-date (*note Display Modes::).

`Inv'
     "Inverse" prefix was pressed (`I'; *note Inverse and Hyperbolic::).

`Hyp'
     "Hyperbolic" prefix was pressed (`H').

`Keep'
     "Keep-arguments" prefix was pressed (`K').

`Narrow'
     Stack is truncated (`d t'; *note Truncating the Stack::).

   In addition, the symbols `Active' and `~Active' can appear as minor
modes on an Embedded buffer's mode line.  *Note Embedded Mode::.


File: calc,  Node: Arithmetic,  Next: Scientific Functions,  Prev: Mode Settings,  Up: Top

9 Arithmetic Functions
**********************

This chapter describes the Calc commands for doing simple calculations
on numbers, such as addition, absolute value, and square roots.  These
commands work by removing the top one or two values from the stack,
performing the desired operation, and pushing the result back onto the
stack.  If the operation cannot be performed, the result pushed is a
formula instead of a number, such as `2/0' (because division by zero is
invalid) or `sqrt(x)' (because the argument `x' is a formula).

   Most of the commands described here can be invoked by a single
keystroke.  Some of the more obscure ones are two-letter sequences
beginning with the `f' ("functions") prefix key.

   *Note Prefix Arguments::, for a discussion of the effect of numeric
prefix arguments on commands in this chapter which do not otherwise
interpret a prefix argument.

* Menu:

* Basic Arithmetic::
* Integer Truncation::
* Complex Number Functions::
* Conversions::
* Date Arithmetic::
* Financial Functions::
* Binary Functions::


File: calc,  Node: Basic Arithmetic,  Next: Integer Truncation,  Prev: Arithmetic,  Up: Arithmetic

9.1 Basic Arithmetic
====================

The `+' (`calc-plus') command adds two numbers.  The numbers may be any
of the standard Calc data types.  The resulting sum is pushed back onto
the stack.

   If both arguments of `+' are vectors or matrices (of matching
dimensions), the result is a vector or matrix sum.  If one argument is
a vector and the other a scalar (i.e., a non-vector), the scalar is
added to each of the elements of the vector to form a new vector.  If
the scalar is not a number, the operation is left in symbolic form:
Suppose you added `x' to the vector `[1,2]'.  You may want the result
`[1+x,2+x]', or you may plan to substitute a 2-vector for `x' in the
future.  Since the Calculator can't tell which interpretation you want,
it makes the safest assumption.  *Note Reducing and Mapping::, for a
way to add `x' to every element of a vector.

   If either argument of `+' is a complex number, the result will in
general be complex.  If one argument is in rectangular form and the
other polar, the current Polar mode determines the form of the result.
If Symbolic mode is enabled, the sum may be left as a formula if the
necessary conversions for polar addition are non-trivial.

   If both arguments of `+' are HMS forms, the forms are added
according to the usual conventions of hours-minutes-seconds notation.
If one argument is an HMS form and the other is a number, that number
is converted from degrees or radians (depending on the current Angular
mode) to HMS format and then the two HMS forms are added.

   If one argument of `+' is a date form, the other can be either a
real number, which advances the date by a certain number of days, or an
HMS form, which advances the date by a certain amount of time.
Subtracting two date forms yields the number of days between them.
Adding two date forms is meaningless, but Calc interprets it as the
subtraction of one date form and the negative of the other.  (The
negative of a date form can be understood by remembering that dates are
stored as the number of days before or after Jan 1, 1 AD.)

   If both arguments of `+' are error forms, the result is an error form
with an appropriately computed standard deviation.  If one argument is
an error form and the other is a number, the number is taken to have
zero error.  Error forms may have symbolic formulas as their mean
and/or error parts; adding these will produce a symbolic error form
result.  However, adding an error form to a plain symbolic formula (as
in `(a +/- b) + c') will not work, for the same reasons just mentioned
for vectors.  Instead you must write `(a +/- b) + (c +/- 0)'.

   If both arguments of `+' are modulo forms with equal values of `M',
or if one argument is a modulo form and the other a plain number, the
result is a modulo form which represents the sum, modulo `M', of the
two values.

   If both arguments of `+' are intervals, the result is an interval
which describes all possible sums of the possible input values.  If one
argument is a plain number, it is treated as the interval `[x .. x]'.

   If one argument of `+' is an infinity and the other is not, the
result is that same infinity.  If both arguments are infinite and in
the same direction, the result is the same infinity, but if they are
infinite in different directions the result is `nan'.

   The `-' (`calc-minus') command subtracts two values.  The top number
on the stack is subtracted from the one behind it, so that the
computation `5 <RET> 2 -' produces 3, not -3.  All options available
for `+' are available for `-' as well.

   The `*' (`calc-times') command multiplies two numbers.  If one
argument is a vector and the other a scalar, the scalar is multiplied by
the elements of the vector to produce a new vector.  If both arguments
are vectors, the interpretation depends on the dimensions of the
vectors:  If both arguments are matrices, a matrix multiplication is
done.  If one argument is a matrix and the other a plain vector, the
vector is interpreted as a row vector or column vector, whichever is
dimensionally correct.  If both arguments are plain vectors, the result
is a single scalar number which is the dot product of the two vectors.

   If one argument of `*' is an HMS form and the other a number, the
HMS form is multiplied by that amount.  It is an error to multiply two
HMS forms together, or to attempt any multiplication involving date
forms.  Error forms, modulo forms, and intervals can be multiplied; see
the comments for addition of those forms.  When two error forms or
intervals are multiplied they are considered to be statistically
independent; thus, `[-2 .. 3] * [-2 .. 3]' is `[-6 .. 9]', whereas
`[-2 .. 3] ^ 2' is `[0 .. 9]'.

   The `/' (`calc-divide') command divides two numbers.

   When combining multiplication and division in an algebraic formula,
it is good style to use parentheses to distinguish between possible
interpretations; the expression `a/b*c' should be written `(a/b)*c' or
`a/(b*c)', as appropriate.  Without the parentheses, Calc will
interpret `a/b*c' as `a/(b*c)', since in algebraic entry Calc gives
division a lower precedence than multiplication. (This is not standard
across all computer languages, and Calc may change the precedence
depending on the language mode being used.  *Note Language Modes::.)
This default ordering can be changed by setting the customizable
variable `calc-multiplication-has-precedence' to `nil' (*note
Customizing Calc::); this will give multiplication and division equal
precedences.  Note that Calc's default choice of precedence allows `a b
/ c d' to be used as a shortcut for
     a b
     ---.
     c d

   When dividing a scalar `B' by a square matrix `A', the computation
performed is `B' times the inverse of `A'.  This also occurs if `B' is
itself a vector or matrix, in which case the effect is to solve the set
of linear equations represented by `B'.  If `B' is a matrix with the
same number of rows as `A', or a plain vector (which is interpreted
here as a column vector), then the equation `A X = B' is solved for the
vector or matrix `X'.  Otherwise, if `B' is a non-square matrix with
the same number of _columns_ as `A', the equation `X A = B' is solved.
If you wish a vector `B' to be interpreted as a row vector to be solved
as `X A = B', make it into a one-row matrix with `C-u 1 v p' first.  To
force a left-handed solution with a square matrix `B', transpose `A'
and `B' before dividing, then transpose the result.

   HMS forms can be divided by real numbers or by other HMS forms.
Error forms can be divided in any combination of ways.  Modulo forms
where both values and the modulo are integers can be divided to get an
integer modulo form result.  Intervals can be divided; dividing by an
interval that encompasses zero or has zero as a limit will result in an
infinite interval.

   The `^' (`calc-power') command raises a number to a power.  If the
power is an integer, an exact result is computed using repeated
multiplications.  For non-integer powers, Calc uses Newton's method or
logarithms and exponentials.  Square matrices can be raised to integer
powers.  If either argument is an error (or interval or modulo) form,
the result is also an error (or interval or modulo) form.

   If you press the `I' (inverse) key first, the `I ^' command computes
an Nth root:  `125 <RET> 3 I ^' computes the number 5.  (This is
entirely equivalent to `125 <RET> 1:3 ^'.)

   The `\' (`calc-idiv') command divides two numbers on the stack to
produce an integer result.  It is equivalent to dividing with </>, then
rounding down with `F' (`calc-floor'), only a bit more convenient and
efficient.  Also, since it is an all-integer operation when the
arguments are integers, it avoids problems that `/ F' would have with
floating-point roundoff.

   The `%' (`calc-mod') command performs a "modulo" (or "remainder")
operation.  Mathematically, `a%b = a - (a\b)*b', and is defined for all
real numbers `a' and `b' (except `b=0').  For positive `b', the result
will always be between 0 (inclusive) and `b' (exclusive).  Modulo does
not work for HMS forms and error forms.  If `a' is a modulo form, its
modulo is changed to `b', which must be positive real number.

   The `:' (`calc-fdiv') [`fdiv'] command divides the two integers on
the top of the stack to produce a fractional result.  This is a
convenient shorthand for enabling Fraction mode (with `m f')
temporarily and using `/'.  Note that during numeric entry the `:' key
is interpreted as a fraction separator, so to divide 8 by 6 you would
have to type `8 <RET> 6 <RET> :'.  (Of course, in this case, it would
be much easier simply to enter the fraction directly as `8:6 <RET>'!)

   The `n' (`calc-change-sign') command negates the number on the top
of the stack.  It works on numbers, vectors and matrices, HMS forms,
date forms, error forms, intervals, and modulo forms.

   The `A' (`calc-abs') [`abs'] command computes the absolute value of
a number.  The result of `abs' is always a nonnegative real number:
With a complex argument, it computes the complex magnitude.  With a
vector or matrix argument, it computes the Frobenius norm, i.e., the
square root of the sum of the squares of the absolute values of the
elements.  The absolute value of an error form is defined by replacing
the mean part with its absolute value and leaving the error part the
same.  The absolute value of a modulo form is undefined.  The absolute
value of an interval is defined in the obvious way.

   The `f A' (`calc-abssqr') [`abssqr'] command computes the absolute
value squared of a number, vector or matrix, or error form.

   The `f s' (`calc-sign') [`sign'] command returns 1 if its argument
is positive, -1 if its argument is negative, or 0 if its argument is
zero.  In algebraic form, you can also write `sign(a,x)' which
evaluates to `x * sign(a)', i.e., either `x', `-x', or zero depending
on the sign of `a'.

   The `&' (`calc-inv') [`inv'] command computes the reciprocal of a
number, i.e., `1 / x'.  Operating on a square matrix, it computes the
inverse of that matrix.

   The `Q' (`calc-sqrt') [`sqrt'] command computes the square root of a
number.  For a negative real argument, the result will be a complex
number whose form is determined by the current Polar mode.

   The `f h' (`calc-hypot') [`hypot'] command computes the square root
of the sum of the squares of two numbers.  That is, `hypot(a,b)' is the
length of the hypotenuse of a right triangle with sides `a' and `b'.
If the arguments are complex numbers, their squared magnitudes are used.

   The `f Q' (`calc-isqrt') [`isqrt'] command computes the integer
square root of an integer.  This is the true square root of the number,
rounded down to an integer.  For example, `isqrt(10)' produces 3.  Note
that, like `\' [`idiv'], this uses exact integer arithmetic throughout
to avoid roundoff problems.  If the input is a floating-point number or
other non-integer value, this is exactly the same as `floor(sqrt(x))'.

   The `f n' (`calc-min') [`min'] and `f x' (`calc-max') [`max']
commands take the minimum or maximum of two real numbers, respectively.
These commands also work on HMS forms, date forms, intervals, and
infinities.  (In algebraic expressions, these functions take any number
of arguments and return the maximum or minimum among all the arguments.)

   The `f M' (`calc-mant-part') [`mant'] function extracts the
"mantissa" part `m' of its floating-point argument; `f X'
(`calc-xpon-part') [`xpon'] extracts the "exponent" part `e'.  The
original number is equal to `m * 10^e', where `m' is in the interval
`[1.0 .. 10.0)' except that `m=e=0' if the original number is zero.
For integers and fractions, `mant' returns the number unchanged and
`xpon' returns zero.  The `v u' (`calc-unpack') command can also be
used to "unpack" a floating-point number; this produces an integer
mantissa and exponent, with the constraint that the mantissa is not a
multiple of ten (again except for the `m=e=0' case).

   The `f S' (`calc-scale-float') [`scf'] function scales a number by a
given power of ten.  Thus, `scf(mant(x), xpon(x)) = x' for any real
`x'.  The second argument must be an integer, but the first may
actually be any numeric value.  For example, `scf(5,-2) = 0.05' or
`1:20' depending on the current Fraction mode.

   The `f [' (`calc-decrement') [`decr'] and `f ]' (`calc-increment')
[`incr'] functions decrease or increase a number by one unit.  For
integers, the effect is obvious.  For floating-point numbers, the
change is by one unit in the last place.  For example, incrementing
`12.3456' when the current precision is 6 digits yields `12.3457'.  If
the current precision had been 8 digits, the result would have been
`12.345601'.  Incrementing `0.0' produces `10^-p', where `p' is the
current precision.  These operations are defined only on integers and
floats.  With numeric prefix arguments, they change the number by `n'
units.

   Note that incrementing followed by decrementing, or vice-versa, will
almost but not quite always cancel out.  Suppose the precision is 6
digits and the number `9.99999' is on the stack.  Incrementing will
produce `10.0000'; decrementing will produce `9.9999'.  One digit has
been dropped.  This is an unavoidable consequence of the way
floating-point numbers work.

   Incrementing a date/time form adjusts it by a certain number of
seconds.  Incrementing a pure date form adjusts it by a certain number
of days.


File: calc,  Node: Integer Truncation,  Next: Complex Number Functions,  Prev: Basic Arithmetic,  Up: Arithmetic

9.2 Integer Truncation
======================

There are four commands for truncating a real number to an integer,
differing mainly in their treatment of negative numbers.  All of these
commands have the property that if the argument is an integer, the
result is the same integer.  An integer-valued floating-point argument
is converted to integer form.

   If you press `H' (`calc-hyperbolic') first, the result will be
expressed as an integer-valued floating-point number.

   The `F' (`calc-floor') [`floor' or `ffloor'] command truncates a
real number to the next lower integer, i.e., toward minus infinity.
Thus `3.6 F' produces 3, but `_3.6 F' produces -4.

   The `I F' (`calc-ceiling') [`ceil' or `fceil'] command truncates
toward positive infinity.  Thus `3.6 I F' produces 4, and `_3.6 I F'
produces -3.

   The `R' (`calc-round') [`round' or `fround'] command rounds to the
nearest integer.  When the fractional part is .5 exactly, this command
rounds away from zero.  (All other rounding in the Calculator uses this
convention as well.)  Thus `3.5 R' produces 4 but `3.4 R' produces 3;
`_3.5 R' produces -4.

   The `I R' (`calc-trunc') [`trunc' or `ftrunc'] command truncates
toward zero.  In other words, it "chops off" everything after the
decimal point.  Thus `3.6 I R' produces 3 and `_3.6 I R' produces -3.

   These functions may not be applied meaningfully to error forms, but
they do work for intervals.  As a convenience, applying `floor' to a
modulo form floors the value part of the form.  Applied to a vector,
these functions operate on all elements of the vector one by one.
Applied to a date form, they operate on the internal numerical
representation of dates, converting a date/time form into a pure date.

   There are two more rounding functions which can only be entered in
algebraic notation.  The `roundu' function is like `round' except that
it rounds up, toward plus infinity, when the fractional part is .5.
This distinction matters only for negative arguments.  Also, `rounde'
rounds to an even number in the case of a tie, rounding up or down as
necessary.  For example, `rounde(3.5)' and `rounde(4.5)' both return 4,
but `rounde(5.5)' returns 6.  The advantage of round-to-even is that
the net error due to rounding after a long calculation tends to cancel
out to zero.  An important subtle point here is that the number being
fed to `rounde' will already have been rounded to the current precision
before `rounde' begins.  For example, `rounde(2.500001)' with a current
precision of 6 will incorrectly, or at least surprisingly, yield 2
because the argument will first have been rounded down to `2.5' (which
`rounde' sees as an exact tie between 2 and 3).

   Each of these functions, when written in algebraic formulas, allows
a second argument which specifies the number of digits after the
decimal point to keep.  For example, `round(123.4567, 2)' will produce
the answer 123.46, and `round(123.4567, -1)' will produce 120 (i.e.,
the cutoff is one digit to the _left_ of the decimal point).  A second
argument of zero is equivalent to no second argument at all.

   To compute the fractional part of a number (i.e., the amount which,
when added to `floor(N)', will produce N) just take N modulo 1 using
the `%' command.

   Note also the `\' (integer quotient), `f I' (integer logarithm), and
`f Q' (integer square root) commands, which are analogous to `/', `B',
and `Q', respectively, except that they take integer arguments and
return the result rounded down to an integer.


File: calc,  Node: Complex Number Functions,  Next: Conversions,  Prev: Integer Truncation,  Up: Arithmetic

9.3 Complex Number Functions
============================

The `J' (`calc-conj') [`conj'] command computes the complex conjugate
of a number.  For complex number `a+bi', the complex conjugate is
`a-bi'.  If the argument is a real number, this command leaves it the
same.  If the argument is a vector or matrix, this command replaces
each element by its complex conjugate.

   The `G' (`calc-argument') [`arg'] command computes the "argument" or
polar angle of a complex number.  For a number in polar notation, this
is simply the second component of the pair `(R;THETA)'.  The result is
expressed according to the current angular mode and will be in the
range -180 degrees (exclusive) to +180 degrees (inclusive), or the
equivalent range in radians.

   The `calc-imaginary' command multiplies the number on the top of the
stack by the imaginary number `i = (0,1)'.  This command is not
normally bound to a key in Calc, but it is available on the <IMAG>
button in Keypad mode.

   The `f r' (`calc-re') [`re'] command replaces a complex number by
its real part.  This command has no effect on real numbers.  (As an
added convenience, `re' applied to a modulo form extracts the value
part.)

   The `f i' (`calc-im') [`im'] command replaces a complex number by
its imaginary part; real numbers are converted to zero.  With a vector
or matrix argument, these functions operate element-wise.

   The `v p' (`calc-pack') command can pack the top two numbers on the
stack into a composite object such as a complex number.  With a prefix
argument of -1, it produces a rectangular complex number; with an
argument of -2, it produces a polar complex number.  (Also, *note
Building Vectors::.)

   The `v u' (`calc-unpack') command takes the complex number (or other
composite object) on the top of the stack and unpacks it into its
separate components.


File: calc,  Node: Conversions,  Next: Date Arithmetic,  Prev: Complex Number Functions,  Up: Arithmetic

9.4 Conversions
===============

The commands described in this section convert numbers from one form to
another; they are two-key sequences beginning with the letter `c'.

   The `c f' (`calc-float') [`pfloat'] command converts the number on
the top of the stack to floating-point form.  For example, `23' is
converted to `23.0', `3:2' is converted to `1.5', and `2.3' is left the
same.  If the value is a composite object such as a complex number or
vector, each of the components is converted to floating-point.  If the
value is a formula, all numbers in the formula are converted to
floating-point.  Note that depending on the current floating-point
precision, conversion to floating-point format may lose information.

   As a special exception, integers which appear as powers or subscripts
are not floated by `c f'.  If you really want to float a power, you can
use a `j s' command to select the power followed by `c f'.  Because `c
f' cannot examine the formula outside of the selection, it does not
notice that the thing being floated is a power.  *Note Selecting
Subformulas::.

   The normal `c f' command is "pervasive" in the sense that it applies
to all numbers throughout the formula.  The `pfloat' algebraic function
never stays around in a formula; `pfloat(a + 1)' changes to `a + 1.0'
as soon as it is evaluated.

   With the Hyperbolic flag, `H c f' [`float'] operates only on the
number or vector of numbers at the top level of its argument.  Thus,
`float(1)' is 1.0, but `float(a + 1)' is left unevaluated because its
argument is not a number.

   You should use `H c f' if you wish to guarantee that the final
value, once all the variables have been assigned, is a float; you would
use `c f' if you wish to do the conversion on the numbers that appear
right now.

   The `c F' (`calc-fraction') [`pfrac'] command converts a
floating-point number into a fractional approximation.  By default, it
produces a fraction whose decimal representation is the same as the
input number, to within the current precision.  You can also give a
numeric prefix argument to specify a tolerance, either directly, or, if
the prefix argument is zero, by using the number on top of the stack as
the tolerance.  If the tolerance is a positive integer, the fraction is
correct to within that many significant figures.  If the tolerance is a
non-positive integer, it specifies how many digits fewer than the
current precision to use.  If the tolerance is a floating-point number,
the fraction is correct to within that absolute amount.

   The `pfrac' function is pervasive, like `pfloat'.  There is also a
non-pervasive version, `H c F' [`frac'], which is analogous to `H c f'
discussed above.

   The `c d' (`calc-to-degrees') [`deg'] command converts a number into
degrees form.  The value on the top of the stack may be an HMS form
(interpreted as degrees-minutes-seconds), or a real number which will
be interpreted in radians regardless of the current angular mode.

   The `c r' (`calc-to-radians') [`rad'] command converts an HMS form
or angle in degrees into an angle in radians.

   The `c h' (`calc-to-hms') [`hms'] command converts a real number,
interpreted according to the current angular mode, to an HMS form
describing the same angle.  In algebraic notation, the `hms' function
also accepts three arguments: `hms(H, M, S)'.  (The three-argument
version is independent of the current angular mode.)

   The `calc-from-hms' command converts the HMS form on the top of the
stack into a real number according to the current angular mode.

   The `c p' (`calc-polar') command converts the complex number on the
top of the stack from polar to rectangular form, or from rectangular to
polar form, whichever is appropriate.  Real numbers are left the same.
This command is equivalent to the `rect' or `polar' functions in
algebraic formulas, depending on the direction of conversion.  (It uses
`polar', except that if the argument is already a polar complex number,
it uses `rect' instead.  The `I c p' command always uses `rect'.)

   The `c c' (`calc-clean') [`pclean'] command "cleans" the number on
the top of the stack.  Floating point numbers are re-rounded according
to the current precision.  Polar numbers whose angular components have
strayed from the -180 to +180 degree range are normalized.  (Note that
results will be undesirable if the current angular mode is different
from the one under which the number was produced!)  Integers and
fractions are generally unaffected by this operation.  Vectors and
formulas are cleaned by cleaning each component number (i.e.,
pervasively).

   If the simplification mode is set below the default level, it is
raised to the default level for the purposes of this command.  Thus, `c
c' applies the default simplifications even if their automatic
application is disabled.  *Note Simplification Modes::.

   A numeric prefix argument to `c c' sets the floating-point precision
to that value for the duration of the command.  A positive prefix (of at
least 3) sets the precision to the specified value; a negative or zero
prefix decreases the precision by the specified amount.

   The keystroke sequences `c 0' through `c 9' are equivalent to `c c'
with the corresponding negative prefix argument.  If roundoff errors
have changed 2.0 into 1.999999, typing `c 1' to clip off one decimal
place often conveniently does the trick.

   The `c c' command with a numeric prefix argument, and the `c 0'
through `c 9' commands, also "clip" very small floating-point numbers
to zero.  If the exponent is less than or equal to the negative of the
specified precision, the number is changed to 0.0.  For example, if the
current precision is 12, then `c 2' changes the vector `[1e-8, 1e-9,
1e-10, 1e-11]' to `[1e-8, 1e-9, 0, 0]'.  Numbers this small generally
arise from roundoff noise.

   If the numbers you are using really are legitimately this small, you
should avoid using the `c 0' through `c 9' commands.  (The plain `c c'
command rounds to the current precision but does not clip small
numbers.)

   One more property of `c 0' through `c 9', and of `c c' with a prefix
argument, is that integer-valued floats are converted to plain
integers, so that `c 1' on `[1., 1.5, 2., 2.5, 3.]' produces `[1, 1.5,
2, 2.5, 3]'.  This is not done for huge numbers (`1e100' is technically
an integer-valued float, but you wouldn't want it automatically
converted to a 100-digit integer).

   With the Hyperbolic flag, `H c c' and `H c 0' through `H c 9'
operate non-pervasively [`clean'].


File: calc,  Node: Date Arithmetic,  Next: Financial Functions,  Prev: Conversions,  Up: Arithmetic

9.5 Date Arithmetic
===================

The commands described in this section perform various conversions and
calculations involving date forms (*note Date Forms::).  They use the
`t' (for time/date) prefix key followed by shifted letters.

   The simplest date arithmetic is done using the regular `+' and `-'
commands.  In particular, adding a number to a date form advances the
date form by a certain number of days; adding an HMS form to a date
form advances the date by a certain amount of time; and subtracting two
date forms produces a difference measured in days.  The commands
described here provide additional, more specialized operations on dates.

   Many of these commands accept a numeric prefix argument; if you give
plain `C-u' as the prefix, these commands will instead take the
additional argument from the top of the stack.

* Menu:

* Date Conversions::
* Date Functions::
* Time Zones::
* Business Days::


File: calc,  Node: Date Conversions,  Next: Date Functions,  Prev: Date Arithmetic,  Up: Date Arithmetic

9.5.1 Date Conversions
----------------------

The `t D' (`calc-date') [`date'] command converts a date form into a
number, measured in days since Jan 1, 1 AD.  The result will be an
integer if DATE is a pure date form, or a fraction or float if DATE is
a date/time form.  Or, if its argument is a number, it converts this
number into a date form.

   With a numeric prefix argument, `t D' takes that many objects (up to
six) from the top of the stack and interprets them in one of the
following ways:

   The `date(YEAR, MONTH, DAY)' function builds a pure date form out of
the specified year, month, and day, which must all be integers.  YEAR
is a year number, such as 1991 (_not_ the same as 91!).  MONTH must be
an integer in the range 1 to 12; DAY must be in the range 1 to 31.  If
the specified month has fewer than 31 days and DAY is too large, the
equivalent day in the following month will be used.

   The `date(MONTH, DAY)' function builds a pure date form using the
current year, as determined by the real-time clock.

   The `date(YEAR, MONTH, DAY, HMS)' function builds a date/time form
using an HMS form.

   The `date(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)' function builds a
date/time form.  HOUR should be an integer in the range 0 to 23; MINUTE
should be an integer in the range 0 to 59; SECOND should be any real
number in the range `[0 .. 60)'.  The last two arguments default to
zero if omitted.

   The `t J' (`calc-julian') [`julian'] command converts a date form
into a Julian day count, which is the number of days since noon (GMT)
on Jan 1, 4713 BC.  A pure date is converted to an integer Julian count
representing noon of that day.  A date/time form is converted to an
exact floating-point Julian count, adjusted to interpret the date form
in the current time zone but the Julian day count in Greenwich Mean
Time.  A numeric prefix argument allows you to specify the time zone;
*note Time Zones::.  Use a prefix of zero to suppress the time zone
adjustment.  Note that pure date forms are never time-zone adjusted.

   This command can also do the opposite conversion, from a Julian day
count (either an integer day, or a floating-point day and time in the
GMT zone), into a pure date form or a date/time form in the current or
specified time zone.

   The `t U' (`calc-unix-time') [`unixtime'] command converts a date
form into a Unix time value, which is the number of seconds since
midnight on Jan 1, 1970, or vice-versa.  The numeric result will be an
integer if the current precision is 12 or less; for higher precision,
the result may be a float with (PRECISION-12) digits after the decimal.
Just as for `t J', the numeric time is interpreted in the GMT time zone
and the date form is interpreted in the current or specified zone.
Some systems use Unix-like numbering but with the local time zone; give
a prefix of zero to suppress the adjustment if so.

   The `t C' (`calc-convert-time-zones') [`tzconv'] command converts a
date form from one time zone to another.  You are prompted for each
time zone name in turn; you can answer with any suitable Calc time zone
expression (*note Time Zones::).  If you answer either prompt with a
blank line, the local time zone is used for that prompt.  You can also
answer the first prompt with `$' to take the two time zone names from
the stack (and the date to be converted from the third stack level).


File: calc,  Node: Date Functions,  Next: Business Days,  Prev: Date Conversions,  Up: Date Arithmetic

9.5.2 Date Functions
--------------------

The `t N' (`calc-now') [`now'] command pushes the current date and time
on the stack as a date form.  The time is reported in terms of the
specified time zone; with no numeric prefix argument, `t N' reports for
the current time zone.

   The `t P' (`calc-date-part') command extracts one part of a date
form.  The prefix argument specifies the part; with no argument, this
command prompts for a part code from 1 to 9.  The various part codes
are described in the following paragraphs.

   The `M-1 t P' [`year'] function extracts the year number from a date
form as an integer, e.g., 1991.  This and the following functions will
also accept a real number for an argument, which is interpreted as a
standard Calc day number.  Note that this function will never return
zero, since the year 1 BC immediately precedes the year 1 AD.

   The `M-2 t P' [`month'] function extracts the month number from a
date form as an integer in the range 1 to 12.

   The `M-3 t P' [`day'] function extracts the day number from a date
form as an integer in the range 1 to 31.

   The `M-4 t P' [`hour'] function extracts the hour from a date form
as an integer in the range 0 (midnight) to 23.  Note that 24-hour time
is always used.  This returns zero for a pure date form.  This function
(and the following two) also accept HMS forms as input.

   The `M-5 t P' [`minute'] function extracts the minute from a date
form as an integer in the range 0 to 59.

   The `M-6 t P' [`second'] function extracts the second from a date
form.  If the current precision is 12 or less, the result is an integer
in the range 0 to 59.  For higher precision, the result may instead be
a floating-point number.

   The `M-7 t P' [`weekday'] function extracts the weekday number from
a date form as an integer in the range 0 (Sunday) to 6 (Saturday).

   The `M-8 t P' [`yearday'] function extracts the day-of-year number
from a date form as an integer in the range 1 (January 1) to 366
(December 31 of a leap year).

   The `M-9 t P' [`time'] function extracts the time portion of a date
form as an HMS form.  This returns `0@ 0' 0"' for a pure date form.

   The `t M' (`calc-new-month') [`newmonth'] command computes a new
date form that represents the first day of the month specified by the
input date.  The result is always a pure date form; only the year and
month numbers of the input are retained.  With a numeric prefix
argument N in the range from 1 to 31, `t M' computes the Nth day of the
month.  (If N is greater than the actual number of days in the month,
or if N is zero, the last day of the month is used.)

   The `t Y' (`calc-new-year') [`newyear'] command computes a new pure
date form that represents the first day of the year specified by the
input.  The month, day, and time of the input date form are lost.  With
a numeric prefix argument N in the range from 1 to 366, `t Y' computes
the Nth day of the year (366 is treated as 365 in non-leap years).  A
prefix argument of 0 computes the last day of the year (December 31).
A negative prefix argument from -1 to -12 computes the first day of the
Nth month of the year.

   The `t W' (`calc-new-week') [`newweek'] command computes a new pure
date form that represents the Sunday on or before the input date.  With
a numeric prefix argument, it can be made to use any day of the week as
the starting day; the argument must be in the range from 0 (Sunday) to
6 (Saturday).  This function always subtracts between 0 and 6 days from
the input date.

   Here's an example use of `newweek':  Find the date of the next
Wednesday after a given date.  Using `M-3 t W' or `newweek(d, 3)' will
give you the _preceding_ Wednesday, so `newweek(d+7, 3)' will give you
the following Wednesday.  A further look at the definition of `newweek'
shows that if the input date is itself a Wednesday, this formula will
return the Wednesday one week in the future.  An exercise for the
reader is to modify this formula to yield the same day if the input is
already a Wednesday.  Another interesting exercise is to preserve the
time-of-day portion of the input (`newweek' resets the time to
midnight; hint: how can `newweek' be defined in terms of the `weekday'
function?).

   The `pwday(DATE)' function (not on any key) computes the
day-of-month number of the Sunday on or before DATE.  With two
arguments, `pwday(DATE, DAY)' computes the day number of the Sunday on
or before day number DAY of the month specified by DATE.  The DAY must
be in the range from 7 to 31; if the day number is greater than the
actual number of days in the month, the true number of days is used
instead.  Thus `pwday(DATE, 7)' finds the first Sunday of the month, and
`pwday(DATE, 31)' finds the last Sunday of the month.  With a third
WEEKDAY argument, `pwday' can be made to look for any day of the week
instead of Sunday.

   The `t I' (`calc-inc-month') [`incmonth'] command increases a date
form by one month, or by an arbitrary number of months specified by a
numeric prefix argument.  The time portion, if any, of the date form
stays the same.  The day also stays the same, except that if the new
month has fewer days the day number may be reduced to lie in the valid
range.  For example, `incmonth(<Jan 31, 1991>)' produces `<Feb 28,
1991>'.  Because of this, `t I t I' and `M-2 t I' do not always give
the same results (`<Mar 28, 1991>' versus `<Mar 31, 1991>' in this
case).

   The `incyear(DATE, STEP)' function increases a date form by the
specified number of years, which may be any positive or negative
integer.  Note that `incyear(d, n)' is equivalent to
`incmonth(d, 12*n)', but these do not have simple equivalents in terms
of day arithmetic because months and years have varying lengths.  If
the STEP argument is omitted, 1 year is assumed.  There is no keyboard
command for this function; use `C-u 12 t I' instead.

   There is no `newday' function at all because `F' [`floor'] serves
this purpose.  Similarly, instead of `incday' and `incweek' simply use
`d + n' or `d + 7 n'.

   *Note Basic Arithmetic::, for the `f ]' [`incr'] command which can
adjust a date/time form by a certain number of seconds.


File: calc,  Node: Business Days,  Next: Time Zones,  Prev: Date Functions,  Up: Date Arithmetic

9.5.3 Business Days
-------------------

Often time is measured in "business days" or "working days," where
weekends and holidays are skipped.  Calc's normal date arithmetic
functions use calendar days, so that subtracting two consecutive
Mondays will yield a difference of 7 days.  By contrast, subtracting
two consecutive Mondays would yield 5 business days (assuming two-day
weekends and the absence of holidays).

   The `t +' (`calc-business-days-plus') [`badd'] and `t -'
(`calc-business-days-minus') [`bsub'] commands perform arithmetic using
business days.  For `t +', one argument must be a date form and the
other must be a real number (positive or negative).  If the number is
not an integer, then a certain amount of time is added as well as a
number of days; for example, adding 0.5 business days to a time in
Friday evening will produce a time in Monday morning.  It is also
possible to add an HMS form; adding `12@ 0' 0"' also adds half a
business day.  For `t -', the arguments are either a date form and a
number or HMS form, or two date forms, in which case the result is the
number of business days between the two dates.

   By default, Calc considers any day that is not a Saturday or Sunday
to be a business day.  You can define any number of additional holidays
by editing the variable `Holidays'.  (There is an `s H' convenience
command for editing this variable.)  Initially, `Holidays' contains the
vector `[sat, sun]'.  Entries in the `Holidays' vector may be any of
the following kinds of objects:

   * Date forms (pure dates, not date/time forms).  These specify
     particular days which are to be treated as holidays.

   * Intervals of date forms.  These specify a range of days, all of
     which are holidays (e.g., Christmas week).  *Note Interval Forms::.

   * Nested vectors of date forms.  Each date form in the vector is
     considered to be a holiday.

   * Any Calc formula which evaluates to one of the above three things.
     If the formula involves the variable `y', it stands for a yearly
     repeating holiday; `y' will take on various year numbers like
     1992.  For example, `date(y, 12, 25)' specifies Christmas day, and
     `newweek(date(y, 11, 7), 4) + 21' specifies Thanksgiving (which is
     held on the fourth Thursday of November).  If the formula involves
     the variable `m', that variable takes on month numbers from 1 to
     12:  `date(y, m, 15)' is a holiday that takes place on the 15th of
     every month.

   * A weekday name, such as `sat' or `sun'.  This is really a variable
     whose name is a three-letter, lower-case day name.

   * An interval of year numbers (integers).  This specifies the span of
     years over which this holiday list is to be considered valid.  Any
     business-day arithmetic that goes outside this range will result
     in an error message.  Use this if you are including an explicit
     list of holidays, rather than a formula to generate them, and you
     want to make sure you don't accidentally go beyond the last point
     where the holidays you entered are complete.  If there is no
     limiting interval in the `Holidays' vector, the default `[1 ..
     2737]' is used.  (This is the absolute range of years for which
     Calc's business-day algorithms will operate.)

   * An interval of HMS forms.  This specifies the span of hours that
     are to be considered one business day.  For example, if this range
     is `[9@ 0' 0" .. 17@ 0' 0"]' (i.e., 9am to 5pm), then the business
     day is only eight hours long, so that `1.5 t +' on `<4:00pm Fri
     Dec 13, 1991>' will add one business day and four business hours
     to produce `<12:00pm Tue Dec 17, 1991>'.  Likewise, `t -' will now
     express differences in time as fractions of an eight-hour day.
     Times before 9am will be treated as 9am by business date
     arithmetic, and times at or after 5pm will be treated as
     4:59:59pm.  If there is no HMS interval in `Holidays', the full
     24-hour day `[0 0' 0" .. 24 0' 0"]' is assumed.  (Regardless of
     the type of bounds you specify, the interval is treated as
     inclusive on the low end and exclusive on the high end, so that
     the work day goes from 9am up to, but not including, 5pm.)

   If the `Holidays' vector is empty, then `t +' and `t -' will act
just like `+' and `-' because there will then be no difference between
business days and calendar days.

   Calc expands the intervals and formulas you give into a complete
list of holidays for internal use.  This is done mainly to make sure it
can detect multiple holidays.  (For example, `<Jan 1, 1989>' is both
New Year's Day and a Sunday, but Calc's algorithms take care to count
it only once when figuring the number of holidays between two dates.)

   Since the complete list of holidays for all the years from 1 to 2737
would be huge, Calc actually computes only the part of the list between
the smallest and largest years that have been involved in business-day
calculations so far.  Normally, you won't have to worry about this.
Keep in mind, however, that if you do one calculation for 1992, and
another for 1792, even if both involve only a small range of years,
Calc will still work out all the holidays that fall in that 200-year
span.

   If you add a (positive) number of days to a date form that falls on a
weekend or holiday, the date form is treated as if it were the most
recent business day.  (Thus adding one business day to a Friday,
Saturday, or Sunday will all yield the following Monday.)  If you
subtract a number of days from a weekend or holiday, the date is
effectively on the following business day.  (So subtracting one business
day from Saturday, Sunday, or Monday yields the preceding Friday.)  The
difference between two dates one or both of which fall on holidays
equals the number of actual business days between them.  These
conventions are consistent in the sense that, if you add N business
days to any date, the difference between the result and the original
date will come out to N business days.  (It can't be completely
consistent though; a subtraction followed by an addition might come out
a bit differently, since `t +' is incapable of producing a date that
falls on a weekend or holiday.)

   There is a `holiday' function, not on any keys, that takes any date
form and returns 1 if that date falls on a weekend or holiday, as
defined in `Holidays', or 0 if the date is a business day.


File: calc,  Node: Time Zones,  Prev: Business Days,  Up: Date Arithmetic

9.5.4 Time Zones
----------------

Time zones and daylight saving time are a complicated business.  The
conversions to and from Julian and Unix-style dates automatically
compute the correct time zone and daylight saving adjustment to use,
provided they can figure out this information.  This section describes
Calc's time zone adjustment algorithm in detail, in case you want to do
conversions in different time zones or in case Calc's algorithms can't
determine the right correction to use.

   Adjustments for time zones and daylight saving time are done by `t
U', `t J', `t N', and `t C', but not by any other commands.  In
particular, `<may 1 1991> - <apr 1 1991>' evaluates to exactly 30 days
even though there is a daylight-saving transition in between.  This is
also true for Julian pure dates: `julian(<may 1 1991>) - julian(<apr 1
1991>)'.  But Julian and Unix date/times will adjust for daylight
saving time:  using Calc's default daylight saving time rule (see the
explanation below), `julian(<12am may 1 1991>) - julian(<12am apr 1
1991>)' evaluates to `29.95833' (that's 29 days and 23 hours) because
one hour was lost when daylight saving commenced on April 7, 1991.

   In brief, the idiom `julian(DATE1) - julian(DATE2)' computes the
actual number of 24-hour periods between two dates, whereas `DATE1 -
DATE2' computes the number of calendar days between two dates without
taking daylight saving into account.

   The `calc-time-zone' [`tzone'] command converts the time zone
specified by its numeric prefix argument into a number of seconds
difference from Greenwich mean time (GMT).  If the argument is a
number, the result is simply that value multiplied by 3600.  Typical
arguments for North America are 5 (Eastern) or 8 (Pacific).  If
Daylight Saving time is in effect, one hour should be subtracted from
the normal difference.

   If you give a prefix of plain `C-u', `calc-time-zone' (like other
date arithmetic commands that include a time zone argument) takes the
zone argument from the top of the stack.  (In the case of `t J' and `t
U', the normal argument is then taken from the second-to-top stack
position.)  This allows you to give a non-integer time zone adjustment.
The time-zone argument can also be an HMS form, or it can be a variable
which is a time zone name in upper- or lower-case.  For example
`tzone(PST) = tzone(8)' and `tzone(pdt) = tzone(7)' (for Pacific
standard and daylight saving times, respectively).

   North American and European time zone names are defined as follows;
note that for each time zone there is one name for standard time,
another for daylight saving time, and a third for "generalized" time in
which the daylight saving adjustment is computed from context.

     YST  PST  MST  CST  EST  AST    NST    GMT   WET     MET    MEZ
      9    8    7    6    5    4     3.5     0     -1      -2     -2

     YDT  PDT  MDT  CDT  EDT  ADT    NDT    BST  WETDST  METDST  MESZ
      8    7    6    5    4    3     2.5     -1    -2      -3     -3

     YGT  PGT  MGT  CGT  EGT  AGT    NGT    BGT   WEGT    MEGT   MEGZ
     9/8  8/7  7/6  6/5  5/4  4/3  3.5/2.5  0/-1 -1/-2   -2/-3  -2/-3

   To define time zone names that do not appear in the above table, you
must modify the Lisp variable `math-tzone-names'.  This is a list of
lists describing the different time zone names; its structure is best
explained by an example.  The three entries for Pacific Time look like
this:

     ( ( "PST" 8 0 )    ; Name as an upper-case string, then standard
       ( "PDT" 8 -1 )   ; adjustment, then daylight saving adjustment.
       ( "PGT" 8 "PST" "PDT" ) )   ; Generalized time zone.

   With no arguments, `calc-time-zone' or `tzone()' will by default get
the time zone and daylight saving information from the calendar (*note
Calendar/Diary: (emacs)Daylight Saving.).  To use a different time
zone, or if the calendar does not give the desired result, you can set
the Calc variable `TimeZone' (which is by default `nil') to an
appropriate time zone name.  (The easiest way to do this is to edit the
`TimeZone' variable using Calc's `s T' command, then use the `s p'
(`calc-permanent-variable') command to save the value of `TimeZone'
permanently.)  If the time zone given by `TimeZone' is a generalized
time zone, e.g., `EGT', Calc examines the date being converted to tell
whether to use standard or daylight saving time.  But if the current
time zone is explicit, e.g., `EST' or `EDT', then that adjustment is
used exactly and Calc's daylight saving algorithm is not consulted.
The special time zone name `local' is equivalent to no argument; i.e.,
it uses the information obtained from the calendar.

   The `t J' and `t U' commands with no numeric prefix arguments do the
same thing as `tzone()'; namely, use the information from the calendar
if `TimeZone' is `nil', otherwise use the time zone given by `TimeZone'.

   When Calc computes the daylight saving information itself (i.e., when
the `TimeZone' variable is set), it will by default consider daylight
saving time to begin at 2 a.m. on the second Sunday of March (for years
from 2007 on) or on the last Sunday in April (for years before 2007),
and to end at 2 a.m. on the first Sunday of November. (for years from
2007 on) or the last Sunday in October (for years before 2007).  These
are the rules that have been in effect in much of North America since
1966 and take into account the rule change that began in 2007.  If you
are in a country that uses different rules for computing daylight
saving time, you have two choices: Write your own daylight saving hook,
or control time zones explicitly by setting the `TimeZone' variable
and/or always giving a time-zone argument for the conversion functions.

   The Lisp variable `math-daylight-savings-hook' holds the name of a
function that is used to compute the daylight saving adjustment for a
given date.  The default is `math-std-daylight-savings', which computes
an adjustment (either 0 or -1) using the North American rules given
above.

   The daylight saving hook function is called with four arguments: The
date, as a floating-point number in standard Calc format; a six-element
list of the date decomposed into year, month, day, hour, minute, and
second, respectively; a string which contains the generalized time zone
name in upper-case, e.g., `"WEGT"'; and a special adjustment to be
applied to the hour value when converting into a generalized time zone
(see below).

   The Lisp function `math-prev-weekday-in-month' is useful for
daylight saving computations.  This is an internal version of the
user-level `pwday' function described in the previous section. It takes
four arguments:  The floating-point date value, the corresponding
six-element date list, the day-of-month number, and the weekday number
(0-6).

   The default daylight saving hook ignores the time zone name, but a
more sophisticated hook could use different algorithms for different
time zones.  It would also be possible to use different algorithms
depending on the year number, but the default hook always uses the
algorithm for 1987 and later.  Here is a listing of the default
daylight saving hook:

     (defun math-std-daylight-savings (date dt zone bump)
       (cond ((< (nth 1 dt) 4) 0)
             ((= (nth 1 dt) 4)
              (let ((sunday (math-prev-weekday-in-month date dt 7 0)))
                (cond ((< (nth 2 dt) sunday) 0)
                      ((= (nth 2 dt) sunday)
                       (if (>= (nth 3 dt) (+ 3 bump)) -1 0))
                      (t -1))))
             ((< (nth 1 dt) 10) -1)
             ((= (nth 1 dt) 10)
              (let ((sunday (math-prev-weekday-in-month date dt 31 0)))
                (cond ((< (nth 2 dt) sunday) -1)
                      ((= (nth 2 dt) sunday)
                       (if (>= (nth 3 dt) (+ 2 bump)) 0 -1))
                      (t 0))))
             (t 0))
     )

The `bump' parameter is equal to zero when Calc is converting from a
date form in a generalized time zone into a GMT date value.  It is -1
when Calc is converting in the other direction.  The adjustments shown
above ensure that the conversion behaves correctly and reasonably
around the 2 a.m. transition in each direction.

   There is a "missing" hour between 2 a.m. and 3 a.m. at the beginning
of daylight saving time; converting a date/time form that falls in this
hour results in a time value for the following hour, from 3 a.m. to 4
a.m.  At the end of daylight saving time, the hour from 1 a.m. to 2
a.m. repeats itself; converting a date/time form that falls in this
hour results in a time value for the first manifestation of that time
(_not_ the one that occurs one hour later).

   If `math-daylight-savings-hook' is `nil', then the daylight saving
adjustment is always taken to be zero.

   In algebraic formulas, `tzone(ZONE, DATE)' computes the time zone
adjustment for a given zone name at a given date.  The DATE is ignored
unless ZONE is a generalized time zone.  If DATE is a date form, the
daylight saving computation is applied to it as it appears.  If DATE is
a numeric date value, it is adjusted for the daylight-saving version of
ZONE before being given to the daylight saving hook.  This odd-sounding
rule ensures that the daylight-saving computation is always done in
local time, not in the GMT time that a numeric DATE is typically
represented in.

   The `dsadj(DATE, ZONE)' function computes the daylight saving
adjustment that is appropriate for DATE in time zone ZONE.  If ZONE is
explicitly in or not in daylight saving time (e.g., `PDT' or `PST') the
DATE is ignored.  If ZONE is a generalized time zone, the algorithms
described above are used.  If ZONE is omitted, the computation is done
for the current time zone.


File: calc,  Node: Financial Functions,  Next: Binary Functions,  Prev: Date Arithmetic,  Up: Arithmetic

9.6 Financial Functions
=======================

Calc's financial or business functions use the `b' prefix key followed
by a shifted letter.  (The `b' prefix followed by a lower-case letter
is used for operations on binary numbers.)

   Note that the rate and the number of intervals given to these
functions must be on the same time scale, e.g., both months or both
years.  Mixing an annual interest rate with a time expressed in months
will give you very wrong answers!

   It is wise to compute these functions to a higher precision than you
really need, just to make sure your answer is correct to the last
penny; also, you may wish to check the definitions at the end of this
section to make sure the functions have the meaning you expect.

* Menu:

* Percentages::
* Future Value::
* Present Value::
* Related Financial Functions::
* Depreciation Functions::
* Definitions of Financial Functions::


File: calc,  Node: Percentages,  Next: Future Value,  Prev: Financial Functions,  Up: Financial Functions

9.6.1 Percentages
-----------------

The `M-%' (`calc-percent') command takes a percentage value, say 5.4,
and converts it to an equivalent actual number.  For example, `5.4 M-%'
enters 0.054 on the stack.  (That's the <META> or <ESC> key combined
with `%'.)

   Actually, `M-%' creates a formula of the form `5.4%'.  You can enter
`5.4%' yourself during algebraic entry.  The `%' operator simply means,
"the preceding value divided by 100."  The `%' operator has very high
precedence, so that `1+8%' is interpreted as `1+(8%)', not as `(1+8)%'.
(The `%' operator is just a postfix notation for the `percent'
function, just like `20!' is the notation for `fact(20)', or
twenty-factorial.)

   The formula `5.4%' would normally evaluate immediately to 0.054, but
the `M-%' command suppresses evaluation as it puts the formula onto the
stack.  However, the next Calc command that uses the formula `5.4%'
will evaluate it as its first step.  The net effect is that you get to
look at `5.4%' on the stack, but Calc commands see it as `0.054', which
is what they expect.

   In particular, `5.4%' and `0.054' are suitable values for the RATE
arguments of the various financial functions, but the number `5.4' is
probably _not_ suitable--it represents a rate of 540 percent!

   The key sequence `M-% *' effectively means "percent-of."  For
example, `68 <RET> 25 M-% *' computes 17, which is 25% of 68 (and also
68% of 25, which comes out to the same thing).

   The `c %' (`calc-convert-percent') command converts the value on the
top of the stack from numeric to percentage form.  For example, if 0.08
is on the stack, `c %' converts it to `8%'.  The quantity is the same,
it's just represented differently.  (Contrast this with `M-%', which
would convert this number to `0.08%'.)  The `=' key is a convenient way
to convert a formula like `8%' back to numeric form, 0.08.

   To compute what percentage one quantity is of another quantity, use
`/ c %'.  For example, `17 <RET> 68 / c %' displays `25%'.

   The `b %' (`calc-percent-change') [`relch'] command calculates the
percentage change from one number to another.  For example, `40 <RET>
50 b %' produces the answer `25%', since 50 is 25% larger than 40.  A
negative result represents a decrease:  `50 <RET> 40 b %' produces
`-20%', since 40 is 20% smaller than 50.  (The answers are different in
magnitude because, in the first case, we're increasing by 25% of 40, but
in the second case, we're decreasing by 20% of 50.)  The effect of `40
<RET> 50 b %' is to compute `(50-40)/40', converting the answer to
percentage form as if by `c %'.


File: calc,  Node: Future Value,  Next: Present Value,  Prev: Percentages,  Up: Financial Functions

9.6.2 Future Value
------------------

The `b F' (`calc-fin-fv') [`fv'] command computes the future value of
an investment.  It takes three arguments from the stack:  `fv(RATE, N,
PAYMENT)'.  If you give payments of PAYMENT every year for N years, and
the money you have paid earns interest at RATE per year, then this
function tells you what your investment would be worth at the end of
the period.  (The actual interval doesn't have to be years, as long as
N and RATE are expressed in terms of the same intervals.)  This
function assumes payments occur at the _end_ of each interval.

   The `I b F' [`fvb'] command does the same computation, but assuming
your payments are at the beginning of each interval.  Suppose you plan
to deposit $1000 per year in a savings account earning 5.4% interest,
starting right now.  How much will be in the account after five years?
`fvb(5.4%, 5, 1000) = 5870.73'.  Thus you will have earned $870 worth
of interest over the years.  Using the stack, this calculation would
have been `5.4 M-% 5 <RET> 1000 I b F'.  Note that the rate is expressed
as a number between 0 and 1, _not_ as a percentage.

   The `H b F' [`fvl'] command computes the future value of an initial
lump sum investment.  Suppose you could deposit those five thousand
dollars in the bank right now; how much would they be worth in five
years?  `fvl(5.4%, 5, 5000) = 6503.89'.

   The algebraic functions `fv' and `fvb' accept an optional fourth
argument, which is used as an initial lump sum in the sense of `fvl'.
In other words, `fv(RATE, N, PAYMENT, INITIAL) = fv(RATE, N, PAYMENT) +
fvl(RATE, N, INITIAL)'.

   To illustrate the relationships between these functions, we could do
the `fvb' calculation "by hand" using `fvl'.  The final balance will be
the sum of the contributions of our five deposits at various times.
The first deposit earns interest for five years:  `fvl(5.4%, 5, 1000) =
1300.78'.  The second deposit only earns interest for four years:
`fvl(5.4%, 4, 1000) = 1234.13'.  And so on down to the last deposit,
which earns one year's interest:  `fvl(5.4%, 1, 1000) = 1054.00'.  The
sum of these five values is, sure enough, $5870.73, just as was computed
by `fvb' directly.

   What does `fv(5.4%, 5, 1000) = 5569.96' mean?  The payments are now
at the ends of the periods.  The end of one year is the same as the
beginning of the next, so what this really means is that we've lost the
payment at year zero (which contributed $1300.78), but we're now
counting the payment at year five (which, since it didn't have a chance
to earn interest, counts as $1000).  Indeed, `5569.96 = 5870.73 -
1300.78 + 1000' (give or take a bit of roundoff error).


File: calc,  Node: Present Value,  Next: Related Financial Functions,  Prev: Future Value,  Up: Financial Functions

9.6.3 Present Value
-------------------

The `b P' (`calc-fin-pv') [`pv'] command computes the present value of
an investment.  Like `fv', it takes three arguments:  `pv(RATE, N,
PAYMENT)'.  It computes the present value of a series of regular
payments.  Suppose you have the chance to make an investment that will
pay $2000 per year over the next four years; as you receive these
payments you can put them in the bank at 9% interest.  You want to know
whether it is better to make the investment, or to keep the money in
the bank where it earns 9% interest right from the start.  The
calculation `pv(9%, 4, 2000)' gives the result 6479.44.  If your
initial investment must be less than this, say, $6000, then the
investment is worthwhile.  But if you had to put up $7000, then it
would be better just to leave it in the bank.

   Here is the interpretation of the result of `pv':  You are trying to
compare the return from the investment you are considering, which is
`fv(9%, 4, 2000) = 9146.26', with the return from leaving the money in
the bank, which is `fvl(9%, 4, X)' where X is the amount of money you
would have to put up in advance.  The `pv' function finds the
break-even point, `x = 6479.44', at which `fvl(9%, 4, 6479.44)' is also
equal to 9146.26.  This is the largest amount you should be willing to
invest.

   The `I b P' [`pvb'] command solves the same problem, but with
payments occurring at the beginning of each interval.  It has the same
relationship to `fvb' as `pv' has to `fv'.  For example `pvb(9%, 4,
2000) = 7062.59', a larger number than `pv' produced because we get to
start earning interest on the return from our investment sooner.

   The `H b P' [`pvl'] command computes the present value of an
investment that will pay off in one lump sum at the end of the period.
For example, if we get our $8000 all at the end of the four years,
`pvl(9%, 4, 8000) = 5667.40'.  This is much less than `pv' reported,
because we don't earn any interest on the return from this investment.
Note that `pvl' and `fvl' are simple inverses:  `fvl(9%, 4, 5667.40) =
8000'.

   You can give an optional fourth lump-sum argument to `pv' and `pvb';
this is handled in exactly the same way as the fourth argument for `fv'
and `fvb'.

   The `b N' (`calc-fin-npv') [`npv'] command computes the net present
value of a series of irregular investments.  The first argument is the
interest rate.  The second argument is a vector which represents the
expected return from the investment at the end of each interval.  For
example, if the rate represents a yearly interest rate, then the vector
elements are the return from the first year, second year, and so on.

   Thus, `npv(9%, [2000,2000,2000,2000]) = pv(9%, 4, 2000) = 6479.44'.
Obviously this function is more interesting when the payments are not
all the same!

   The `npv' function can actually have two or more arguments.
Multiple arguments are interpreted in the same way as for the vector
statistical functions like `vsum'.  *Note Single-Variable Statistics::.
Basically, if there are several payment arguments, each either a vector
or a plain number, all these values are collected left-to-right into
the complete list of payments.  A numeric prefix argument on the `b N'
command says how many payment values or vectors to take from the stack.

   The `I b N' [`npvb'] command computes the net present value where
payments occur at the beginning of each interval rather than at the end.

