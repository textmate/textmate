This is /home/cyd/emacs/doc/emacs/../../info/emacs, produced by
makeinfo version 4.13 from /home/cyd/emacs/doc/emacs/emacs.texi.

This is the `GNU Emacs Manual', updated for Emacs version 24.1.

Copyright (C) 1985-1987, 1993-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).       The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


File: emacs,  Node: Top,  Next: Distrib,  Prev: (dir),  Up: (dir)

The Emacs Editor
****************

Emacs is the extensible, customizable, self-documenting real-time
display editor.  This Info file describes how to edit with Emacs and
some of the ways to customize it; it corresponds to GNU Emacs version
24.1.

   If you are reading this in Emacs, type `h' to read a basic
introduction to the Info documentation system.

   For information on extending Emacs, see *note Emacs Lisp: (elisp)Top.

   This is the `GNU Emacs Manual', updated for Emacs version 24.1.

   Copyright (C) 1985-1987, 1993-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

* Menu:

* Distrib::             How to get the latest Emacs distribution.
* Intro::               An introduction to Emacs concepts.
* Glossary::            Terms used in this manual.

Indexes (each index contains a large menu)
* Key Index::           An item for each standard Emacs key sequence.
* Option Index::        An item for every command-line option.
* Command Index::       An item for each command name.
* Variable Index::      An item for each documented variable.
* Concept Index::       An item for each concept.

* Acknowledgments::     Major contributors to GNU Emacs.

Important General Concepts
* Screen::              How to interpret what you see on the screen.
* User Input::          Kinds of input events (characters, buttons,
                          function keys).
* Keys::                Key sequences: what you type to request one
                          editing action.
* Commands::            Named functions run by key sequences to do editing.
* Entering Emacs::      Starting Emacs from the shell.
* Exiting::             Stopping or killing Emacs.

Fundamental Editing Commands
* Basic::               The most basic editing commands.
* Minibuffer::          Entering arguments that are prompted for.
* M-x::                 Invoking commands by their names.
* Help::                Commands for asking Emacs about its commands.

Important Text-Changing Commands
* Mark::                The mark: how to delimit a "region" of text.
* Killing::             Killing (cutting) and yanking (copying) text.
* Registers::           Saving a text string or a location in the buffer.
* Display::             Controlling what text is displayed.
* Search::              Finding or replacing occurrences of a string.
* Fixit::               Commands especially useful for fixing typos.
* Keyboard Macros::     Recording a sequence of keystrokes to be replayed.

Major Structures of Emacs
* Files::               All about handling files.
* Buffers::             Multiple buffers; editing several files at once.
* Windows::             Viewing multiple pieces of text in one frame.
* Frames::              Using multiple "windows" on your display.
* International::       Using non-ASCII character sets.

Advanced Features
* Modes::               Major and minor modes alter Emacs's basic behavior.
* Indentation::         Editing the white space at the beginnings of lines.
* Text::                Commands and modes for editing human languages.
* Programs::            Commands and modes for editing programs.
* Building::            Compiling, running and debugging programs.
* Maintaining::         Features for maintaining large programs.
* Abbrevs::             Defining text abbreviations to reduce typing.
* Dired::               Directory and file manager.
* Calendar/Diary::      Calendar and diary facilities.
* Sending Mail::        Sending mail in Emacs.
* Rmail::               Reading mail in Emacs.
* Gnus::                A flexible mail and news reader.
* Document View::       Viewing PDF, PS and DVI files.
* Shell::               Executing shell commands from Emacs.
* Emacs Server::        Using Emacs as an editing server.
* Printing::            Printing hardcopies of buffers or regions.
* Sorting::             Sorting lines, paragraphs or pages within Emacs.

* Picture Mode::        Editing pictures made up of text characters.
* Editing Binary Files::  Editing binary files with Hexl mode.
* Saving Emacs Sessions:: Saving Emacs state from one session to the next.
* Recursive Edit::      Performing edits while "within another command".
* Emulation::           Emulating some other editors with Emacs.
* Hyperlinking::        Following links in buffers.
* Amusements::          Various games and hacks.
* Packages::            Installing additional features.
* Customization::       Modifying the behavior of Emacs.

Recovery from Problems
* Quitting::            Quitting and aborting.
* Lossage::             What to do if Emacs is hung or malfunctioning.
* Bugs::                How and when to report a bug.
* Contributing::        How to contribute improvements to Emacs.
* Service::             How to get help for your own Emacs needs.

Appendices
* Copying::             The GNU General Public License gives you permission
                          to redistribute GNU Emacs on certain terms;
                          it also explains that there is no warranty.
* GNU Free Documentation License:: The license for this documentation.
* Emacs Invocation::    Hairy startup options.
* X Resources::         X resources for customizing Emacs.
* Antinews::            Information about Emacs version 23.
* Mac OS / GNUstep::    Using Emacs under Mac OS and GNUstep.
* Microsoft Windows::   Using Emacs on Microsoft Windows and MS-DOS.
* Manifesto::           What's GNU?  Gnu's Not Unix!


 --- The Detailed Node Listing ---
 ---------------------------------

Here are some other nodes which are really subnodes of the ones
already listed, mentioned here so you can get to them in one step:

The Organization of the Screen

* Point::               The place in the text where editing commands operate.
* Echo Area::           Short messages appear at the bottom of the screen.
* Mode Line::           Interpreting the mode line.
* Menu Bar::            How to use the menu bar.

Basic Editing Commands

* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        Moving the cursor to the place where you want to
                        change something.
* Erasing::             Deleting and killing text.
* Basic Undo::          Undoing recent changes in the text.
* Basic Files::         Visiting, creating, and saving files.
* Basic Help::          Asking what a character does.
* Blank Lines::         Making and deleting blank lines.
* Continuation Lines::  How Emacs displays lines too wide for the screen.
* Position Info::       What line, row, or column is point on?
* Arguments::           Numeric arguments for repeating a command N times.
* Repeating::           Repeating the previous command quickly.

The Minibuffer

* Minibuffer File::     Entering file names with the minibuffer.
* Minibuffer Edit::     How to edit in the minibuffer.
* Completion::          An abbreviation facility for minibuffer input.
* Minibuffer History::  Reusing recent minibuffer arguments.
* Repetition::          Re-executing commands that used the minibuffer.
* Passwords::           Entering passwords in the echo area.

Completion

* Completion Example::  Examples of using completion.
* Completion Commands:: A list of completion commands.
* Completion Exit::     Completion and minibuffer text submission.
* Completion Styles::   How completion matches are chosen.
* Completion Options::  Options for completion.

Help

* Help Summary::        Brief list of all Help commands.
* Key Help::            Asking what a key does in Emacs.
* Name Help::           Asking about a command, variable or function name.
* Apropos::             Asking what pertains to a given topic.
* Help Mode::           Special features of Help mode and Help buffers.
* Package Keywords::    Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Misc Help::           Other help commands.
* Help Files::          Commands to display auxiliary help files.
* Help Echo::           Help on active text and tooltips ("balloon help").

The Mark and the Region

* Setting Mark::        Commands to set the mark.
* Marking Objects::     Commands to put region around textual units.
* Using Region::        Summary of ways to operate on contents of the region.
* Mark Ring::           Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.
* Shift Selection::     Using shifted cursor motion keys.
* Disabled Transient Mark:: Leaving regions unhighlighted by default.

Killing and Moving Text

* Deletion and Killing:: Commands that remove text.
* Yanking::             Commands that insert text.
* Cut and Paste::       Clipboard and selections on graphical displays.
* Accumulating Text::   Other methods to add text to the buffer.
* Rectangles::          Operating on text in rectangular areas.
* CUA Bindings::        Using C-x/C-c/C-v to kill and yank.

Deletion and Killing

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.
* Kill Options::        Options that affect killing.

Yanking

* Kill Ring::           Where killed text is stored.
* Earlier Kills::       Yanking something killed some time ago.
* Appending Kills::     Several kills in a row all yank together.

"Cut and Paste" Operations on Graphical Displays

* Clipboard::           How Emacs uses the system clipboard.
* Primary Selection::   The temporarily selected text selection.
* Secondary Selection:: Cutting without altering point and mark.

Registers

* Position Registers::      Saving positions in registers.
* Text Registers::          Saving text in registers.
* Rectangle Registers::     Saving rectangles in registers.
* Configuration Registers:: Saving window configurations in registers.
* Number Registers::        Numbers in registers.
* File Registers::          File names in registers.
* Bookmarks::               Bookmarks are like registers, but persistent.

Controlling the Display

* Scrolling::              Commands to move text up and down in a window.
* Recentering::            A scroll command that centers the current line.
* Auto Scrolling::         Redisplay scrolls text automatically when needed.
* Horizontal Scrolling::   Moving text left and right in a window.
* Narrowing::              Restricting display and editing to a portion
                             of the buffer.
* View Mode::              Viewing read-only buffers.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Faces::                  How to change the display style using faces.
* Colors::                 Specifying colors for faces.
* Standard Faces::         The main predefined faces.
* Text Scale::             Increasing or decreasing text size in a buffer.
* Font Lock::              Minor mode for syntactic highlighting using faces.
* Highlight Interactively:: Tell Emacs what text to highlight.
* Fringes::                Enabling or disabling window fringes.
* Displaying Boundaries::  Displaying top and bottom of the buffer.
* Useless Whitespace::     Showing possibly spurious trailing whitespace.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Cursor Display::         Features for displaying the cursor.
* Line Truncation::        Truncating lines to fit the screen width instead
                             of continuing them to multiple screen lines.
* Visual Line Mode::       Word wrap and screen line-based editing.
* Display Custom::         Information on variables for customizing display.

Searching and Replacement

* Incremental Search::     Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::            Search for sequence of words.
* Regexp Search::          Search for match for a regexp.
* Regexps::                Syntax of regular expressions.
* Regexp Backslash::       Regular expression constructs starting with `\'.
* Regexp Example::         A complex regular expression explained.
* Search Case::            To ignore case while searching, or not.
* Replace::                Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.

Incremental Search

* Basic Isearch::       Basic incremental search commands.
* Repeat Isearch::      Searching for the same string again.
* Error in Isearch::    When your string is not found.
* Special Isearch::     Special input in incremental search.
* Isearch Yank::        Commands that grab text into the search string
                          or else edit the search string.
* Isearch Scroll::      Scrolling during an incremental search.
* Isearch Minibuffer::  Incremental search of the minibuffer history.

Replacement Commands

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.

Commands for Fixing Typos

* Undo::                The Undo commands.
* Transpose::           Exchanging two characters, words, lines, lists...
* Fixing Case::         Correcting case of last word entered.
* Spelling::            Apply spelling checker to a word, or a whole file.

Keyboard Macros

* Basic Keyboard Macro::     Defining and running keyboard macros.
* Keyboard Macro Ring::      Where previous keyboard macros are saved.
* Keyboard Macro Counter::   Inserting incrementing numbers in macros.
* Keyboard Macro Query::     Making keyboard macros do different things each
                                time.
* Save Keyboard Macro::      Giving keyboard macros names; saving them in
                                files.
* Edit Keyboard Macro::      Editing keyboard macros.
* Keyboard Macro Step-Edit:: Interactively executing and editing a keyboard
                                macro.

File Handling

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.

* Autorevert::          Auto Reverting non-file buffers.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Diff Mode::           Mode for editing file differences.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* File Archives::       Operating on tar, zip, jar etc. archive files.
* Remote Files::        Accessing files on other machines.
* Quoted File Names::   Quoting special characters in file names.
* File Name Cache::     Completion against a list of files you often use.
* File Conveniences::   Convenience Features for Finding Files.
* Filesets::            Handling sets of files.

Saving Files

* Save Commands::       Commands for saving files.
* Backup::              How Emacs saves the old version of your file.
* Customize Save::      Customizing the saving of files.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.
* File Shadowing::      Copying files to "shadows" automatically.
* Time Stamps::         Emacs can update time stamps on saved files.

Backup Files

* Backup Names::        How backup files are named.
* Backup Deletion::     Emacs deletes excess numbered backups.
* Backup Copying::      Backups can be made by copying or renaming.


Auto Reverting Non-File Buffers

* Auto Reverting the Buffer Menu:: Auto Revert of the Buffer Menu.
* Auto Reverting Dired::           Auto Revert of Dired buffers.
* Supporting additional buffers::  How to add more Auto Revert support.

Auto-Saving: Protection Against Disasters

* Auto Save Files::     The file where auto-saved changes are
                          actually made until you save the file.
* Auto Save Control::   Controlling when and how often to auto-save.
* Recover::             Recovering text from auto-save files.

Using Multiple Buffers

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::         Renaming; changing read-onlyness; copying text.
* Kill Buffer::         Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
                          and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer.
* Buffer Convenience::  Convenience and customization features for
                          buffer handling.

Convenience Features and Customization of Buffer Handling

* Uniquify::            Making buffer names unique with directory parts.
* Iswitchb::            Switching between buffers with substrings.
* Buffer Menus::        Configurable buffer menu.

Multiple Windows

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Change Window::       Deleting windows and changing their sizes.
* Displaying Buffers::  How Emacs picks a window for displaying a buffer.
* Window Convenience::  Convenience functions for window handling.

Displaying a Buffer in a Window

* Window Choice::       How `display-buffer' works.

Frames and Graphical Displays

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Word and Line Mouse:: Mouse commands for selecting whole words or lines.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Frame Commands::      Iconifying, deleting, and switching frames.
* Fonts::               Changing the frame font.
* Speedbar::            How to make and use a speedbar frame.
* Multiple Displays::   How one Emacs instance can talk to several displays.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::         How to enable and disable scroll bars; how to use them.
* Drag and Drop::       Using drag and drop to open files and insert text.
* Menu Bars::           Enabling and disabling the menu bar.
* Tool Bars::           Enabling and disabling the tool bar.
* Dialog Boxes::        Controlling use of dialog boxes.
* Tooltips::            Displaying information at the current mouse position.
* Mouse Avoidance::     Preventing the mouse pointer from obscuring text.
* Non-Window Terminals::  Multiple frames on terminals that show only one.
* Text-Only Mouse::     Using the mouse in text terminals.

International Character Set Support

* International Chars::     Basic concepts of multibyte characters.
* Disabling Multibyte::     Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Specifying a file's coding system explicitly.
* Output Coding::           Choosing coding systems for output.
* Text Coding::             Choosing conversion to use for file text.
* Communication Coding::    Coding systems for interprocess communication.
* File Name Coding::        Coding systems for file _names_.
* Terminal Coding::         Specifying coding systems for converting
                              terminal input and output.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Modifying Fontsets::      Modifying an existing fontset.
* Undisplayable Characters::When characters don't display.
* Unibyte Mode::            You can pick one European character set
                              to use without multibyte characters.
* Charsets::                How Emacs groups its internal character codes.
* Bidirectional Editing::   Support for right-to-left scripts.

Major and Minor Modes

* Major Modes::         Text mode vs. Lisp mode vs. C mode...
* Minor Modes::         Each minor mode is a feature you can turn on
                          independently of any others.
* Choosing Modes::      How modes are chosen when visiting files.

Indentation

* Indentation Commands::  More commands for performing indentation.
* Tab Stops::             Stop points for indentation in Text modes.
* Just Spaces::           Using only space characters for indentation.
* Indent Convenience::    Optional indentation features.

Commands for Human Languages

* Words::               Moving over and killing words.
* Sentences::           Moving over and killing sentences.
* Paragraphs::          Moving over paragraphs.
* Pages::               Moving over pages.
* Filling::             Filling or justifying text.
* Case::                Changing the case of text.
* Text Mode::           The major modes for editing text files.
* Outline Mode::        Editing outlines.
* Org Mode::            The Emacs organizer.
* TeX Mode::            Editing TeX and LaTeX files.
* HTML Mode::           Editing HTML and SGML files.
* Nroff Mode::          Editing input to the nroff formatter.
* Enriched Text::       Editing text "enriched" with fonts, colors, etc.
* Text Based Tables::   Commands for editing text-based tables.
* Two-Column::          Splitting text columns into separate windows.

Filling Text

* Auto Fill::           Auto Fill mode breaks long lines automatically.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::         Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.

Outline Mode

* Outline Format::      What the text of an outline looks like.
* Outline Motion::      Special commands for moving through outlines.
* Outline Visibility::  Commands to control what is visible.
* Outline Views::       Outlines and multiple views.
* Foldout::             Folding means zooming in on outlines.

Org Mode

* Org Organizer::       Managing TODO lists and agendas.
* Org Authoring::       Exporting Org buffers to various formats.

TeX Mode

* TeX Editing::         Special commands for editing in TeX mode.
* LaTeX Editing::       Additional commands for LaTeX input files.
* TeX Print::           Commands for printing part of a file with TeX.
* TeX Misc::            Customization of TeX mode, and related features.

Enriched Text

* Enriched Mode::           Entering and exiting Enriched mode.
* Hard and Soft Newlines::  There are two different kinds of newlines.
* Editing Format Info::     How to edit text properties.
* Enriched Faces::          Bold, italic, underline, etc.
* Enriched Indentation::    Changing the left and right margins.
* Enriched Justification::  Centering, setting text flush with the
                              left or right margin, etc.
* Enriched Properties::     The "special" text properties submenu.


Editing Text-based Tables

* Table Definition::    What is a text based table.
* Table Creation::      How to create a table.
* Table Recognition::   How to activate and deactivate tables.
* Cell Commands::       Cell-oriented commands in a table.
* Cell Justification::  Justifying cell contents.
* Table Rows and Columns:: Inserting and deleting rows and columns.
* Table Conversion::    Converting between plain text and tables.
* Table Misc::          Table miscellany.

Editing Programs

* Program Modes::       Major modes for editing programs.
* Defuns::              Commands to operate on major top-level parts
                          of a program.
* Program Indent::      Adjusting indentation to show the nesting.
* Parentheses::         Commands that operate on parentheses.
* Comments::            Inserting, killing, and aligning comments.
* Documentation::       Getting documentation of functions you plan to call.
* Hideshow::            Displaying blocks selectively.
* Symbol Completion::   Completion on symbol names of your program or language.
* Glasses::             Making identifiersLikeThis more readable.
* Semantic::            Suite of editing tools based on source code parsing.
* Misc for Programs::   Other Emacs features useful for editing programs.
* C Modes::             Special commands of C, C++, Objective-C,
                          Java, IDL, Pike and AWK modes.
* Asm Mode::            Asm mode and its special features.

* Fortran::             Fortran mode and its special features.

Top-Level Definitions, or Defuns

* Left Margin Paren::   An open-paren or similar opening delimiter
                          starts a defun if it is at the left margin.
* Moving by Defuns::    Commands to move over or mark a major definition.
* Imenu::               Making buffer indexes as menus.
* Which Function::      Which Function mode shows which function you are in.

Indentation for Programs

* Basic Indent::        Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::         Specifying how each Lisp function should be indented.
* C Indent::            Extra features for indenting C and related modes.
* Custom C Indent::     Controlling indentation style for C and related modes.

Commands for Editing with Parentheses

* Expressions::         Expressions with balanced parentheses.
* Moving by Parens::    Commands for moving up, down and across
                          in the structure of parentheses.
* Matching::            Insertion of a close-delimiter flashes matching open.

Manipulating Comments

* Comment Commands::    Inserting, killing, and aligning comments.
* Multi-Line Comments:: Commands for adding and editing multi-line comments.
* Options for Comments::Customizing the comment features.

Documentation Lookup

* Info Lookup::        Looking up library functions and commands in Info files.
* Man Page::           Looking up man pages of library functions and commands.
* Lisp Doc::           Looking up Emacs Lisp functions, etc.

C and Related Modes

* Motion in C::         Commands to move by C statements, etc.
* Electric C::          Colon and other chars can automatically reindent.
* Hungry Delete::       A more powerful DEL command.
* Other C Commands::    Filling comments, viewing expansion of macros,
                          and other neat features.


Fortran Mode

* Fortran Motion::      Moving point by statements or subprograms.
* Fortran Indent::      Indentation commands for Fortran.
* Fortran Comments::    Inserting and aligning comments.
* Fortran Autofill::    Auto fill support for Fortran.
* Fortran Columns::     Measuring columns for valid Fortran.
* Fortran Abbrev::      Built-in abbrevs for Fortran keywords.

Fortran Indentation

* ForIndent Commands::  Commands for indenting and filling Fortran.
* ForIndent Cont::      How continuation lines indent.
* ForIndent Num::       How line numbers auto-indent.
* ForIndent Conv::      Conventions you must obey to avoid trouble.
* ForIndent Vars::      Variables controlling Fortran indent style.

Compiling and Testing Programs

* Compilation::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Grep Searching::      Searching with grep.
* Flymake::             Finding syntax errors on the fly.
* Debuggers::           Running symbolic debuggers for non-Lisp programs.
* Executing Lisp::      Various modes for editing Lisp programs,
                          with different facilities for running
                          the Lisp programs.
* Lisp Libraries::      How Lisp programs are loaded into Emacs.
* Lisp Eval::           Executing a single Lisp expression in Emacs.
* Lisp Interaction::    Executing Lisp in an Emacs buffer.
* External Lisp::       Communicating through Emacs with a separate Lisp.

Running Debuggers Under Emacs

* Starting GUD::        How to start a debugger subprocess.
* Debugger Operation::  Connection between the debugger and source buffers.
* Commands of GUD::     Key bindings for common commands.
* GUD Customization::   Defining your own commands for GUD.
* GDB Graphical Interface::  An enhanced mode that uses GDB features to
                          implement a graphical debugging environment.

GDB Graphical Interface

* GDB User Interface Layout::   Control the number of displayed buffers.
* Source Buffers::              Use the mouse in the fringe/margin to
                                control your program.
* Breakpoints Buffer::          A breakpoint control panel.
* Threads Buffer::              Displays your threads.
* Stack Buffer::                Select a frame from the call stack.
* Other GDB Buffers::           Other buffers for controlling the GDB state.
* Watch Expressions::           Monitor variable values in the speedbar.
* Multithreaded Debugging::     Debugging programs with several threads.

Maintaining Large Programs

* Version Control::     Using version control systems.
* Change Log::          Maintaining a change history for your program.
* Tags::                Go directly to any function in your program in one
                          command.  Tags remembers which file it is in.
* EDE::                 An integrated development environment for Emacs.

* Emerge::              A convenient way of merging two versions of a program.

Version Control

* Introduction to VC::  How version control works in general.
* VC Mode Line::        How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Log Buffer::          Features available in log entry buffers.
* Registering::         Putting a file under version control.
* Old Revisions::       Examining and comparing old versions.
* VC Change Log::       Viewing the VC Change Log.
* VC Undo::             Canceling changes before or after committing.
* VC Directory Mode::   Listing files managed by version control.
* Branches::            Multiple lines of development.

* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.

Introduction to Version Control

* Why Version Control?::    Understanding the problems it addresses.
* Version Control Systems:: Supported version control back-end systems.
* VCS Concepts::            Words and concepts related to version control.
* VCS Merging::             How file conflicts are handled.
* VCS Changesets::          How changes are grouped.
* VCS Repositories::        Where version control repositories are stored.
* Types of Log File::       The VCS log in contrast to the ChangeLog.

Basic Editing under Version Control

* VC With A Merging VCS::  Without locking: default mode for CVS.
* VC With A Locking VCS::  RCS in its default mode, SCCS, and optionally CVS.
* Advanced C-x v v::       Advanced features available with a prefix argument.

VC Directory Mode

* VC Directory Buffer::   What the buffer looks like and means.
* VC Directory Commands:: Commands to use in a VC directory buffer.

Version Control Branches

* Switching Branches::    How to get to another existing branch.
* VC Pull::               Updating the contents of a branch.
* Merging::               Transferring changes between branches.
* Creating Branches::     How to start a new branch.


Miscellaneous Commands and Features of VC

* Change Logs and VC::    Generating a change log file from log entries.
* VC Delete/Rename::      Deleting and renaming version-controlled files.
* Revision Tags::         Symbolic names for revisions.
* Version Headers::       Inserting version control headers into working files.

Customizing VC

* General VC Options::    Options that apply to multiple back ends.
* RCS and SCCS::          Options for RCS and SCCS.
* CVS Options::           Options for CVS.

Change Logs

* Change Log Commands:: Commands for editing change log files.
* Format of ChangeLog:: What the change log file looks like.

Tags Tables

* Tag Syntax::          Tag syntax for various types of code and text files.
* Create Tags Table::   Creating a tags table with `etags'.
* Etags Regexps::       Create arbitrary tags using regular expressions.
* Select Tags Table::   How to visit a tags table.
* Find Tag::            Commands to find the definition of a specific tag.
* Tags Search::         Using a tags table for searching and replacing.
* List Tags::           Using tags for completion, and listing them.


Merging Files with Emerge

* Overview of Emerge::  How to start Emerge.  Basic concepts.
* Submodes of Emerge::  Fast mode vs. Edit mode.
                          Skip Prefers mode and Auto Advance mode.
* State of Difference:: You do the merge by specifying state A or B
                          for each difference.
* Merge Commands::      Commands for selecting a difference,
                          changing states of differences, etc.
* Exiting Emerge::      What to do when you've finished the merge.
* Combining in Emerge::     How to keep both alternatives for a difference.
* Fine Points of Emerge::   Miscellaneous issues.

Abbrevs

* Abbrev Concepts::     Fundamentals of defined abbrevs.
* Defining Abbrevs::    Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs::   Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::     Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::      Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::     Abbreviations for words already in the buffer.
* Dabbrev Customization:: What is a word, for dynamic abbrevs.  Case handling.


Editing Pictures

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                            after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.

Dired, the Directory Editor

* Dired Enter::              How to invoke Dired.
* Dired Navigation::         Special motion commands in the Dired buffer.
* Dired Deletion::           Deleting files with Dired.
* Flagging Many Files::      Flagging files based on their names.
* Dired Visiting::           Other file operations through Dired.
* Marks vs Flags::           Flagging for deletion vs marking.
* Operating on Files::       How to copy, rename, print, compress, etc.
                               either one file or several files.
* Shell Commands in Dired::  Running a shell command on the marked files.
* Transforming File Names::  Using patterns to rename multiple files.
* Comparison in Dired::      Running `diff' by way of Dired.
* Subdirectories in Dired::  Adding subdirectories to the Dired buffer.

* Subdir Switches::          Subdirectory switches in Dired.
* Subdirectory Motion::      Moving across subdirectories, and up and down.
* Hiding Subdirectories::    Making subdirectories visible or invisible.
* Dired Updating::           Discarding lines for files of no interest.
* Dired and Find::           Using `find' to choose the files for Dired.
* Wdired::                   Operating on files by editing the Dired buffer.
* Image-Dired::              Viewing image thumbnails in Dired.
* Misc Dired Features::      Various other features.

The Calendar and the Diary

* Calendar Motion::     Moving through the calendar; selecting a date.
* Scroll Calendar::     Bringing earlier or later months onto the screen.
* Counting Days::       How many days are there between two dates?
* General Calendar::    Exiting or recomputing the calendar.
* Writing Calendar Files:: Writing calendars to files of various formats.
* Holidays::            Displaying dates of holidays.
* Sunrise/Sunset::      Displaying local times of sunrise and sunset.
* Lunar Phases::        Displaying phases of the moon.
* Other Calendars::     Converting dates to other calendar systems.
* Diary::               Displaying events from your diary.
* Appointments::        Reminders when it's time to do something.
* Importing Diary::     Converting diary events to/from other formats.
* Daylight Saving::     How to specify when daylight saving time is active.
* Time Intervals::      Keeping track of time intervals.

* Advanced Calendar/Diary Usage:: Advanced Calendar/Diary customization.

Movement in the Calendar

* Calendar Unit Motion::      Moving by days, weeks, months, and years.
* Move to Beginning or End::  Moving to start/end of weeks, months, and years.
* Specified Dates::           Moving to the current date or another
                                specific date.

Conversion To and From Other Calendars

* Calendar Systems::       The calendars Emacs understands
                             (aside from Gregorian).
* To Other Calendar::      Converting the selected date to various calendars.
* From Other Calendar::    Moving to a date specified in another calendar.
* Mayan Calendar::         Moving to a date specified in a Mayan calendar.

The Diary

* Displaying the Diary::   Viewing diary entries and associated calendar dates.
* Format of Diary File::   Entering events in your diary.
* Date Formats::           Various ways you can specify dates.
* Adding to Diary::        Commands to create diary entries.
* Special Diary Entries::  Anniversaries, blocks of dates, cyclic entries, etc.


Customizing the Calendar and Diary

* Calendar Customizing::   Calendar layout and hooks.
* Holiday Customizing::    Defining your own holidays.
* Date Display Format::    Changing the format.
* Time Display Format::    Changing the format.
* Diary Customizing::      Defaults you can set.
* Non-Gregorian Diary::    Diary entries based on other calendars.
* Diary Display::          A choice of ways to display the diary.
* Fancy Diary Display::    Sorting diary entries, using included diary files.
* Sexp Diary Entries::     More flexible diary entries.

Sending Mail

* Mail Format::         Format of a mail message.
* Mail Headers::        Details of some standard mail header fields.
* Mail Aliases::        Abbreviating and grouping mail addresses.
* Mail Commands::       Special commands for editing mail being composed.
* Mail Signature::      Adding a signature to every message.
* Mail Amusements::     Distracting the NSA; adding fortune messages.
* Mail Methods::        Using alternative mail-composition methods.

Mail Commands

* Mail Sending::        Commands to send the message.
* Header Editing::      Commands to move to header fields and edit them.
* Citing Mail::         Quoting a message you are replying to.
* Mail Misc::           Attachments, spell checking, etc.

Reading Mail with Rmail

* Rmail Basics::        Basic concepts of Rmail, and simple use.
* Rmail Scrolling::     Scrolling through a message.
* Rmail Motion::        Moving to another message.
* Rmail Deletion::      Deleting and expunging messages.
* Rmail Inbox::         How mail gets into the Rmail file.
* Rmail Files::         Using multiple Rmail files.
* Rmail Output::        Copying message out to files.
* Rmail Labels::        Classifying messages by labeling them.
* Rmail Attributes::    Certain standard labels, called attributes.
* Rmail Reply::         Sending replies to messages you are viewing.
* Rmail Summary::       Summaries show brief info on many messages.
* Rmail Sorting::       Sorting messages in Rmail.
* Rmail Display::       How Rmail displays a message; customization.
* Rmail Coding::        How Rmail handles decoding character sets.
* Rmail Editing::       Editing message text and headers in Rmail.
* Rmail Digest::        Extracting the messages from a digest message.
* Rmail Rot13::         Reading messages encoded in the rot13 code.
* Movemail::            More details of fetching new mail.
* Remote Mailboxes::    Retrieving mail from remote mailboxes.
* Other Mailbox Formats:: Retrieving mail from local mailboxes in
                          various formats.

Rmail Summaries

* Rmail Make Summary::  Making various sorts of summaries.
* Rmail Summary Edit::  Manipulating messages from the summary.

Gnus

* Buffers of Gnus::     The group, summary, and article buffers.
* Gnus Startup::        What you should know about starting Gnus.
* Gnus Group Buffer::   A short description of Gnus group commands.
* Gnus Summary Buffer:: A short description of Gnus summary commands.

Document Viewing

* DocView Navigation::  Navigating DocView buffers.
* DocView Searching::   Searching inside documents.
* DocView Slicing::     Specifying which part of a page is displayed.
* DocView Conversion::  Influencing and triggering conversion.

Running Shell Commands from Emacs

* Single Shell::        How to run one shell command and return.
* Interactive Shell::   Permanent shell taking input via Emacs.
* Shell Mode::          Special Emacs commands used with permanent shell.
* Shell Prompts::       Two ways to recognize shell prompts.
* Shell History::       Repeating previous commands in a shell buffer.
* Directory Tracking::  Keeping track when the subshell changes directory.
* Shell Options::       Options for customizing Shell mode.
* Terminal emulator::   An Emacs window as a terminal emulator.
* Term Mode::           Special Emacs commands used in Term mode.
* Remote Host::         Connecting to another computer.
* Serial Terminal::     Connecting to a serial port.

Shell Command History

* Shell Ring::           Fetching commands from the history list.
* Shell History Copying::Moving to a command and then copying it.
* History References::   Expanding `!'-style history references.

Using Emacs as a Server

* Invoking emacsclient:: Connecting to the Emacs server.
* emacsclient Options::  Emacs client startup options.

Printing Hard Copies

* PostScript::           Printing buffers or regions as PostScript.
* PostScript Variables:: Customizing the PostScript printing commands.
* Printing Package::     An optional advanced printing interface.

Hyperlinking and Navigation Features

* Browse-URL::          Following URLs.
* Goto Address mode::   Activating URLs.
* FFAP::                Finding files etc. at point.

Emacs Lisp Packages

* Package Menu::         Buffer for viewing and managing packages.
* Package Installation:: Options for package installation.
* Package Files::        Where packages are installed.

Customization

* Easy Customization::  Convenient way to browse and change settings.
* Variables::           Many Emacs commands examine Emacs variables
                          to decide what to do; by setting variables,
                          you can control their functioning.
* Key Bindings::        The keymaps say what command each key runs.
                          By changing them, you can "redefine" keys.
* Init File::           How to write common customizations in the
                          initialization file.

Easy Customization Interface

* Customization Groups::     How settings are classified.
* Browsing Custom::          Browsing and searching for settings.
* Changing a Variable::      How to edit an option's value and set the option.
* Saving Customizations::    Saving customizations for future Emacs sessions.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Customizing specific settings or groups.
* Custom Themes::            Collections of customization settings.
* Creating Custom Themes::   How to create a new custom theme.

Variables

* Examining::           Examining or setting one variable's value.
* Hooks::               Hook variables let you specify programs for parts
                          of Emacs to run on particular occasions.
* Locals::              Per-buffer values of variables.
* File Variables::      How files can specify variable values.
* Directory Variables:: How variable values can be specified by directory.

Local Variables in Files

* Specifying File Variables:: Specifying file local variables.
* Safe File Variables::       Making sure file local variables are safe.

Customizing Key Bindings

* Keymaps::             Generalities.  The global keymap.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major and minor modes have their own keymaps.
* Minibuffer Maps::     The minibuffer uses its own local keymaps.
* Rebinding::           How to redefine one key's meaning conveniently.
* Init Rebinding::      Rebinding keys with your initialization file.
* Modifier Keys::       Using modifier keys in key bindings.
* Function Keys::       Rebinding terminal function keys.
* Named ASCII Chars::   Distinguishing <TAB> from C-i, and so on.
* Mouse Buttons::       Rebinding mouse buttons in Emacs.
* Disabling::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.

The Emacs Initialization File

* Init Syntax::         Syntax of constants in Emacs Lisp.
* Init Examples::       How to do some things with an init file.
* Terminal Init::       Each terminal type can have an init file.
* Find Init::           How Emacs finds the init file.
* Init Non-ASCII::      Using non-ASCII characters in an init file.

Dealing with Emacs Trouble

* DEL Does Not Delete:: What to do if <DEL> doesn't delete.
* Stuck Recursive::     `[...]' in mode line around the parentheses.
* Screen Garbled::      Garbage on the screen.
* Text Garbled::        Garbage in the text.
* Memory Full::         How to cope when you run out of memory.
* After a Crash::       Recovering editing in an Emacs session that crashed.
* Emergency Escape::    What to do if Emacs stops responding.

Reporting Bugs

* Known Problems::      How to read about known problems and bugs.
* Bug Criteria::        Have you really found a bug?
* Understanding Bug Reporting:: How to report a bug effectively.
* Checklist::           Steps to follow for a good bug report.
* Sending Patches::     How to send a patch for GNU Emacs.

Command Line Arguments for Emacs Invocation

* Action Arguments::    Arguments to visit files, load libraries,
                          and call functions.
* Initial Options::     Arguments that take effect while starting Emacs.
* Command Example::     Examples of using command line arguments.
* Environment::         Environment variables that Emacs uses.
* Display X::           Changing the default display and using remote login.
* Font X::              Choosing a font for text, under X.
* Colors X::            Choosing display colors.
* Window Size X::       Start-up window size, under X.
* Borders X::           Internal and external borders, under X.
* Title X::             Specifying the initial frame's title.
* Icons X::             Choosing what sort of icon to use, under X.
* Misc X::              Other display options.

Environment Variables

* General Variables::   Environment variables that all versions of Emacs use.
* Misc Variables::      Certain system-specific variables.
* MS-Windows Registry:: An alternative to the environment on MS-Windows.

X Options and Resources

* Resources::           Using X resources with Emacs (in general).
* Table of Resources::  Table of specific X resources that affect Emacs.
* Lucid Resources::     X resources for Lucid menus.
* LessTif Resources::   X resources for LessTif and Motif menus.
* GTK resources::       Resources for GTK widgets.

GTK resources

* GTK Resource Basics::   Basic usage of GTK+ resources.
* GTK Widget Names::      How GTK+ widgets are named.
* GTK Names in Emacs::    GTK widgets used by Emacs.
* GTK styles::            What can be customized in a GTK widget.

Emacs and Mac OS / GNUstep

* Mac / GNUstep Basics::        Basic Emacs usage under GNUstep or Mac OS.
* Mac / GNUstep Customization:: Customizations under GNUstep or Mac OS.
* Mac / GNUstep Events::        How window system events are handled.
* GNUstep Support::             Details on status of GNUstep support.

Emacs and Microsoft Windows/MS-DOS

* Windows Startup::     How to start Emacs on Windows.
* Text and Binary::     Text files use CRLF to terminate lines.
* Windows Files::       File-name conventions on Windows.
* ls in Lisp::          Emulation of `ls' for Dired.
* Windows HOME::        Where Emacs looks for your `.emacs' and
                          where it starts up.
* Windows Keyboard::    Windows-specific keyboard features.
* Windows Mouse::       Windows-specific mouse features.
* Windows Processes::   Running subprocesses on Windows.
* Windows Printing::    How to specify the printer on MS-Windows.
* Windows Fonts::       Specifying fonts on MS-Windows.
* Windows Misc::        Miscellaneous Windows features.

* MS-DOS::              Using Emacs on MS-DOS.

Emacs and MS-DOS

* MS-DOS Keyboard::     Keyboard conventions on MS-DOS.
* MS-DOS Mouse::        Mouse conventions on MS-DOS.
* MS-DOS Display::      Fonts, frames and display size on MS-DOS.
* MS-DOS File Names::   File name conventions on MS-DOS.
* MS-DOS Printing::     Printing specifics on MS-DOS.
* MS-DOS and MULE::     Support for internationalization on MS-DOS.
* MS-DOS Processes::    Running subprocesses on MS-DOS.


File: emacs,  Node: Distrib,  Next: Intro,  Prev: Top,  Up: Top

Distribution
************

GNU Emacs is "free software"; this means that everyone is free to use
it and free to redistribute it under certain conditions.  GNU Emacs is
not in the public domain; it is copyrighted and there are restrictions
on its distribution, but these restrictions are designed to permit
everything that a good cooperating citizen would want to do.  What is
not allowed is to try to prevent others from further sharing any
version of GNU Emacs that they might get from you.  The precise
conditions are found in the GNU General Public License that comes with
Emacs and also appears in this manual(1).  *Note Copying::.

   One way to get a copy of GNU Emacs is from someone else who has it.
You need not ask for our permission to do so, or tell any one else;
just copy it.  If you have access to the Internet, you can get the
latest distribution version of GNU Emacs by anonymous FTP; see
`http://www.gnu.org/software/emacs' on our website for more information.

   You may also receive GNU Emacs when you buy a computer.  Computer
manufacturers are free to distribute copies on the same terms that
apply to everyone else.  These terms require them to give you the full
sources, including whatever changes they may have made, and to permit
you to redistribute the GNU Emacs received from them under the usual
terms of the General Public License.  In other words, the program must
be free for you when you get it, not just free for the manufacturer.

   If you find GNU Emacs useful, please *send a donation* to the Free
Software Foundation to support our work.  Donations to the Free
Software Foundation are tax deductible in the US.  If you use GNU Emacs
at your workplace, please suggest that the company make a donation.
For more information on how you can help, see
`http://www.gnu.org/help/help.html'.

   We also sell hardcopy versions of this manual and `An Introduction
to Programming in Emacs Lisp', by Robert J. Chassell.  You can visit
our online store at `http://shop.fsf.org/'.  The income from sales goes
to support the foundation's purpose: the development of new free
software, and improvements to our existing programs including GNU Emacs.

   If you need to contact the Free Software Foundation, see
`http://www.fsf.org/about/contact/', or write to

     Free Software Foundation
     51 Franklin Street, Fifth Floor
     Boston, MA 02110-1301
     USA

   ---------- Footnotes ----------

   (1) This manual is itself covered by the GNU Free Documentation
License.  This license is similar in spirit to the General Public
License, but is more suitable for documentation.  *Note GNU Free
Documentation License::.


File: emacs,  Node: Intro,  Next: Glossary,  Prev: Distrib,  Up: Top

Introduction
************

You are reading about GNU Emacs, the GNU incarnation of the advanced,
self-documenting, customizable, extensible editor Emacs.  (The `G' in
`GNU' is not silent.)

   We call Emacs "advanced" because it can do much more than simple
insertion and deletion of text.  It can control subprocesses, indent
programs automatically, show multiple files at once, and more.  Emacs
editing commands operate in terms of characters, words, lines,
sentences, paragraphs, and pages, as well as expressions and comments
in various programming languages.

   "Self-documenting" means that at any time you can use special
commands, known as "help commands", to find out what your options are,
or to find out what any command does, or to find all the commands that
pertain to a given topic.  *Note Help::.

   "Customizable" means that you can easily alter the behavior of Emacs
commands in simple ways.  For instance, if you use a programming
language in which comments start with `<**' and end with `**>', you can
tell the Emacs comment manipulation commands to use those strings
(*note Comments::).  To take another example, you can rebind the basic
cursor motion commands (up, down, left and right) to any keys on the
keyboard that you find comfortable.  *Note Customization::.

   "Extensible" means that you can go beyond simple customization and
create entirely new commands.  New commands are simply programs written
in the Lisp language, which are run by Emacs's own Lisp interpreter.
Existing commands can even be redefined in the middle of an editing
session, without having to restart Emacs.  Most of the editing commands
in Emacs are written in Lisp; the few exceptions could have been
written in Lisp but use C instead for efficiency.  Writing an extension
is programming, but non-programmers can use it afterwards.  *Note Emacs
Lisp Intro: (eintr)Top, if you want to learn Emacs Lisp programming.


File: emacs,  Node: Screen,  Next: User Input,  Prev: Acknowledgments,  Up: Top

1 The Organization of the Screen
********************************

On a graphical display, such as on GNU/Linux using the X Window System,
Emacs occupies a "graphical window".  On a text terminal, Emacs
occupies the entire terminal screen.  We will use the term "frame" to
mean a graphical window or terminal screen occupied by Emacs.  Emacs
behaves very similarly on both kinds of frames.  It normally starts out
with just one frame, but you can create additional frames if you wish
(*note Frames::).

   Each frame consists of several distinct regions.  At the top of the
frame is a "menu bar", which allows you to access commands via a series
of menus.  On a graphical display, directly below the menu bar is a
"tool bar", a row of icons that perform editing commands if you click
on them.  At the very bottom of the frame is an "echo area", where
informative messages are displayed and where you enter information when
Emacs asks for it.

   The main area of the frame, below the tool bar (if one exists) and
above the echo area, is called "the window".  Henceforth in this
manual, we will use the word "window" in this sense.  Graphical display
systems commonly use the word "window" with a different meaning; but,
as stated above, we refer to those "graphical windows" as "frames".

   An Emacs window is where the "buffer"--the text you are editing--is
displayed.  On a graphical display, the window possesses a "scroll bar"
on one side, which can be used to scroll through the buffer.  The last
line of the window is a "mode line".  This displays various information
about what is going on in the buffer, such as whether there are unsaved
changes, the editing modes that are in use, the current line number,
and so forth.

   When you start Emacs, there is normally only one window in the
frame.  However, you can subdivide this window horizontally or
vertically to create multiple windows, each of which can independently
display a buffer (*note Windows::).

   At any time, one window is the "selected window".  On a graphical
display, the selected window shows a more prominent cursor (usually
solid and blinking); other windows show a less prominent cursor
(usually a hollow box).  On a text terminal, there is only one cursor,
which is shown in the selected window.  The buffer displayed in the
selected window is called the "current buffer", and it is where editing
happens.  Most Emacs commands implicitly apply to the current buffer;
the text displayed in unselected windows is mostly visible for
reference.  If you use multiple frames on a graphical display,
selecting a particular frame selects a window in that frame.

* Menu:

* Point::             The place in the text where editing commands operate.
* Echo Area::         Short messages appear at the bottom of the screen.
* Mode Line::         Interpreting the mode line.
* Menu Bar::          How to use the menu bar.


File: emacs,  Node: Point,  Next: Echo Area,  Up: Screen

1.1 Point
=========

The cursor in the selected window shows the location where most editing
commands take effect, which is called "point"(1).  Many Emacs commands
move point to different places in the buffer; for example, you can
place point by clicking mouse button 1 (normally the left button) at
the desired location.

   By default, the cursor in the selected window is drawn as a solid
block and appears to be _on_ a character, but you should think of point
as _between_ two characters; it is situated _before_ the character
under the cursor.  For example, if your text looks like `frob' with the
cursor over the `b', then point is between the `o' and the `b'.  If you
insert the character `!' at that position, the result is `fro!b', with
point between the `!'  and the `b'.  Thus, the cursor remains over the
`b', as before.

   If you are editing several files in Emacs, each in its own buffer,
each buffer has its own value of point.  A buffer that is not currently
displayed remembers its value of point if you later display it again.
Furthermore, if a buffer is displayed in multiple windows, each of
those windows has its own value of point.

   *Note Cursor Display::, for options that control how Emacs displays
the cursor.

   ---------- Footnotes ----------

   (1) The term "point" comes from the character `.', which was the
command in TECO (the language in which the original Emacs was written)
for accessing the editing position.


File: emacs,  Node: Echo Area,  Next: Mode Line,  Prev: Point,  Up: Screen

1.2 The Echo Area
=================

The line at the very bottom of the frame is the "echo area".  It is
used to display small amounts of text for various purposes.

   The echo area is so-named because one of the things it is used for
is "echoing", which means displaying the characters of a
multi-character command as you type.  Single-character commands are not
echoed.  Multi-character commands (*note Keys::) are echoed if you
pause for more than a second in the middle of a command.  Emacs then
echoes all the characters of the command so far, to prompt you for the
rest.  Once echoing has started, the rest of the command echoes
immediately as you type it.  This behavior is designed to give
confident users fast response, while giving hesitant users maximum
feedback.

   The echo area is also used to display an "error message" when a
command cannot do its job.  Error messages may be accompanied by
beeping or by flashing the screen.

   Some commands display informative messages in the echo area to tell
you what the command has done, or to provide you with some specific
information.  These "informative" messages, unlike error messages, are
not accompanied with a beep or flash.  For example, `C-x =' (hold down
<CTRL> and type `x', then let go of <CTRL> and type `=') displays a
message describing the character at point, its position in the buffer,
and its current column in the window.  Commands that take a long time
often display messages ending in `...' while they are working
(sometimes also indicating how much progress has been made, as a
percentage), and add `done' when they are finished.

   Informative echo area messages are saved in a special buffer named
`*Messages*'.  (We have not explained buffers yet; see *note Buffers::,
for more information about them.)  If you miss a message that appeared
briefly on the screen, you can switch to the `*Messages*' buffer to see
it again.  The `*Messages*' buffer is limited to a certain number of
lines, specified by the variable `message-log-max'.  (We have not
explained variables either; see *note Variables::, for more information
about them.)  Beyond this limit, one line is deleted from the beginning
whenever a new message line is added at the end.

   *Note Display Custom::, for options that control how Emacs uses the
echo area.

   The echo area is also used to display the "minibuffer", a special
window where you can input arguments to commands, such as the name of a
file to be edited.  When the minibuffer is in use, the text displayed
in the echo area begins with a "prompt string", and the active cursor
appears within the minibuffer, which is temporarily considered the
selected window.  You can always get out of the minibuffer by typing
`C-g'.  *Note Minibuffer::.


File: emacs,  Node: Mode Line,  Next: Menu Bar,  Prev: Echo Area,  Up: Screen

1.3 The Mode Line
=================

At the bottom of each window is a "mode line", which describes what is
going on in the current buffer.  When there is only one window, the
mode line appears right above the echo area; it is the next-to-last
line in the frame.  On a graphical display, the mode line is drawn with
a 3D box appearance.  Emacs also usually draws the mode line of the
selected window with a different color than that of unselected windows,
in order to make it stand out.

   The text displayed in the mode line has the following format:

      CS:CH-FR  BUF      POS LINE   (MAJOR MINOR)

On a text terminal, this text is followed by a series of dashes
extending to the right edge of the window.  These dashes are omitted on
a graphical display.

   The CS string and the colon character after it describe the
character set and newline convention used for the current buffer.
Normally, Emacs automatically handles these settings for you, but it is
sometimes useful to have this information.

   CS describes the character set of the text in the buffer (*note
Coding Systems::).  If it is a dash (`-'), that indicates no special
character set handling (with the possible exception of end-of-line
conventions, described in the next paragraph).  `=' means no conversion
whatsoever, and is usually used for files containing non-textual data.
Other characters represent various "coding systems"--for example, `1'
represents ISO Latin-1.

   On a text terminal, CS is preceded by two additional characters that
describe the coding systems for keyboard input and terminal output.
Furthermore, if you are using an input method, CS is preceded by a
string that identifies the input method (*note Input Methods::).

   The character after CS is usually a colon.  If a different string is
displayed, that indicates a nontrivial end-of-line convention for
encoding a file.  Usually, lines of text are separated by "newline
characters" in a file, but two other conventions are sometimes used.
The MS-DOS convention uses a "carriage-return" character followed by a
"linefeed" character; when editing such files, the colon changes to
either a backslash (`\') or `(DOS)', depending on the operating system.
Another convention, employed by older Macintosh systems, uses a
"carriage-return" character instead of a newline; when editing such
files, the colon changes to either a forward slash (`/') or `(Mac)'.
On some systems, Emacs displays `(Unix)' instead of the colon for files
that use newline as the line separator.

   The next element on the mode line is the string indicated by CH.
This shows two dashes (`--') if the buffer displayed in the window has
the same contents as the corresponding file on the disk; i.e., if the
buffer is "unmodified".  If the buffer is modified, it shows two stars
(`**').  For a read-only buffer, it shows `%*' if the buffer is
modified, and `%%' otherwise.

   The character after CH is normally a dash (`-').  However, if the
default-directory for the current buffer is on a remote machine, `@' is
displayed instead (*note File Names::).

   FR gives the selected frame name (*note Frames::).  It appears only
on text terminals.  The initial frame's name is `F1'.

   BUF is the name of the buffer displayed in the window.  Usually,
this is the same as the name of a file you are editing.  *Note
Buffers::.

   POS tells you whether there is additional text above the top of the
window, or below the bottom.  If your buffer is small and all of it is
visible in the window, POS is `All'.  Otherwise, it is `Top' if you are
looking at the beginning of the buffer, `Bot' if you are looking at the
end of the buffer, or `NN%', where NN is the percentage of the buffer
above the top of the window.  With Size Indication mode, you can
display the size of the buffer as well.  *Note Optional Mode Line::.

   LINE is the character `L' followed by the line number at point.
(You can display the current column number too, by turning on Column
Number mode.  *Note Optional Mode Line::.)

   MAJOR is the name of the "major mode" used in the buffer.  A major
mode is a principal editing mode for the buffer, such as Text mode,
Lisp mode, C mode, and so forth.  *Note Major Modes::.  Some major
modes display additional information after the major mode name.  For
example, Compilation buffers and Shell buffers display the status of
the subprocess.

   MINOR is a list of some of the enabled "minor modes", which are
optional editing modes that provide additional features on top of the
major mode.  *Note Minor Modes::.

   Some features are listed together with the minor modes whenever they
are turned on, even though they are not really minor modes.  `Narrow'
means that the buffer being displayed has editing restricted to only a
portion of its text (*note Narrowing::).  `Def' means that a keyboard
macro is currently being defined (*note Keyboard Macros::).

   In addition, if Emacs is inside a recursive editing level, square
brackets (`[...]') appear around the parentheses that surround the
modes.  If Emacs is in one recursive editing level within another,
double square brackets appear, and so on.  Since recursive editing
levels affect Emacs globally, such square brackets appear in the mode
line of every window.  *Note Recursive Edit::.

   You can change the appearance of the mode line as well as the format
of its contents.  *Note Optional Mode Line::.  In addition, the mode
line is mouse-sensitive; clicking on different parts of the mode line
performs various commands.  *Note Mode Line Mouse::.


File: emacs,  Node: Menu Bar,  Prev: Mode Line,  Up: Screen

1.4 The Menu Bar
================

Each Emacs frame normally has a "menu bar" at the top which you can use
to perform common operations.  There's no need to list them here, as
you can more easily see them yourself.

   On a graphical display, you can use the mouse to choose a command
from the menu bar.  An arrow on the right edge of a menu item means it
leads to a subsidiary menu, or "submenu".  A `...' at the end of a menu
item means that the command will prompt you for further input before it
actually does anything.

   Some of the commands in the menu bar have ordinary key bindings as
well; if so, a key binding is shown in parentheses after the item
itself.  To view the full command name and documentation for a menu
item, type `C-h k', and then select the menu bar with the mouse in the
usual way (*note Key Help::).

   Instead of using the mouse, you can also invoke the first menu bar
item by pressing <F10> (to run the command `menu-bar-open').  You can
then navigate the menus with the arrow keys.  To activate a selected
menu item, press <RET>; to cancel menu navigation, press <ESC>.

   On a text terminal, you can use the menu bar by typing `M-`' or
<F10> (these run the command `tmm-menubar').  This lets you select a
menu item with the keyboard.  A provisional choice appears in the echo
area.  You can use the up and down arrow keys to move through the menu
to different items, and then you can type <RET> to select the item.
Each menu item is also designated by a letter or digit (usually the
initial of some word in the item's name).  This letter or digit is
separated from the item name by `=>'.  You can type the item's letter
or digit to select the item.


File: emacs,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

2 Kinds of User Input
*********************

GNU Emacs is primarily designed for use with the keyboard.  While it is
possible to use the mouse to issue editing commands through the menu
bar and tool bar, that is not as efficient as using the keyboard.
Therefore, this manual mainly documents how to edit with the keyboard.

   Keyboard input into Emacs is based on a heavily-extended version of
ASCII.  Simple characters, like `a', `B', `3', `=', and the space
character (denoted as <SPC>), are entered by typing the corresponding
key.  "Control characters", such as <RET>, <TAB>, <DEL>, <ESC>, <F1>,
<Home>, and <left>, are also entered this way, as are certain
characters found on non-English keyboards (*note International::).

   Emacs also recognizes control characters that are entered using
"modifier keys".  Two commonly-used modifier keys are <Control>
(usually labeled <Ctrl>), and <Meta> (usually labeled <Alt>)(1).  For
example, `Control-a' is entered by holding down the <Ctrl> key while
pressing `a'; we will refer to this as `C-a' for short.  Similarly
`Meta-a', or `M-a' for short, is entered by holding down the <Alt> key
and pressing `a'.  Modifier keys can also be applied to
non-alphanumerical characters, e.g. `C-<F1>' or `M-<left>'.

   You can also type Meta characters using two-character sequences
starting with <ESC>.  Thus, you can enter `M-a' by typing `<ESC> a'.
You can enter `C-M-a' by typing `<ESC> C-a'.  Unlike <Meta>, <ESC> is
entered as a separate character.  You don't hold down <ESC> while
typing the next character; instead, press <ESC> and release it, then
enter the next character.  This feature is useful on certain text
terminals where the <Meta> key does not function reliably.

   On graphical displays, the window manager might block some keyboard
inputs, including `M-<TAB>', `M-<SPC>', `C-M-d' and `C-M-l'.  If you
have this problem, you can either customize your window manager to not
block those keys, or "rebind" the affected Emacs commands (*note
Customization::).

   Simple characters and control characters, as well as certain
non-keyboard inputs such as mouse clicks, are collectively referred to
as "input events".  For details about how Emacs internally handles
input events, see *note Input Events: (elisp)Input Events.

   ---------- Footnotes ----------

   (1) We refer to <Alt> as <Meta> for historical reasons.


File: emacs,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

3 Keys
******

Some Emacs commands are invoked by just one input event; for example,
`C-f' moves forward one character in the buffer.  Other commands take
two or more input events to invoke, such as `C-x C-f' and `C-x 4 C-f'.

   A "key sequence", or "key" for short, is a sequence of one or more
input events that is meaningful as a unit.  If a key sequence invokes a
command, we call it a "complete key"; for example, `C-f', `C-x C-f' and
`C-x 4 C-f' are all complete keys.  If a key sequence isn't long enough
to invoke a command, we call it a "prefix key"; from the preceding
example, we see that `C-x' and `C-x 4' are prefix keys.  Every key
sequence is either a complete key or a prefix key.

   A prefix key combines with the following input event to make a
longer key sequence.  For example, `C-x' is a prefix key, so typing
`C-x' alone does not invoke a command; instead, Emacs waits for further
input (if you pause for longer than a second, it echoes the `C-x' key
to prompt for that input; *note Echo Area::).  `C-x' combines with the
next input event to make a two-event key sequence, which could itself
be a prefix key (such as `C-x 4'), or a complete key (such as `C-x
C-f').  There is no limit to the length of key sequences, but in
practice they are seldom longer than three or four input events.

   You can't add input events onto a complete key.  For example,
because `C-f' is a complete key, the two-event sequence `C-f C-k' is
two key sequences, not one.

   By default, the prefix keys in Emacs are `C-c', `C-h', `C-x', `C-x
<RET>', `C-x @', `C-x a', `C-x n', `C-x r', `C-x v', `C-x 4', `C-x 5',
`C-x 6', <ESC>, `M-g', and `M-o'.  (<F1> and <F2> are aliases for `C-h'
and `C-x 6'.)  This list is not cast in stone; if you customize Emacs,
you can make new prefix keys.  You could even eliminate some of the
standard ones, though this is not recommended for most users; for
example, if you remove the prefix definition of `C-x 4', then `C-x 4
C-f' becomes an invalid key sequence.  *Note Key Bindings::.

   Typing the help character (`C-h' or <F1>) after a prefix key
displays a list of the commands starting with that prefix.  The sole
exception to this rule is <ESC>: `<ESC> C-h' is equivalent to `C-M-h',
which does something else entirely.  You can, however, use <F1> to
display a list of commands starting with <ESC>.


File: emacs,  Node: Commands,  Next: Entering Emacs,  Prev: Keys,  Up: Top

4 Keys and Commands
*******************

This manual is full of passages that tell you what particular keys do.
But Emacs does not assign meanings to keys directly.  Instead, Emacs
assigns meanings to named "commands", and then gives keys their
meanings by "binding" them to commands.

   Every command has a name chosen by a programmer.  The name is
usually made of a few English words separated by dashes; for example,
`next-line' or `forward-word'.  Internally, each command is a special
type of Lisp "function", and the actions associated with the command
are performed by running the function.  *Note What Is a Function:
(elisp)What Is a Function.

   The bindings between keys and commands are recorded in tables called
"keymaps".  *Note Keymaps::.

   When we say that "`C-n' moves down vertically one line" we are
glossing over a subtle distinction that is irrelevant in ordinary use,
but vital for Emacs customization.  The command `next-line' does a
vertical move downward.  `C-n' has this effect _because_ it is bound to
`next-line'.  If you rebind `C-n' to the command `forward-word', `C-n'
will move forward one word instead.

   In this manual, we will often speak of keys like `C-n' as commands,
even though strictly speaking the key is bound to a command.  Usually
we state the name of the command which really does the work in
parentheses after mentioning the key that runs it.  For example, we
will say that "The command `C-n' (`next-line') moves point vertically
down", meaning that the command `next-line' moves vertically down, and
the key `C-n' is normally bound to it.

   Since we are discussing customization, we should tell you about
"variables".  Often the description of a command will say, "To change
this, set the variable `mumble-foo'."  A variable is a name used to
store a value.  Most of the variables documented in this manual are
meant for customization: some command or other part of Emacs examines
the variable and behaves differently according to the value that you
set.  You can ignore the information about variables until you are
interested in customizing them.  Then read the basic information on
variables (*note Variables::) and the information about specific
variables will make sense.


File: emacs,  Node: Entering Emacs,  Next: Exiting,  Prev: Commands,  Up: Top

5 Entering Emacs
****************

The usual way to invoke Emacs is with the shell command `emacs'.  From
a terminal window running in the X Window System, you can run Emacs in
the background with `emacs &'; this way, Emacs won't tie up the
terminal window, so you can use it to run other shell commands.

   When Emacs starts up, the initial frame displays a special buffer
named `*GNU Emacs*'.  This "startup screen" contains information about
Emacs and "links" to common tasks that are useful for beginning users.
For instance, activating the `Emacs Tutorial' link opens the Emacs
tutorial; this does the same thing as the command `C-h t'
(`help-with-tutorial').  To activate a link, either move point onto it
and type `<RET>', or click on it with `mouse-1' (the left mouse button).

   Using a command line argument, you can tell Emacs to visit one or
more files as soon as it starts up.  For example, `emacs foo.txt'
starts Emacs with a buffer displaying the contents of the file
`foo.txt'.  This feature exists mainly for compatibility with other
editors, which are designed to be launched from the shell for short
editing sessions.  If you call Emacs this way, the initial frame is
split into two windows--one showing the specified file, and the other
showing the startup screen.  *Note Windows::.

   Generally, it is unnecessary and wasteful to start Emacs afresh each
time you want to edit a file.  The recommended way to use Emacs is to
start it just once, just after you log in, and do all your editing in
the same Emacs session.  *Note Files::, for information on visiting
more than one file.  If you use Emacs this way, the Emacs session
accumulates valuable context, such as the kill ring, registers, undo
history, and mark ring data, which together make editing more
convenient.  These features are described later in the manual.

   To edit a file from another program while Emacs is running, you can
use the `emacsclient' helper program to open a file in the existing
Emacs session.  *Note Emacs Server::.

   Emacs accepts other command line arguments that tell it to load
certain Lisp files, where to put the initial frame, and so forth.
*Note Emacs Invocation::.

   If the variable `inhibit-startup-screen' is non-`nil', Emacs does
not display the startup screen.  In that case, if one or more files
were specified on the command line, Emacs simply displays those files;
otherwise, it displays a buffer named `*scratch*', which can be used to
evaluate Emacs Lisp expressions interactively.  *Note Lisp
Interaction::.  You can set the variable `inhibit-startup-screen' using
the Customize facility (*note Easy Customization::), or by editing your
initialization file (*note Init File::).(1)

   You can also force Emacs to display a file or directory at startup
by setting the variable `initial-buffer-choice' to a non-`nil' value.
(In that case, even if you specify one or more files on the command
line, Emacs opens but does not display them.)  The value of
`initial-buffer-choice' should be the name of the desired file or
directory.

   ---------- Footnotes ----------

   (1) Setting `inhibit-startup-screen' in `site-start.el' doesn't
work, because the startup screen is set up before reading
`site-start.el'.  *Note Init File::, for information about
`site-start.el'.


File: emacs,  Node: Exiting,  Next: Basic,  Prev: Entering Emacs,  Up: Top

6 Exiting Emacs
***************

`C-x C-c'
     Kill Emacs (`save-buffers-kill-terminal').

`C-z'
     On a text terminal, suspend Emacs; on a graphical display,
     "minimize" the selected frame (`suspend-emacs').

   "Killing" Emacs means terminating the Emacs program.  To do this,
type `C-x C-c' (`save-buffers-kill-terminal').  A two-character key
sequence is used to make it harder to type by accident.  If there are
any modified file-visiting buffers when you type `C-x C-c', Emacs first
offers to save these buffers.  If you do not save them all, it asks for
confirmation again, since the unsaved changes will be lost.  Emacs also
asks for confirmation if any subprocesses are still running, since
killing Emacs will also kill the subprocesses (*note Shell::).

   `C-x C-c' behaves specially if you are using Emacs as a server.  If
you type it from a "client frame", it closes the client connection.
*Note Emacs Server::.

   Emacs can, optionally, record certain session information when you
kill it, such as the files you were visiting at the time.  This
information is then available the next time you start Emacs.  *Note
Saving Emacs Sessions::.

   If the value of the variable `confirm-kill-emacs' is non-`nil', `C-x
C-c' assumes that its value is a predicate function, and calls that
function.  If the result of the function call is non-`nil', the session
is killed, otherwise Emacs continues to run.  One convenient function
to use as the value of `confirm-kill-emacs' is the function
`yes-or-no-p'.  The default value of `confirm-kill-emacs' is `nil'.

   To kill Emacs without being prompted about saving, type `M-x
kill-emacs'.

   `C-z' runs the command `suspend-frame'.  On a graphical display,
this command "minimizes" (or "iconifies") the selected Emacs frame,
hiding it in a way that lets you bring it back later (exactly how this
hiding occurs depends on the window system).  On a text terminal, the
`C-z' command "suspends" Emacs, stopping the program temporarily and
returning control to the parent process (usually a shell); in most
shells, you can resume Emacs after suspending it with the shell command
`%emacs'.

   Text terminals usually listen for certain special characters whose
meaning is to kill or suspend the program you are running.  This
terminal feature is turned off while you are in Emacs.  The meanings of
`C-z' and `C-x C-c' as keys in Emacs were inspired by the use of `C-z'
and `C-c' on several operating systems as the characters for stopping
or killing a program, but that is their only relationship with the
operating system.  You can customize these keys to run any commands of
your choice (*note Keymaps::).


File: emacs,  Node: Basic,  Next: Minibuffer,  Prev: Exiting,  Up: Top

7 Basic Editing Commands
************************

Here we explain the basics of how to enter text, make corrections, and
save the text in a file.  If this material is new to you, we suggest
you first run the Emacs learn-by-doing tutorial, by typing `C-h t'
(`help-with-tutorial').

* Menu:


* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        Moving the cursor to the place where you want to
                          change something.
* Erasing::             Deleting and killing text.
* Basic Undo::          Undoing recent changes in the text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* Blank Lines::         Making and deleting blank lines.
* Continuation Lines::  How Emacs displays lines too wide for the screen.
* Position Info::       What line, row, or column is point on?
* Arguments::           Numeric arguments for repeating a command N times.
* Repeating::           Repeating the previous command quickly.


File: emacs,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

7.1 Inserting Text
==================

You can insert an ordinary "graphic character" (e.g., `a', `B', `3',
and `=') by typing the associated key.  This adds the character to the
buffer at point.  Insertion moves point forward, so that point remains
just after the inserted text.  *Note Point::.

   To end a line and start a new one, type <RET> (`newline').  (The
<RET> key may be labeled <Return> or <Enter> on your keyboard, but we
refer to it as <RET> in this manual.)  This command inserts a newline
character into the buffer.  If point is at the end of the line, the
effect is to create a new blank line after it; if point is in the
middle of a line, the line is split at that position.

   As we explain later in this manual, you can change the way Emacs
handles text insertion by turning on "minor modes".  For instance, the
minor mode called Auto Fill mode splits lines automatically when they
get too long (*note Filling::).  The minor mode called Overwrite mode
causes inserted characters to replace (overwrite) existing text,
instead of shoving it to the right.  *Note Minor Modes::.

   Only graphic characters can be inserted by typing the associated
key; other keys act as editing commands and do not insert themselves.
For instance, `DEL' runs the command `delete-backward-char' by default
(some modes bind it to a different command); it does not insert a
literal `DEL' character (ASCII character code 127).

   To insert a non-graphic character, or a character that your keyboard
does not support, first "quote" it by typing `C-q' (`quoted-insert').
There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.  For instance, `C-q <DEL>' inserts a literal `DEL'
     character.

   * `C-q' followed by a sequence of octal digits inserts the character
     with the specified octal character code.  You can use any number of
     octal digits; any non-digit terminates the sequence.  If the
     terminating character is <RET>, that <RET> serves only to
     terminate the sequence.  Any other non-digit terminates the
     sequence and then acts as normal input--thus, `C-q 1 0 1 B' inserts
     `AB'.

     The use of octal sequences is disabled in ordinary non-binary
     Overwrite mode, to give you a convenient way to insert a digit
     instead of overwriting with it.

To use decimal or hexadecimal instead of octal, set the variable
`read-quoted-char-radix' to 10 or 16.  If the radix is 16, the letters
`a' to `f' serve as part of a character code, just like digits.  Case
is ignored.

   Instead of `C-q', you can use the command `C-x 8 <RET>'
(`ucs-insert').  This prompts for the Unicode name or code-point of a
character, using the minibuffer.  If you enter a name, the command
provides completion (*note Completion::).  If you enter a code-point,
it should be a hexadecimal number (which is the convention for
Unicode).  The command then inserts the corresponding character into
the buffer.  For example, both of the following insert the infinity
sign (Unicode code-point `U+221E'):

     C-x 8 <RET> infinity <RET>
     C-x 8 <RET> 221e <RET>

   A numeric argument to either `C-q' or `C-x 8 <RET>' specifies how
many copies of the character to insert (*note Arguments::).


File: emacs,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

7.2 Changing the Location of Point
==================================

To do more than insert characters, you have to know how to move point
(*note Point::).  The keyboard commands `C-f', `C-b', `C-n', and `C-p'
move point to the right, left, down, and up, respectively.  You can
also move point using the "arrow keys" present on most keyboards:
`<right>', `<left>', `<down>', and `<up>'; however, many Emacs users
find that it is slower to use the arrow keys than the control keys,
because you need to move your hand to the area of the keyboard where
those keys are located.

   You can also click the left mouse button to move point to the
position clicked.  Emacs also provides a variety of additional keyboard
commands that move point in more sophisticated ways.

`C-f'
     Move forward one character (`forward-char').

`<right>'
     This command (`right-char') behaves like `C-f', with one
     exception: when editing right-to-left scripts such as Arabic, it
     instead moves _backward_ if the current paragraph is a
     right-to-left paragraph.  *Note Bidirectional Editing::.

`C-b'
     Move backward one character (`backward-char').

`<left>'
     This command (`left-char') behaves like `C-b', except it moves
     _forward_ if the current paragraph is right-to-left.  *Note
     Bidirectional Editing::.

`C-n'
`<down>'
     Move down one screen line (`next-line').  This command attempts to
     keep the horizontal position unchanged, so if you start in the
     middle of one line, you move to the middle of the next.

`C-p'
`<up>'
     Move up one screen line (`previous-line').  This command preserves
     position within the line, like `C-n'.

`C-a'
`<Home>'
     Move to the beginning of the line (`move-beginning-of-line').

`C-e'
`<End>'
     Move to the end of the line (`move-end-of-line').

`M-f'
     Move forward one word (`forward-word').

`C-<right>'
`M-<right>'
     This command (`right-word') behaves like `M-f', except it moves
     _backward_ by one word if the current paragraph is right-to-left.
     *Note Bidirectional Editing::.

`M-b'
     Move backward one word (`backward-word').

`C-<left>'
`M-<left>'
     This command (`left-word') behaves like `M-f', except it moves
     _forward_ by one word if the current paragraph is right-to-left.
     *Note Bidirectional Editing::.

`M-r'
     Without moving the text on the screen, reposition point on the left
     margin of the center-most text line of the window; on subsequent
     consecutive invocations, move point to the left margin of the
     top-most line, the bottom-most line, and so forth, in cyclic order
     (`move-to-window-line-top-bottom').

     A numeric argument says which screen line to place point on,
     counting downward from the top of the window (zero means the top
     line).  A negative argument counts lines up from the bottom (-1
     means the bottom line).  *Note Arguments::, for more information
     on numeric arguments.

`M-<'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.

`M->'
     Move to the end of the buffer (`end-of-buffer').

`C-v'
`<PageDown>'
`<next>'
     Scroll the display one screen forward, and move point onscreen if
     necessary (`scroll-up-command').  *Note Scrolling::.

`M-v'
`<PageUp>'
`<prior>'
     Scroll one screen backward, and move point onscreen if necessary
     (`scroll-down-command').  *Note Scrolling::.

`M-x goto-char'
     Read a number N and move point to buffer position N.  Position 1
     is the beginning of the buffer.

`M-g M-g'
`M-g g'
     Read a number N and move point to the beginning of line number N
     (`goto-line').  Line 1 is the beginning of the buffer.  If point
     is on or just after a number in the buffer, that is the default
     for N.  Just type <RET> in the minibuffer to use it.  You can also
     specify N by giving `M-g M-g' a numeric prefix argument.  *Note
     Select Buffer::, for the behavior of `M-g M-g' when you give it a
     plain prefix argument.

`C-x C-n'
     Use the current column of point as the "semipermanent goal column"
     for `C-n' and `C-p' (`set-goal-column').  When a semipermanent
     goal column is in effect, those commands always try to move to
     this column, or as close as possible to it, after moving
     vertically.  The goal column remains in effect until canceled.

`C-u C-x C-n'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' try to
     preserve the horizontal position, as usual.

   When a line of text in the buffer is longer than the width of the
window, Emacs usually displays it on two or more "screen lines".  For
convenience, `C-n' and `C-p' move point by screen lines, as do the
equivalent keys `<down>' and `<up>'.  You can force these commands to
move according to "logical lines" (i.e., according to the text lines in
the buffer) by setting the variable `line-move-visual' to `nil'; if a
logical line occupies multiple screen lines, the cursor then skips over
the additional screen lines.  For details, see *note Continuation
Lines::.  *Note Variables::, for how to set variables such as
`line-move-visual'.

   Unlike `C-n' and `C-p', most of the Emacs commands that work on
lines work on _logical_ lines.  For instance, `C-a'
(`move-beginning-of-line') and `C-e' (`move-end-of-line') respectively
move to the beginning and end of the logical line.  Whenever we
encounter commands that work on screen lines, such as `C-n' and `C-p',
we will point these out.

   When `line-move-visual' is `nil', you can also set the variable
`track-eol' to a non-`nil' value.  Then `C-n' and `C-p', when starting
at the end of the logical line, move to the end of the next logical
line.  Normally, `track-eol' is `nil'.

   `C-n' normally stops at the end of the buffer when you use it on the
last line in the buffer.  However, if you set the variable
`next-line-add-newlines' to a non-`nil' value, `C-n' on the last line
of a buffer creates an additional line at the end and moves down into
it.


File: emacs,  Node: Erasing,  Next: Basic Undo,  Prev: Moving Point,  Up: Basic

7.3 Erasing Text
================

`<DEL>'
`<Backspace>'
     Delete the character before point, or the region if it is active
     (`delete-backward-char').

`<Delete>'
     Delete the character after point, or the region if it is active
     (`delete-forward-char').

`C-d'
     Delete the character after point (`delete-char').

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-<DEL>'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   The `<DEL>' (`delete-backward-char') command removes the character
before point, moving the cursor and the characters after it backwards.
If point was at the beginning of a line, this deletes the preceding
newline, joining this line to the previous one.

   If, however, the region is active, `<DEL>' instead deletes the text
in the region.  *Note Mark::, for a description of the region.

   On most keyboards, <DEL> is labeled <Backspace>, but we refer to it
as <DEL> in this manual.  (Do not confuse <DEL> with the <Delete> key;
we will discuss <Delete> momentarily.)  On some text terminals, Emacs
may not recognize the <DEL> key properly.  *Note DEL Does Not Delete::,
if you encounter this problem.

   The <delete> (`delete-forward-char') command deletes in the
"opposite direction": it deletes the character after point, i.e. the
character under the cursor.  If point was at the end of a line, this
joins the following line onto this one.  Like `<DEL>', it deletes the
text in the region if the region is active (*note Mark::).

   `C-d' (`delete-char') deletes the character after point, similar to
<delete>, but regardless of whether the region is active.

   *Note Deletion::, for more detailed information about the above
deletion commands.

   `C-k' (`kill-line') erases (kills) a line at a time.  If you type
`C-k' at the beginning or middle of a line, it kills all the text up to
the end of the line.  If you type `C-k' at the end of a line, it joins
that line with the following line.

   *Note Killing::, for more information about `C-k' and related
commands.


File: emacs,  Node: Basic Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

7.4 Undoing Changes
===================

`C-/'
     Undo one entry of the undo records--usually, one command worth
     (`undo').

`C-x u'
`C-_'
     The same.

   Emacs records a list of changes made in the buffer text, so you can
undo recent changes.  This is done using the `undo' command, which is
bound to `C-/' (as well as `C-x u' and `C-_').  Normally, this command
undoes the last change, moving point back to where it was before the
change.  The undo command applies only to changes in the buffer; you
can't use it to undo cursor motion.

   Although each editing command usually makes a separate entry in the
undo records, very simple commands may be grouped together.  Sometimes,
an entry may cover just part of a complex command.

   If you repeat `C-/' (or its aliases), each repetition undoes
another, earlier change, back to the limit of the undo information
available.  If all recorded changes have already been undone, the undo
command displays an error message and does nothing.

   To learn more about the `undo' command, see *note Undo::.


File: emacs,  Node: Basic Files,  Next: Basic Help,  Prev: Basic Undo,  Up: Basic

7.5 Files
=========

Text that you insert in an Emacs buffer lasts only as long as the Emacs
session.  To keep any text permanently, you must put it in a "file".

   Suppose there is a file named `test.emacs' in your home directory.
To begin editing this file in Emacs, type

     C-x C-f test.emacs <RET>

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type <RET> to terminate the argument (*note
Minibuffer::).

   Emacs obeys this command by "visiting" the file: it creates a
buffer, copies the contents of the file into the buffer, and then
displays the buffer for editing.  If you alter the text, you can "save"
the new text in the file by typing `C-x C-s' (`save-buffer').  This
copies the altered buffer contents back into the file `test.emacs',
making them permanent.  Until you save, the changed text exists only
inside Emacs, and the file `test.emacs' is unaltered.

   To create a file, just visit it with `C-x C-f' as if it already
existed.  This creates an empty buffer, in which you can insert the
text you want to put in the file.  Emacs actually creates the file the
first time you save this buffer with `C-x C-s'.

   To learn more about using files in Emacs, see *note Files::.


File: emacs,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

7.6 Help
========

If you forget what a key does, you can find out by typing `C-h k'
(`describe-key'), followed by the key of interest; for example, `C-h k
C-n' tells you what `C-n' does.

   The prefix key `C-h' stands for "help".  The key <F1> serves as an
alias for `C-h'.  Apart from `C-h k', there are many other help
commands providing different kinds of help.

   *Note Help::, for details.


File: emacs,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

7.7 Blank Lines
===============

Here are special commands and techniques for inserting and deleting
blank lines.

`C-o'
     Insert a blank line after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   We have seen how `<RET>' (`newline') starts a new line of text.
However, it may be easier to see what you are doing if you first make a
blank line and then insert the desired text into it.  This is easy to
do using the key `C-o' (`open-line'), which inserts a newline after
point but leaves point in front of the newline.  After `C-o', type the
text for the new line.

   You can make several blank lines by typing `C-o' several times, or
by giving it a numeric argument specifying how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, the `C-o'
command inserts the fill prefix on the new line, if typed at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command
`C-x C-o' (`delete-blank-lines').  If point lies within a run of
several blank lines, `C-x C-o' deletes all but one of them.  If point
is on a single blank line, `C-x C-o' deletes it.  If point is on a
nonblank line, `C-x C-o' deletes all following blank lines, if any
exists.


File: emacs,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

7.8 Continuation Lines
======================

Sometimes, a line of text in the buffer--a "logical line"--is too long
to fit in the window, and Emacs displays it as two or more "screen
lines".  This is called "line wrapping" or "continuation", and the long
logical line is called a "continued line".  On a graphical display,
Emacs indicates line wrapping with small bent arrows in the left and
right window fringes.  On a text terminal, Emacs indicates line
wrapping by displaying a `\' character at the right margin.

   Most commands that act on lines act on logical lines, not screen
lines.  For instance, `C-k' kills a logical line.  As described
earlier, `C-n' (`next-line') and `C-p' (`previous-line') are special
exceptions: they move point down and up, respectively, by one screen
line (*note Moving Point::).

   Emacs can optionally "truncate" long logical lines instead of
continuing them.  This means that every logical line occupies a single
screen line; if it is longer than the width of the window, the rest of
the line is not displayed.  On a graphical display, a truncated line is
indicated by a small straight arrow in the right fringe; on a text
terminal, it is indicated by a `$' character in the right margin.
*Note Line Truncation::.

   By default, continued lines are wrapped at the right window edge.
Since the wrapping may occur in the middle of a word, continued lines
can be difficult to read.  The usual solution is to break your lines
before they get too long, by inserting newlines.  If you prefer, you
can make Emacs insert a newline automatically when a line gets too
long, by using Auto Fill mode.  *Note Filling::.

   Sometimes, you may need to edit files containing many long logical
lines, and it may not be practical to break them all up by adding
newlines.  In that case, you can use Visual Line mode, which enables
"word wrapping": instead of wrapping long lines exactly at the right
window edge, Emacs wraps them at the word boundaries (i.e., space or
tab characters) nearest to the right window edge.  Visual Line mode
also redefines editing commands such as `C-a', `C-n', and `C-k' to
operate on screen lines rather than logical lines.  *Note Visual Line
Mode::.


File: emacs,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

7.9 Cursor Position Information
===============================

Here are commands to get information about the size and position of
parts of the buffer, and to count words and lines.

`M-x what-line'
     Display the line number of point.

`M-x line-number-mode'
`M-x column-number-mode'
     Toggle automatic display of the current line number or column
     number.  *Note Optional Mode Line::.

`M-='
     Display the number of lines, words, and characters that are
     present in the region (`count-words-region').  *Note Mark::, for
     information about the region.

`M-x count-words'
     Display the number of lines, words, and characters that are
     present in the buffer.  If the region is active (*note Mark::),
     display the numbers for the region instead.

`C-x ='
     Display the character code of character after point, character
     position of point, and column of point (`what-cursor-position').

`M-x hl-line-mode'
     Enable or disable highlighting of the current line.  *Note Cursor
     Display::.

`M-x size-indication-mode'
     Toggle automatic display of the size of the buffer.  *Note
     Optional Mode Line::.

   `M-x what-line' displays the current line number in the echo area.
This command is usually redundant, because the current line number is
shown in the mode line (*note Mode Line::).  However, if you narrow the
buffer, the mode line shows the line number relative to the accessible
portion (*note Narrowing::).  By contrast, `what-line' displays both
the line number relative to the narrowed region and the line number
relative to the whole buffer.

   `M-=' (`count-words-region') displays a message reporting the number
of lines, words, and characters in the region.  `M-x count-words'
displays a similar message for the entire buffer, or for the region if
the region is "active".  *Note Mark::, for an explanation of the region.

   The command `C-x =' (`what-cursor-position') shows information about
the current cursor position and the buffer contents at that position.
It displays a line in the echo area that looks like this:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   After `Char:', this shows the character in the buffer at point.  The
text inside the parenthesis shows the corresponding decimal, octal and
hex character codes; for more information about how `C-x =' displays
character information, see *note International Chars::.  After `point='
is the position of point as a character count (the first character in
the buffer is position 1, the second character is position 2, and so
on).  The number after that is the total number of characters in the
buffer, and the number in parenthesis expresses the position as a
percentage of the total.  After `column=' is the horizontal position of
point, in columns counting from the left edge of the window.

   If the buffer has been narrowed, making some of the text at the
beginning and the end temporarily inaccessible, `C-x =' displays
additional text describing the currently accessible range.  For
example, it might display this:

     Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0

where the two extra numbers give the smallest and largest character
position that point is allowed to assume.  The characters between those
two positions are the accessible ones.  *Note Narrowing::.


File: emacs,  Node: Arguments,  Next: Repeating,  Prev: Position Info,  Up: Basic

7.10 Numeric Arguments
======================

In the terminology of mathematics and computing, "argument" means "data
provided to a function or operation".  You can give any Emacs command a
"numeric argument" (also called a "prefix argument").  Some commands
interpret the argument as a repetition count.  For example, giving
`C-f' an argument of ten causes it to move point forward by ten
characters instead of one.  With these commands, no argument is
equivalent to an argument of one, and negative arguments cause them to
move or act in the opposite direction.

   The easiest way to specify a numeric argument is to type a digit
and/or a minus sign while holding down the <META> key.  For example,

     M-5 C-n

moves down five lines.  The keys `M-1', `M-2', and so on, as well as
`M--', are bound to commands (`digit-argument' and `negative-argument')
that set up an argument for the next command.  `Meta--' without digits
normally means -1.

   If you enter more than one digit, you need not hold down the <META>
key for the second and subsequent digits.  Thus, to move down fifty
lines, type

     M-5 0 C-n

Note that this _does not_ insert five copies of `0' and move down one
line, as you might expect--the `0' is treated as part of the prefix
argument.

   (What if you do want to insert five copies of `0'?  Type `M-5 C-u
0'.  Here, `C-u' "terminates" the prefix argument, so that the next
keystroke begins the command that you want to execute.  Note that this
meaning of `C-u' applies only to this case.  For the usual role of
`C-u', see below.)

   Instead of typing `M-1', `M-2', and so on, another way to specify a
numeric argument is to type `C-u' (`universal-argument') followed by
some digits, or (for a negative argument) a minus sign followed by
digits.  A minus sign without digits normally means -1.

   `C-u' alone has the special meaning of "four times": it multiplies
the argument for the next command by four.  `C-u C-u' multiplies it by
sixteen.  Thus, `C-u C-u C-f' moves forward sixteen characters.  Other
useful combinations are `C-u C-n', `C-u C-u C-n' (move down a good
fraction of a screen), `C-u C-u C-o' (make "a lot" of blank lines), and
`C-u C-k' (kill four lines).

   You can use a numeric argument before a self-inserting character to
insert multiple copies of it.  This is straightforward when the
character is not a digit; for example, `C-u 6 4 a' inserts 64 copies of
the character `a'.  But this does not work for inserting digits; `C-u 6
4 1' specifies an argument of 641.  You can separate the argument from
the digit to insert with another `C-u'; for example, `C-u 6 4 C-u 1'
does insert 64 copies of the character `1'.

   Some commands care whether there is an argument, but ignore its
value.  For example, the command `M-q' (`fill-paragraph') fills text;
with an argument, it justifies the text as well.  (*Note Filling::, for
more information on `M-q'.)  For these commands, it is enough to the
argument with a single `C-u'.

   Some commands use the value of the argument as a repeat count, but
do something special when there is no argument.  For example, the
command `C-k' (`kill-line') with argument N kills N lines, including
their terminating newlines.  But `C-k' with no argument is special: it
kills the text up to the next newline, or, if point is right at the end
of the line, it kills the newline itself.  Thus, two `C-k' commands
with no arguments can kill a nonblank line, just like `C-k' with an
argument of one.  (*Note Killing::, for more information on `C-k'.)

   A few commands treat a plain `C-u' differently from an ordinary
argument.  A few others may treat an argument of just a minus sign
differently from an argument of -1.  These unusual cases are described
when they come up; they exist to make an individual command more
convenient, and they are documented in that command's documentation
string.

   We use the term "prefix argument" as well as "numeric argument", to
emphasize that you type these argument before the command, and to
distinguish them from minibuffer arguments that come after the command.


File: emacs,  Node: Repeating,  Prev: Arguments,  Up: Basic

7.11 Repeating a Command
========================

Many simple commands, such as those invoked with a single key or with
`M-x COMMAND-NAME <RET>', can be repeated by invoking them with a
numeric argument that serves as a repeat count (*note Arguments::).
However, if the command you want to repeat prompts for input, or uses a
numeric argument in another way, that method won't work.

   The command `C-x z' (`repeat') provides another way to repeat an
Emacs command many times.  This command repeats the previous Emacs
command, whatever that was.  Repeating a command uses the same arguments
that were used before; it does not read new arguments each time.

   To repeat the command more than once, type additional `z''s: each
`z' repeats the command one more time.  Repetition ends when you type a
character other than `z', or press a mouse button.

   For example, suppose you type `C-u 2 0 C-d' to delete 20 characters.
You can repeat that command (including its argument) three additional
times, to delete a total of 80 characters, by typing `C-x z z z'.  The
first `C-x z' repeats the command once, and each subsequent `z' repeats
it once again.


File: emacs,  Node: Minibuffer,  Next: M-x,  Prev: Basic,  Up: Top

8 The Minibuffer
****************

The "minibuffer" is where Emacs commands read complicated arguments,
such as file names, buffer names, Emacs command names, or Lisp
expressions.  We call it the "minibuffer" because it's a
special-purpose buffer with a small amount of screen space.  You can
use the usual Emacs editing commands in the minibuffer to edit the
argument text.

   When the minibuffer is in use, it appears in the echo area, with a
cursor.  The minibuffer starts with a "prompt" in a distinct color,
usually ending with a colon.  The prompt states what kind of input is
expected, and how it will be used.

   The simplest way to enter a minibuffer argument is to type the text,
then <RET> to submit the argument and exit the minibuffer.  You can
cancel the minibuffer, and the command that wants the argument, by
typing `C-g'.

   Sometimes, a "default argument" appears in the prompt, inside
parentheses before the colon.  This default will be used as the
argument if you just type <RET>.  For example, commands that read
buffer names usually show a buffer name as the default; you can type
<RET> to operate on that default buffer.

   Since the minibuffer appears in the echo area, it can conflict with
other uses of the echo area.  If an error message or an informative
message is emitted while the minibuffer is active, the message hides
the minibuffer for a few seconds, or until you type something; then the
minibuffer comes back.  While the minibuffer is in use, keystrokes do
not echo.

* Menu:

* Minibuffer File::       Entering file names with the minibuffer.
* Minibuffer Edit::       How to edit in the minibuffer.
* Completion::            An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::            Re-executing commands that used the minibuffer.
* Passwords::             Entering passwords in the echo area.


File: emacs,  Node: Minibuffer File,  Next: Minibuffer Edit,  Up: Minibuffer

8.1 Minibuffers for File Names
==============================

Commands such as `C-x C-f' (`find-file') use the minibuffer to read a
file name argument (*note Basic Files::).  When the minibuffer is used
to read a file name, it typically starts out with some initial text
ending in a slash.  This is the "default directory".  For example, it
may start out like this:

     Find file: /u2/emacs/src/

Here, `Find file: ' is the prompt and `/u2/emacs/src/' is the default
directory.  If you now type `buffer.c' as input, that specifies the
file `/u2/emacs/src/buffer.c'.  *Note File Names::, for information
about the default directory.

   You can specify the parent directory with `..': `/a/b/../foo.el' is
equivalent to `/a/foo.el'.  Alternatively, you can use `M-<DEL>' to
kill directory names backwards (*note Words::).

   To specify a file in a completely different directory, you can kill
the entire default with `C-a C-k' (*note Minibuffer Edit::).
Alternatively, you can ignore the default, and enter an absolute file
name starting with a slash or a tilde after the default directory.  For
example, you can specify `/etc/termcap' as follows:

     Find file: /u2/emacs/src//etc/termcap

Emacs interprets a double slash as "ignore everything before the second
slash in the pair".  In the example above, `/u2/emacs/src/' is ignored,
so the argument you supplied is `/etc/termcap'.  The ignored part of
the file name is dimmed if the terminal allows it.  (To disable this
dimming, turn off File Name Shadow mode with the command `M-x
file-name-shadow-mode'.)

   Emacs interprets `~/' as your home directory.  Thus, `~/foo/bar.txt'
specifies a file named `bar.txt', inside a directory named `foo', which
is in turn located in your home directory.  In addition, `~USER-ID/'
means the home directory of a user whose login name is USER-ID.  Any
leading directory name in front of the `~' is ignored: thus,
`/u2/emacs/~/foo/bar.txt' is equivalent to `~/foo/bar.txt'.

   On MS-Windows and MS-DOS systems, where a user doesn't always have a
home directory, Emacs uses several alternatives.  For MS-Windows, see
*note Windows HOME::; for MS-DOS, see *note MS-DOS File Names::.  On
these systems, the `~USER-ID/' construct is supported only for the
current user, i.e., only if USER-ID is the current user's login name.

   To prevent Emacs from inserting the default directory when reading
file names, change the variable `insert-default-directory' to `nil'.
In that case, the minibuffer starts out empty.  Nonetheless, relative
file name arguments are still interpreted based on the same default
directory.

   You can also enter remote file names in the minibuffer.  *Note
Remote Files::.


File: emacs,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

8.2 Editing in the Minibuffer
=============================

The minibuffer is an Emacs buffer, albeit a peculiar one, and the usual
Emacs commands are available for editing the argument text.  (The
prompt, however, is "read-only", and cannot be changed.)

   Since <RET> in the minibuffer submits the argument, you can't use it
to insert a newline.  You can do that with `C-q C-j', which inserts a
`C-j' control character, which is formally equivalent to a newline
character (*note Inserting Text::).  Alternatively, you can use the
`C-o' (`open-line') command (*note Blank Lines::).

   Inside a minibuffer, the keys <TAB>, <SPC>, and `?' are often bound
to "completion commands", which allow you to easily fill in the desired
text without typing all of it.  *Note Completion::.  As with <RET>, you
can use `C-q' to insert a <TAB>, <SPC>, or `?'  character.

   For convenience, `C-a' (`move-beginning-of-line') in a minibuffer
moves point to the beginning of the argument text, not the beginning of
the prompt.  For example, this allows you to erase the entire argument
with `C-a C-k'.

   When the minibuffer is active, the echo area is treated much like an
ordinary Emacs window.  For instance, you can switch to another window
(with `C-x o'), edit text there, then return to the minibuffer window
to finish the argument.  You can even kill text in another window,
return to the minibuffer window, and yank the text into the argument.
There are some restrictions on the minibuffer window, however: for
instance, you cannot split it.  *Note Windows::.

   Normally, the minibuffer window occupies a single screen line.
However, if you add two or more lines' worth of text into the
minibuffer, it expands automatically to accommodate the text.  The
variable `resize-mini-windows' controls the resizing of the minibuffer.
The default value is `grow-only', which means the behavior we have just
described.  If the value is `t', the minibuffer window will also shrink
automatically if you remove some lines of text from the minibuffer,
down to a minimum of one screen line.  If the value is `nil', the
minibuffer window never changes size automatically, but you can use the
usual window-resizing commands on it (*note Windows::).

   The variable `max-mini-window-height' controls the maximum height
for resizing the minibuffer window.  A floating-point number specifies
a fraction of the frame's height; an integer specifies the maximum
number of lines; `nil' means do not resize the minibuffer window
automatically.  The default value is 0.25.

   The `C-M-v' command in the minibuffer scrolls the help text from
commands that display help text of any sort in another window.  You can
also scroll the help text with `M-<prior>' and `M-<next>' (or,
equivalently, `M-<PageUp>' and `M-<PageDown>').  This is especially
useful with long lists of possible completions.  *Note Other Window::.

   Emacs normally disallows most commands that use the minibuffer while
the minibuffer is active.  To allow such commands in the minibuffer,
set the variable `enable-recursive-minibuffers' to `t'.

   When not active, the minibuffer is in `minibuffer-inactive-mode',
and clicking `Mouse-1' there shows the `*Messages*' buffer.  If you use
a dedicated frame for minibuffers, Emacs also recognizes certain keys
there, for example `n' to make a new frame.


File: emacs,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

8.3 Completion
==============

You can often use a feature called "completion" to help enter
arguments.  This means that after you type part of the argument, Emacs
can fill in the rest, or some of it, based on what was typed so far.

   When completion is available, certain keys (usually <TAB>, <RET>,
and <SPC>) are rebound in the minibuffer to special completion commands
(*note Completion Commands::).  These commands attempt to complete the
text in the minibuffer, based on a set of "completion alternatives"
provided by the command that requested the argument.  You can usually
type `?' to see a list of completion alternatives.

   Although completion is usually done in the minibuffer, the feature
is sometimes available in ordinary buffers too.  *Note Symbol
Completion::.

* Menu:

* Completion Example::       Examples of using completion.
* Completion Commands::      A list of completion commands.
* Completion Exit::          Completion and minibuffer text submission.
* Completion Styles::        How completion matches are chosen.
* Completion Options::       Options for completion.


File: emacs,  Node: Completion Example,  Next: Completion Commands,  Up: Completion

8.3.1 Completion Example
------------------------

A simple example may help here.  `M-x' uses the minibuffer to read the
name of a command, so completion works by matching the minibuffer text
against the names of existing Emacs commands.  Suppose you wish to run
the command `auto-fill-mode'.  You can do that by typing `M-x
auto-fill-mode <RET>', but it is easier to use completion.

   If you type `M-x a u <TAB>', the <TAB> looks for completion
alternatives (in this case, command names) that start with `au'.  There
are several, including `auto-fill-mode' and `autoconf-mode', but they
all begin with `auto', so the `au' in the minibuffer completes to
`auto'.  (More commands may be defined in your Emacs session.  For
example, if a command called `authorize-me' was defined, Emacs could
only complete as far as `aut'.)

   If you type <TAB> again immediately, it cannot determine the next
character; it could be `-', `a', or `c'.  So it does not add any
characters; instead, <TAB> displays a list of all possible completions
in another window.

   Next, type `-f'.  The minibuffer now contains `auto-f', and the only
command name that starts with this is `auto-fill-mode'.  If you now
type <TAB>, completion fills in the rest of the argument
`auto-fill-mode' into the minibuffer.

   Hence, typing just `a u <TAB> - f <TAB>' allows you to enter
`auto-fill-mode'.


File: emacs,  Node: Completion Commands,  Next: Completion Exit,  Prev: Completion Example,  Up: Completion

8.3.2 Completion Commands
-------------------------

Here is a list of the completion commands defined in the minibuffer
when completion is allowed.

`<TAB>'
     Complete the text in the minibuffer as much as possible; if unable
     to complete, display a list of possible completions
     (`minibuffer-complete').

`<SPC>'
     Complete up to one word from the minibuffer text before point
     (`minibuffer-complete-word').  This command is not available for
     arguments that often include spaces, such as file names.

`<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first (`minibuffer-complete-and-exit').  *Note
     Completion Exit::.

`?'
     Display a list of completions (`minibuffer-completion-help').

   <TAB> (`minibuffer-complete') is the most fundamental completion
command.  It searches for all possible completions that match the
existing minibuffer text, and attempts to complete as much as it can.
*Note Completion Styles::, for how completion alternatives are chosen.

   <SPC> (`minibuffer-complete-word') completes like <TAB>, but only up
to the next hyphen or space.  If you have `auto-f' in the minibuffer
and type <SPC>, it finds that the completion is `auto-fill-mode', but
it only inserts `ill-', giving `auto-fill-'.  Another <SPC> at this
point completes all the way to `auto-fill-mode'.

   If <TAB> or <SPC> is unable to complete, it displays a list of
matching completion alternatives (if there are any) in another window.
You can display the same list with `?' (`minibuffer-completion-help').
The following commands can be used with the completion list:

`Mouse-1'
`Mouse-2'
     Clicking mouse button 1 or 2 on a completion alternative chooses it
     (`mouse-choose-completion').

`M-v'
`<PageUp>'
`<prior>'
     Typing `M-v', while in the minibuffer, selects the window showing
     the completion list (`switch-to-completions').  This paves the way
     for using the commands below.  <PageUp> or <prior> does the same.
     You can also select the window in other ways (*note Windows::).

`<RET>'
     While in the completion list buffer, this chooses the completion at
     point (`choose-completion').

`<Right>'
     While in the completion list buffer, this moves point to the
     following completion alternative (`next-completion').

`<Left>'
     While in the completion list buffer, this moves point to the
     previous completion alternative (`previous-completion').


File: emacs,  Node: Completion Exit,  Next: Completion Styles,  Prev: Completion Commands,  Up: Completion

8.3.3 Completion Exit
---------------------

When a command reads an argument using the minibuffer with completion,
it also controls what happens when you type <RET>
(`minibuffer-complete-and-exit') to submit the argument.  There are
four types of behavior:

   * "Strict completion" accepts only exact completion matches.  Typing
     <RET> exits the minibuffer only if the minibuffer text is an exact
     match, or completes to one.  Otherwise, Emacs refuses to exit the
     minibuffer; instead it tries to complete, and if no completion can
     be done it momentarily displays `[No match]' after the minibuffer
     text.  (You can still leave the minibuffer by typing `C-g' to
     cancel the command.)

     An example of a command that uses this behavior is `M-x', since it
     is meaningless for it to accept a non-existent command name.

   * "Cautious completion" is like strict completion, except <RET>
     exits only if the text is already an exact match.  If the text
     completes to an exact match, <RET> performs that completion but
     does not exit yet; you must type a second <RET> to exit.

     Cautious completion is used for reading file names for files that
     must already exist, for example.

   * "Permissive completion" allows any input; the completion
     candidates are just suggestions.  Typing <RET> does not complete,
     it just submits the argument as you have entered it.

   * "Permissive completion with confirmation" is like permissive
     completion, with an exception: if you typed <TAB> and this
     completed the text up to some intermediate state (i.e., one that
     is not yet an exact completion match), typing <RET> right
     afterward does not submit the argument.  Instead, Emacs asks for
     confirmation by momentarily displaying `[Confirm]' after the text;
     type <RET> again to confirm and submit the text.  This catches a
     common mistake, in which one types <RET> before realizing that
     <TAB> did not complete as far as desired.

     You can tweak the confirmation behavior by customizing the variable
     `confirm-nonexistent-file-or-buffer'.  The default value,
     `after-completion', gives the behavior we have just described.  If
     you change it to `nil', Emacs does not ask for confirmation,
     falling back on permissive completion.  If you change it to any
     other non-`nil' value, Emacs asks for confirmation whether or not
     the preceding command was <TAB>.

     This behavior is used by most commands that read file names, like
     `C-x C-f', and commands that read buffer names, like `C-x b'.


File: emacs,  Node: Completion Styles,  Next: Completion Options,  Prev: Completion Exit,  Up: Completion

8.3.4 How Completion Alternatives Are Chosen
--------------------------------------------

Completion commands work by narrowing a large list of possible
completion alternatives to a smaller subset that "matches" what you
have typed in the minibuffer.  In *note Completion Example::, we gave a
simple example of such matching.  The procedure of determining what
constitutes a "match" is quite intricate.  Emacs attempts to offer
plausible completions under most circumstances.

   Emacs performs completion using one or more "completion
styles"--sets of criteria for matching minibuffer text to completion
alternatives.  During completion, Emacs tries each completion style in
turn.  If a style yields one or more matches, that is used as the list
of completion alternatives.  If a style produces no matches, Emacs
falls back on the next style.

   The list variable `completion-styles' specifies the completion
styles to use.  Each list element is the name of a completion style (a
Lisp symbol).  The default completion styles are (in order):

`basic'
     A matching completion alternative must have the same beginning as
     the text in the minibuffer before point.  Furthermore, if there is
     any text in the minibuffer after point, the rest of the completion
     alternative must contain that text as a substring.

`partial-completion'
     This aggressive completion style divides the minibuffer text into
     words separated by hyphens or spaces, and completes each word
     separately.  (For example, when completing command names, `em-l-m'
     completes to `emacs-lisp-mode'.)

     Furthermore, a `*' in the minibuffer text is treated as a
     "wildcard"--it matches any character at the corresponding position
     in the completion alternative.

`emacs22'
     This completion style is similar to `basic', except that it
     ignores the text in the minibuffer after point.  It is so-named
     because it corresponds to the completion behavior in Emacs 22.

The following additional completion styles are also defined, and you
can add them to `completion-styles' if you wish (*note Customization::):

`substring'
     A matching completion alternative must contain the text in the
     minibuffer before point, and the text in the minibuffer after
     point, as substrings (in that same order).

     Thus, if the text in the minibuffer is `foobar', with point
     between `foo' and `bar', that matches `AfooBbarC', where A, B, and
     C can be any string including the empty string.

`initials'
     This very aggressive completion style attempts to complete acronyms
     and initialisms.  For example, when completing command names, it
     matches `lch' to `list-command-history'.

There is also a very simple completion style called `emacs21'.  In this
style, if the text in the minibuffer is `foobar', only matches starting
with `foobar' are considered.

   You can use different completion styles in different situations, by
setting the variable `completion-category-overrides'.  For example, the
default setting says to use only `basic' and `substring' completion for
buffer names.


File: emacs,  Node: Completion Options,  Prev: Completion Styles,  Up: Completion

8.3.5 Completion Options
------------------------

Case is significant when completing case-sensitive arguments, such as
command names.  For example, when completing command names, `AU' does
not complete to `auto-fill-mode'.  Case differences are ignored when
completing arguments in which case does not matter.

   When completing file names, case differences are ignored if the
variable `read-file-name-completion-ignore-case' is non-`nil'.  The
default value is `nil' on systems that have case-sensitive file-names,
such as GNU/Linux; it is non-`nil' on systems that have
case-insensitive file-names, such as Microsoft Windows.  When
completing buffer names, case differences are ignored if the variable
`read-buffer-completion-ignore-case' is non-`nil'; the default is `nil'.

   When completing file names, Emacs usually omits certain alternatives
that are considered unlikely to be chosen, as determined by the list
variable `completion-ignored-extensions'.  Each element in the list
should be a string; any file name ending in such a string is ignored as
a completion alternative.  Any element ending in a slash (`/')
represents a subdirectory name.  The standard value of
`completion-ignored-extensions' has several elements including `".o"',
`".elc"', and `"~"'.  For example, if a directory contains `foo.c' and
`foo.elc', `foo' completes to `foo.c'.  However, if _all_ possible
completions end in "ignored" strings, they are not ignored: in the
previous example, `foo.e' completes to `foo.elc'.  Emacs disregards
`completion-ignored-extensions' when showing completion alternatives in
the completion list.

   If `completion-auto-help' is set to `nil', the completion commands
never display the completion list buffer; you must type `?'  to display
the list.  If the value is `lazy', Emacs only shows the completion list
buffer on the second attempt to complete.  In other words, if there is
nothing to complete, the first <TAB> echoes `Next char not unique'; the
second <TAB> shows the completion list buffer.

   If `completion-cycle-threshold' is non-`nil', completion commands
can "cycle" through completion alternatives.  Normally, if there is
more than one completion alternative for the text in the minibuffer, a
completion command completes up to the longest common substring.  If
you change `completion-cycle-threshold' to `t', the completion command
instead completes to the first of those completion alternatives; each
subsequent invocation of the completion command replaces that with the
next completion alternative, in a cyclic manner.  If you give
`completion-cycle-threshold' a numeric value N, completion commands
switch to this cycling behavior only when there are fewer than N
alternatives.

   Icomplete mode presents a constantly-updated display that tells you
what completions are available for the text you've entered so far.  The
command to enable or disable this minor mode is `M-x icomplete-mode'.


File: emacs,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

8.4 Minibuffer History
======================

Every argument that you enter with the minibuffer is saved in a
"minibuffer history list" so you can easily use it again later.  You
can use the following arguments to quickly fetch an earlier argument
into the minibuffer:

`M-p'
`<Up>'
     Move to the previous item in the minibuffer history, an earlier
     argument (`previous-history-element').

`M-n'
`<Down>'
     Move to the next item in the minibuffer history
     (`next-history-element').

`M-r REGEXP <RET>'
     Move to an earlier item in the minibuffer history that matches
     REGEXP (`previous-matching-history-element').

`M-s REGEXP <RET>'
     Move to a later item in the minibuffer history that matches REGEXP
     (`next-matching-history-element').

   While in the minibuffer, `M-p' or <Up> (`previous-history-element')
moves through the minibuffer history list, one item at a time.  Each
`M-p' fetches an earlier item from the history list into the
minibuffer, replacing its existing contents.  Typing `M-n' or <Down>
(`next-history-element') moves through the minibuffer history list in
the opposite direction, fetching later entries into the minibuffer.

   If you type `M-n' in the minibuffer when there are no later entries
in the minibuffer history (e.g., if you haven't previously typed
`M-p'), Emacs tries fetching from a list of default arguments: values
that you are likely to enter.  You can think of this as moving through
the "future history" list.

   If you edit the text inserted by the `M-p' or <M-n> minibuffer
history commands, this does not change its entry in the history list.
However, the edited argument does go at the end of the history list
when you submit it.

   You can use `M-r' (`previous-matching-history-element') to search
through older elements in the history list, and `M-s'
(`next-matching-history-element') to search through newer entries.
Each of these commands asks for a "regular expression" as an argument,
and fetches the first matching entry into the minibuffer.  *Note
Regexps::, for an explanation of regular expressions.  A numeric prefix
argument N means to fetch the Nth matching entry.  These commands are
unusual, in that they use the minibuffer to read the regular expression
argument, even though they are invoked from the minibuffer.  An
upper-case letter in the regular expression makes the search
case-sensitive (*note Search Case::).

   You can also search through the history using an incremental search.
*Note Isearch Minibuffer::.

   Emacs keeps separate history lists for several different kinds of
arguments.  For example, there is a list for file names, used by all
the commands that read file names.  Other history lists include buffer
names, command names (used by `M-x'), and command arguments (used by
commands like `query-replace').

   The variable `history-length' specifies the maximum length of a
minibuffer history list; adding a new element deletes the oldest
element if the list gets too long.  If the value is `t', there is no
maximum length.

   The variable `history-delete-duplicates' specifies whether to delete
duplicates in history.  If it is non-`nil', adding a new element
deletes from the list all other elements that are equal to it.  The
default is `nil'.


File: emacs,  Node: Repetition,  Next: Passwords,  Prev: Minibuffer History,  Up: Minibuffer

8.5 Repeating Minibuffer Commands
=================================

Every command that uses the minibuffer once is recorded on a special
history list, the "command history", together with the values of its
arguments, so that you can repeat the entire command.  In particular,
every use of `M-x' is recorded there, since `M-x' uses the minibuffer
to read the command name.

`C-x <ESC> <ESC>'
     Re-execute a recent minibuffer command from the command history
     (`repeat-complex-command').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     <ESC> <ESC>' can repeat, most recent first.

   `C-x <ESC> <ESC>' re-executes a recent command that used the
minibuffer.  With no argument, it repeats the last such command.  A
numeric argument specifies which command to repeat; 1 means the last
one, 2 the previous, and so on.

   `C-x <ESC> <ESC>' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  Even if you don't know Lisp, it will probably be
obvious which command is displayed for repetition.  If you type just
<RET>, that repeats the command unchanged.  You can also change the
command by editing the Lisp expression before you execute it.  The
repeated command is added to the front of the command history unless it
is identical to the most recent item.

   Once inside the minibuffer for `C-x <ESC> <ESC>', you can use the
usual minibuffer history commands (*note Minibuffer History::) to move
through the history list.  After finding the desired previous command,
you can edit its expression as usual and then repeat it by typing <RET>.

   Incremental search does not, strictly speaking, use the minibuffer.
Therefore, although it behaves like a complex command, it normally does
not appear in the history list for `C-x <ESC> <ESC>'.  You can make
incremental search commands appear in the history by setting
`isearch-resume-in-command-history' to a non-`nil' value.  *Note
Incremental Search::.

   The list of previous minibuffer-using commands is stored as a Lisp
list in the variable `command-history'.  Each element is a Lisp
expression that describes one command and its arguments.  Lisp programs
can re-execute a command by calling `eval' with the `command-history'
element.


File: emacs,  Node: Passwords,  Prev: Repetition,  Up: Minibuffer

8.6 Entering passwords
======================

Sometimes, you may need to enter a password into Emacs.  For instance,
when you tell Emacs to visit a file on another machine via a network
protocol such as FTP, you often need to supply a password to gain
access to the machine (*note Remote Files::).

   Entering a password is similar to using a minibuffer.  Emacs
displays a prompt in the echo area (such as `Password: '); after you
type the required password, press <RET> to submit it.  To prevent
others from seeing your password, every character you type is displayed
as a dot (`.') instead of its usual form.

   Most of the features and commands associated with the minibuffer can
_not_ be used when entering a password.  There is no history or
completion, and you cannot change windows or perform any other action
with Emacs until you have submitted the password.

   While you are typing the password, you may press <DEL> to delete
backwards, removing the last character entered.  <C-u> deletes
everything you have typed so far.  `C-g' quits the password prompt
(*note Quitting::).  `C-y' inserts the current kill into the password
(*note Killing::).  You may type either <RET> or <ESC> to submit the
password.  Any other self-inserting character key inserts the
associated character into the password, and all other input is ignored.


File: emacs,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

9 Running Commands by Name
**************************

Every Emacs command has a name that you can use to run it.  For
convenience, many commands also have key bindings.  You can run those
commands by typing the keys, or run them by name.  Most Emacs commands
have no key bindings, so the only way to run them is by name.  (*Note
Key Bindings::, for how to set up key bindings.)

   By convention, a command name consists of one or more words,
separated by hyphens; for example, `auto-fill-mode' or `manual-entry'.
Command names mostly use complete English words to make them easier to
remember.

   To run a command by name, start with `M-x', type the command name,
then terminate it with <RET>.  `M-x' uses the minibuffer to read the
command name.  The string `M-x' appears at the beginning of the
minibuffer as a "prompt" to remind you to enter a command name to be
run.  <RET> exits the minibuffer and runs the command.  *Note
Minibuffer::, for more information on the minibuffer.

   You can use completion to enter the command name.  For example, to
invoke the command `forward-char', you can type

     M-x forward-char <RET>

or

     M-x forw <TAB> c <RET>

Note that `forward-char' is the same command that you invoke with the
key `C-f'.  The existence of a key binding does not stop you from
running the command by name.

   To cancel the `M-x' and not run a command, type `C-g' instead of
entering the command name.  This takes you back to command level.

   To pass a numeric argument to the command you are invoking with
`M-x', specify the numeric argument before `M-x'.  The argument value
appears in the prompt while the command name is being read, and finally
`M-x' passes the argument to that command.

   When the command you run with `M-x' has a key binding, Emacs
mentions this in the echo area after running the command.  For example,
if you type `M-x forward-word', the message says that you can run the
same command by typing `M-f'.  You can turn off these messages by
setting the variable `suggest-key-bindings' to `nil'.

   In this manual, when we speak of running a command by name, we often
omit the <RET> that terminates the name.  Thus we might say `M-x
auto-fill-mode' rather than `M-x auto-fill-mode <RET>'.  We mention the
<RET> only for emphasis, such as when the command is followed by
arguments.

   `M-x' works by running the command `execute-extended-command', which
is responsible for reading the name of another command and invoking it.


File: emacs,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

10 Help
*******

Emacs provides a wide variety of help commands, all accessible through
the prefix key `C-h' (or, equivalently, the function key <F1>).  These
help commands are described in the following sections.  You can also
type `C-h C-h' to view a list of help commands (`help-for-help').  You
can scroll the list with <SPC> and <DEL>, then type the help command
you want.  To cancel, type `C-g'.

   Many help commands display their information in a special "help
buffer".  In this buffer, you can type <SPC> and <DEL> to scroll and
type <RET> to follow hyperlinks.  *Note Help Mode::.

   If you are looking for a certain feature, but don't know what it is
called or where to look, we recommend three methods.  First, try an
apropos command, then try searching the manual index, then look in the
FAQ and the package keywords.

`C-h a TOPICS <RET>'
     This searches for commands whose names match the argument TOPICS.
     The argument can be a keyword, a list of keywords, or a regular
     expression (*note Regexps::).  *Note Apropos::.

`C-h i d m emacs <RET> i TOPIC <RET>'
     This searches for TOPIC in the indices of the Emacs Info manual,
     displaying the first match found.  Press `,' to see subsequent
     matches.  You can use a regular expression as TOPIC.

`C-h i d m emacs <RET> s TOPIC <RET>'
     Similar, but searches the _text_ of the manual rather than the
     indices.

`C-h C-f'
     This displays the Emacs FAQ, using Info.

`C-h p'
     This displays the available Emacs packages based on keywords.
     *Note Package Keywords::.

   `C-h' or <F1> means "help" in various other contexts as well.  For
instance, you can type them after a prefix key to view a list of the
keys that can follow the prefix key.  (A few prefix keys don't support
`C-h' in this way, because they define other meanings for it, but they
all support <F1> for help.)

* Menu:

* Help Summary::        Brief list of all Help commands.
* Key Help::            Asking what a key does in Emacs.
* Name Help::           Asking about a command, variable or function name.
* Apropos::             Asking what pertains to a given topic.
* Help Mode::           Special features of Help mode and Help buffers.
* Package Keywords::    Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Misc Help::           Other help commands.
* Help Files::          Commands to display auxiliary help files.
* Help Echo::           Help on active text and tooltips ("balloon help").


File: emacs,  Node: Help Summary,  Next: Key Help,  Up: Help

10.1 Help Summary
=================

   Here is a summary of help commands for accessing the built-in
documentation.  Most of these are described in more detail in the
following sections.

`C-h a TOPICS <RET>'
     Display a list of commands whose names match TOPICS
     (`apropos-command').

`C-h b'
     Display all active key bindings; minor mode bindings first, then
     those of the major mode, then global bindings
     (`describe-bindings').

`C-h c KEY'
     Show the name of the command that the key sequence KEY is bound to
     (`describe-key-briefly').  Here `c' stands for "character".  For
     more extensive information on KEY, use `C-h k'.

`C-h d TOPICS <RET>'
     Display the commands and variables whose documentation matches
     TOPICS (`apropos-documentation').

`C-h e'
     Display the `*Messages*' buffer (`view-echo-area-messages').

`C-h f FUNCTION <RET>'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Since commands are Lisp functions, this
     works for commands too.

`C-h h'
     Display the `HELLO' file, which shows examples of various character
     sets.

`C-h i'
     Run Info, the GNU documentation browser (`info').  The Emacs
     manual is available in Info.

`C-h k KEY'
     Display the name and documentation of the command that KEY runs
     (`describe-key').

`C-h l'
     Display a description of your last 300 keystrokes (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h n'
     Display news of recent Emacs changes (`view-emacs-news').

`C-h p'
     Find packages by topic keyword (`finder-by-keyword').  This lists
     packages using a package menu buffer.  *Note Packages::.

`C-h P PACKAGE <RET>'
     Display documentation about the package named PACKAGE
     (`describe-package').

`C-h r'
     Display the Emacs manual in Info (`info-emacs-manual').

`C-h s'
     Display the contents of the current "syntax table"
     (`describe-syntax').  The syntax table says which characters are
     opening delimiters, which are parts of words, and so on.  *Note
     Syntax Tables: (elisp)Syntax Tables, for details.

`C-h t'
     Enter the Emacs interactive tutorial (`help-with-tutorial').

`C-h v VAR <RET>'
     Display the documentation of the Lisp variable VAR
     (`describe-variable').

`C-h w COMMAND <RET>'
     Show which keys run the command named COMMAND (`where-is').

`C-h C CODING <RET>'
     Describe the coding system CODING (`describe-coding-system').

`C-h C <RET>'
     Describe the coding systems currently in use.

`C-h F COMMAND <RET>'
     Enter Info and go to the node that documents the Emacs command
     COMMAND (`Info-goto-emacs-command-node').

`C-h I METHOD <RET>'
     Describe the input method METHOD (`describe-input-method').

`C-h K KEY'
     Enter Info and go to the node that documents the key sequence KEY
     (`Info-goto-emacs-key-command-node').

`C-h L LANGUAGE-ENV <RET>'
     Display information on the character sets, coding systems, and
     input methods used in language environment LANGUAGE-ENV
     (`describe-language-environment').

`C-h S SYMBOL <RET>'
     Display the Info documentation on symbol SYMBOL according to the
     programming language you are editing (`info-lookup-symbol').

`C-h .'
     Display the help message for a special text area, if point is in
     one (`display-local-help').  (These include, for example, links in
     `*Help*' buffers.)


File: emacs,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

10.2 Documentation for a Key
============================

The help commands to get information about a key sequence are `C-h c'
(`describe-key-briefly') and `C-h k' (`describe-key').

   `C-h c KEY' displays in the echo area the name of the command that
KEY is bound to.  For example, `C-h c C-f' displays `forward-char'.

   `C-h k KEY' is similar but gives more information: it displays a
help buffer containing the command's "documentation string", which
describes exactly what the command does.

   `C-h K KEY' displays the section of the Emacs manual that describes
the command corresponding to KEY.

   `C-h c', `C-h k' and `C-h K' work for any sort of key sequences,
including function keys, menus, and mouse events.  For instance, after
`C-h k' you can select a menu item from the menu bar, to view the
documentation string of the command it runs.

   `C-h w COMMAND <RET>' lists the keys that are bound to COMMAND.  It
displays the list in the echo area.  If it says the command is not on
any key, that means you must use `M-x' to run it.  `C-h w' runs the
command `where-is'.


File: emacs,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

10.3 Help by Command or Variable Name
=====================================

`C-h f FUNCTION <RET>' (`describe-function') displays the documentation
of Lisp function FUNCTION, in a window.  Since commands are Lisp
functions, you can use this method to view the documentation of any
command whose name you know.  For example,

     C-h f auto-fill-mode <RET>

displays the documentation of `auto-fill-mode'.  This is the only way
to get the documentation of a command that is not bound to any key (one
which you would normally run using `M-x').

   `C-h f' is also useful for Lisp functions that you use in a Lisp
program.  For example, if you have just written the expression
`(make-vector len)' and want to check that you are using `make-vector'
properly, type `C-h f make-vector <RET>'.  Because `C-h f' allows all
function names, not just command names, you may find that some of your
favorite completion abbreviations that work in `M-x' don't work in `C-h
f'.  An abbreviation that is unique among command names may not be
unique among all function names.

   If you type `C-h f <RET>', it describes the function called by the
innermost Lisp expression in the buffer around point, _provided_ that
function name is a valid, defined Lisp function.  (That name appears as
the default while you enter the argument.)  For example, if point is
located following the text `(make-vector (car x)', the innermost list
containing point is the one that starts with `(make-vector', so `C-h f
<RET>' will describe the function `make-vector'.

   `C-h f' is also useful just to verify that you spelled a function
name correctly.  If the minibuffer prompt for `C-h f' shows the
function name from the buffer as the default, it means that name is
defined as a Lisp function.  Type `C-g' to cancel the `C-h f' command
if you don't really want to view the documentation.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a defined Lisp variable.
*Note Variables::.

   Help buffers that describe Emacs variables and functions normally
have hyperlinks to the corresponding source code, if you have the
source files installed (*note Hyperlinking::).

   To find a command's documentation in a manual, use `C-h F'
(`Info-goto-emacs-command-node').  This knows about various manuals,
not just the Emacs manual, and finds the right one.


File: emacs,  Node: Apropos,  Next: Help Mode,  Prev: Name Help,  Up: Help

10.4 Apropos
============

The "apropos" commands answer questions like, "What are the commands
for working with files?"  More precisely, you specify an "apropos
pattern", which means either a word, a list of words, or a regular
expression.

   Each of the following apropos commands reads an apropos pattern in
the minibuffer, searches for items that match the pattern, and displays
the results in a different window.

`C-h a'
     Search for commands (`apropos-command').  With a prefix argument,
     search for noninteractive functions too.

`M-x apropos'
     Search for functions and variables.  Both interactive functions
     (commands) and noninteractive functions can be found by this.

`M-x apropos-variable'
     Search for user-customizable variables.  With a prefix argument,
     search for non-customizable variables too.

`M-x apropos-value'
     Search for variables whose values match the specified pattern.
     With a prefix argument, search also for functions with definitions
     matching the pattern, and Lisp symbols with properties matching
     the pattern.

`C-h d'
     Search for functions and variables whose documentation strings
     match the specified pattern (`apropos-documentation').

   The simplest kind of apropos pattern is one word.  Anything
containing that word matches the pattern.  Thus, to find commands that
work on files, type `C-h a file <RET>'.  This displays a list of all
command names that contain `file', including `copy-file', `find-file',
and so on.  Each command name comes with a brief description and a list
of keys you can currently invoke it with.  In our example, it would say
that you can invoke `find-file' by typing `C-x C-f'.

   For more information about a function definition, variable or symbol
property listed in an apropos buffer, you can click on it with
`Mouse-1' or `Mouse-2', or move there and type <RET>.

   When you specify more than one word in the apropos pattern, a name
must contain at least two of the words in order to match.  Thus, if you
are looking for commands to kill a chunk of text before point, you
could try `C-h a kill back backward behind before <RET>'.  The real
command name `kill-backward' will match that; if there were a command
`kill-text-before', it would also match, since it contains two of the
specified words.

   For even greater flexibility, you can specify a regular expression
(*note Regexps::).  An apropos pattern is interpreted as a regular
expression if it contains any of the regular expression special
characters, `^$*+?.\['.

   Following the conventions for naming Emacs commands, here are some
words that you'll find useful in apropos patterns.  By using them in
`C-h a', you will also get a feel for the naming conventions.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe, default.

   If the variable `apropos-do-all' is non-`nil', the apropos commands
always behave as if they had been given a prefix argument.

   By default, all apropos commands except `apropos-documentation' list
their results in alphabetical order.  If the variable
`apropos-sort-by-scores' is non-`nil', these commands instead try to
guess the relevance of each result, and display the most relevant ones
first.  The `apropos-documentation' command lists its results in order
of relevance by default; to list them in alphabetical order, change the
variable `apropos-documentation-sort-by-scores' to `nil'.


File: emacs,  Node: Help Mode,  Next: Package Keywords,  Prev: Apropos,  Up: Help

10.5 Help Mode Commands
=======================

Help buffers provide the same commands as View mode (*note View
Mode::); for instance, <SPC> scrolls forward, and <DEL> scrolls
backward.  A few special commands are also provided:

`<RET>'
     Follow a cross reference at point (`help-follow').

`<TAB>'
     Move point forward to the next hyperlink (`forward-button').

`S-<TAB>'
     Move point back to the previous hyperlink (`backward-button').

`Mouse-1'
`Mouse-2'
     Follow a hyperlink that you click on.

`C-c C-c'
     Show all documentation about the symbol at point
     (`help-follow-symbol').

`C-c C-b'
     Go back to the previous help topic (`help-go-back').

   When a function name, variable name, or face name (*note Faces::)
appears in the documentation in the help buffer, it is normally an
underlined "hyperlink".  To view the associated documentation, move
point there and type <RET> (`help-follow'), or click on the hyperlink
with `Mouse-1' or `Mouse-2'.  Doing so replaces the contents of the
help buffer; to retrace your steps, type `C-c C-b' (`help-go-back').

   A help buffer can also contain hyperlinks to Info manuals, source
code definitions, and URLs (web pages).  The first two are opened in
Emacs, and the third using a web browser via the `browse-url' command
(*note Browse-URL::).

   In a help buffer, <TAB> (`forward-button') moves point forward to
the next hyperlink, while `S-<TAB>' (`backward-button') point back to
the previous hyperlink.  These commands act cyclically; for instance,
typing <TAB> at the last hyperlink moves back to the first hyperlink.

   To view all documentation about any symbol in the text, move point
to there and type `C-c C-c' (`help-follow-symbol').  This shows all
available documentation about the symbol--as a variable, function
and/or face.


File: emacs,  Node: Package Keywords,  Next: Language Help,  Prev: Help Mode,  Up: Help

10.6 Keyword Search for Packages
================================

Most optional features in Emacs are grouped into "packages".  Emacs
contains several hundred built-in packages, and more can be installed
over the network (*note Packages::).

   To make it easier to find packages related to a topic, most packages
are associated with one or more "keywords" based on what they do.  Type
`C-h p' (`finder-by-keyword') to bring up a list of package keywords,
together with a description of what the keywords mean.  To view a list
of packages for a given keyword, type <RET> on that line; this displays
the list of packages in a Package Menu buffer (*note Package Menu::).

   `C-h P' (`describe-package') prompts for the name of a package, and
displays a help buffer describing the attributes of the package and the
features that it implements.


File: emacs,  Node: Language Help,  Next: Misc Help,  Prev: Package Keywords,  Up: Help

10.7 Help for International Language Support
============================================

For information on a specific language environment (*note Language
Environments::), type `C-h L' (`describe-language-environment').  This
displays a help buffer describing the languages supported by the
language environment, and listing the associated character sets, coding
systems, and input methods, as well as some sample text for that
language environment.

   The command `C-h h' (`view-hello-file') displays the file
`etc/HELLO', which demonstrates various character sets by showing how
to say "hello" in many languages.

   The command `C-h I' (`describe-input-method') describes an input
method--either a specified input method, or by default the input method
currently in use.  *Note Input Methods::.

   The command `C-h C' (`describe-coding-system') describes coding
systems--either a specified coding system, or the ones currently in
use.  *Note Coding Systems::.


File: emacs,  Node: Misc Help,  Next: Help Files,  Prev: Language Help,  Up: Help

10.8 Other Help Commands
========================

`C-h i' (`info') runs the Info program, which browses structured
documentation files.  The entire Emacs manual is available within Info,
along with many other manuals for the GNU system.  Type `h' after
entering Info to run a tutorial on using Info.

   With a numeric argument N, `C-h i' selects the Info buffer
`*info*<N>'.  This is useful if you want to browse multiple Info
manuals simultaneously.  If you specify just `C-u' as the prefix
argument, `C-h i' prompts for the name of a documentation file, so you
can browse a file which doesn't have an entry in the top-level Info
menu.

   The help commands `C-h F FUNCTION <RET>' and `C-h K KEY', described
above, enter Info and go straight to the documentation of FUNCTION or
KEY.

   When editing a program, if you have an Info version of the manual
for the programming language, you can use `C-h S'
(`info-lookup-symbol') to find an entry for a symbol (keyword, function
or variable) in the proper manual.  The details of how this command
works depend on the major mode.

   If something surprising happens, and you are not sure what you typed,
use `C-h l' (`view-lossage').  `C-h l' displays your last 300 input
keystrokes.  If you see commands that you don't know, you can use `C-h
c' to find out what they do.

   To review recent echo area messages, use `C-h e'
(`view-echo-area-messages').  This displays the buffer `*Messages*',
where those messages are kept.

   Each Emacs major mode typically redefines a few keys and makes other
changes in how editing works.  `C-h m' (`describe-mode') displays
documentation on the current major mode, which normally describes the
commands and features that are changed in this mode.

   `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax') show
other information about the current environment within Emacs.  `C-h b'
displays a list of all the key bindings now in effect: first the local
bindings of the current minor modes, then the local bindings defined by
the current major mode, and finally the global bindings (*note Key
Bindings::).  `C-h s' displays the contents of the syntax table, with
explanations of each character's syntax (*note Syntax Tables:
(elisp)Syntax Tables.).

   You can get a list of subcommands for a particular prefix key by
typing `C-h' (`describe-prefix-bindings') after the prefix key.  (There
are a few prefix keys for which this does not work--those that provide
their own bindings for `C-h'.  One of these is <ESC>, because `<ESC>
C-h' is actually `C-M-h', which marks a defun.)


File: emacs,  Node: Help Files,  Next: Help Echo,  Prev: Misc Help,  Up: Help

10.9 Help Files
===============

Apart from the built-in documentation and manuals, Emacs contains
several other files describing topics like copying conditions, release
notes, instructions for debugging and reporting bugs, and so forth.
You can use the following commands to view these files.  Apart from
`C-h g', they all have the form `C-h C-CHAR'.

`C-h C-c'
     Display the rules under which you can copy and redistribute Emacs
     (`describe-copying').

`C-h C-d'
     Display help for debugging Emacs (`view-emacs-debugging').

`C-h C-e'
     Display information about where to get external packages
     (`view-external-packages').

`C-h C-f'
     Display the Emacs frequently-answered-questions list
     (`view-emacs-FAQ').

`C-h g'
     Display information about the GNU Project (`describe-gnu-project').

`C-h C-m'
     Display information about ordering printed copies of Emacs manuals
     (`view-order-manuals').

`C-h C-n'
     Display the "news" file, which lists the new features in this
     version of Emacs (`view-emacs-news').

`C-h C-o'
     Display how to order or download the latest version of Emacs and
     other GNU software (`describe-distribution').

`C-h C-p'
     Display the list of known Emacs problems, sometimes with suggested
     workarounds (`view-emacs-problems').

`C-h C-t'
     Display the Emacs to-do list (`view-emacs-todo').

`C-h C-w'
     Display the full details on the complete absence of warranty for
     GNU Emacs (`describe-no-warranty').


File: emacs,  Node: Help Echo,  Prev: Help Files,  Up: Help

10.10 Help on Active Text and Tooltips
======================================

In Emacs, stretches of "active text" (text that does something special
in response to mouse clicks or <RET>) often have associated help text.
This includes hyperlinks in Emacs buffers, as well as parts of the mode
line.  On graphical displays, as well as some text terminals which
support mouse tracking, moving the mouse over the active text displays
the help text as a "tooltip".  *Note Tooltips::.

   On terminals that don't support mouse-tracking, you can display the
help text for active buffer text at point by typing `C-h .'
(`display-local-help').  This shows the help text in the echo area.  To
display help text automatically whenever it is available at point, set
the variable `help-at-pt-display-when-idle' to `t'.


File: emacs,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

11 The Mark and the Region
**************************

Many Emacs commands operate on an arbitrary contiguous part of the
current buffer.  To specify the text for such a command to operate on,
you set "the mark" at one end of it, and move point to the other end.
The text between point and the mark is called "the region".  The region
always extends between point and the mark, no matter which one comes
earlier in the text; each time you move point, the region changes.

   Setting the mark at a position in the text also "activates" it.
When the mark is active, we say also that the region is active; Emacs
indicates its extent by highlighting the text within it, using the
`region' face (*note Face Customization::).

   After certain non-motion commands, including any command that
changes the text in the buffer, Emacs automatically "deactivates" the
mark; this turns off the highlighting.  You can also explicitly
deactivate the mark at any time, by typing `C-g' (*note Quitting::).

   The above default behavior is known as Transient Mark mode.
Disabling Transient Mark mode switches Emacs to an alternative
behavior, in which the region is usually not highlighted.  *Note
Disabled Transient Mark::.

   Setting the mark in one buffer has no effect on the marks in other
buffers.  When you return to a buffer with an active mark, the mark is
at the same place as before.  When multiple windows show the same
buffer, they can have different values of point, and thus different
regions, but they all share one common mark position.  *Note Windows::.
Ordinarily, only the selected window highlights its region; however, if
the variable `highlight-nonselected-windows' is non-`nil', each window
highlights its own region.

* Menu:

* Setting Mark::            Commands to set the mark.
* Marking Objects::         Commands to put region around textual units.
* Using Region::            Summary of ways to operate on contents of the region.
* Mark Ring::               Previous mark positions saved so you can go back there.
* Global Mark Ring::        Previous mark positions in various buffers.
* Shift Selection::         Using shifted cursor motion keys.
* Disabled Transient Mark:: Leaving regions unhighlighted by default.


File: emacs,  Node: Setting Mark,  Next: Marking Objects,  Up: Mark

11.1 Setting the Mark
=====================

Here are some commands for setting the mark:

`C-<SPC>'
     Set the mark at point, and activate it (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Set the mark at point, and activate it; then move point where the
     mark used to be (`exchange-point-and-mark').

`Drag-Mouse-1'
     Set point and the mark around the text you drag across.

`Mouse-3'
     Set the mark at point, then move point to where you click
     (`mouse-save-then-kill').

``Shifted cursor motion keys''
     Set the mark at point if the mark is inactive, then move point.
     *Note Shift Selection::.

   The most common way to set the mark is with `C-<SPC>'
(`set-mark-command')(1).  This sets the mark where point is, and
activates it.  You can then move point away, leaving the mark behind.

   For example, suppose you wish to convert part of the buffer to upper
case.  To accomplish this, go to one end of the desired text, type
`C-<SPC>', and move point until the desired portion of text is
highlighted.  Now type `C-x C-u' (`upcase-region').  This converts the
text in the region to upper case, and then deactivates the mark.

   Whenever the mark is active, you can deactivate it by typing `C-g'
(*note Quitting::).  Most commands that operate on the region also
automatically deactivate the mark, like `C-x C-u' in the above example.

   Instead of setting the mark in order to operate on a region, you can
also use it to "remember" a position in the buffer (by typing `C-<SPC>
C-<SPC>'), and later jump back there (by typing `C-u C-<SPC>').  *Note
Mark Ring::, for details.

   The command `C-x C-x' (`exchange-point-and-mark') exchanges the
positions of point and the mark.  `C-x C-x' is useful when you are
satisfied with the position of point but want to move the other end of
the region (where the mark is).  Using `C-x C-x' a second time, if
necessary, puts the mark at the new position with point back at its
original position.  Normally, if the mark is inactive, this command
first reactivates the mark wherever it was last set, to ensure that the
region is left highlighted.  However, if you call it with a prefix
argument, it leaves the mark inactive and the region unhighlighted; you
can use this to jump to the mark in a manner similar to `C-u C-<SPC>'.

   You can also set the mark with the mouse.  If you press the left
mouse button (`down-mouse-1') and drag the mouse across a range of
text, this sets the mark where you first pressed the mouse button and
puts point where you release it.  Alternatively, clicking the right
mouse button (`mouse-3') sets the mark at point and then moves point to
where you clicked.  *Note Mouse Commands::, for a more detailed
description of these mouse commands.

   Finally, you can set the mark by holding down the shift key while
typing certain cursor motion commands (such as `S-<right>', `S-C-f',
`S-C-n', etc.)  This is called "shift-selection".  It sets the mark at
point before moving point, but only if there is no active mark set via
shift-selection.  The mark set by mouse commands and by shift-selection
behaves slightly differently from the usual mark: any subsequent
unshifted cursor motion command deactivates it automatically.  For
details, *Note Shift Selection::.

   Many commands that insert text, such as `C-y' (`yank'), set the mark
at the other end of the inserted text, without activating it.  This
lets you easily return to that position (*note Mark Ring::).  You can
tell that a command does this when it shows `Mark set' in the echo area.

   Under X, every time the active region changes, Emacs saves the text
in the region to the "primary selection".  This lets you insert that
text into other X applications with `mouse-2' clicks.  *Note Primary
Selection::.

   ---------- Footnotes ----------

   (1) There is no `C-<SPC>' character in ASCII; usually, typing
`C-<SPC>' on a text terminal gives the character `C-@'.  This key is
also bound to `set-mark-command', so unless you are unlucky enough to
have a text terminal that behaves differently, you might as well think
of `C-@' as `C-<SPC>'.


File: emacs,  Node: Marking Objects,  Next: Using Region,  Prev: Setting Mark,  Up: Mark

11.2 Commands to Mark Textual Objects
=====================================

Here are commands for placing point and the mark around a textual
object such as a word, list, paragraph or page:

`M-@'
     Set mark after end of next word (`mark-word').  This does not move
     point.

`C-M-@'
     Set mark after end of following balanced expression (`mark-sexp').
     This does not move point.

`M-h'
     Move point to the beginning of the current paragraph, and set mark
     at the end (`mark-paragraph').

`C-M-h'
     Move point to the beginning of the current defun, and set mark at
     the end (`mark-defun').

`C-x C-p'
     Move point to the beginning of the current page, and set mark at
     the end (`mark-page').

`C-x h'
     Move point to the beginning of the buffer, and set mark at the end
     (`mark-whole-buffer').

   `M-@' (`mark-word') sets the mark at the end of the next word (*note
Words::, for information about words).  Repeated invocations of this
command extend the region by advancing the mark one word at a time.  As
an exception, if the mark is active and located before point, `M-@'
moves the mark backwards from its current position one word at a time.

   This command also accepts a numeric argument N, which tells it to
advance the mark by N words.  A negative argument moves the mark back
by N words.

   Similarly, `C-M-@' (`mark-sexp') puts the mark at the end of the
next balanced expression (*note Expressions::).  Repeated invocations
extend the region to subsequent expressions, while positive or negative
numeric arguments move the mark forward or backward by the specified
number of expressions.

   The other commands in the above list set both point and mark, so as
to delimit an object in the buffer.  `M-h' (`mark-paragraph') marks
paragraphs (*note Paragraphs::), `C-M-h' (`mark-defun') marks top-level
definitions (*note Moving by Defuns::), and `C-x C-p' (`mark-page')
marks pages (*note Pages::).  Repeated invocations again play the same
role, extending the region to consecutive objects; similarly, numeric
arguments specify how many objects to move the mark by.

   `C-x h' (`mark-whole-buffer') sets up the entire buffer as the
region, by putting point at the beginning and the mark at the end.


File: emacs,  Node: Using Region,  Next: Mark Ring,  Prev: Marking Objects,  Up: Mark

11.3 Operating on the Region
============================

Once you have a region, here are some of the ways you can operate on it:

   * Kill it with `C-w' (*note Killing::).

   * Copy it to the kill ring with `M-w' (*note Yanking::).

   * Convert case with `C-x C-l' or `C-x C-u' (*note Case::).

   * Undo changes within it using `C-u C-/' (*note Undo::).

   * Replace text within it using `M-%' (*note Query Replace::).

   * Indent it with `C-x <TAB>' or `C-M-\' (*note Indentation::).

   * Fill it as text with `M-x fill-region' (*note Filling::).

   * Check the spelling of words within it with `M-$' (*note
     Spelling::).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::).

   * Save it in a register with `C-x r s' (*note Registers::).

   * Save it in a buffer or a file (*note Accumulating Text::).

   Some commands have a default behavior when the mark is inactive, but
operate on the region if the mark is active.  For example, `M-$'
(`ispell-word') normally checks the spelling of the word at point, but
it checks the text in the region if the mark is active (*note
Spelling::).  Normally, such commands use their default behavior if the
region is empty (i.e., if mark and point are at the same position).  If
you want them to operate on the empty region, change the variable
`use-empty-active-region' to `t'.

   As described in *note Erasing::, the <DEL> (`backward-delete-char')
and <delete> (`delete-forward-char') commands also act this way.  If
the mark is active, they delete the text in the region.  (As an
exception, if you supply a numeric argument N, where N is not one, these
commands delete N characters regardless of whether the mark is active).
If you change the variable `delete-active-region' to `nil', then these
commands don't act differently when the mark is active.  If you change
the value to `kill', these commands "kill" the region instead of
deleting it (*note Killing::).

   Other commands always operate on the region, and have no default
behavior.  Such commands usually have the word `region' in their names,
like `C-w' (`kill-region') and `C-x C-u' (`upcase-region').  If the
mark is inactive, they operate on the "inactive region"--that is, on
the text between point and the position at which the mark was last set
(*note Mark Ring::).  To disable this behavior, change the variable
`mark-even-if-inactive' to `nil'.  Then these commands will instead
signal an error if the mark is inactive.

   By default, text insertion occurs normally even if the mark is
active--for example, typing `a' inserts the character `a', then
deactivates the mark.  If you enable Delete Selection mode, a minor
mode, then inserting text while the mark is active causes the text in
the region to be deleted first.  To toggle Delete Selection mode on or
off, type `M-x delete-selection-mode'.


File: emacs,  Node: Mark Ring,  Next: Global Mark Ring,  Prev: Using Region,  Up: Mark

11.4 The Mark Ring
==================

Each buffer remembers previous locations of the mark, in the "mark
ring".  Commands that set the mark also push the old mark onto this
ring.  One of the uses of the mark ring is to remember spots that you
may want to go back to.

`C-<SPC> C-<SPC>'
     Set the mark, pushing it onto the mark ring, without activating it.

`C-u C-<SPC>'
     Move point to where the mark was, and restore the mark from the
     ring of former marks.

   The command `C-<SPC> C-<SPC>' is handy when you want to use the mark
to remember a position to which you may wish to return.  It pushes the
current point onto the mark ring, without activating the mark (which
would cause Emacs to highlight the region).  This is actually two
consecutive invocations of `C-<SPC>' (`set-mark-command'); the first
`C-<SPC>' sets the mark, and the second `C-<SPC>' deactivates it.
(When Transient Mark mode is off, `C-<SPC> C-<SPC>' instead activates
Transient Mark mode temporarily; *note Disabled Transient Mark::.)

   To return to a marked position, use `set-mark-command' with a prefix
argument: `C-u C-<SPC>'.  This moves point to where the mark was, and
deactivates the mark if it was active.  Each subsequent `C-u C-<SPC>'
jumps to a prior position stored in the mark ring.  The positions you
move through in this way are not lost; they go to the end of the ring.

   If you set `set-mark-command-repeat-pop' to non-`nil', then
immediately after you type `C-u C-<SPC>', you can type `C-<SPC>'
instead of `C-u C-<SPC>' to cycle through the mark ring.  By default,
`set-mark-command-repeat-pop' is `nil'.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-<SPC>' always stays
in the same buffer.

   The variable `mark-ring-max' specifies the maximum number of entries
to keep in the mark ring.  This defaults to 16 entries.  If that many
entries exist and another one is pushed, the earliest one in the list
is discarded.  Repeating `C-u C-<SPC>' cycles through the positions
currently in the ring.

   If you want to move back to the same place over and over, the mark
ring may not be convenient enough.  If so, you can record the position
in a register for later retrieval (*note Saving Positions in Registers:
Position Registers.).


File: emacs,  Node: Global Mark Ring,  Next: Shift Selection,  Prev: Mark Ring,  Up: Mark

11.5 The Global Mark Ring
=========================

In addition to the ordinary mark ring that belongs to each buffer,
Emacs has a single "global mark ring".  Each time you set a mark, this
is recorded in the global mark ring in addition to the current buffer's
own mark ring, if you have switched buffers since the previous mark
setting.  Hence, the global mark ring records a sequence of buffers
that you have been in, and, for each buffer, a place where you set the
mark.  The length of the global mark ring is controlled by
`global-mark-ring-max', and is 16 by default.

   The command `C-x C-<SPC>' (`pop-global-mark') jumps to the buffer
and position of the latest entry in the global ring.  It also rotates
the ring, so that successive uses of `C-x C-<SPC>' take you to earlier
buffers and mark positions.


File: emacs,  Node: Shift Selection,  Next: Disabled Transient Mark,  Prev: Global Mark Ring,  Up: Mark

11.6 Shift Selection
====================

If you hold down the shift key while typing a cursor motion command,
this sets the mark before moving point, so that the region extends from
the original position of point to its new position.  This feature is
referred to as "shift-selection".  It is similar to the way text is
selected in other editors.

   The mark set via shift-selection behaves a little differently from
what we have described above.  Firstly, in addition to the usual ways
of deactivating the mark (such as changing the buffer text or typing
`C-g'), the mark is deactivated by any _unshifted_ cursor motion
command.  Secondly, any subsequent _shifted_ cursor motion command
avoids setting the mark anew.  Therefore, a series of shifted cursor
motion commands will continuously adjust the region.

   Shift-selection only works if the shifted cursor motion key is not
already bound to a separate command (*note Customization::).  For
example, if you bind `S-C-f' to another command, typing `S-C-f' runs
that command instead of performing a shift-selected version of `C-f'
(`forward-char').

   A mark set via mouse commands behaves the same as a mark set via
shift-selection (*note Setting Mark::).  For example, if you specify a
region by dragging the mouse, you can continue to extend the region
using shifted cursor motion commands.  In either case, any unshifted
cursor motion command deactivates the mark.

   To turn off shift-selection, set `shift-select-mode' to `nil'.
Doing so does not disable setting the mark via mouse commands.


File: emacs,  Node: Disabled Transient Mark,  Prev: Shift Selection,  Up: Mark

11.7 Disabling Transient Mark Mode
==================================

The default behavior of the mark and region, in which setting the mark
activates it and highlights the region, is called Transient Mark mode.
This is a minor mode that is enabled by default.  It can be toggled
with `M-x transient-mark-mode', or with the `Active Region
Highlighting' menu item in the `Options' menu.  Turning it off switches
Emacs to an alternative mode of operation:

   * Setting the mark, with commands like `C-<SPC>' or `C-x C-x', does
     not highlight the region.  Therefore, you can't tell by looking
     where the mark is located; you have to remember.

     The usual solution to this problem is to set the mark and then use
     it soon, before you forget where it is.  You can also check where
     the mark is by using `C-x C-x', which exchanges the positions of
     the point and the mark (*note Setting Mark::).

   * Many commands that move point long distances, like `M-<' and
     `C-s', first set the mark where point was.

   * Some commands, which ordinarily act on the region when the mark is
     active, no longer do so.  For example, normally `M-%'
     (`query-replace') performs replacements within the region, if the
     mark is active.  When Transient Mark mode is off, it always
     operates from point to the end of the buffer.  Commands that act
     this way are identified in their own documentation.

   While Transient Mark mode is off, you can activate it temporarily
using `C-<SPC> C-<SPC>' or `C-u C-x C-x'.

`C-<SPC> C-<SPC>'
     Set the mark at point (like plain `C-<SPC>') and enable Transient
     Mark mode just once, until the mark is deactivated.  (This is not
     really a separate command; you are using the `C-<SPC>' command
     twice.)

`C-u C-x C-x'
     Activate the mark and enable Transient Mark mode temporarily, until
     the mark is next deactivated.  (This is the `C-x C-x' command,
     `exchange-point-and-mark', with a prefix argument.)

   These commands set or activate the mark, and enable Transient Mark
mode only until the mark is deactivated.  One reason you may want to
use them is that some commands operate on the entire buffer instead of
the region when Transient Mark mode is off.  Enabling Transient Mark
mode momentarily gives you a way to use these commands on the region.

   When you specify a region with the mouse (*note Setting Mark::), or
with shift-selection (*note Shift Selection::), this likewise activates
Transient Mark mode temporarily and highlights the region.


File: emacs,  Node: Killing,  Next: Registers,  Prev: Mark,  Up: Top

12 Killing and Moving Text
**************************

In Emacs, "killing" means erasing text and copying it into the "kill
ring".  "Yanking" means bringing text from the kill ring back into the
buffer.  (Some applications use the terms "cutting" and "pasting" for
similar operations.)  The kill ring is so-named because it can be
visualized as a set of blocks of text arranged in a ring, which you can
access in cyclic order.  *Note Kill Ring::.

   Killing and yanking are the most common way to move or copy text
within Emacs.  It is very versatile, because there are commands for
killing many different types of syntactic units.

* Menu:

* Deletion and Killing:: Commands that remove text.
* Yanking::              Commands that insert text.
* Cut and Paste::        Clipboard and selections on graphical displays.
* Accumulating Text::    Other methods to add text to the buffer.
* Rectangles::           Operating on text in rectangular areas.
* CUA Bindings::         Using C-x/C-c/C-v to kill and yank.


File: emacs,  Node: Deletion and Killing,  Next: Yanking,  Up: Killing

12.1 Deletion and Killing
=========================

Most commands which erase text from the buffer save it in the kill
ring.  These are known as "kill" commands, and their names normally
contain the word `kill' (e.g. `kill-line').  The kill ring stores
several recent kills, not just the last one, so killing is a very safe
operation: you don't have to worry much about losing text that you
previously killed.  The kill ring is shared by all buffers, so text
that is killed in one buffer can be yanked into another buffer.

   When you use `C-/' (`undo') to undo a kill command (*note Undo::),
that brings the killed text back into the buffer, but does not remove
it from the kill ring.

   On graphical displays, killing text also copies it to the system
clipboard.  *Note Cut and Paste::.

   Commands that erase text but do not save it in the kill ring are
known as "delete" commands; their names usually contain the word
`delete'.  These include `C-d' (`delete-char') and <DEL>
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands that
can erase significant amounts of nontrivial data generally do a kill
operation instead.

   You can also use the mouse to kill and yank.  *Note Cut and Paste::.

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.
* Kill Options::        Options that affect killing.


File: emacs,  Node: Deletion,  Next: Killing by Lines,  Up: Deletion and Killing

12.1.1 Deletion
---------------

Deletion means erasing text and not saving it in the kill ring.  For
the most part, the Emacs commands that delete text are those that erase
just one character or only whitespace.

`<DEL>'
`<Backspace>'
     Delete the previous character, or the text in the region if it is
     active (`delete-backward-char').

`<Delete>'
     Delete the next character, or the text in the region if it is
     active (`delete-forward-char').

`C-d'
     Delete the next character (`delete-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-<SPC>'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, along with any
     indentation following it (`delete-indentation').

   We have already described the basic deletion commands <DEL>
(`delete-backward-char'), <delete> (`delete-forward-char'), and `C-d'
(`delete-char').  *Note Erasing::.  With a numeric argument, they
delete the specified number of characters.  If the numeric argument is
omitted or one, they delete all the text in the region if it is active
(*note Using Region::).

   The other delete commands are those that delete only whitespace
characters: spaces, tabs and newlines.  `M-\'
(`delete-horizontal-space') deletes all the spaces and tab characters
before and after point.  With a prefix argument, this only deletes
spaces and tab characters before point.  `M-<SPC>' (`just-one-space')
does likewise but leaves a single space before point, regardless of the
number of spaces that existed previously (even if there were none
before).  With a numeric argument N, it leaves N spaces before point if
N is positive; if N is negative, it deletes newlines in addition to
spaces and tabs, leaving a single space before point.

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line.  If the current line is blank, it deletes all blank lines
preceding the current line as well (leaving one blank line, the current
line).  On a solitary blank line, it deletes that line.

   `M-^' (`delete-indentation') joins the current line and the previous
line, by deleting a newline and all surrounding spaces, usually leaving
a single space.  *Note M-^: Indentation.


File: emacs,  Node: Killing by Lines,  Next: Other Kill Commands,  Prev: Deletion,  Up: Deletion and Killing

12.1.2 Killing by Lines
-----------------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

`C-S-backspace'
     Kill an entire line at once (`kill-whole-line')

   The simplest kill command is `C-k' (`kill-line').  If used at the
end of a line, it kills the line-ending newline character, merging the
next line into the current one (thus, a blank line is entirely
removed).  Otherwise, `C-k' kills all the text from point up to the end
of the line; if point was originally at the beginning of the line, this
leaves the line blank.

   Spaces and tabs at the end of the line are ignored when deciding
which case applies.  As long as point is after the last visible
character in the line, you can be sure that `C-k' will kill the
newline.  To kill an entire non-blank line, go to the beginning and
type `C-k' twice.

   In this context, "line" means a logical text line, not a screen line
(*note Continuation Lines::).

   When `C-k' is given a positive argument N, it kills N lines and the
newlines that follow them (text on the current line before point is not
killed).  With a negative argument -N, it kills N lines preceding the
current line, together with the text on the current line before point.
`C-k' with an argument of zero kills the text before point on the
current line.

   If the variable `kill-whole-line' is non-`nil', `C-k' at the very
beginning of a line kills the entire line including the following
newline.  This variable is normally `nil'.

   `C-S-backspace' (`kill-whole-line') kills a whole line including its
newline, regardless of the position of point within the line.  Note
that many text terminals will prevent you from typing the key sequence
`C-S-backspace'.


File: emacs,  Node: Other Kill Commands,  Next: Kill Options,  Prev: Killing by Lines,  Up: Deletion and Killing

12.1.3 Other Kill Commands
--------------------------

`C-w'
     Kill the region (`kill-region').

`M-w'
     Copy the region into the kill ring (`kill-ring-save').

`M-d'
     Kill the next word (`kill-word').  *Note Words::.

`M-<DEL>'
     Kill one word backwards (`backward-kill-word').

`C-x <DEL>'
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.

`M-k'
     Kill to the end of the sentence (`kill-sentence').

`C-M-k'
     Kill the following balanced expression (`kill-sexp').  *Note
     Expressions::.

`M-z CHAR'
     Kill through the next occurrence of CHAR (`zap-to-char').

   One of the commonly-used kill commands is `C-w' (`kill-region'),
which kills the text in the region (*note Mark::).  Similarly, `M-w'
(`kill-ring-save') copies the text in the region into the kill ring
without removing it from the buffer.  If the mark is inactive when you
type `C-w' or `M-w', the command acts on the text between point and
where you last set the mark (*note Using Region::).

   Emacs also provides commands to kill specific syntactic units:
words, with `M-<DEL>' and `M-d' (*note Words::); balanced expressions,
with `C-M-k' (*note Expressions::); and sentences, with `C-x <DEL>' and
`M-k' (*note Sentences::).

   The command `M-z' (`zap-to-char') combines killing with searching:
it reads a character and kills from point up to (and including) the
next occurrence of that character in the buffer.  A numeric argument
acts as a repeat count; a negative argument means to search backward
and kill text before point.


File: emacs,  Node: Kill Options,  Prev: Other Kill Commands,  Up: Deletion and Killing

12.1.4 Options for Killing
--------------------------

Some specialized buffers contain "read-only text", which cannot be
modified and therefore cannot be killed.  The kill commands work
specially in a read-only buffer: they move over text and copy it to the
kill ring, without actually deleting it from the buffer.  Normally,
they also beep and display an error message when this happens.  But if
you set the variable `kill-read-only-ok' to a non-`nil' value, they
just print a message in the echo area to explain why the text has not
been erased.

   If you change the variable `kill-do-not-save-duplicates' to a
non-`nil' value, identical subsequent kills yield a single kill-ring
entry, without duplication.


File: emacs,  Node: Yanking,  Next: Cut and Paste,  Prev: Deletion and Killing,  Up: Killing

12.2 Yanking
============

"Yanking" means reinserting text previously killed.  The usual way to
move or copy text is to kill it and then yank it elsewhere.

`C-y'
     Yank the last kill into the buffer, at point (`yank').

`M-y'
     Replace the text just yanked with an earlier batch of killed text
     (`yank-pop').  *Note Earlier Kills::.

`C-M-w'
     Cause the following command, if it is a kill command, to append to
     the previous kill (`append-next-kill').  *Note Appending Kills::.

   The basic yanking command is `C-y' (`yank').  It inserts the most
recent kill, leaving the cursor at the end of the inserted text.  It
also sets the mark at the beginning of the inserted text, without
activating the mark; this lets you jump easily to that position, if you
wish, with `C-u C-<SPC>' (*note Mark Ring::).

   With a plain prefix argument (`C-u C-y'), the command instead leaves
the cursor in front of the inserted text, and sets the mark at the end.
Using any other prefix argument specifies an earlier kill; e.g. `C-u 4
C-y' reinserts the fourth most recent kill.  *Note Earlier Kills::.

   On graphical displays, `C-y' first checks if another application has
placed any text in the system clipboard more recently than the last
Emacs kill.  If so, it inserts the text in the clipboard instead.
Thus, Emacs effectively treats "cut" or "copy" clipboard operations
performed in other applications like Emacs kills, except that they are
not recorded in the kill ring.  *Note Cut and Paste::, for details.

* Menu:

* Kill Ring::           Where killed text is stored.
* Earlier Kills::       Yanking something killed some time ago.
* Appending Kills::     Several kills in a row all yank together.


File: emacs,  Node: Kill Ring,  Next: Earlier Kills,  Up: Yanking

12.2.1 The Kill Ring
--------------------

The "kill ring" is a list of blocks of text that were previously
killed.  There is only one kill ring, shared by all buffers, so you can
kill text in one buffer and yank it in another buffer.  This is the
usual way to move text from one buffer to another.  (There are several
other methods: for instance, you could store the text in a register;
see *note Registers::.  *Note Accumulating Text::, for some other ways
to move text around.)

   The maximum number of entries in the kill ring is controlled by the
variable `kill-ring-max'.  The default is 60.  If you make a new kill
when this limit has been reached, Emacs makes room by deleting the
oldest entry in the kill ring.

   The actual contents of the kill ring are stored in a variable named
`kill-ring'; you can view the entire contents of the kill ring with
`C-h v kill-ring'.


File: emacs,  Node: Earlier Kills,  Next: Appending Kills,  Prev: Kill Ring,  Up: Yanking

12.2.2 Yanking Earlier Kills
----------------------------

As explained in *note Yanking::, you can use a numeric argument to
`C-y' to yank text that is no longer the most recent kill.  This is
useful if you remember which kill ring entry you want.  If you don't,
you can use the `M-y' (`yank-pop') command to cycle through the
possibilities.

   If the previous command was a yank command, `M-y' takes the text
that was yanked and replaces it with the text from an earlier kill.
So, to recover the text of the next-to-the-last kill, first use `C-y'
to yank the last kill, and then use `M-y' to replace it with the
previous kill.  `M-y' is allowed only after a `C-y' or another `M-y'.

   You can understand `M-y' in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
`C-y' yanks the entry which the "last yank" pointer points to.  `M-y'
moves the "last yank" pointer to a different entry, and the text in the
buffer changes to match.  Enough `M-y' commands can move the pointer to
any entry in the ring, so you can get any entry into the buffer.
Eventually the pointer reaches the end of the ring; the next `M-y'
loops back around to the first entry again.

   `M-y' moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   `M-y' can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy of
the kill ring entry, so editing it in the buffer does not change what's
in the ring.  As long as no new killing is done, the "last yank"
pointer remains at the same place in the kill ring, so repeating `C-y'
will yank another copy of the same previous kill.

   When you call `C-y' with a numeric argument, that also sets the
"last yank" pointer to the entry that it yanks.


File: emacs,  Node: Appending Kills,  Prev: Earlier Kills,  Up: Yanking

12.2.3 Appending Kills
----------------------

Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks all the text as a unit, just
as it was before it was killed.

   Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add text
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains this text:

     This is a line -!-of sample text.

with point shown by -!-.  If you type `M-d M-<DEL> M-d M-<DEL>',
killing alternately forward and backward, you end up with `a line of
sample' as one entry in the kill ring, and `This is  text.' in the
buffer.  (Note the double space between `is' and `text', which you can
clean up with `M-<SPC>' or `M-q'.)

   Another way to kill the same text is to move back two words with
`M-b M-b', then kill all four words forward with `C-u M-d'.  This
produces exactly the same results in the buffer and in the kill ring.
`M-f M-f C-u M-<DEL>' kills the same text, all going backward; once
again, the result is the same.  The text in the kill ring entry always
has the same order that it had in the buffer before you killed it.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command
`C-M-w' (`append-next-kill') right before it.  The `C-M-w' tells the
following command, if it is a kill command, to append the text it kills
to the last killed text, instead of starting a new entry.  With
`C-M-w', you can kill several separated pieces of text and accumulate
them to be yanked back in one place.

   A kill command following `M-w' (`kill-ring-save') does not append to
the text that `M-w' copied into the kill ring.


File: emacs,  Node: Cut and Paste,  Next: Accumulating Text,  Prev: Yanking,  Up: Killing

12.3 "Cut and Paste" Operations on Graphical Displays
=====================================================

In most graphical desktop environments, you can transfer data (usually
text) between different applications using a system facility called the
"clipboard".  On X, two other similar facilities are available: the
primary selection and the secondary selection.  When Emacs is run on a
graphical display, its kill and yank commands integrate with these
facilities, so that you can easily transfer text between Emacs and
other graphical applications.

   By default, Emacs uses UTF-8 as the coding system for inter-program
text transfers.  If you find that the pasted text is not what you
expected, you can specify another coding system by typing `C-x <RET> x'
or `C-x <RET> X'.  You can also request a different data type by
customizing `x-select-request-type'.  *Note Communication Coding::.

* Menu:

* Clipboard::           How Emacs uses the system clipboard.
* Primary Selection::   The temporarily selected text selection.
* Secondary Selection:: Cutting without altering point and mark.


File: emacs,  Node: Clipboard,  Next: Primary Selection,  Up: Cut and Paste

12.3.1 Using the Clipboard
--------------------------

The "clipboard" is the facility that most graphical applications use
for "cutting and pasting".  When the clipboard exists, the kill and
yank commands in Emacs make use of it.

   When you kill some text with a command such as `C-w'
(`kill-region'), or copy it to the kill ring with a command such as
`M-w' (`kill-ring-save'), that text is also put in the clipboard.

   When an Emacs kill command puts text in the clipboard, the existing
clipboard contents are normally lost.  Optionally, you can change
`save-interprogram-paste-before-kill' to `t'.  Then Emacs will first
save the clipboard to its kill ring, preventing you from losing the old
clipboard data--at the risk of high memory consumption if that data
turns out to be large.

   Yank commands, such as `C-y' (`yank'), also use the clipboard.  If
another application "owns" the clipboard--i.e., if you cut or copied
text there more recently than your last kill command in Emacs--then
Emacs yanks from the clipboard instead of the kill ring.

   Normally, rotating the kill ring with `M-y' (`yank-pop') does not
alter the clipboard.  However, if you change
`yank-pop-change-selection' to `t', then `M-y' saves the new yank to
the clipboard.

   To prevent kill and yank commands from accessing the clipboard,
change the variable `x-select-enable-clipboard' to `nil'.

   Many X desktop environments support a feature called the "clipboard
manager".  If you exit Emacs while it is the current "owner" of the
clipboard data, and there is a clipboard manager running, Emacs
transfers the clipboard data to the clipboard manager so that it is not
lost.  In some circumstances, this may cause a delay when exiting
Emacs; if you wish to prevent Emacs from transferring data to the
clipboard manager, change the variable
`x-select-enable-clipboard-manager' to `nil'.

   Prior to Emacs 24, the kill and yank commands used the primary
selection (*note Primary Selection::), not the clipboard.  If you
prefer this behavior, change `x-select-enable-clipboard' to `nil',
`x-select-enable-primary' to `t', and `mouse-drag-copy-region' to `t'.
In this case, you can use the following commands to act explicitly on
the clipboard: `clipboard-kill-region' kills the region and saves it to
the clipboard; `clipboard-kill-ring-save' copies the region to the kill
ring and saves it to the clipboard; and `clipboard-yank' yanks the
contents of the clipboard at point.


File: emacs,  Node: Primary Selection,  Next: Secondary Selection,  Prev: Clipboard,  Up: Cut and Paste

12.3.2 Cut and Paste with Other Window Applications
---------------------------------------------------

Under the X Window System, there exists a "primary selection"
containing the last stretch of text selected in an X application
(usually by dragging the mouse).  Typically, this text can be inserted
into other X applications by `mouse-2' clicks.  The primary selection
is separate from the clipboard.  Its contents are more "fragile"; they
are overwritten each time you select text with the mouse, whereas the
clipboard is only overwritten by explicit "cut" or "copy" commands.

   Under X, whenever the region is active (*note Mark::), the text in
the region is saved in the primary selection.  This applies regardless
of whether the region was made by dragging or clicking the mouse (*note
Mouse Commands::), or by keyboard commands (e.g. by typing `C-<SPC>'
and moving point; *note Setting Mark::).

   If you change the variable `select-active-regions' to `only', Emacs
saves only temporarily active regions to the primary selection, i.e.
those made with the mouse or with shift selection (*note Shift
Selection::).  If you change `select-active-regions' to `nil', Emacs
avoids saving active regions to the primary selection entirely.

   To insert the primary selection into an Emacs buffer, click
`mouse-2' (`mouse-yank-primary') where you want to insert it.  *Note
Mouse Commands::.

   MS-Windows provides no primary selection, but Emacs emulates it
within a single Emacs session by storing the selected text internally.
Therefore, all the features and commands related to the primary
selection work on Windows as they do on X, for cutting and pasting
within the same session, but not across Emacs sessions or with other
applications.


File: emacs,  Node: Secondary Selection,  Prev: Primary Selection,  Up: Cut and Paste

12.3.3 Secondary Selection
--------------------------

In addition to the primary selection, the X Window System provides a
second similar facility known as the "secondary selection".  Nowadays,
few X applications make use of the secondary selection, but you can
access it using the following Emacs commands:

`M-Drag-Mouse-1'
     Set the secondary selection, with one end at the place where you
     press down the button, and the other end at the place where you
     release it (`mouse-set-secondary').  The selected text is
     highlighted, using the `secondary-selection' face, as you drag.
     The window scrolls automatically if you drag the mouse off the top
     or bottom of the window, just like `mouse-set-region' (*note Mouse
     Commands::).

     This command does not alter the kill ring.

`M-Mouse-1'
     Set one endpoint for the "secondary selection"
     (`mouse-start-secondary').

`M-Mouse-3'
     Set the secondary selection, with one end at the position clicked
     and the other at the position specified with `M-Mouse-1'
     (`mouse-secondary-save-then-kill').  This also puts the selected
     text in the kill ring.  A second `M-Mouse-3' at the same place
     kills the secondary selection just made.

`M-Mouse-2'
     Insert the secondary selection where you click, placing point at
     the end of the yanked text (`mouse-yank-secondary').

   Double or triple clicking of `M-Mouse-1' operates on words and
lines, much like `Mouse-1'.

   If `mouse-yank-at-point' is non-`nil', `M-Mouse-2' yanks at point.
Then it does not matter precisely where you click, or even which of the
frame's windows you click on.  *Note Mouse Commands::.


File: emacs,  Node: Accumulating Text,  Next: Rectangles,  Prev: Cut and Paste,  Up: Killing

12.4 Accumulating Text
======================

Usually we copy or move text by killing it and yanking it, but there
are other convenient methods for copying one block of text in many
places, or for copying many scattered blocks of text into one place.
Here we describe the commands to accumulate scattered pieces of text
into a buffer or into a file.

`M-x append-to-buffer'
     Append region to the contents of a specified buffer.

`M-x prepend-to-buffer'
     Prepend region to the contents of a specified buffer.

`M-x copy-to-buffer'
     Copy region into a specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert the contents of a specified buffer into current buffer at
     point.

`M-x append-to-file'
     Append region to the contents of a specified file, at the end.

   To accumulate text into a buffer, use `M-x append-to-buffer'.  This
reads a buffer name, then inserts a copy of the region into the buffer
specified.  If you specify a nonexistent buffer, `append-to-buffer'
creates the buffer.  The text is inserted wherever point is in that
buffer.  If you have been using the buffer for editing, the copied text
goes into the middle of the text of the buffer, starting from wherever
point happens to be at that moment.

   Point in that buffer is left at the end of the copied text, so
successive uses of `append-to-buffer' accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, `append-to-buffer' does not always append to the text already
in the buffer--it appends only if point in that buffer is at the end.
However, if `append-to-buffer' is the only command you use to alter a
buffer, then point is always at the end.

   `M-x prepend-to-buffer' is just like `append-to-buffer' except that
point in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is
similar, except that any existing text in the other buffer is deleted,
so the buffer is left containing just the text newly copied into it.

   The command `M-x insert-buffer' can be used to retrieve the
accumulated text from another buffer.  This prompts for the name of a
buffer, and inserts a copy of all the text in that buffer into the
current buffer at point, leaving point at the beginning of the inserted
text.  It also adds the position of the end of the inserted text to the
mark ring, without activating the mark.  *Note Buffers::, for
background information on buffers.

   Instead of accumulating text in a buffer, you can append text
directly into a file with `M-x append-to-file'.  This prompts for a
filename, and adds the text of the region to the end of the specified
file.  The file is changed immediately on disk.

   You should use `append-to-file' only with files that are _not_ being
visited in Emacs.  Using it on a file that you are editing in Emacs
would change the file behind Emacs's back, which can lead to losing
some of your editing.

   Another way to move text around is to store it in a register.  *Note
Registers::.


File: emacs,  Node: Rectangles,  Next: CUA Bindings,  Prev: Accumulating Text,  Up: Killing

12.5 Rectangles
===============

"Rectangle" commands operate on rectangular areas of the text: all the
characters between a certain pair of columns, in a certain range of
lines.  Emacs has commands to kill rectangles, yank killed rectangles,
clear them out, fill them with blanks or text, or delete them.
Rectangle commands are useful with text in multicolumn formats, and for
changing text into or out of such formats.

   To specify a rectangle for a command to work on, set the mark at one
corner and point at the opposite corner.  The rectangle thus specified
is called the "region-rectangle".  If point and the mark are in the
same column, the region-rectangle is empty.  If they are in the same
line, the region-rectangle is one line high.

   The region-rectangle is controlled in much the same way as the
region is controlled.  But remember that a given combination of point
and mark values can be interpreted either as a region or as a
rectangle, depending on the command that uses them.

`C-x r k'
     Kill the text of the region-rectangle, saving its contents as the
     "last killed rectangle" (`kill-rectangle').

`C-x r d'
     Delete the text of the region-rectangle (`delete-rectangle').

`C-x r y'
     Yank the last killed rectangle with its upper left corner at point
     (`yank-rectangle').

`C-x r o'
     Insert blank space to fill the space of the region-rectangle
     (`open-rectangle').  This pushes the previous contents of the
     region-rectangle to the right.

`C-x r N'
     Insert line numbers along the left edge of the region-rectangle
     (`rectangle-number-lines').  This pushes the previous contents of
     the region-rectangle to the right.

`C-x r c'
     Clear the region-rectangle by replacing all of its contents with
     spaces (`clear-rectangle').

`M-x delete-whitespace-rectangle'
     Delete whitespace in each of the lines on the specified rectangle,
     starting from the left edge column of the rectangle.

`C-x r t STRING <RET>'
     Replace rectangle contents with STRING on each line
     (`string-rectangle').

`M-x string-insert-rectangle <RET> STRING <RET>'
     Insert STRING on each line of the rectangle.

   The rectangle operations fall into two classes: commands to erase or
insert rectangles, and commands to make blank rectangles.

   There are two ways to erase the text in a rectangle: `C-x r d'
(`delete-rectangle') to delete the text outright, or `C-x r k'
(`kill-rectangle') to remove the text and save it as the "last killed
rectangle".  In both cases, erasing the region-rectangle is like
erasing the specified text on each line of the rectangle; if there is
any following text on the line, it moves backwards to fill the gap.

   "Killing" a rectangle is not killing in the usual sense; the
rectangle is not stored in the kill ring, but in a special place that
only records the most recent rectangle killed.  This is because yanking
a rectangle is so different from yanking linear text that different
yank commands have to be used.  Yank-popping is not defined for
rectangles.

   To yank the last killed rectangle, type `C-x r y'
(`yank-rectangle').  The rectangle's first line is inserted at point,
the rectangle's second line is inserted at the same horizontal position
one line vertically below, and so on.  The number of lines affected is
determined by the height of the saved rectangle.

   For example, you can convert two single-column lists into a
double-column list by killing one of the single-column lists as a
rectangle, and then yanking it beside the other list.

   You can also copy rectangles into and out of registers with `C-x r r
R' and `C-x r i R'.  *Note Rectangle Registers::.

   There are two commands you can use for making blank rectangles: `C-x
r c' (`clear-rectangle') blanks out existing text in the
region-rectangle, and `C-x r o' (`open-rectangle') inserts a blank
rectangle.

   `M-x delete-whitespace-rectangle' deletes horizontal whitespace
starting from a particular column.  This applies to each of the lines
in the rectangle, and the column is specified by the left edge of the
rectangle.  The right edge of the rectangle does not make any
difference to this command.

   The command `C-x r N' (`rectangle-number-lines') inserts line
numbers along the left edge of the region-rectangle.  Normally, the
numbering begins from 1 (for the first line of the rectangle).  With a
prefix argument, the command prompts for a number to begin from, and
for a format string with which to print the numbers (*note Formatting
Strings: (elisp)Formatting Strings.).

   The command `C-x r t' (`string-rectangle') replaces the contents of
a region-rectangle with a string on each line.  The string's width need
not be the same as the width of the rectangle.  If the string's width
is less, the text after the rectangle shifts left; if the string is
wider than the rectangle, the text after the rectangle shifts right.

   The command `M-x string-insert-rectangle' is similar to
`string-rectangle', but inserts the string on each line, shifting the
original text to the right.


File: emacs,  Node: CUA Bindings,  Prev: Rectangles,  Up: Killing

12.6 CUA Bindings
=================

The command `M-x cua-mode' sets up key bindings that are compatible
with the Common User Access (CUA) system used in many other
applications.

   When CUA mode is enabled, the keys `C-x', `C-c', `C-v', and `C-z'
invoke commands that cut (kill), copy, paste (yank), and undo
respectively.  The `C-x' and `C-c' keys perform cut and copy only if
the region is active.  Otherwise, they still act as prefix keys, so
that standard Emacs commands like `C-x C-c' still work.  Note that this
means the variable `mark-even-if-inactive' has no effect for `C-x' and
`C-c' (*note Using Region::).

   To enter an Emacs command like `C-x C-f' while the mark is active,
use one of the following methods: either hold `Shift' together with the
prefix key, e.g. `S-C-x C-f', or quickly type the prefix key twice,
e.g. `C-x C-x C-f'.

   To disable the overriding of standard Emacs binding by CUA mode,
while retaining the other features of CUA mode described below, set the
variable `cua-enable-cua-keys' to `nil'.

   In CUA mode, typed text replaces the active region as in
Delete-Selection mode (*note Mouse Commands::).

   CUA mode provides enhanced rectangle support with visible rectangle
highlighting.  Use `C-RET' to start a rectangle, extend it using the
movement commands, and cut or copy it using `C-x' or `C-c'.  `RET'
moves the cursor to the next (clockwise) corner of the rectangle, so
you can easily expand it in any direction.  Normal text you type is
inserted to the left or right of each line in the rectangle (on the
same side as the cursor).

   With CUA you can easily copy text and rectangles into and out of
registers by providing a one-digit numeric prefix to the kill, copy,
and yank commands, e.g. `C-1 C-c' copies the region into register `1',
and `C-2 C-v' yanks the contents of register `2'.

   CUA mode also has a global mark feature which allows easy moving and
copying of text between buffers.  Use `C-S-SPC' to toggle the global
mark on and off.  When the global mark is on, all text that you kill or
copy is automatically inserted at the global mark, and text you type is
inserted at the global mark rather than at the current position.

   For example, to copy words from various buffers into a word list in
a given buffer, set the global mark in the target buffer, then navigate
to each of the words you want in the list, mark it (e.g. with `S-M-f'),
copy it to the list with `C-c' or `M-w', and insert a newline after the
word in the target list by pressing <RET>.


File: emacs,  Node: Registers,  Next: Display,  Prev: Killing,  Up: Top

13 Registers
************

Emacs "registers" are compartments where you can save text, rectangles,
positions, and other things for later use.  Once you save text or a
rectangle in a register, you can copy it into the buffer once, or many
times; once you save a position in a register, you can jump back to
that position once, or many times.

   Each register has a name that consists of a single character, which
we will denote by R; R can be a letter (such as `a') or a number (such
as `1'); case matters, so register `a' is not the same as register `A'.

   A register can store a position, a piece of text, a rectangle, a
number, a window configuration, or a file name, but only one thing at
any given time.  Whatever you store in a register remains there until
you store something else in that register.  To see what register R
contains, use `M-x view-register':

`M-x view-register <RET> R'
     Display a description of what register R contains.

   "Bookmarks" record files and positions in them, so you can return to
those positions when you look at the file again.  Bookmarks are similar
in spirit to registers, so they are also documented in this chapter.

* Menu:

* Position Registers::       Saving positions in registers.
* Text Registers::           Saving text in registers.
* Rectangle Registers::      Saving rectangles in registers.
* Configuration Registers::  Saving window configurations in registers.
* Number Registers::         Numbers in registers.
* File Registers::           File names in registers.
* Bookmarks::                Bookmarks are like registers, but persistent.


File: emacs,  Node: Position Registers,  Next: Text Registers,  Up: Registers

13.1 Saving Positions in Registers
==================================

`C-x r <SPC> R'
     Record the position of point and the current buffer in register R
     (`point-to-register').

`C-x r j R'
     Jump to the position and buffer saved in register R
     (`jump-to-register').

   Typing `C-x r <SPC>' (`point-to-register'), followed by a character
`R', saves both the position of point and the current buffer in
register R.  The register retains this information until you store
something else in it.

   The command `C-x r j R' switches to the buffer recorded in register
R, and moves point to the recorded position.  The contents of the
register are not changed, so you can jump to the saved position any
number of times.

   If you use `C-x r j' to go to a saved position, but the buffer it
was saved from has been killed, `C-x r j' tries to create the buffer
again by visiting the same file.  Of course, this works only for buffers
that were visiting files.


File: emacs,  Node: Text Registers,  Next: Rectangle Registers,  Prev: Position Registers,  Up: Registers

13.2 Saving Text in Registers
=============================

When you want to insert a copy of the same piece of text several times,
it may be inconvenient to yank it from the kill ring, since each
subsequent kill moves that entry further down the ring.  An alternative
is to store the text in a register and later retrieve it.

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r i R'
     Insert text from register R (`insert-register').

`M-x append-to-register <RET> R'
     Append region to text in register R.

`M-x prepend-to-register <RET> R'
     Prepend region to text in register R.

   `C-x r s R' stores a copy of the text of the region into the
register named R.  If the mark is inactive, Emacs first reactivates the
mark where it was last set.  The mark is deactivated at the end of this
command.  *Note Mark::.  `C-u C-x r s R', the same command with a
prefix argument, copies the text into register R and deletes the text
from the buffer as well; you can think of this as "moving" the region
text into the register.

   `M-x append-to-register <RET> R' appends the copy of the text in the
region to the text already stored in the register named R.  If invoked
with a prefix argument, it deletes the region after appending it to the
register.  The command `prepend-to-register' is similar, except that it
_prepends_ the region text to the text in the register instead of
_appending_ it.

   `C-x r i R' inserts in the buffer the text from register R.
Normally it leaves point before the text and sets the mark after,
without activating it.  With a numeric argument, it instead puts point
after the text and the mark before.


File: emacs,  Node: Rectangle Registers,  Next: Configuration Registers,  Prev: Text Registers,  Up: Registers

13.3 Saving Rectangles in Registers
===================================

A register can contain a rectangle instead of linear text.  *Note
Rectangles::, for basic information on how to specify a rectangle in
the buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-rectangle-to-register').  With numeric argument, delete it
     as well.

`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' (`insert-register') command, previously documented
in *note Text Registers::, inserts a rectangle rather than a text
string, if the register contains a rectangle.


File: emacs,  Node: Configuration Registers,  Next: Number Registers,  Prev: Rectangle Registers,  Up: Registers

13.4 Saving Window Configurations in Registers
==============================================

You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.  *Note Windows::, for information
about window configurations.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`C-x r f R'
     Save the state of all frames, including all their windows, in
     register R (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: emacs,  Node: Number Registers,  Next: File Registers,  Prev: Configuration Registers,  Up: Registers

13.5 Keeping Numbers in Registers
=================================

There are commands to store a number in a register, to insert the
number in the buffer in decimal, and to increment it.  These commands
can be useful in keyboard macros (*note Keyboard Macros::).

`C-u NUMBER C-x r n R'
     Store NUMBER into register R (`number-to-register').

`C-u NUMBER C-x r + R'
     Increment the number in register R by NUMBER
     (`increment-register').

`C-x r i R'
     Insert the number from register R into the buffer.

   `C-x r i' is the same command used to insert any other sort of
register contents into the buffer.  `C-x r +' with no numeric argument
increments the register value by 1; `C-x r n' with no numeric argument
stores zero in the register.


File: emacs,  Node: File Registers,  Next: Bookmarks,  Prev: Number Registers,  Up: Registers

13.6 Keeping File Names in Registers
====================================

If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)


File: emacs,  Node: Bookmarks,  Prev: File Registers,  Up: Registers

13.7 Bookmarks
==============

"Bookmarks" are somewhat like registers in that they record positions
you can jump to.  Unlike registers, they have long names, and they
persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

`C-x r m <RET>'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK <RET>'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK <RET>'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks').

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions or annotate the bookmarks.
Type `C-h m' in the bookmark buffer for more information about its
special editing commands.

   When you kill Emacs, Emacs saves your bookmarks, if you have changed
any bookmark values.  You can also save the bookmarks at any time with
the `M-x bookmark-save' command.  Bookmarks are saved to the file
`~/.emacs.d/bookmarks' (for compatibility with older versions of Emacs,
if you have a file named `~/.emacs.bmk', that is used instead).  The
bookmark commands load your default bookmark file automatically.  This
saving and loading is how bookmarks persist from one Emacs session to
the next.

   If you set the variable `bookmark-save-flag' to 1, each command that
sets a bookmark will also save your bookmarks; this way, you don't lose
any bookmark values even if Emacs crashes.  The value, if a number,
says how many bookmark modifications should go by between saving.  If
you set this variable to `nil', Emacs only saves bookmarks if you
explicitly use `M-x bookmark-save'.

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record on each side of the bookmark's position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load <RET> FILENAME <RET>'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write <RET> FILENAME <RET>'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete <RET> BOOKMARK <RET>'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-insert-location <RET> BOOKMARK <RET>'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert <RET> BOOKMARK <RET>'
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.


File: emacs,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

14 Controlling the Display
**************************

Since only part of a large buffer fits in the window, Emacs has to show
only a part of it.  This chapter describes commands and variables that
let you specify which part of the text you want to see, and how the
text is displayed.

* Menu:

* Scrolling::              Commands to move text up and down in a window.
* Recentering::            A scroll command that centers the current line.
* Auto Scrolling::         Redisplay scrolls text automatically when needed.
* Horizontal Scrolling::   Moving text left and right in a window.
* Narrowing::              Restricting display and editing to a portion
                             of the buffer.
* View Mode::              Viewing read-only buffers.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Faces::                  How to change the display style using faces.
* Colors::                 Specifying colors for faces.
* Standard Faces::         The main predefined faces.
* Text Scale::             Increasing or decreasing text size in a buffer.
* Font Lock::              Minor mode for syntactic highlighting using faces.
* Highlight Interactively:: Tell Emacs what text to highlight.
* Fringes::                Enabling or disabling window fringes.
* Displaying Boundaries::  Displaying top and bottom of the buffer.
* Useless Whitespace::     Showing possibly spurious trailing whitespace.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Cursor Display::         Features for displaying the cursor.
* Line Truncation::        Truncating lines to fit the screen width instead
                             of continuing them to multiple screen lines.
* Visual Line Mode::       Word wrap and screen line-based editing.
* Display Custom::         Information on variables for customizing display.


File: emacs,  Node: Scrolling,  Next: Recentering,  Up: Display

14.1 Scrolling
==============

If a window is too small to display all the text in its buffer, it
displays only a portion of it.  "Scrolling" commands change which
portion of the buffer is displayed.

   Scrolling "forward" or "up" advances the portion of the buffer
displayed in the window; equivalently, it moves the buffer text upwards
relative to the window.  Scrolling "backward" or "down" displays an
earlier portion of the buffer, and moves the text downwards relative to
the window.

   In Emacs, scrolling "up" or "down" refers to the direction that the
text moves in the window, _not_ the direction that the window moves
relative to the text.  This terminology was adopted by Emacs before the
modern meaning of "scrolling up" and "scrolling down" became
widespread.  Hence, the strange result that <PageDown> scrolls "up" in
the Emacs sense.

   The portion of a buffer displayed in a window always contains point.
If you move point past the bottom or top of the window, scrolling
occurs automatically to bring it back onscreen (*note Auto
Scrolling::).  You can also scroll explicitly with these commands:

`C-v'
`<next>'
`<PageDown>'
     Scroll forward by nearly a full window (`scroll-up-command').

`M-v'
`<prior>'
`<PageUp>'
     Scroll backward (`scroll-down-command').

   `C-v' (`scroll-up-command') scrolls forward by nearly the whole
window height.  The effect is to take the two lines at the bottom of
the window and put them at the top, followed by lines that were not
previously visible.  If point was in the text that scrolled off the
top, it ends up on the window's new topmost line.  The <next> (or
<PageDown>) key is equivalent to `C-v'.

   `M-v' (`scroll-down-command') scrolls backward in a similar way.
The <prior> (or <PageUp>) key is equivalent to `M-v'.

   The number of lines of overlap left by these scroll commands is
controlled by the variable `next-screen-context-lines', whose default
value is 2.  You can supply the commands with a numeric prefix
argument, N, to scroll by N lines; Emacs attempts to leave point
unchanged, so that the text and point move up or down together.  `C-v'
with a negative argument is like `M-v' and vice versa.

   By default, these commands signal an error (by beeping or flashing
the screen) if no more scrolling is possible, because the window has
reached the beginning or end of the buffer.  If you change the variable
`scroll-error-top-bottom' to `t', the command moves point to the
farthest possible position.  If point is already there, the command
signals an error.

   Some users like scroll commands to keep point at the same screen
position, so that scrolling back to the same screen conveniently
returns point to its original position.  You can enable this behavior
via the variable `scroll-preserve-screen-position'.  If the value is
`t', Emacs adjusts point to keep the cursor at the same screen position
whenever a scroll command moves it off-window, rather than moving it to
the topmost or bottommost line.  With any other non-`nil' value, Emacs
adjusts point this way even if the scroll command leaves point in the
window.  This variable affects all the scroll commands documented in
this section, as well as scrolling with the mouse wheel (*note Mouse
Commands::); in general, it affects any command that has a non-`nil'
`scroll-command' property.  *Note Property Lists: (elisp)Property Lists.

   The commands `M-x scroll-up' and `M-x scroll-down' behave similarly
to `scroll-up-command' and `scroll-down-command', except they do not
obey `scroll-error-top-bottom'.  Prior to Emacs 24, these were the
default commands for scrolling up and down.  The commands `M-x
scroll-up-line' and `M-x scroll-down-line' scroll the current window by
one line at a time.  If you intend to use any of these commands, you
might want to give them key bindings (*note Init Rebinding::).


File: emacs,  Node: Recentering,  Next: Auto Scrolling,  Prev: Scrolling,  Up: Display

14.2 Recentering
================

`C-l'
     Scroll the selected window so the current line is the center-most
     text line; on subsequent consecutive invocations, make the current
     line the top line, the bottom line, and so on in cyclic order.
     Possibly redisplay the screen too (`recenter-top-bottom').

`M-x recenter'
     Scroll the selected window so the current line is the center-most
     text line.  Possibly redisplay the screen too.

`C-M-l'
     Scroll heuristically to bring useful information onto the screen
     (`reposition-window').

   The `C-l' (`recenter-top-bottom') command "recenters" the selected
window, scrolling it so that the current screen line is exactly in the
center of the window, or as close to the center as possible.

   Typing `C-l' twice in a row (`C-l C-l') scrolls the window so that
point is on the topmost screen line.  Typing a third `C-l' scrolls the
window so that point is on the bottom-most screen line.  Each
successive `C-l' cycles through these three positions.

   You can change the cycling order by customizing the list variable
`recenter-positions'.  Each list element should be the symbol `top',
`middle', or `bottom', or a number; an integer means to move the line
to the specified screen line, while a floating-point number between 0.0
and 1.0 specifies a percentage of the screen space from the top of the
window.  The default, `(middle top bottom)', is the cycling order
described above.  Furthermore, if you change the variable
`scroll-margin' to a non-zero value N, `C-l' always leaves at least N
screen lines between point and the top or bottom of the window (*note
Auto Scrolling::).

   You can also give `C-l' a prefix argument.  A plain prefix argument,
`C-u C-l', simply recenters point.  A positive argument N puts point N
lines down from the top of the window.  An argument of zero puts point
on the topmost line.  A negative argument -N puts point N lines from
the bottom of the window.  When given an argument, `C-l' does not clear
the screen or cycle through different screen positions.

   If the variable `recenter-redisplay' has a non-`nil' value, each
invocation of `C-l' also clears and redisplays the screen; the special
value `tty' (the default) says to do this on text-terminal frames only.
Redisplaying is useful in case the screen becomes garbled for any
reason (*note Screen Garbled::).

   The more primitive command `M-x recenter' behaves like
`recenter-top-bottom', but does not cycle among screen positions.

   `C-M-l' (`reposition-window') scrolls the current window
heuristically in a way designed to get useful information onto the
screen.  For example, in a Lisp file, this command tries to get the
entire current defun onto the screen if possible.


File: emacs,  Node: Auto Scrolling,  Next: Horizontal Scrolling,  Prev: Recentering,  Up: Display

14.3 Automatic Scrolling
========================

Emacs performs "automatic scrolling" when point moves out of the
visible portion of the text.

   Normally, this centers point vertically within the window.  However,
if you set `scroll-conservatively' to a small number N, then if you
move point just a little off the screen (less than N lines), Emacs
scrolls the text just far enough to bring point back on screen.  By
default, `scroll-conservatively' is 0.  If you set
`scroll-conservatively' to a large number (larger than 100), Emacs will
never center point as result of scrolling, even if point moves far away
from the text previously displayed in the window.  With such a large
value, Emacs will always scroll text just enough for bringing point
into view, so point will end up at the top or bottom of the window,
depending on the scroll direction.

   The variable `scroll-step' determines how many lines to scroll the
window when point moves off the screen.  If moving by that number of
lines fails to bring point back into view, point is centered instead.
The default value is zero, which causes point to always be centered
after scrolling.

   When the window does scroll by a distance longer than `scroll-step',
you can control how aggressively it scrolls by setting the variables
`scroll-up-aggressively' and `scroll-down-aggressively'.  The value of
`scroll-up-aggressively' should be either `nil', or a fraction F
between 0 and 1.  A fraction specifies where on the screen to put point
when scrolling upward, i.e. forward.  When point goes off the window
end, the new start position is chosen to put point F parts of the
window height from the bottom margin.  Thus, larger F means more
aggressive scrolling: more new text is brought into view.  The default
value, `nil', is equivalent to 0.5.

   Likewise, `scroll-down-aggressively' is used for scrolling down,
i.e. backward.  The value specifies how far point should be placed from
the top margin of the window; thus, as with `scroll-up-aggressively', a
larger value is more aggressive.

   These two variables are ignored if either `scroll-step' or
`scroll-conservatively' are set to a non-zero value.

   The variable `scroll-margin' restricts how close point can come to
the top or bottom of a window (even if aggressive scrolling specifies a
fraction F that is larger than the window portion between the top and
the bottom margins).  Its value is a number of screen lines; if point
comes within that many lines of the top or bottom of the window, Emacs
performs automatic scrolling.  By default, `scroll-margin' is 0.


File: emacs,  Node: Horizontal Scrolling,  Next: Narrowing,  Prev: Auto Scrolling,  Up: Display

14.4 Horizontal Scrolling
=========================

"Horizontal scrolling" means shifting all the lines sideways within a
window, so that some of the text near the left margin is not displayed.
When the text in a window is scrolled horizontally, text lines are
truncated rather than continued (*note Line Truncation::).  If a window
shows truncated lines, Emacs performs automatic horizontal scrolling
whenever point moves off the left or right edge of the screen.  To
disable automatic horizontal scrolling, set the variable
`auto-hscroll-mode' to `nil'.  Note that when the automatic horizontal
scrolling is turned off, if point moves off the edge of the screen, the
cursor disappears to indicate that.  (On text terminals, the cursor is
left at the edge instead.)

   The variable `hscroll-margin' controls how close point can get to
the window's edges before automatic scrolling occurs.  It is measured
in columns.  For example, if the value is 5, then moving point within 5
columns of an edge causes horizontal scrolling away from that edge.

   The variable `hscroll-step' determines how many columns to scroll
the window when point gets too close to the edge.  Zero, the default
value, means to center point horizontally within the window.  A
positive integer value specifies the number of columns to scroll by.  A
floating-point number specifies the fraction of the window's width to
scroll by.

   You can also perform explicit horizontal scrolling with the
following commands:

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

   `C-x <' (`scroll-left') scrolls text in the selected window to the
left by the full width of the window, less two columns.  (In other
words, the text in the window moves left relative to the window.)  With
a numeric argument N, it scrolls by N columns.

   If the text is scrolled to the left, and point moves off the left
edge of the window, the cursor will freeze at the left edge of the
window, until point moves back to the displayed portion of the text.
This is independent of the current setting of `auto-hscroll-mode',
which, for text scrolled to the left, only affects the behavior at the
right edge of the window.

   `C-x >' (`scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displayed
normally, with each line starting at the window's left margin;
attempting to do so has no effect.  This means that you don't have to
calculate the argument precisely for `C-x >'; any sufficiently large
argument will restore the normal display.

   If you use those commands to scroll a window horizontally, that sets
a lower bound for automatic horizontal scrolling.  Automatic scrolling
will continue to scroll the window, but never farther to the right than
the amount you previously set by `scroll-left'.


File: emacs,  Node: Narrowing,  Next: View Mode,  Prev: Horizontal Scrolling,  Up: Display

14.5 Narrowing
==============

"Narrowing" means focusing in on some portion of the buffer, making the
rest temporarily inaccessible.  The portion which you can still get to
is called the "accessible portion".  Canceling the narrowing, which
makes the entire buffer once again accessible, is called "widening".
The bounds of narrowing in effect in a buffer are called the buffer's
"restriction".

   Narrowing can make it easier to concentrate on a single subroutine or
paragraph by eliminating clutter.  It can also be used to limit the
range of operation of a replace command or repeating keyboard macro.

`C-x n n'
     Narrow down to between point and mark (`narrow-to-region').

`C-x n w'
     Widen to make the entire buffer accessible again (`widen').

`C-x n p'
     Narrow down to the current page (`narrow-to-page').

`C-x n d'
     Narrow down to the current defun (`narrow-to-defun').

   When you have narrowed down to a part of the buffer, that part
appears to be all there is.  You can't see the rest, you can't move
into it (motion commands won't go outside the accessible part), you
can't change it in any way.  However, it is not gone, and if you save
the file all the inaccessible text will be saved.  The word `Narrow'
appears in the mode line whenever narrowing is in effect.

   The primary narrowing command is `C-x n n' (`narrow-to-region').  It
sets the current buffer's restrictions so that the text in the current
region remains accessible, but all text before the region or after the
region is inaccessible.  Point and mark do not change.

   Alternatively, use `C-x n p' (`narrow-to-page') to narrow down to
the current page.  *Note Pages::, for the definition of a page.  `C-x n
d' (`narrow-to-defun') narrows down to the defun containing point
(*note Defuns::).

   The way to cancel narrowing is to widen with `C-x n w' (`widen').
This makes all text in the buffer accessible again.

   You can get information on what part of the buffer you are narrowed
down to using the `C-x =' command.  *Note Position Info::.

   Because narrowing can easily confuse users who do not understand it,
`narrow-to-region' is normally a disabled command.  Attempting to use
this command asks for confirmation and gives you the option of enabling
it; if you enable the command, confirmation will no longer be required
for it.  *Note Disabling::.


File: emacs,  Node: View Mode,  Next: Follow Mode,  Prev: Narrowing,  Up: Display

14.6 View Mode
==============

View mode is a minor mode that lets you scan a buffer by sequential
screenfuls.  It provides commands for scrolling through the buffer
conveniently but not for changing it.  Apart from the usual Emacs
cursor motion commands, you can type <SPC> to scroll forward one
windowful, <DEL> to scroll backward, and `s' to start an incremental
search.

   Typing `q' (`View-quit') disables View mode, and switches back to
the buffer and position before View mode was enabled.  Typing `e'
(`View-exit') disables View mode, keeping the current buffer and
position.

   `M-x view-buffer' prompts for an existing Emacs buffer, switches to
it, and enables View mode.  `M-x view-file' prompts for a file and
visits it with View mode enabled.


File: emacs,  Node: Follow Mode,  Next: Faces,  Prev: View Mode,  Up: Display

14.7 Follow Mode
================

"Follow mode" is a minor mode that makes two windows, both showing the
same buffer, scroll as a single tall "virtual window".  To use Follow
mode, go to a frame with just one window, split it into two
side-by-side windows using `C-x 3', and then type `M-x follow-mode'.
From then on, you can edit the buffer in either of the two windows, or
scroll either one; the other window follows it.

   In Follow mode, if you move point outside the portion visible in one
window and into the portion visible in the other window, that selects
the other window--again, treating the two as if they were parts of one
large window.

   To turn off Follow mode, type `M-x follow-mode' a second time.


File: emacs,  Node: Faces,  Next: Colors,  Prev: Follow Mode,  Up: Display

14.8 Text Faces
===============

Emacs can display text in several different styles, called "faces".
Each face can specify various "face attributes", such as the font,
height, weight, slant, foreground and background color, and underlining
or overlining.  Most major modes assign faces to the text
automatically, via Font Lock mode.  *Note Font Lock::, for more
information about how these faces are assigned.

   To see what faces are currently defined, and what they look like,
type `M-x list-faces-display'.  With a prefix argument, this prompts
for a regular expression, and displays only faces with names matching
that regular expression (*note Regexps::).

   It's possible for a given face to look different in different
frames.  For instance, some text terminals do not support all face
attributes, particularly font, height, and width, and some support a
limited range of colors.

   You can customize a face to alter its appearance, and save those
changes for future Emacs sessions.  *Note Face Customization::.  A face
does not have to specify every single attribute; often it inherits most
attributes from another face.  Any ultimately unspecified attribute is
taken from the face named `default'.

   The `default' face is the default for displaying text, and all of
its attributes are specified.  Its background color is also used as the
frame's background color.  *Note Colors::.

   Another special face is the `cursor' face.  On graphical displays,
the background color of this face is used to draw the text cursor.
None of the other attributes of this face have any effect; the
foreground color for text under the cursor is taken from the background
color of the underlying text.  On text terminals, the appearance of the
text cursor is determined by the terminal, not by the `cursor' face.

   You can also use X resources to specify attributes of any particular
face.  *Note Resources::.

   Emacs can display variable-width fonts, but some Emacs commands,
particularly indentation commands, do not account for variable
character display widths.  Therefore, we recommend not using
variable-width fonts for most faces, particularly those assigned by
Font Lock mode.


File: emacs,  Node: Colors,  Next: Standard Faces,  Prev: Faces,  Up: Display

14.9 Colors for Faces
=====================

Faces can have various foreground and background colors.  When you
specify a color for a face--for instance, when customizing the face
(*note Face Customization::)--you can use either a "color name" or an
"RGB triplet".

   A color name is a pre-defined name, such as `dark orange' or `medium
sea green'.  To view a list of color names, type `M-x
list-colors-display'.  To control the order in which colors are shown,
customize `list-colors-sort'.  If you run this command on a graphical
display, it shows the full range of color names known to Emacs (these
are the standard X11 color names, defined in X's `rgb.txt' file).  If
you run the command on a text terminal, it shows only a small subset of
colors that can be safely displayed on such terminals.  However, Emacs
understands X11 color names even on text terminals; if a face is given
a color specified by an X11 color name, it is displayed using the
closest-matching terminal color.

   An RGB triplet is a string of the form `#RRGGBB'.  Each of the R, G,
and B components is a hexadecimal number specifying the component's
relative intensity, one to four digits long (usually two digits are
used).  The components must have the same number of digits.  For
hexadecimal values A to F, either upper or lower case are acceptable.

   The `M-x list-colors-display' command also shows the equivalent RGB
triplet for each named color.  For instance, `medium sea green' is
equivalent to `#3CB371'.

   You can change the foreground and background colors of a face with
`M-x set-face-foreground' and `M-x set-face-background'.  These
commands prompt in the minibuffer for a face name and a color, with
completion, and then set that face to use the specified color.  They
affect the face colors on all frames, but their effects do not persist
for future Emacs sessions, unlike using the customization buffer or X
resources.  You can also use frame parameters to set foreground and
background colors for a specific frame; *Note Frame Parameters::.


File: emacs,  Node: Standard Faces,  Next: Text Scale,  Prev: Colors,  Up: Display

14.10 Standard Faces
====================

Here are the standard faces for specifying text appearance.  You can
apply them to specific text when you want the effects they produce.

`default'
     This face is used for ordinary text that doesn't specify any face.
     Its background color is used as the frame's background color.

`bold'
     This face uses a bold variant of the default font.

`italic'
     This face uses an italic variant of the default font.

`bold-italic'
     This face uses a bold italic variant of the default font.

`underline'
     This face underlines text.

`fixed-pitch'
     This face forces use of a fixed-width font.  It's reasonable to
     customize this face to use a different fixed-width font, if you
     like, but you should not make it a variable-width font.

`variable-pitch'
     This face forces use of a variable-width font.

`shadow'
     This face is used for making the text less noticeable than the
     surrounding ordinary text.  Usually this can be achieved by using
     shades of gray in contrast with either black or white default
     foreground color.

   Here's an incomplete list of faces used to highlight parts of the
text temporarily for specific purposes.  (Many other modes define their
own faces for this purpose.)

`highlight'
     This face is used for text highlighting in various contexts, such
     as when the mouse cursor is moved over a hyperlink.

`isearch'
     This face is used to highlight the current Isearch match (*note
     Incremental Search::).

`query-replace'
     This face is used to highlight the current Query Replace match
     (*note Replace::).

`lazy-highlight'
     This face is used to highlight "lazy matches" for Isearch and Query
     Replace (matches other than the current one).

`region'
     This face is used for displaying an active region (*note Mark::).
     When Emacs is built with GTK support, its colors are taken from the
     current GTK theme.

`secondary-selection'
     This face is used for displaying a secondary X selection (*note
     Secondary Selection::).

`trailing-whitespace'
     The face for highlighting excess spaces and tabs at the end of a
     line when `show-trailing-whitespace' is non-`nil' (*note Useless
     Whitespace::).

`escape-glyph'
     The face for displaying control characters and escape sequences
     (*note Text Display::).

`nobreak-space'
     The face for displaying "no-break" space characters (*note Text
     Display::).

   The following faces control the appearance of parts of the Emacs
frame:

`mode-line'
     This face is used for the mode line of the currently selected
     window, and for menu bars when toolkit menus are not used.  By
     default, it's drawn with shadows for a "raised" effect on
     graphical displays, and drawn as the inverse of the default face
     on non-windowed terminals.

`mode-line-inactive'
     Like `mode-line', but used for mode lines of the windows other
     than the selected one (if `mode-line-in-non-selected-windows' is
     non-`nil').  This face inherits from `mode-line', so changes in
     that face affect mode lines in all windows.

`mode-line-highlight'
     Like `highlight', but used for portions of text on mode lines.

`mode-line-buffer-id'
     This face is used for buffer identification parts in the mode line.

`header-line'
     Similar to `mode-line' for a window's header line, which appears
     at the top of a window just as the mode line appears at the bottom.
     Most windows do not have a header line--only some special modes,
     such Info mode, create one.

`vertical-border'
     This face is used for the vertical divider between windows on text
     terminals.

`minibuffer-prompt'
     This face is used for the prompt strings displayed in the
     minibuffer.  By default, Emacs automatically adds this face to the
     value of `minibuffer-prompt-properties', which is a list of text
     properties used to display the prompt text.  (This variable takes
     effect when you enter the minibuffer.)

`fringe'
     The face for the fringes to the left and right of windows on
     graphic displays.  (The fringes are the narrow portions of the
     Emacs frame between the text area and the window's right and left
     borders.)  *Note Fringes::.

`cursor'
     The `:background' attribute of this face specifies the color of
     the text cursor.  *Note Cursor Display::.

`tooltip'
     This face is used for tooltip text.  By default, if Emacs is built
     with GTK support, tooltips are drawn via GTK and this face has no
     effect.  *Note Tooltips::.

`mouse'
     This face determines the color of the mouse pointer.

   The following faces likewise control the appearance of parts of the
Emacs frame, but only on text terminals, or when Emacs is built on X
with no toolkit support.  (For all other cases, the appearance of the
respective frame elements is determined by system-wide settings.)

`scroll-bar'
     This face determines the visual appearance of the scroll bar.
     *Note Scroll Bars::.

`tool-bar'
     This face determines the color of tool bar icons.  *Note Tool
     Bars::.

`menu'
     This face determines the colors and font of Emacs's menus.  *Note
     Menu Bars::.


File: emacs,  Node: Text Scale,  Next: Font Lock,  Prev: Standard Faces,  Up: Display

14.11 Text Scale
================

To increase the height of the default face in the current buffer, type
`C-x C-+' or `C-x C-='.  To decrease it, type `C-x C--'.  To restore
the default (global) face height, type `C-x C-0'.  These keys are all
bound to the same command, `text-scale-adjust', which looks at the last
key typed to determine which action to take.

   The final key of these commands may be repeated without the leading
`C-x'.  For instance, `C-x C-= C-= C-=' increases the face height by
three steps.  Each step scales the text height by a factor of 1.2; to
change this factor, customize the variable `text-scale-mode-step'.  As
an exception, a numeric argument of 0 to the `text-scale-adjust'
command restores the default height, similar to typing `C-x C-0'.

   The commands `text-scale-increase' and `text-scale-decrease'
increase or decrease the height of the default face, just like `C-x
C-+' and `C-x C--' respectively.  You may find it convenient to bind to
these commands, rather than `text-scale-adjust'.

   The command `text-scale-set' scales the height of the default face
in the current buffer to an absolute level specified by its prefix
argument.

   The above commands automatically enable the minor mode
`text-scale-mode' if the current font scaling is other than 1, and
disable it otherwise.


File: emacs,  Node: Font Lock,  Next: Highlight Interactively,  Prev: Text Scale,  Up: Display

14.12 Font Lock mode
====================

Font Lock mode is a minor mode, always local to a particular buffer,
which assigns faces to (or "fontifies") the text in the buffer.  Each
buffer's major mode tells Font Lock mode which text to fontify; for
instance, programming language modes fontify syntactically relevant
constructs like comments, strings, and function names.

   Font Lock mode is enabled by default.  To toggle it in the current
buffer, type `M-x font-lock-mode'.  A positive numeric argument
unconditionally enables Font Lock mode, and a negative or zero argument
disables it.

   To toggle Font Lock mode in all buffers, type `M-x
global-font-lock-mode'.  To impose this setting for future Emacs
sessions, customize the variable `global-font-lock-mode' (*note Easy
Customization::), or add the following line to your init file:

     (global-font-lock-mode 0)

If you have disabled Global Font Lock mode, you can still enable Font
Lock for specific major modes by adding the function `font-lock-mode'
to the mode hooks (*note Hooks::).  For example, to enable Font Lock
mode for editing C files, you can do this:

     (add-hook 'c-mode-hook 'font-lock-mode)

   Font Lock mode uses several specifically named faces to do its job,
including `font-lock-string-face', `font-lock-comment-face', and
others.  The easiest way to find them all is to use `M-x
customize-group <RET> font-lock-faces <RET>'.  You can then use that
customization buffer to customize the appearance of these faces.  *Note
Face Customization::.

   You can customize the variable `font-lock-maximum-decoration' to
alter the amount of fontification applied by Font Lock mode, for major
modes that support this feature.  The value should be a number (with 1
representing a minimal amount of fontification; some modes support
levels as high as 3); or `t', meaning "as high as possible" (the
default).  You can also specify different numbers for particular major
modes; for example, to use level 1 for C/C++ modes, and the default
level otherwise, use the value

     '((c-mode . 1) (c++-mode . 1)))

   Comment and string fontification (or "syntactic" fontification)
relies on analysis of the syntactic structure of the buffer text.  For
the sake of speed, some modes, including Lisp mode, rely on a special
convention: an open-parenthesis or open-brace in the leftmost column
always defines the beginning of a defun, and is thus always outside any
string or comment.  Therefore, you should avoid placing an
open-parenthesis or open-brace in the leftmost column, if it is inside
a string or comment.  *Note Left Margin Paren::, for details.

   The variable `font-lock-beginning-of-syntax-function', which is
always buffer-local, specifies how Font Lock mode can find a position
guaranteed to be outside any comment or string.  In modes which use the
leftmost column parenthesis convention, the default value of the
variable is `beginning-of-defun'--that tells Font Lock mode to use the
convention.  If you set this variable to `nil', Font Lock no longer
relies on the convention.  This avoids incorrect results, but the price
is that, in some cases, fontification for a changed text must rescan
buffer text from the beginning of the buffer.  This can considerably
slow down redisplay while scrolling, particularly if you are close to
the end of a large buffer.

   Font Lock highlighting patterns already exist for most modes, but
you may want to fontify additional patterns.  You can use the function
`font-lock-add-keywords', to add your own highlighting patterns for a
particular mode.  For example, to highlight `FIXME:' words in C
comments, use this:

     (add-hook 'c-mode-hook
               (lambda ()
                (font-lock-add-keywords nil
                 '(("\\<\\(FIXME\\):" 1
                    font-lock-warning-face t)))))

To remove keywords from the font-lock highlighting patterns, use the
function `font-lock-remove-keywords'.  *Note Search-based
Fontification: (elisp)Search-based Fontification.

   Fontifying large buffers can take a long time.  To avoid large
delays when a file is visited, Emacs initially fontifies only the
visible portion of a buffer.  As you scroll through the buffer, each
portion that becomes visible is fontified as soon as it is displayed;
this type of Font Lock is called "Just-In-Time" (or "JIT") Lock.  You
can control how JIT Lock behaves, including telling it to perform
fontification while idle, by customizing variables in the customization
group `jit-lock'.  *Note Specific Customization::.


File: emacs,  Node: Highlight Interactively,  Next: Fringes,  Prev: Font Lock,  Up: Display

14.13 Interactive Highlighting
==============================

Highlight Changes mode is a minor mode that "highlights" the parts of
the buffer that were changed most recently, by giving that text a
different face.  To enable or disable Highlight Changes mode, use `M-x
highlight-changes-mode'.

   Hi Lock mode is a minor mode that highlights text that matches
regular expressions you specify.  For example, you can use it to
highlight all the references to a certain variable in a program source
file, highlight certain parts in a voluminous output of some program,
or highlight certain names in an article.  To enable or disable Hi Lock
mode, use the command `M-x hi-lock-mode'.  To enable Hi Lock mode for
all buffers, use `M-x global-hi-lock-mode' or place
`(global-hi-lock-mode 1)' in your `.emacs' file.

   Hi Lock mode works like Font Lock mode (*note Font Lock::), except
that you specify explicitly the regular expressions to highlight.  You
control them with these commands:

`C-x w h REGEXP <RET> FACE <RET>'
     Highlight text that matches REGEXP using face FACE
     (`highlight-regexp').  The highlighting will remain as long as the
     buffer is loaded.  For example, to highlight all occurrences of
     the word "whim" using the default face (a yellow background) `C-x
     w h whim <RET> <RET>'.  Any face can be used for highlighting, Hi
     Lock provides several of its own and these are pre-loaded into a
     list of default values.  While being prompted for a face use `M-n'
     and `M-p' to cycle through them.

     You can use this command multiple times, specifying various regular
     expressions to highlight in different ways.

`C-x w r REGEXP <RET>'
     Unhighlight REGEXP (`unhighlight-regexp').

     If you invoke this from the menu, you select the expression to
     unhighlight from a list.  If you invoke this from the keyboard, you
     use the minibuffer.  It will show the most recently added regular
     expression; use `M-p' to show the next older expression and `M-n'
     to select the next newer expression.  (You can also type the
     expression by hand, with completion.)  When the expression you
     want to unhighlight appears in the minibuffer, press `<RET>' to
     exit the minibuffer and unhighlight it.

`C-x w l REGEXP <RET> FACE <RET>'
     Highlight entire lines containing a match for REGEXP, using face
     FACE (`highlight-lines-matching-regexp').

`C-x w b'
     Insert all the current highlighting regexp/face pairs into the
     buffer at point, with comment delimiters to prevent them from
     changing your program.  (This key binding runs the
     `hi-lock-write-interactive-patterns' command.)

     These patterns are extracted from the comments, if appropriate, if
     you invoke `M-x hi-lock-find-patterns', or if you visit the file
     while Hi Lock mode is enabled (since that runs
     `hi-lock-find-patterns').

`C-x w i'
     Extract regexp/face pairs from comments in the current buffer
     (`hi-lock-find-patterns').  Thus, you can enter patterns
     interactively with `highlight-regexp', store them into the file
     with `hi-lock-write-interactive-patterns', edit them (perhaps
     including different faces for different parenthesized parts of the
     match), and finally use this command (`hi-lock-find-patterns') to
     have Hi Lock highlight the edited patterns.

     The variable `hi-lock-file-patterns-policy' controls whether Hi
     Lock mode should automatically extract and highlight patterns
     found in a file when it is visited.  Its value can be `nil' (never
     highlight), `ask' (query the user), or a function.  If it is a
     function, `hi-lock-find-patterns' calls it with the patterns as
     argument; if the function returns non-`nil', the patterns are
     used.  The default is `ask'.  Note that patterns are always
     highlighted if you call `hi-lock-find-patterns' directly,
     regardless of the value of this variable.

     Also, `hi-lock-find-patterns' does nothing if the current major
     mode's symbol is a member of the list `hi-lock-exclude-modes'.


File: emacs,  Node: Fringes,  Next: Displaying Boundaries,  Prev: Highlight Interactively,  Up: Display

14.14 Window Fringes
====================

On graphical displays, each Emacs window normally has narrow "fringes"
on the left and right edges.  The fringes are used to display symbols
that provide information about the text in the window.  You can type
`M-x fringe-mode' to disable the fringes, or modify their width.  This
command affects fringes in all frames; to modify fringes on the
selected frame only, use `M-x set-fringe-style'.

   The most common use of the fringes is to indicate a continuation
line (*note Continuation Lines::).  When one line of text is split into
multiple screen lines, the left fringe shows a curving arrow for each
screen line except the first, indicating that "this is not the real
beginning".  The right fringe shows a curving arrow for each screen
line except the last, indicating that "this is not the real end".  If
the line's direction is right-to-left (*note Bidirectional Editing::),
the meanings of the curving arrows in the fringes are swapped.

   The fringes indicate line truncation with short horizontal arrows
meaning "there's more text on this line which is scrolled horizontally
out of view".  Clicking the mouse on one of the arrows scrolls the
display horizontally in the direction of the arrow.

   The fringes can also indicate other things, such as buffer
boundaries (*note Displaying Boundaries::), and where a program you are
debugging is executing (*note Debuggers::).

   The fringe is also used for drawing the cursor, if the current line
is exactly as wide as the window and point is at the end of the line.
To disable this, change the variable `overflow-newline-into-fringe' to
`nil'; this causes Emacs to continue or truncate lines that are exactly
as wide as the window.


File: emacs,  Node: Displaying Boundaries,  Next: Useless Whitespace,  Prev: Fringes,  Up: Display

14.15 Displaying Boundaries
===========================

On graphical displays, Emacs can indicate the buffer boundaries in the
fringes.  If you enable this feature, the first line and the last line
are marked with angle images in the fringes.  This can be combined with
up and down arrow images which say whether it is possible to scroll the
window.

   The buffer-local variable `indicate-buffer-boundaries' controls how
the buffer boundaries and window scrolling is indicated in the fringes.
If the value is `left' or `right', both angle and arrow bitmaps are
displayed in the left or right fringe, respectively.

   If value is an alist, each element `(INDICATOR .  POSITION)'
specifies the position of one of the indicators.  The INDICATOR must be
one of `top', `bottom', `up', `down', or `t' which specifies the default
position for the indicators not present in the alist.  The POSITION is
one of `left', `right', or `nil' which specifies not to show this
indicator.

   For example, `((top . left) (t . right))' places the top angle
bitmap in left fringe, the bottom angle bitmap in right fringe, and
both arrow bitmaps in right fringe.  To show just the angle bitmaps in
the left fringe, but no arrow bitmaps, use `((top .  left) (bottom .
left))'.


File: emacs,  Node: Useless Whitespace,  Next: Selective Display,  Prev: Displaying Boundaries,  Up: Display

14.16 Useless Whitespace
========================

It is easy to leave unnecessary spaces at the end of a line, or empty
lines at the end of a file, without realizing it.  In most cases, this
"trailing whitespace" has no effect, but there are special
circumstances where it matters, and it can be a nuisance.

   You can make trailing whitespace at the end of a line visible by
setting the buffer-local variable `show-trailing-whitespace' to `t'.
Then Emacs displays trailing whitespace, using the face
`trailing-whitespace'.

   This feature does not apply when point is at the end of the line
containing the whitespace.  Strictly speaking, that is "trailing
whitespace" nonetheless, but displaying it specially in that case looks
ugly while you are typing in new text.  In this special case, the
location of point is enough to show you that the spaces are present.

   Type `M-x delete-trailing-whitespace' to delete all trailing
whitespace within the buffer.  If the region is active, it deletes all
trailing whitespace in the region instead.

   On graphical displays, Emacs can indicate unused lines at the end of
the window with a small image in the left fringe (*note Fringes::).
The image appears for screen lines that do not correspond to any buffer
text, so blank lines at the end of the buffer stand out because they
lack this image.  To enable this feature, set the buffer-local variable
`indicate-empty-lines' to a non-`nil' value.  You can enable or disable
this feature for all new buffers by setting the default value of this
variable, e.g. `(setq-default indicate-empty-lines t)'.

   Whitespace mode is a buffer-local minor mode that lets you
"visualize" many kinds of whitespace in the buffer, by either drawing
the whitespace characters with a special face or displaying them as
special glyphs.  To toggle this mode, type `M-x whitespace-mode'.  The
kinds of whitespace visualized are determined by the list variable
`whitespace-style'.  Here is a partial list of possible elements (see
the variable's documentation for the full list):

`face'
     Enable all visualizations which use special faces.  This element
     has a special meaning: if it is absent from the list, none of the
     other visualizations take effect except `space-mark', `tab-mark',
     and `newline-mark'.

`trailing'
     Highlight trailing whitespace.

`tabs'
     Highlight tab characters.

`spaces'
     Highlight space and non-breaking space characters.

`lines'
     Highlight lines longer than 80 lines.  To change the column limit,
     customize the variable `whitespace-line-column'.

`newline'
     Highlight newlines.

`empty'
     Highlight empty lines.

`space-mark'
     Draw space and non-breaking characters with a special glyph.

`tab-mark'
     Draw tab characters with a special glyph.

`newline-mark'
     Draw newline characters with a special glyph.


File: emacs,  Node: Selective Display,  Next: Optional Mode Line,  Prev: Useless Whitespace,  Up: Display

14.17 Selective Display
=======================

Emacs has the ability to hide lines indented more than a given number
of columns.  You can use this to get an overview of a part of a program.

   To hide lines in the current buffer, type `C-x $'
(`set-selective-display') with a numeric argument N.  Then lines with
at least N columns of indentation disappear from the screen.  The only
indication of their presence is that three dots (`...') appear at the
end of each visible line that is followed by one or more hidden ones.

   The commands `C-n' and `C-p' move across the hidden lines as if they
were not there.

   The hidden lines are still present in the buffer, and most editing
commands see them as usual, so you may find point in the middle of the
hidden text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the
visible line, before the newline that ends it, the cursor appears before
the three dots.

   To make all lines visible again, type `C-x $' with no argument.

   If you set the variable `selective-display-ellipses' to `nil', the
three dots do not appear at the end of a line that precedes hidden
lines.  Then there is no visible indication of the hidden lines.  This
variable becomes local automatically when set.

   See also *note Outline Mode:: for another way to hide part of the
text in a buffer.


File: emacs,  Node: Optional Mode Line,  Next: Text Display,  Prev: Selective Display,  Up: Display

14.18 Optional Mode Line Features
=================================

The buffer percentage POS indicates the percentage of the buffer above
the top of the window.  You can additionally display the size of the
buffer by typing `M-x size-indication-mode' to turn on Size Indication
mode.  The size will be displayed immediately following the buffer
percentage like this:

     POS of SIZE

Here SIZE is the human readable representation of the number of
characters in the buffer, which means that `k' for 10^3, `M' for 10^6,
`G' for 10^9, etc., are used to abbreviate.

   The current line number of point appears in the mode line when Line
Number mode is enabled.  Use the command `M-x line-number-mode' to turn
this mode on and off; normally it is on.  The line number appears after
the buffer percentage POS, with the letter `L' to indicate what it is.

   Similarly, you can display the current column number by turning on
Column number mode with `M-x column-number-mode'.  The column number is
indicated by the letter `C'.  However, when both of these modes are
enabled, the line and column numbers are displayed in parentheses, the
line number first, rather than with `L' and `C'.  For example:
`(561,2)'.  *Note Minor Modes::, for more information about minor modes
and about how to use these commands.

   If you have narrowed the buffer (*note Narrowing::), the displayed
line number is relative to the accessible portion of the buffer.  Thus,
it isn't suitable as an argument to `goto-line'.  (Use `what-line'
command to see the line number relative to the whole file.)

   If the buffer is very large (larger than the value of
`line-number-display-limit'), Emacs won't compute the line number,
because that would be too slow; therefore, the line number won't appear
on the mode-line.  To remove this limit, set
`line-number-display-limit' to `nil'.

   Line-number computation can also be slow if the lines in the buffer
are too long.  For this reason, Emacs doesn't display line numbers if
the average width, in characters, of lines near point is larger than
the value of `line-number-display-limit-width'.  The default value is
200 characters.

   Emacs can optionally display the time and system load in all mode
lines.  To enable this feature, type `M-x display-time' or customize
the option `display-time-mode'.  The information added to the mode line
looks like this:

     HH:MMpm L.LL

Here HH and MM are the hour and minute, followed always by `am' or
`pm'.  L.LL is the average number, collected for the last few minutes,
of processes in the whole system that were either running or ready to
run (i.e. were waiting for an available processor).  (Some fields may
be missing if your operating system cannot support them.)  If you
prefer time display in 24-hour format, set the variable
`display-time-24hr-format' to `t'.

   The word `Mail' appears after the load level if there is mail for
you that you have not read yet.  On graphical displays, you can use an
icon instead of `Mail' by customizing `display-time-use-mail-icon';
this may save some space on the mode line.  You can customize
`display-time-mail-face' to make the mail indicator prominent.  Use
`display-time-mail-file' to specify the mail file to check, or set
`display-time-mail-directory' to specify the directory to check for
incoming mail (any nonempty regular file in the directory is considered
as "newly arrived mail").

   When running Emacs on a laptop computer, you can display the battery
charge on the mode-line, by using the command `display-battery-mode' or
customizing the variable `display-battery-mode'.  The variable
`battery-mode-line-format' determines the way the battery charge is
displayed; the exact mode-line message depends on the operating system,
and it usually shows the current battery charge as a percentage of the
total charge.

   On graphical displays, the mode line is drawn as a 3D box.  If you
don't like this effect, you can disable it by customizing the
`mode-line' face and setting its `box' attribute to `nil'.  *Note Face
Customization::.

   By default, the mode line of nonselected windows is displayed in a
different face, called `mode-line-inactive'.  Only the selected window
is displayed in the `mode-line' face.  This helps show which window is
selected.  When the minibuffer is selected, since it has no mode line,
the window from which you activated the minibuffer has its mode line
displayed using `mode-line'; as a result, ordinary entry to the
minibuffer does not change any mode lines.

   You can disable use of `mode-line-inactive' by setting variable
`mode-line-in-non-selected-windows' to `nil'; then all mode lines are
displayed in the `mode-line' face.

   You can customize the mode line display for each of the end-of-line
formats by setting each of the variables `eol-mnemonic-unix',
`eol-mnemonic-dos', `eol-mnemonic-mac', and `eol-mnemonic-undecided' to
the strings you prefer.


File: emacs,  Node: Text Display,  Next: Cursor Display,  Prev: Optional Mode Line,  Up: Display

14.19 How Text Is Displayed
===========================

Most characters are "printing characters": when they appear in a
buffer, they are displayed literally on the screen.  Printing
characters include ASCII numbers, letters, and punctuation characters,
as well as many non-ASCII characters.

   The ASCII character set contains non-printing "control characters".
Two of these are displayed specially: the newline character (Unicode
code point `U+000A') is displayed by starting a new line, while the tab
character (`U+0009') is displayed as a space that extends to the next
tab stop column (normally every 8 columns).  The number of spaces per
tab is controlled by the buffer-local variable `tab-width', which must
have an integer value between 1 and 1000, inclusive.  Note that how the
tab character in the buffer is displayed has nothing to do with the
definition of <TAB> as a command.

   Other ASCII control characters, whose codes are below `U+0020'
(octal 40, decimal 32), are displayed as a caret (`^') followed by the
non-control version of the character, with the `escape-glyph' face.
For instance, the `control-A' character, `U+0001', is displayed as `^A'.

   The raw bytes with codes `U+0080' (octal 200) through `U+009F'
(octal 237) are displayed as "octal escape sequences", with the
`escape-glyph' face.  For instance, character code `U+0098' (octal 230)
is displayed as `\230'.  If you change the buffer-local variable
`ctl-arrow' to `nil', the ASCII control characters are also displayed
as octal escape sequences instead of caret escape sequences.

   Some non-ASCII characters have the same appearance as an ASCII space
or hyphen (minus) character.  Such characters can cause problems if
they are entered into a buffer without your realization, e.g. by
yanking; for instance, source code compilers typically do not treat
non-ASCII spaces as whitespace characters.  To deal with this problem,
Emacs displays such characters specially: it displays `U+00A0'
(no-break space) with the `nobreak-space' face, and it displays
`U+00AD' (soft hyphen), `U+2010' (hyphen), and `U+2011' (non-breaking
hyphen) with the `escape-glyph' face.  To disable this, change the
variable `nobreak-char-display' to `nil'.  If you give this variable a
non-`nil' and non-`t' value, Emacs instead displays such characters as
a highlighted backslash followed by a space or hyphen.

   You can customize the way any particular character code is displayed
by means of a display table.  *Note Display Tables: (elisp)Display
Tables.

   On graphical displays, some characters may have no glyphs in any of
the fonts available to Emacs.  These "glyphless characters" are
normally displayed as boxes containing the hexadecimal character code.
Similarly, on text terminals, characters that cannot be displayed using
the terminal encoding (*note Terminal Coding::) are normally displayed
as question signs.  You can control the display method by customizing
the variable `glyphless-char-display-control'.  *Note Glyphless
Character Display: (elisp)Glyphless Chars, for details.


File: emacs,  Node: Cursor Display,  Next: Line Truncation,  Prev: Text Display,  Up: Display

14.20 Displaying the Cursor
===========================

On a text terminal, the cursor's appearance is controlled by the
terminal, largely out of the control of Emacs.  Some terminals offer
two different cursors: a "visible" static cursor, and a "very visible"
blinking cursor.  By default, Emacs uses the very visible cursor, and
switches to it when you start or resume Emacs.  If the variable
`visible-cursor' is `nil' when Emacs starts or resumes, it uses the
normal cursor.

   On a graphical display, many more properties of the text cursor can
be altered.  To customize its color, change the `:background' attribute
of the face named `cursor' (*note Face Customization::).  (The other
attributes of this face have no effect; the text shown under the cursor
is drawn using the frame's background color.)  To change its shape,
customize the buffer-local variable `cursor-type'; possible values are
`box' (the default), `hollow' (a hollow box), `bar' (a vertical bar),
`(bar . N)' (a vertical bar N pixels wide), `hbar' (a horizontal bar),
`(hbar . N)' (a horizontal bar N pixels tall), or `nil' (no cursor at
all).

   To disable cursor blinking, change the variable `blink-cursor-mode'
to `nil' (*note Easy Customization::), or add the line
`(blink-cursor-mode 0)' to your init file.  Alternatively, you can
change how the cursor looks when it "blinks off" by customizing the
list variable `blink-cursor-alist'.  Each element in the list should
have the form `(ON-TYPE . OFF-TYPE)'; this means that if the cursor is
displayed as ON-TYPE when it blinks on (where ON-TYPE is one of the
cursor types described above), then it is displayed as OFF-TYPE when it
blinks off.

   Some characters, such as tab characters, are "extra wide".  When the
cursor is positioned over such a character, it is normally drawn with
the default character width.  You can make the cursor stretch to cover
wide characters, by changing the variable `x-stretch-cursor' to a
non-`nil' value.

   The cursor normally appears in non-selected windows as a
non-blinking hollow box.  (For a bar cursor, it instead appears as a
thinner bar.)  To turn off cursors in non-selected windows, change the
variable `cursor-in-non-selected-windows' to `nil'.

   To make the cursor even more visible, you can use HL Line mode, a
minor mode that highlights the line containing point.  Use `M-x
hl-line-mode' to enable or disable it in the current buffer.  `M-x
global-hl-line-mode' enables or disables the same mode globally.


File: emacs,  Node: Line Truncation,  Next: Visual Line Mode,  Prev: Cursor Display,  Up: Display

14.21 Line Truncation
=====================

As an alternative to continuation (*note Continuation Lines::), Emacs
can display long lines by "truncation".  This means that all the
characters that do not fit in the width of the screen or window do not
appear at all.  On graphical displays, a small straight arrow in the
fringe indicates truncation at either end of the line.  On text
terminals, this is indicated with `$' signs in the leftmost and/or
rightmost columns.

   Horizontal scrolling automatically causes line truncation (*note
Horizontal Scrolling::).  You can explicitly enable line truncation for
a particular buffer with the command `M-x toggle-truncate-lines'.  This
works by locally changing the variable `truncate-lines'.  If that
variable is non-`nil', long lines are truncated; if it is `nil', they
are continued onto multiple screen lines.  Setting the variable
`truncate-lines' in any way makes it local to the current buffer; until
that time, the default value, which is normally `nil', is in effect.

   If a split window becomes too narrow, Emacs may automatically enable
line truncation.  *Note Split Window::, for the variable
`truncate-partial-width-windows' which controls this.


File: emacs,  Node: Visual Line Mode,  Next: Display Custom,  Prev: Line Truncation,  Up: Display

14.22 Visual Line Mode
======================

Another alternative to ordinary line continuation is to use "word
wrap".  Here, each long logical line is divided into two or more screen
lines, like in ordinary line continuation.  However, Emacs attempts to
wrap the line at word boundaries near the right window edge.  This
makes the text easier to read, as wrapping does not occur in the middle
of words.

   Word wrap is enabled by Visual Line mode, an optional minor mode.
To turn on Visual Line mode in the current buffer, type `M-x
visual-line-mode'; repeating this command turns it off.  You can also
turn on Visual Line mode using the menu bar: in the Options menu,
select the `Line Wrapping in this Buffer' submenu, followed by the
`Word Wrap (Visual Line Mode)' menu item.  While Visual Line mode is
enabled, the mode-line shows the string `wrap' in the mode display.
The command `M-x global-visual-line-mode' toggles Visual Line mode in
all buffers.

   In Visual Line mode, some editing commands work on screen lines
instead of logical lines: `C-a' (`beginning-of-visual-line') moves to
the beginning of the screen line, `C-e' (`end-of-visual-line') moves to
the end of the screen line, and `C-k' (`kill-visual-line') kills text
to the end of the screen line.

   To move by logical lines, use the commands `M-x next-logical-line'
and `M-x previous-logical-line'.  These move point to the next logical
line and the previous logical line respectively, regardless of whether
Visual Line mode is enabled.  If you use these commands frequently, it
may be convenient to assign key bindings to them.  *Note Init
Rebinding::.

   By default, word-wrapped lines do not display fringe indicators.
Visual Line mode is often used to edit files that contain many long
logical lines, so having a fringe indicator for each wrapped line would
be visually distracting.  You can change this by customizing the
variable `visual-line-fringe-indicators'.


File: emacs,  Node: Display Custom,  Prev: Visual Line Mode,  Up: Display

14.23 Customization of Display
==============================

This section describes variables that control miscellaneous aspects of
the appearance of the Emacs screen.  Beginning users can skip it.

   If the variable `visible-bell' is non-`nil', Emacs attempts to make
the whole screen blink when it would normally make an audible bell
sound.  This variable has no effect if your terminal does not have a way
to make the screen blink.

   The variable `echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero, meaning don't echo at all.
The value takes effect when there is something to echo.  *Note Echo
Area::.

   On graphical displays, Emacs displays the mouse pointer as an
hourglass if Emacs is busy.  To disable this feature, set the variable
`display-hourglass' to `nil'.  The variable `hourglass-delay'
determines the number of seconds of "busy time" before the hourglass is
shown; the default is 1.

   If the mouse pointer lies inside an Emacs frame, Emacs makes it
invisible each time you type a character to insert text, to prevent it
from obscuring the text.  (To be precise, the hiding occurs when you
type a "self-inserting" character.  *Note Inserting Text::.)  Moving
the mouse pointer makes it visible again.  To disable this feature, set
the variable `make-pointer-invisible' to `nil'.

   On graphical displays, the variable `underline-minimum-offset'
determines the minimum distance between the baseline and underline, in
pixels, for underlined text.  By default, the value is 1; increasing it
may improve the legibility of underlined text for certain fonts.
(However, Emacs will never draw the underline below the current line
area.)  The variable `x-underline-at-descent-line' determines how to
draw underlined text.  The default is `nil', which means to draw it at
the baseline level of the font; if you change it to `nil', Emacs draws
the underline at the same height as the font's descent line.

   The variable `overline-margin' specifies the vertical position of an
overline above the text, including the height of the overline itself,
in pixels; the default is 2.

   On some text terminals, bold face and inverse video together result
in text that is hard to read.  Call the function
`tty-suppress-bold-inverse-default-colors' with a non-`nil' argument to
suppress the effect of bold-face in this case.


File: emacs,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

15 Searching and Replacement
****************************

Like other editors, Emacs has commands to search for occurrences of a
string.  Emacs also has commands to replace occurrences of a string
with a different string.  There are also commands that do the same
thing, but search for patterns instead of fixed strings.

   You can also search multiple files under the control of a tags table
(*note Tags Search::) or through the Dired `A' command (*note Operating
on Files::), or ask the `grep' program to do it (*note Grep
Searching::).

* Menu:

* Incremental Search::        Search happens as you type the string.
* Nonincremental Search::     Specify entire string and then search.
* Word Search::               Search for sequence of words.
* Regexp Search::             Search for match for a regexp.
* Regexps::                   Syntax of regular expressions.
* Regexp Backslash::          Regular expression constructs starting with `\'.
* Regexp Example::            A complex regular expression explained.
* Search Case::               To ignore case while searching, or not.
* Replace::                   Search, and replace some or all matches.
* Other Repeating Search::    Operating on all matches for some regexp.


File: emacs,  Node: Incremental Search,  Next: Nonincremental Search,  Up: Search

15.1 Incremental Search
=======================

The principal search command in Emacs is "incremental": it begins
searching as soon as you type the first character of the search string.
As you type in the search string, Emacs shows you where the string (as
you have typed it so far) would be found.  When you have typed enough
characters to identify the place you want, you can stop.  Depending on
what you plan to do next, you may or may not need to terminate the
search explicitly with <RET>.

`C-s'
     Incremental search forward (`isearch-forward').

`C-r'
     Incremental search backward (`isearch-backward').

* Menu:

* Basic Isearch::       Basic incremental search commands.
* Repeat Isearch::      Searching for the same string again.
* Error in Isearch::    When your string is not found.
* Special Isearch::     Special input in incremental search.
* Isearch Yank::        Commands that grab text into the search string
                          or else edit the search string.
* Isearch Scroll::      Scrolling during an incremental search.
* Isearch Minibuffer::  Incremental search of the minibuffer history.



Local Variables:
coding: iso-8859-1
End:
