This is ../../info/gnus, produced by makeinfo version 4.13 from
gnus.texi.

Copyright (C) 1995-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual", and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License".

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs network features
START-INFO-DIR-ENTRY
* Gnus: (gnus).                 The newsreader Gnus.
END-INFO-DIR-ENTRY


File: gnus,  Node: Agent Commands,  Next: Agent Visuals,  Prev: Agent Categories,  Up: Gnus Unplugged

6.9.3 Agent Commands
--------------------

All the Gnus Agent commands are on the `J' submap.  The `J j'
(`gnus-agent-toggle-plugged') command works in all modes, and toggles
the plugged/unplugged state of the Gnus Agent.

* Menu:

* Group Agent Commands::        Configure groups and fetch their contents.
* Summary Agent Commands::      Manually select then fetch specific articles.
* Server Agent Commands::       Select the servers that are supported by the agent.


File: gnus,  Node: Group Agent Commands,  Next: Summary Agent Commands,  Up: Agent Commands

6.9.3.1 Group Agent Commands
............................

`J u'
     Fetch all eligible articles in the current group
     (`gnus-agent-fetch-groups').

`J c'
     Enter the Agent category buffer (`gnus-enter-category-buffer').

`J s'
     Fetch all eligible articles in all groups
     (`gnus-agent-fetch-session').

`J S'
     Send all sendable messages in the queue group
     (`gnus-group-send-queue').  *Note Drafts::.

`J a'
     Add the current group to an Agent category
     (`gnus-agent-add-group').  This command understands the
     process/prefix convention (*note Process/Prefix::).

`J r'
     Remove the current group from its category, if any
     (`gnus-agent-remove-group').  This command understands the
     process/prefix convention (*note Process/Prefix::).

`J Y'
     Synchronize flags changed while unplugged with remote server, if
     any.



File: gnus,  Node: Summary Agent Commands,  Next: Server Agent Commands,  Prev: Group Agent Commands,  Up: Agent Commands

6.9.3.2 Summary Agent Commands
..............................

`J #'
     Mark the article for downloading (`gnus-agent-mark-article').

`J M-#'
     Remove the downloading mark from the article
     (`gnus-agent-unmark-article').

`@'
     Toggle whether to download the article (`gnus-agent-toggle-mark').
     The download mark is `%' by default.

`J c'
     Mark all articles as read (`gnus-agent-catchup') that are neither
     cached, downloaded, nor downloadable.

`J S'
     Download all eligible (*note Agent Categories::) articles in this
     group.  (`gnus-agent-fetch-group').

`J s'
     Download all processable articles in this group.
     (`gnus-agent-summary-fetch-series').

`J u'
     Download all downloadable articles in the current group
     (`gnus-agent-summary-fetch-group').



File: gnus,  Node: Server Agent Commands,  Prev: Summary Agent Commands,  Up: Agent Commands

6.9.3.3 Server Agent Commands
.............................

`J a'
     Add the current server to the list of servers covered by the Gnus
     Agent (`gnus-agent-add-server').

`J r'
     Remove the current server from the list of servers covered by the
     Gnus Agent (`gnus-agent-remove-server').



File: gnus,  Node: Agent Visuals,  Next: Agent as Cache,  Prev: Agent Commands,  Up: Gnus Unplugged

6.9.4 Agent Visuals
-------------------

If you open a summary while unplugged and, Gnus knows from the group's
active range that there are more articles than the headers currently
stored in the Agent, you may see some articles whose subject looks
something like `[Undownloaded article #####]'.  These are placeholders
for the missing headers.  Aside from setting a mark, there is not much
that can be done with one of these placeholders.  When Gnus finally
gets a chance to fetch the group's headers, the placeholders will
automatically be replaced by the actual headers.  You can configure the
summary buffer's maneuvering to skip over the placeholders if you care
(See `gnus-auto-goto-ignores').

   While it may be obvious to all, the only headers and articles
available while unplugged are those headers and articles that were
fetched into the Agent while previously plugged.  To put it another
way, "If you forget to fetch something while plugged, you might have a
less than satisfying unplugged session".  For this reason, the Agent
adds two visual effects to your summary buffer.  These effects display
the download status of each article so that you always know which
articles will be available when unplugged.

   The first visual effect is the `%O' spec.  If you customize
`gnus-summary-line-format' to include this specifier, you will add a
single character field that indicates an article's download status.
Articles that have been fetched into either the Agent or the Cache,
will display `gnus-downloaded-mark' (defaults to `+').  All other
articles will display `gnus-undownloaded-mark' (defaults to `-').  If
you open a group that has not been agentized, a space (` ') will be
displayed.

   The second visual effect are the undownloaded faces.  The faces,
there are three indicating the article's score (low, normal, high),
seem to result in a love/hate response from many Gnus users.  The
problem is that the face selection is controlled by a list of condition
tests and face names (See `gnus-summary-highlight').  Each condition is
tested in the order in which it appears in the list so early conditions
have precedence over later conditions.  All of this means that, if you
tick an undownloaded article, the article will continue to be displayed
in the undownloaded face rather than the ticked face.

   If you use the Agent as a cache (to avoid downloading the same
article each time you visit it or to minimize your connection time), the
undownloaded face will probably seem like a good idea.  The reason
being that you do all of our work (marking, reading, deleting) with
downloaded articles so the normal faces always appear.  For those users
using the agent to improve online performance by caching the NOV
database (most users since 5.10.2), the undownloaded faces may appear
to be an absolutely horrible idea.  The issue being that, since none of
their articles have been fetched into the Agent, all of the normal
faces will be obscured by the undownloaded faces.

   If you would like to use the undownloaded faces, you must enable the
undownloaded faces by setting the `agent-enable-undownloaded-faces'
group parameter to `t'.  This parameter, like all other agent
parameters, may be set on an Agent Category (*note Agent Categories::),
a Group Topic (*note Topic Parameters::), or an individual group (*note
Group Parameters::).

   The one problem common to all users using the agent is how quickly it
can consume disk space.  If you using the agent on many groups, it is
even more difficult to effectively recover disk space.  One solution is
the `%F' format available in `gnus-group-line-format'.  This format
will display the actual disk space used by articles fetched into both
the agent and cache.  By knowing which groups use the most space, users
know where to focus their efforts when "agent expiring" articles.


File: gnus,  Node: Agent as Cache,  Next: Agent Expiry,  Prev: Agent Visuals,  Up: Gnus Unplugged

6.9.5 Agent as Cache
--------------------

When Gnus is plugged, it is not efficient to download headers or
articles from the server again, if they are already stored in the
Agent.  So, Gnus normally only downloads headers once, and stores them
in the Agent.  These headers are later used when generating the summary
buffer, regardless of whether you are plugged or unplugged.  Articles
are not cached in the Agent by default though (that would potentially
consume lots of disk space), but if you have already downloaded an
article into the Agent, Gnus will not download the article from the
server again but use the locally stored copy instead.

   If you so desire, you can configure the agent (see `gnus-agent-cache'
*note Agent Variables::) to always download headers and articles while
plugged.  Gnus will almost certainly be slower, but it will be kept
synchronized with the server.  That last point probably won't make any
sense if you are using a nntp or nnimap back end.


File: gnus,  Node: Agent Expiry,  Next: Agent Regeneration,  Prev: Agent as Cache,  Up: Gnus Unplugged

6.9.6 Agent Expiry
------------------

The Agent back end, `nnagent', doesn't handle expiry.  Well, at least
it doesn't handle it like other back ends.  Instead, there are special
`gnus-agent-expire' and `gnus-agent-expire-group' commands that will
expire all read articles that are older than `gnus-agent-expire-days'
days.  They can be run whenever you feel that you're running out of
space.  Neither are particularly fast or efficient, and it's not a
particularly good idea to interrupt them (with `C-g' or anything else)
once you've started one of them.

   Note that other functions might run `gnus-agent-expire' for you to
keep the agent synchronized with the group.

   The agent parameter `agent-enable-expiration' may be used to prevent
expiration in selected groups.

   If `gnus-agent-expire-all' is non-`nil', the agent expiration
commands will expire all articles--unread, read, ticked and dormant.
If `nil' (which is the default), only read articles are eligible for
expiry, and unread, ticked and dormant articles will be kept
indefinitely.

   If you find that some articles eligible for expiry are never expired,
perhaps some Gnus Agent files are corrupted.  There's are special
commands, `gnus-agent-regenerate' and `gnus-agent-regenerate-group', to
fix possible problems.


File: gnus,  Node: Agent Regeneration,  Next: Agent and flags,  Prev: Agent Expiry,  Up: Gnus Unplugged

6.9.7 Agent Regeneration
------------------------

The local data structures used by `nnagent' may become corrupted due to
certain exceptional conditions.  When this happens, `nnagent'
functionality may degrade or even fail.  The solution to this problem
is to repair the local data structures by removing all internal
inconsistencies.

   For example, if your connection to your server is lost while
downloaded articles into the agent, the local data structures will not
know about articles successfully downloaded prior to the connection
failure.  Running `gnus-agent-regenerate' or
`gnus-agent-regenerate-group' will update the data structures such that
you don't need to download these articles a second time.

   The command `gnus-agent-regenerate' will perform
`gnus-agent-regenerate-group' on every agentized group.  While you can
run `gnus-agent-regenerate' in any buffer, it is strongly recommended
that you first close all summary buffers.

   The command `gnus-agent-regenerate-group' uses the local copies of
individual articles to repair the local NOV(header) database.  It then
updates the internal data structures that document which articles are
stored locally.  An optional argument will mark articles in the agent
as unread.


File: gnus,  Node: Agent and flags,  Next: Agent and IMAP,  Prev: Agent Regeneration,  Up: Gnus Unplugged

6.9.8 Agent and flags
---------------------

The Agent works with any Gnus back end including those, such as nnimap,
that store flags (read, ticked, etc) on the server.  Sadly, the Agent
does not actually know which backends keep their flags in the backend
server rather than in `.newsrc'.  This means that the Agent, while
unplugged or disconnected, will always record all changes to the flags
in its own files.

   When you plug back in, Gnus will then check to see if you have any
changed any flags and ask if you wish to synchronize these with the
server.  This behavior is customizable by
`gnus-agent-synchronize-flags'.

   If `gnus-agent-synchronize-flags' is `nil', the Agent will never
automatically synchronize flags.  If it is `ask', which is the default,
the Agent will check if you made any changes and if so ask if you wish
to synchronize these when you re-connect.  If it has any other value,
all flags will be synchronized automatically.

   If you do not wish to synchronize flags automatically when you
re-connect, you can do it manually with the
`gnus-agent-synchronize-flags' command that is bound to `J Y' in the
group buffer.

   Technical note: the synchronization algorithm does not work by
"pushing" all local flags to the server, but rather by incrementally
updated the server view of flags by changing only those flags that were
changed by the user.  Thus, if you set one flag on an article, quit the
group then re-select the group and remove the flag; the flag will be
set and removed from the server when you "synchronize".  The queued flag
operations can be found in the per-server `flags' file in the Agent
directory.  It's emptied when you synchronize flags.


File: gnus,  Node: Agent and IMAP,  Next: Outgoing Messages,  Prev: Agent and flags,  Up: Gnus Unplugged

6.9.9 Agent and IMAP
--------------------

The Agent works with any Gnus back end, including nnimap.  However,
since there are some conceptual differences between NNTP and IMAP, this
section (should) provide you with some information to make Gnus Agent
work smoother as a IMAP Disconnected Mode client.

   Some things are currently not implemented in the Agent that you'd
might expect from a disconnected IMAP client, including:

   * Copying/moving articles into nnimap groups when unplugged.

   * Creating/deleting nnimap groups when unplugged.



File: gnus,  Node: Outgoing Messages,  Next: Agent Variables,  Prev: Agent and IMAP,  Up: Gnus Unplugged

6.9.10 Outgoing Messages
------------------------

By default, when Gnus is unplugged, all outgoing messages (both mail
and news) are stored in the draft group "queue" (*note Drafts::).  You
can view them there after posting, and edit them at will.

   You can control the circumstances under which outgoing mail is queued
(see `gnus-agent-queue-mail', *note Agent Variables::).  Outgoing news
is always queued when Gnus is unplugged, and never otherwise.

   You can send the messages either from the draft group with the
special commands available there, or you can use the `J S' command in
the group buffer to send all the sendable messages in the draft group.
Posting news will only work when Gnus is plugged, but you can send mail
at any time.

   If sending mail while unplugged does not work for you and you worry
about hitting `J S' by accident when unplugged, you can have Gnus ask
you to confirm your action (see `gnus-agent-prompt-send-queue', *note
Agent Variables::).


File: gnus,  Node: Agent Variables,  Next: Example Setup,  Prev: Outgoing Messages,  Up: Gnus Unplugged

6.9.11 Agent Variables
----------------------

`gnus-agent'
     Is the agent enabled?  The default is `t'.  When first enabled,
     the agent will use `gnus-agent-auto-agentize-methods' to
     automatically mark some back ends as agentized.  You may change
     which back ends are agentized using the agent commands in the
     server buffer.

     To enter the server buffer, use the `^'
     (`gnus-group-enter-server-mode') command in the group buffer.

`gnus-agent-directory'
     Where the Gnus Agent will store its files.  The default is
     `~/News/agent/'.

`gnus-agent-handle-level'
     Groups on levels (*note Group Levels::) higher than this variable
     will be ignored by the Agent.  The default is
     `gnus-level-subscribed', which means that only subscribed group
     will be considered by the Agent by default.

`gnus-agent-plugged-hook'
     Hook run when connecting to the network.

`gnus-agent-unplugged-hook'
     Hook run when disconnecting from the network.

`gnus-agent-fetched-hook'
     Hook run when finished fetching articles.

`gnus-agent-cache'
     Variable to control whether use the locally stored NOV and
     articles when plugged, e.g. essentially using the Agent as a cache.
     The default is non-`nil', which means to use the Agent as a cache.

`gnus-agent-go-online'
     If `gnus-agent-go-online' is `nil', the Agent will never
     automatically switch offline servers into online status.  If it is
     `ask', the default, the Agent will ask if you wish to switch
     offline servers into online status when you re-connect.  If it has
     any other value, all offline servers will be automatically
     switched into online status.

`gnus-agent-mark-unread-after-downloaded'
     If `gnus-agent-mark-unread-after-downloaded' is non-`nil', mark
     articles as unread after downloading.  This is usually a safe
     thing to do as the newly downloaded article has obviously not been
     read.  The default is `t'.

`gnus-agent-synchronize-flags'
     If `gnus-agent-synchronize-flags' is `nil', the Agent will never
     automatically synchronize flags.  If it is `ask', which is the
     default, the Agent will check if you made any changes and if so
     ask if you wish to synchronize these when you re-connect.  If it
     has any other value, all flags will be synchronized automatically.

`gnus-agent-consider-all-articles'
     If `gnus-agent-consider-all-articles' is non-`nil', the agent will
     let the agent predicate decide whether articles need to be
     downloaded or not, for all articles.  When `nil', the default, the
     agent will only let the predicate decide whether unread articles
     are downloaded or not.  If you enable this, you may also want to
     look into the agent expiry settings (*note Category Variables::),
     so that the agent doesn't download articles which the agent will
     later expire, over and over again.

`gnus-agent-max-fetch-size'
     The agent fetches articles into a temporary buffer prior to parsing
     them into individual files.  To avoid exceeding the max. buffer
     size, the agent alternates between fetching and parsing until all
     articles have been fetched.  `gnus-agent-max-fetch-size' provides
     a size limit to control how often the cycling occurs.  A large
     value improves performance.  A small value minimizes the time lost
     should the connection be lost while fetching (You may need to run
     `gnus-agent-regenerate-group' to update the group's state.
     However, all articles parsed prior to losing the connection will be
     available while unplugged).  The default is 10M so it is unusual to
     see any cycling.

`gnus-server-unopen-status'
     Perhaps not an Agent variable, but closely related to the Agent,
     this variable says what will happen if Gnus cannot open a server.
     If the Agent is enabled, the default, `nil', makes Gnus ask the
     user whether to deny the server or whether to unplug the agent.
     If the Agent is disabled, Gnus always simply deny the server.
     Other choices for this variable include `denied' and `offline' the
     latter is only valid if the Agent is used.

`gnus-auto-goto-ignores'
     Another variable that isn't an Agent variable, yet so closely
     related that most will look for it here, this variable tells the
     summary buffer how to maneuver around undownloaded (only headers
     stored in the agent) and unfetched (neither article nor headers
     stored) articles.

     The valid values are `nil' (maneuver to any article),
     `undownloaded' (maneuvering while unplugged ignores articles that
     have not been fetched), `always-undownloaded' (maneuvering always
     ignores articles that have not been fetched), `unfetched'
     (maneuvering ignores articles whose headers have not been fetched).

`gnus-agent-queue-mail'
     When `gnus-agent-queue-mail' is `always', Gnus will always queue
     mail rather than sending it straight away.  When `t', Gnus will
     queue mail when unplugged only.  When `nil', never queue mail.
     The default is `t'.

`gnus-agent-prompt-send-queue'
     When `gnus-agent-prompt-send-queue' is non-`nil' Gnus will prompt
     you to confirm that you really wish to proceed if you hit `J S'
     while unplugged.  The default is `nil'.

`gnus-agent-auto-agentize-methods'
     If you have never used the Agent before (or more technically, if
     `~/News/agent/lib/servers' does not exist), Gnus will
     automatically agentize a few servers for you.  This variable
     control which back ends should be auto-agentized.  It is typically
     only useful to agentize remote back ends.  The auto-agentizing has
     the same effect as running `J a' on the servers (*note Server
     Agent Commands::).  If the file exist, you must manage the servers
     manually by adding or removing them, this variable is only
     applicable the first time you start Gnus.  The default is `nil'.



File: gnus,  Node: Example Setup,  Next: Batching Agents,  Prev: Agent Variables,  Up: Gnus Unplugged

6.9.12 Example Setup
--------------------

If you don't want to read this manual, and you have a fairly standard
setup, you may be able to use something like the following as your
`~/.gnus.el' file to get started.

     ;; Define how Gnus is to fetch news.  We do this over NNTP
     ;; from your ISP's server.
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;; Define how Gnus is to read your mail.  We read mail from
     ;; your ISP's POP server.
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;; Say how Gnus is to store the mail.  We use nnml groups.
     (setq gnus-secondary-select-methods '((nnml "")))

     ;; Make Gnus into an offline newsreader.
     ;; (gnus-agentize) ; The obsolete setting.
     ;; (setq gnus-agent t) ; Now the default.

   That should be it, basically.  Put that in your `~/.gnus.el' file,
edit to suit your needs, start up PPP (or whatever), and type `M-x
gnus'.

   If this is the first time you've run Gnus, you will be subscribed
automatically to a few default newsgroups.  You'll probably want to
subscribe to more groups, and to do that, you have to query the NNTP
server for a complete list of groups with the `A A' command.  This
usually takes quite a while, but you only have to do it once.

   After reading and parsing a while, you'll be presented with a list of
groups.  Subscribe to the ones you want to read with the `u' command.
`l' to make all the killed groups disappear after you've subscribe to
all the groups you want to read.  (`A k' will bring back all the killed
groups.)

   You can now read the groups at once, or you can download the articles
with the `J s' command.  And then read the rest of this manual to find
out which of the other gazillion things you want to customize.


File: gnus,  Node: Batching Agents,  Next: Agent Caveats,  Prev: Example Setup,  Up: Gnus Unplugged

6.9.13 Batching Agents
----------------------

Having the Gnus Agent fetch articles (and post whatever messages you've
written) is quite easy once you've gotten things set up properly.  The
following shell script will do everything that is necessary:

   You can run a complete batch command from the command line with the
following incantation:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-agent-batch >/dev/null 2>&1


File: gnus,  Node: Agent Caveats,  Prev: Batching Agents,  Up: Gnus Unplugged

6.9.14 Agent Caveats
--------------------

The Gnus Agent doesn't seem to work like most other offline
newsreaders.  Here are some common questions that some imaginary people
may ask:

"If I read an article while plugged, do they get entered into the Agent?"
     *No*.  If you want this behavior, add
     `gnus-agent-fetch-selected-article' to `gnus-select-article-hook'.

"If I read an article while plugged, and the article already exists in"
     the Agent, will it get downloaded once more?

     *No*, unless `gnus-agent-cache' is `nil'.


   In short, when Gnus is unplugged, it only looks into the locally
stored articles; when it's plugged, it talks to your ISP and may also
use the locally stored articles.


File: gnus,  Node: Scoring,  Next: Searching,  Prev: Select Methods,  Up: Top

7 Scoring
*********

Other people use "kill files", but we here at Gnus Towers like scoring
better than killing, so we'd rather switch than fight.  They do
something completely different as well, so sit up straight and pay
attention!

   All articles have a default score (`gnus-summary-default-score'),
which is 0 by default.  This score may be raised or lowered either
interactively or by score files.  Articles that have a score lower than
`gnus-summary-mark-below' are marked as read.

   Gnus will read any "score files" that apply to the current group
before generating the summary buffer.

   There are several commands in the summary buffer that insert score
entries based on the current article.  You can, for instance, ask Gnus
to lower or increase the score of all articles with a certain subject.

   There are two sorts of scoring entries: Permanent and temporary.
Temporary score entries are self-expiring entries.  Any entries that are
temporary and have not been used for, say, a week, will be removed
silently to help keep the sizes of the score files down.

* Menu:

* Summary Score Commands::      Adding score entries for the current group.
* Group Score Commands::        General score commands.
* Score Variables::             Customize your scoring.  (My, what terminology).
* Score File Format::           What a score file may contain.
* Score File Editing::          You can edit score files by hand as well.
* Adaptive Scoring::            Big Sister Gnus knows what you read.
* Home Score File::             How to say where new score entries are to go.
* Followups To Yourself::       Having Gnus notice when people answer you.
* Scoring On Other Headers::    Scoring on non-standard headers.
* Scoring Tips::                How to score effectively.
* Reverse Scoring::             That problem child of old is not problem.
* Global Score Files::          Earth-spanning, ear-splitting score files.
* Kill Files::                  They are still here, but they can be ignored.
* Converting Kill Files::       Translating kill files to score files.
* Advanced Scoring::            Using logical expressions to build score rules.
* Score Decays::                It can be useful to let scores wither away.


File: gnus,  Node: Summary Score Commands,  Next: Group Score Commands,  Up: Scoring

7.1 Summary Score Commands
==========================

The score commands that alter score entries do not actually modify real
score files.  That would be too inefficient.  Gnus maintains a cache of
previously loaded score files, one of which is considered the "current
score file alist".  The score commands simply insert entries into this
list, and upon group exit, this list is saved.

   The current score file is by default the group's local score file,
even if no such score file actually exists.  To insert score commands
into some other score file (e.g. `all.SCORE'), you must first make this
score file the current one.

   General score commands that don't actually change the score file:

`V s'
     Set the score of the current article (`gnus-summary-set-score').

`V S'
     Display the score of the current article
     (`gnus-summary-current-score').

`V t'
     Display all score rules that have been used on the current article
     (`gnus-score-find-trace').  In the `*Score Trace*' buffer, you may
     type `e' to edit score file corresponding to the score rule on
     current line and `f' to format (`gnus-score-pretty-print') the
     score file and edit it.

`V w'
     List words used in scoring (`gnus-score-find-favourite-words').

`V R'
     Run the current summary through the scoring process
     (`gnus-summary-rescore').  This might be useful if you're playing
     around with your score files behind Gnus' back and want to see the
     effect you're having.

`V c'
     Make a different score file the current
     (`gnus-score-change-score-file').

`V e'
     Edit the current score file (`gnus-score-edit-current-scores').
     You will be popped into a `gnus-score-mode' buffer (*note Score
     File Editing::).

`V f'
     Edit a score file and make this score file the current one
     (`gnus-score-edit-file').

`V F'
     Flush the score cache (`gnus-score-flush-cache').  This is useful
     after editing score files.

`V C'
     Customize a score file in a visually pleasing manner
     (`gnus-score-customize').


   The rest of these commands modify the local score file.

`V m'
     Prompt for a score, and mark all articles with a score below this
     as read (`gnus-score-set-mark-below').

`V x'
     Prompt for a score, and add a score rule to the current score file
     to expunge all articles below this score
     (`gnus-score-set-expunge-below').

   The keystrokes for actually making score entries follow a very
regular pattern, so there's no need to list all the commands.
(Hundreds of them.)

  1. The first key is either `I' (upper case i) for increasing the score
     or `L' for lowering the score.

  2. The second key says what header you want to score on.  The
     following keys are available:
    `a'
          Score on the author name.

    `s'
          Score on the subject line.

    `x'
          Score on the `Xref' line--i.e., the cross-posting line.

    `r'
          Score on the `References' line.

    `d'
          Score on the date.

    `l'
          Score on the number of lines.

    `i'
          Score on the `Message-ID' header.

    `e'
          Score on an "extra" header, that is, one of those in
          gnus-extra-headers, if your NNTP server tracks additional
          header data in overviews.

    `f'
          Score on followups--this matches the author name, and adds
          scores to the followups to this author.  (Using this key
          leads to the creation of `ADAPT' files.)

    `b'
          Score on the body.

    `h'
          Score on the head.

    `t'
          Score on thread.  (Using this key leads to the creation of
          `ADAPT' files.)


  3. The third key is the match type.  Which match types are valid
     depends on what headers you are scoring on.

    `strings'

         `e'
               Exact matching.

         `s'
               Substring matching.

         `f'
               Fuzzy matching (*note Fuzzy Matching::).

         `r'
               Regexp matching

    `date'

         `b'
               Before date.

         `a'
               After date.

         `n'
               This date.

    `number'

         `<'
               Less than number.

         `='
               Equal to number.

         `>'
               Greater than number.

  4. The fourth and usually final key says whether this is a temporary
     (i.e., expiring) score entry, or a permanent (i.e., non-expiring)
     score entry, or whether it is to be done immediately, without
     adding to the score file.
    `t'
          Temporary score entry.

    `p'
          Permanent score entry.

    `i'
          Immediately scoring.

  5. If you are scoring on `e' (extra) headers, you will then be
     prompted for the header name on which you wish to score.  This
     must be a header named in gnus-extra-headers, and `TAB' completion
     is available.


   So, let's say you want to increase the score on the current author
with exact matching permanently: `I a e p'.  If you want to lower the
score based on the subject line, using substring matching, and make a
temporary score entry: `L s s t'.  Pretty easy.

   To make things a bit more complicated, there are shortcuts.  If you
use a capital letter on either the second or third keys, Gnus will use
defaults for the remaining one or two keystrokes.  The defaults are
"substring" and "temporary".  So `I A' is the same as `I a s t', and `I
a R' is the same as `I a r t'.

   These functions take both the numerical prefix and the symbolic
prefix (*note Symbolic Prefixes::).  A numerical prefix says how much
to lower (or increase) the score of the article.  A symbolic prefix of
`a' says to use the `all.SCORE' file for the command instead of the
current score file.

   The `gnus-score-mimic-keymap' says whether these commands will
pretend they are keymaps or not.


File: gnus,  Node: Group Score Commands,  Next: Score Variables,  Prev: Summary Score Commands,  Up: Scoring

7.2 Group Score Commands
========================

There aren't many of these as yet, I'm afraid.

`W e'
     Edit the apply-to-all-groups all.SCORE file.  You will be popped
     into a `gnus-score-mode' buffer (*note Score File Editing::).

`W f'
     Gnus maintains a cache of score alists to avoid having to reload
     them all the time.  This command will flush the cache
     (`gnus-score-flush-cache').


   You can do scoring from the command line by saying something like:

     $ emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score


File: gnus,  Node: Score Variables,  Next: Score File Format,  Prev: Group Score Commands,  Up: Scoring

7.3 Score Variables
===================

`gnus-use-scoring'
     If `nil', Gnus will not check for score files, and will not, in
     general, do any score-related work.  This is `t' by default.

`gnus-kill-killed'
     If this variable is `nil', Gnus will never apply score files to
     articles that have already been through the kill process.  While
     this may save you lots of time, it also means that if you apply a
     kill file to a group, and then change the kill file and want to
     run it over you group again to kill more articles, it won't work.
     You have to set this variable to `t' to do that.  (It is `t' by
     default.)

`gnus-kill-files-directory'
     All kill and score files will be stored in this directory, which is
     initialized from the `SAVEDIR' environment variable by default.
     This is `~/News/' by default.

`gnus-score-file-suffix'
     Suffix to add to the group name to arrive at the score file name
     (`SCORE' by default.)

`gnus-score-uncacheable-files'
     All score files are normally cached to avoid excessive re-loading
     of score files.  However, this might make your Emacs grow big and
     bloated, so this regexp can be used to weed out score files
     unlikely to be needed again.  It would be a bad idea to deny
     caching of `all.SCORE', while it might be a good idea to not cache
     `comp.infosystems.www.authoring.misc.ADAPT'.  In fact, this
     variable is `ADAPT$' by default, so no adaptive score files will
     be cached.

`gnus-save-score'
     If you have really complicated score files, and do lots of batch
     scoring, then you might set this variable to `t'.  This will make
     Gnus save the scores into the `.newsrc.eld' file.

     If you do not set this to `t', then manual scores (like those set
     with `V s' (`gnus-summary-set-score')) will not be preserved
     across group visits.

`gnus-score-interactive-default-score'
     Score used by all the interactive raise/lower commands to
     raise/lower score with.  Default is 1000, which may seem
     excessive, but this is to ensure that the adaptive scoring scheme
     gets enough room to play with.  We don't want the small changes
     from the adaptive scoring to overwrite manually entered data.

`gnus-summary-default-score'
     Default score of an article, which is 0 by default.

`gnus-summary-expunge-below'
     Don't display the summary lines of articles that have scores lower
     than this variable.  This is `nil' by default, which means that no
     articles will be hidden.  This variable is local to the summary
     buffers, and has to be set from `gnus-summary-mode-hook'.

`gnus-score-over-mark'
     Mark (in the third column) used for articles with a score over the
     default.  Default is `+'.

`gnus-score-below-mark'
     Mark (in the third column) used for articles with a score below the
     default.  Default is `-'.

`gnus-score-find-score-files-function'
     Function used to find score files for the current group.  This
     function is called with the name of the group as the argument.

     Predefined functions available are:
    `gnus-score-find-single'
          Only apply the group's own score file.

    `gnus-score-find-bnews'
          Apply all score files that match, using bnews syntax.  This
          is the default.  If the current group is `gnu.emacs.gnus',
          for instance, `all.emacs.all.SCORE', `not.alt.all.SCORE' and
          `gnu.all.SCORE' would all apply.  In short, the instances of
          `all' in the score file names are translated into `.*', and
          then a regexp match is done.

          This means that if you have some score entries that you want
          to apply to all groups, then you put those entries in the
          `all.SCORE' file.

          The score files are applied in a semi-random order, although
          Gnus will try to apply the more general score files before
          the more specific score files.  It does this by looking at
          the number of elements in the score file names--discarding
          the `all' elements.

    `gnus-score-find-hierarchical'
          Apply all score files from all the parent groups.  This means
          that you can't have score files like `all.SCORE', but you can
          have `SCORE', `comp.SCORE' and `comp.emacs.SCORE' for each
          server.

     This variable can also be a list of functions.  In that case, all
     these functions will be called with the group name as argument, and
     all the returned lists of score files will be applied.  These
     functions can also return lists of lists of score alists directly.
     In that case, the functions that return these non-file score alists
     should probably be placed before the "real" score file functions,
     to ensure that the last score file returned is the local score
     file.  Phu.

     For example, to do hierarchical scoring but use a
     non-server-specific overall score file, you could use the value
          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     This variable says how many days should pass before an unused
     score file entry is expired.  If this variable is `nil', no score
     file entries are expired.  It's 7 by default.

`gnus-update-score-entry-dates'
     If this variable is non-`nil', temporary score entries that have
     been triggered (matched) will have their dates updated.  (This is
     how Gnus controls expiry--all non-matched-entries will become too
     old while matched entries will stay fresh and young.)  However, if
     you set this variable to `nil', even matched entries will grow old
     and will have to face that oh-so grim reaper.

`gnus-score-after-write-file-function'
     Function called with the name of the score file just written.

`gnus-score-thread-simplify'
     If this variable is non-`nil', article subjects will be simplified
     for subject scoring purposes in the same manner as with
     threading--according to the current value of
     `gnus-simplify-subject-functions'.  If the scoring entry uses
     `substring' or `exact' matching, the match will also be simplified
     in this manner.



File: gnus,  Node: Score File Format,  Next: Score File Editing,  Prev: Score Variables,  Up: Scoring

7.4 Score File Format
=====================

A score file is an `emacs-lisp' file that normally contains just a
single form.  Casual users are not expected to edit these files;
everything can be changed from the summary buffer.

   Anyway, if you'd like to dig into it yourself, here's an example:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

   This example demonstrates most score file elements.  *Note Advanced
Scoring::, for a different approach.

   Even though this looks much like Lisp code, nothing here is actually
`eval'ed.  The Lisp reader is used to read this form, though, so it has
to be valid syntactically, if not semantically.

   Six keys are supported by this alist:

`STRING'
     If the key is a string, it is the name of the header to perform the
     match on.  Scoring can only be performed on these eight headers:
     `From', `Subject', `References', `Message-ID', `Xref', `Lines',
     `Chars' and `Date'.  In addition to these headers, there are three
     strings to tell Gnus to fetch the entire article and do the match
     on larger parts of the article: `Body' will perform the match on
     the body of the article, `Head' will perform the match on the head
     of the article, and `All' will perform the match on the entire
     article.  Note that using any of these last three keys will slow
     down group entry _considerably_.  The final "header" you can score
     on is `Followup'.  These score entries will result in new score
     entries being added for all follow-ups to articles that matches
     these score entries.

     Following this key is an arbitrary number of score entries, where
     each score entry has one to four elements.
       1. The first element is the "match element".  On most headers
          this will be a string, but on the Lines and Chars headers,
          this must be an integer.

       2. If the second element is present, it should be a number--the
          "score element".  This number should be an integer in the
          neginf to posinf interval.  This number is added to the score
          of the article if the match is successful.  If this element
          is not present, the `gnus-score-interactive-default-score'
          number will be used instead.  This is 1000 by default.

       3. If the third element is present, it should be a number--the
          "date element".  This date says when the last time this score
          entry matched, which provides a mechanism for expiring the
          score entries.  It this element is not present, the score
          entry is permanent.  The date is represented by the number of
          days since December 31, 1 BCE.

       4. If the fourth element is present, it should be a symbol--the
          "type element".  This element specifies what function should
          be used to see whether this score entry matches the article.
          What match types that can be used depends on what header you
          wish to perform the match on.
         "From, Subject, References, Xref, Message-ID"
               For most header types, there are the `r' and `R'
               (regexp), as well as `s' and `S' (substring) types, and
               `e' and `E' (exact match), and `w' (word match) types.
               If this element is not present, Gnus will assume that
               substring matching should be used.  `R', `S', and `E'
               differ from the others in that the matches will be done
               in a case-sensitive manner.  All these one-letter types
               are really just abbreviations for the `regexp',
               `string', `exact', and `word' types, which you can use
               instead, if you feel like.

         "Extra"
               Just as for the standard string overview headers, if you
               are using gnus-extra-headers, you can score on these
               headers' values.  In this case, there is a 5th element
               in the score entry, being the name of the header to be
               scored.  The following entry is useful in your
               `all.SCORE' file in case of spam attacks from a single
               origin host, if your NNTP server tracks
               `NNTP-Posting-Host' in overviews:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

         "Lines, Chars"
               These two headers use different match types: `<', `>',
               `=', `>=' and `<='.

               These predicates are true if

                    (PREDICATE HEADER MATCH)

               evaluates to non-`nil'.  For instance, the advanced match
               `("lines" 4 <)' (*note Advanced Scoring::) will result
               in the following form:

                    (< header-value 4)

               Or to put it another way: When using `<' on `Lines' with
               4 as the match, we get the score added if the article
               has less than 4 lines.  (It's easy to get confused and
               think it's the other way around.  But it's not.  I
               think.)

               When matching on `Lines', be careful because some back
               ends (like `nndir') do not generate `Lines' header, so
               every article ends up being marked as having 0 lines.
               This can lead to strange results if you happen to lower
               score of the articles with few lines.

         "Date"
               For the Date header we have three kinda silly match
               types: `before', `at' and `after'.  I can't really
               imagine this ever being useful, but, like, it would feel
               kinda silly not to provide this function.  Just in case.
               You never know.  Better safe than sorry.  Once burnt,
               twice shy.  Don't judge a book by its cover.  Never not
               have sex on a first date.  (I have been told that at
               least one person, and I quote, "found this function
               indispensable", however.)

               A more useful match type is `regexp'.  With it, you can
               match the date string using a regular expression.  The
               date is normalized to ISO8601 compact format
               first--YYYYMMDD`T'HHMMSS.  If you want to match all
               articles that have been posted on April 1st in every
               year, you could use `....0401.........' as a match
               string, for instance.  (Note that the date is kept in
               its original time zone, so this will match articles that
               were posted when it was April 1st where the article was
               posted from.  Time zones are such wholesome fun for the
               whole family, eh?)

         "Head, Body, All"
               These three match keys use the same match types as the
               `From' (etc) header uses.

         "Followup"
               This match key is somewhat special, in that it will
               match the `From' header, and affect the score of not
               only the matching articles, but also all followups to
               the matching articles.  This allows you e.g. increase
               the score of followups to your own articles, or decrease
               the score of followups to the articles of some known
               trouble-maker.  Uses the same match types as the `From'
               header uses.  (Using this match key will lead to
               creation of `ADAPT' files.)

         "Thread"
               This match key works along the same lines as the
               `Followup' match key.  If you say that you want to score
               on a (sub-)thread started by an article with a
               `Message-ID' X, then you add a `thread' match.  This
               will add a new `thread' match for each article that has
               X in its `References' header.  (These new `thread'
               matches will use the `Message-ID's of these matching
               articles.)  This will ensure that you can raise/lower
               the score of an entire thread, even though some articles
               in the thread may not have complete `References'
               headers.  Note that using this may lead to
               nondeterministic scores of the articles in the thread.
               (Using this match key will lead to creation of `ADAPT'
               files.)

`mark'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read.

`expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be removed from the summary
     buffer.

`mark-and-expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read and removed
     from the summary buffer.

`thread-mark-and-expunge'
     The value of this entry should be a number.  All articles that
     belong to a thread that has a total score below this number will
     be marked as read and removed from the summary buffer.
     `gnus-thread-score-function' says how to compute the total score
     for a thread.

`files'
     The value of this entry should be any number of file names.  These
     files are assumed to be score files as well, and will be loaded
     the same way this one was.

`exclude-files'
     The clue of this entry should be any number of files.  These files
     will not be loaded, even though they would normally be so, for
     some reason or other.

`eval'
     The value of this entry will be `eval'ed.  This element will be
     ignored when handling global score files.

`read-only'
     Read-only score files will not be updated or saved.  Global score
     files should feature this atom (*note Global Score Files::).
     (Note: "Global" here really means "global"; not your personal
     apply-to-all-groups score files.)

`orphan'
     The value of this entry should be a number.  Articles that do not
     have parents will get this number added to their scores.  Imagine
     you follow some high-volume newsgroup, like `comp.lang.c'.  Most
     likely you will only follow a few of the threads, also want to see
     any new threads.

     You can do this with the following two score file entries:

                  (orphan -500)
                  (mark-and-expunge -100)

     When you enter the group the first time, you will only see the new
     threads.  You then raise the score of the threads that you find
     interesting (with `I T' or `I S'), and ignore (`c y') the rest.
     Next time you enter the group, you will see new articles in the
     interesting threads, plus any new threads.

     I.e.--the orphan score atom is for high-volume groups where a few
     interesting threads which can't be found automatically by ordinary
     scoring rules exist.

`adapt'
     This entry controls the adaptive scoring.  If it is `t', the
     default adaptive scoring rules will be used.  If it is `ignore', no
     adaptive scoring will be performed on this group.  If it is a
     list, this list will be used as the adaptive scoring rules.  If it
     isn't present, or is something other than `t' or `ignore', the
     default adaptive scoring rules will be used.  If you want to use
     adaptive scoring on most groups, you'd set
     `gnus-use-adaptive-scoring' to `t', and insert an `(adapt ignore)'
     in the groups where you do not want adaptive scoring.  If you only
     want adaptive scoring in a few groups, you'd set
     `gnus-use-adaptive-scoring' to `nil', and insert `(adapt t)' in
     the score files of the groups where you want it.

`adapt-file'
     All adaptive score entries will go to the file named by this
     entry.  It will also be applied when entering the group.  This
     atom might be handy if you want to adapt on several groups at
     once, using the same adaptive file for a number of groups.

`local'
     The value of this entry should be a list of `(VAR VALUE)' pairs.
     Each VAR will be made buffer-local to the current summary buffer,
     and set to the value specified.  This is a convenient, if somewhat
     strange, way of setting variables in some groups if you don't like
     hooks much.  Note that the VALUE won't be evaluated.


File: gnus,  Node: Score File Editing,  Next: Adaptive Scoring,  Prev: Score File Format,  Up: Scoring

7.5 Score File Editing
======================

You normally enter all scoring commands from the summary buffer, but you
might feel the urge to edit them by hand as well, so we've supplied you
with a mode for that.

   It's simply a slightly customized `emacs-lisp' mode, with these
additional commands:

`C-c C-c'
     Save the changes you have made and return to the summary buffer
     (`gnus-score-edit-exit').

`C-c C-d'
     Insert the current date in numerical format
     (`gnus-score-edit-insert-date').  This is really the day number, if
     you were wondering.

`C-c C-p'
     The adaptive score files are saved in an unformatted fashion.  If
     you intend to read one of these files, you want to "pretty print"
     it first.  This command (`gnus-score-pretty-print') does that for
     you.


   Type `M-x gnus-score-mode' to use this mode.

   `gnus-score-menu-hook' is run in score mode buffers.

   In the summary buffer you can use commands like `V f', `V e' and `V
t' to begin editing score files.


File: gnus,  Node: Adaptive Scoring,  Next: Home Score File,  Prev: Score File Editing,  Up: Scoring

7.6 Adaptive Scoring
====================

If all this scoring is getting you down, Gnus has a way of making it all
happen automatically--as if by magic.  Or rather, as if by artificial
stupidity, to be precise.

   When you read an article, or mark an article as read, or kill an
article, you leave marks behind.  On exit from the group, Gnus can sniff
these marks and add score elements depending on what marks it finds.
You turn on this ability by setting `gnus-use-adaptive-scoring' to `t'
or `(line)'.  If you want score adaptively on separate words appearing
in the subjects, you should set this variable to `(word)'.  If you want
to use both adaptive methods, set this variable to `(word line)'.

   To give you complete control over the scoring process, you can
customize the `gnus-default-adaptive-score-alist' variable.  For
instance, it might look something like this:

     (setq gnus-default-adaptive-score-alist
       '((gnus-unread-mark)
         (gnus-ticked-mark (from 4))
         (gnus-dormant-mark (from 5))
         (gnus-del-mark (from -4) (subject -1))
         (gnus-read-mark (from 4) (subject 2))
         (gnus-expirable-mark (from -1) (subject -1))
         (gnus-killed-mark (from -1) (subject -3))
         (gnus-kill-file-mark)
         (gnus-ancient-mark)
         (gnus-low-score-mark)
         (gnus-catchup-mark (from -1) (subject -1))))

   As you see, each element in this alist has a mark as a key (either a
variable name or a "real" mark--a character).  Following this key is a
arbitrary number of header/score pairs.  If there are no header/score
pairs following the key, no adaptive scoring will be done on articles
that have that key as the article mark.  For instance, articles with
`gnus-unread-mark' in the example above will not get adaptive score
entries.

   Each article can have only one mark, so just a single of these rules
will be applied to each article.

   To take `gnus-del-mark' as an example--this alist says that all
articles that have that mark (i.e., are marked with `e') will have a
score entry added to lower based on the `From' header by -4, and
lowered by `Subject' by -1.  Change this to fit your prejudices.

   If you have marked 10 articles with the same subject with
`gnus-del-mark', the rule for that mark will be applied ten times.
That means that that subject will get a score of ten times -1, which
should be, unless I'm much mistaken, -10.

   If you have auto-expirable (mail) groups (*note Expiring Mail::), all
the read articles will be marked with the `E' mark.  This'll probably
make adaptive scoring slightly impossible, so auto-expiring and
adaptive scoring doesn't really mix very well.

   The headers you can score on are `from', `subject', `message-id',
`references', `xref', `lines', `chars' and `date'.  In addition, you
can score on `followup', which will create an adaptive score entry that
matches on the `References' header using the `Message-ID' of the
current article, thereby matching the following thread.

   If you use this scheme, you should set the score file atom `mark' to
something small--like -300, perhaps, to avoid having small random
changes result in articles getting marked as read.

   After using adaptive scoring for a week or so, Gnus should start to
become properly trained and enhance the authors you like best, and kill
the authors you like least, without you having to say so explicitly.

   You can control what groups the adaptive scoring is to be performed
on by using the score files (*note Score File Format::).  This will also
let you use different rules in different groups.

   The adaptive score entries will be put into a file where the name is
the group name with `gnus-adaptive-file-suffix' appended.  The default
is `ADAPT'.

   Adaptive score files can get huge and are not meant to be edited by
human hands.  If `gnus-adaptive-pretty-print' is `nil' (the default)
those files will not be written in a human readable way.

   When doing adaptive scoring, substring or fuzzy matching would
probably give you the best results in most cases.  However, if the
header one matches is short, the possibility for false positives is
great, so if the length of the match is less than
`gnus-score-exact-adapt-limit', exact matching will be used.  If this
variable is `nil', exact matching will always be used to avoid this
problem.

   As mentioned above, you can adapt either on individual words or
entire headers.  If you adapt on words, the
`gnus-default-adaptive-word-score-alist' variable says what score each
instance of a word should add given a mark.

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

   This is the default value.  If you have adaption on words enabled,
every word that appears in subjects of articles marked with
`gnus-read-mark' will result in a score rule that increase the score
with 30 points.

   Words that appear in the `gnus-default-ignored-adaptive-words' list
will be ignored.  If you wish to add more words to be ignored, use the
`gnus-ignored-adaptive-words' list instead.

   Some may feel that short words shouldn't count when doing adaptive
scoring.  If so, you may set `gnus-adaptive-word-length-limit' to an
integer.  Words shorter than this number will be ignored.  This
variable defaults to `nil'.

   When the scoring is done, `gnus-adaptive-word-syntax-table' is the
syntax table in effect.  It is similar to the standard syntax table, but
it considers numbers to be non-word-constituent characters.

   If `gnus-adaptive-word-minimum' is set to a number, the adaptive
word scoring process will never bring down the score of an article to
below this number.  The default is `nil'.

   If `gnus-adaptive-word-no-group-words' is set to `t', gnus won't
adaptively word score any of the words in the group name.  Useful for
groups like `comp.editors.emacs', where most of the subject lines
contain the word `emacs'.

   After using this scheme for a while, it might be nice to write a
`gnus-psychoanalyze-user' command to go through the rules and see what
words you like and what words you don't like.  Or perhaps not.

   Note that the adaptive word scoring thing is highly experimental and
is likely to change in the future.  Initial impressions seem to indicate
that it's totally useless as it stands.  Some more work (involving more
rigorous statistical methods) will have to be done to make this useful.


File: gnus,  Node: Home Score File,  Next: Followups To Yourself,  Prev: Adaptive Scoring,  Up: Scoring

7.7 Home Score File
===================

The score file where new score file entries will go is called the "home
score file".  This is normally (and by default) the score file for the
group itself.  For instance, the home score file for `gnu.emacs.gnus'
is `gnu.emacs.gnus.SCORE'.

   However, this may not be what you want.  It is often convenient to
share a common home score file among many groups--all `emacs' groups
could perhaps use the same home score file.

   The variable that controls this is `gnus-home-score-file'.  It can
be:

  1. A string.  Then this file will be used as the home score file for
     all groups.

  2. A function.  The result of this function will be used as the home
     score file.  The function will be called with the name of the
     group as the parameter.

  3. A list.  The elements in this list can be:

       1. `(REGEXP FILE-NAME)'.  If the REGEXP matches the group name,
          the FILE-NAME will be used as the home score file.

       2. A function.  If the function returns non-`nil', the result
          will be used as the home score file.  The function will be
          called with the name of the group as the parameter.

       3. A string.  Use the string as the home score file.

     The list will be traversed from the beginning towards the end
     looking for matches.


   So, if you want to use just a single score file, you could say:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

   If you want to use `gnu.SCORE' for all `gnu' groups and `rec.SCORE'
for all `rec' groups (and so on), you can say:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

   This is a ready-made function provided for your convenience.  Other
functions include

`gnus-current-home-score-file'
     Return the "current" regular score file.  This will make scoring
     commands add entry to the "innermost" matching score file.


   If you want to have one score file for the `emacs' groups and
another for the `comp' groups, while letting all other groups use their
own home score files:

     (setq gnus-home-score-file
           ;; All groups that match the regexp `"\\.emacs"'
           '(("\\.emacs" "emacs.SCORE")
             ;; All the comp groups in one score file
             ("^comp" "comp.SCORE")))

   `gnus-home-adapt-file' works exactly the same way as
`gnus-home-score-file', but says what the home adaptive score file is
instead.  All new adaptive file entries will go into the file specified
by this variable, and the same syntax is allowed.

   In addition to using `gnus-home-score-file' and
`gnus-home-adapt-file', you can also use group parameters (*note Group
Parameters::) and topic parameters (*note Topic Parameters::) to
achieve much the same.  Group and topic parameters take precedence over
this variable.


File: gnus,  Node: Followups To Yourself,  Next: Scoring On Other Headers,  Prev: Home Score File,  Up: Scoring

7.8 Followups To Yourself
=========================

Gnus offers two commands for picking out the `Message-ID' header in the
current buffer.  Gnus will then add a score rule that scores using this
`Message-ID' on the `References' header of other articles.  This will,
in effect, increase the score of all articles that respond to the
article in the current buffer.  Quite useful if you want to easily note
when people answer what you've said.

`gnus-score-followup-article'
     This will add a score to articles that directly follow up your own
     article.

`gnus-score-followup-thread'
     This will add a score to all articles that appear in a thread
     "below" your own article.

   These two functions are both primarily meant to be used in hooks like
`message-sent-hook', like this:
     (add-hook 'message-sent-hook 'gnus-score-followup-thread)

   If you look closely at your own `Message-ID', you'll notice that the
first two or three characters are always the same.  Here's two of mine:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

   So "my" ident on this machine is `x6'.  This can be exploited--the
following rule will raise the score on all followups to myself:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

   Whether it's the first two or first three characters that are "yours"
is system-dependent.


File: gnus,  Node: Scoring On Other Headers,  Next: Scoring Tips,  Prev: Followups To Yourself,  Up: Scoring

7.9 Scoring On Other Headers
============================

Gnus is quite fast when scoring the "traditional" headers--`From',
`Subject' and so on.  However, scoring other headers requires writing a
`head' scoring rule, which means that Gnus has to request every single
article from the back end to find matches.  This takes a long time in
big groups.

   You can inhibit this slow scoring on headers or body by setting the
variable `gnus-inhibit-slow-scoring'.  If `gnus-inhibit-slow-scoring'
is regexp, slow scoring is inhibited if the group matches the regexp.
If it is t, slow scoring on it is inhibited for all groups.

   Now, there's not much you can do about the slowness for news groups,
but for mail groups, you have greater control.  In *note To From
Newsgroups::, it's explained in greater detail what this mechanism
does, but here's a cookbook example for `nnml' on how to allow scoring
on the `To' and `Cc' headers.

   Put the following in your `~/.gnus.el' file.

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

   Restart Gnus and rebuild your `nnml' overview files with the `M-x
nnml-generate-nov-databases' command.  This will take a long time if
you have much mail.

   Now you can score on `To' and `Cc' as "extra headers" like so: `I e
s p To RET <your name> RET'.

   See?  Simple.


File: gnus,  Node: Scoring Tips,  Next: Reverse Scoring,  Prev: Scoring On Other Headers,  Up: Scoring

7.10 Scoring Tips
=================

"Crossposts"
     If you want to lower the score of crossposts, the line to match on
     is the `Xref' header.
          ("xref" (" talk.politics.misc:" -1000))

"Multiple crossposts"
     If you want to lower the score of articles that have been
     crossposted to more than, say, 3 groups:
          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"Matching on the body"
     This is generally not a very good idea--it takes a very long time.
     Gnus actually has to fetch each individual article from the
     server.  But you might want to anyway, I guess.  Even though there
     are three match keys (`Head', `Body' and `All'), you should choose
     one and stick with it in each score file.  If you use any two,
     each article will be fetched _twice_.  If you want to match a bit
     on the `Head' and a bit on the `Body', just use `All' for all the
     matches.

"Marking as read"
     You will probably want to mark articles that have scores below a
     certain number as read.  This is most easily achieved by putting
     the following in your `all.SCORE' file:
          ((mark -100))
     You may also consider doing something similar with `expunge'.

"Negated character classes"
     If you say stuff like `[^abcd]*', you may get unexpected results.
     That will match newlines, which might lead to, well, The Unknown.
     Say `[^abcd\n]*' instead.


File: gnus,  Node: Reverse Scoring,  Next: Global Score Files,  Prev: Scoring Tips,  Up: Scoring

7.11 Reverse Scoring
====================

If you want to keep just articles that have `Sex with Emacs' in the
subject header, and expunge all other articles, you could put something
like this in your score file:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

   So, you raise all articles that match `Sex with Emacs' and mark the
rest as read, and expunge them to boot.


File: gnus,  Node: Global Score Files,  Next: Kill Files,  Prev: Reverse Scoring,  Up: Scoring

7.12 Global Score Files
=======================

Sure, other newsreaders have "global kill files".  These are usually
nothing more than a single kill file that applies to all groups, stored
in the user's home directory.  Bah!  Puny, weak newsreaders!

   What I'm talking about here are Global Score Files.  Score files from
all over the world, from users everywhere, uniting all nations in one
big, happy score file union!  Ange-score!  New and untested!

   All you have to do to use other people's score files is to set the
`gnus-global-score-files' variable.  One entry for each score file, or
each score file directory.  Gnus will decide by itself what score files
are applicable to which group.

   To use the score file
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' and all score
files in the `/ftp@ftp.some-where:/pub/score' directory, say this:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

Simple, eh?  Directory names must end with a `/'.  These directories
are typically scanned only once during each Gnus session.  If you feel
the need to manually re-scan the remote directories, you can use the
`gnus-score-search-global-directories' command.

   Note that, at present, using this option will slow down group entry
somewhat.  (That is--a lot.)

   If you want to start maintaining score files for other people to use,
just put your score file up for anonymous ftp and announce it to the
world.  Become a retro-moderator!  Participate in the retro-moderator
wars sure to ensue, where retro-moderators battle it out for the
sympathy of the people, luring them to use their score files on false
premises!  Yay!  The net is saved!

   Here are some tips for the would-be retro-moderator, off the top of
my head:

   * Articles heavily crossposted are probably junk.

   * To lower a single inappropriate article, lower by `Message-ID'.

   * Particularly brilliant authors can be raised on a permanent basis.

   * Authors that repeatedly post off-charter for the group can safely
     be lowered out of existence.

   * Set the `mark' and `expunge' atoms to obliterate the nastiest
     articles completely.

   * Use expiring score entries to keep the size of the file down.  You
     should probably have a long expiry period, though, as some sites
     keep old articles for a long time.

   ... I wonder whether other newsreaders will support global score
files in the future.  _Snicker_.  Yup, any day now, newsreaders like
Blue Wave, xrn and 1stReader are bound to implement scoring.  Should we
start holding our breath yet?


File: gnus,  Node: Kill Files,  Next: Converting Kill Files,  Prev: Global Score Files,  Up: Scoring

7.13 Kill Files
===============

Gnus still supports those pesky old kill files.  In fact, the kill file
entries can now be expiring, which is something I wrote before Daniel
Quinlan thought of doing score files, so I've left the code in there.

   In short, kill processing is a lot slower (and I do mean _a lot_)
than score processing, so it might be a good idea to rewrite your kill
files into score files.

   Anyway, a kill file is a normal `emacs-lisp' file.  You can put any
forms into this file, which means that you can use kill files as some
sort of primitive hook function to be run on group entry, even though
that isn't a very good idea.

   Normal kill files look like this:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

   This will mark every article written by me as read, and remove the
marked articles from the summary buffer.  Very useful, you'll agree.

   Other programs use a totally different kill file syntax.  If Gnus
encounters what looks like a `rn' kill file, it will take a stab at
interpreting it.

   Two summary functions for editing a GNUS kill file:

`M-k'
     Edit this group's kill file (`gnus-summary-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-summary-edit-global-kill').

   Two group mode functions for editing the kill files:

`M-k'
     Edit this group's kill file (`gnus-group-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-group-edit-global-kill').

   Kill file variables:

`gnus-kill-file-name'
     A kill file for the group `soc.motss' is normally called
     `soc.motss.KILL'.  The suffix appended to the group name to get
     this file name is detailed by the `gnus-kill-file-name' variable.
     The "global" kill file (not in the score file sense of "global", of
     course) is just called `KILL'.

`gnus-kill-save-kill-file'
     If this variable is non-`nil', Gnus will save the kill file after
     processing, which is necessary if you use expiring kills.

`gnus-apply-kill-hook'
     A hook called to apply kill files to a group.  It is
     `(gnus-apply-kill-file)' by default.  If you want to ignore the
     kill file if you have a score file for the same group, you can set
     this hook to `(gnus-apply-kill-file-unless-scored)'.  If you don't
     want kill files to be processed, you should set this variable to
     `nil'.

`gnus-kill-file-mode-hook'
     A hook called in kill-file mode buffers.



File: gnus,  Node: Converting Kill Files,  Next: Advanced Scoring,  Prev: Kill Files,  Up: Scoring

7.14 Converting Kill Files
==========================

If you have loads of old kill files, you may want to convert them into
score files.  If they are "regular", you can use the
`gnus-kill-to-score.el' package; if not, you'll have to do it by hand.

   The kill to score conversion package isn't included in Emacs by
default.  You can fetch it from the contrib directory of the Gnus
distribution or from
`http://heim.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'.

   If your old kill files are very complex--if they contain more
non-`gnus-kill' forms than not, you'll have to convert them by hand.
Or just let them be as they are.  Gnus will still use them as before.


File: gnus,  Node: Advanced Scoring,  Next: Score Decays,  Prev: Converting Kill Files,  Up: Scoring

7.15 Advanced Scoring
=====================

Scoring on Subjects and From headers is nice enough, but what if you're
really interested in what a person has to say only when she's talking
about a particular subject?  Or what if you really don't want to read
what person A has to say when she's following up to person B, but want
to read what she says when she's following up to person C?

   By using advanced scoring rules you may create arbitrarily complex
scoring patterns.

* Menu:

* Advanced Scoring Syntax::     A definition.
* Advanced Scoring Examples::   What they look like.
* Advanced Scoring Tips::       Getting the most out of it.


File: gnus,  Node: Advanced Scoring Syntax,  Next: Advanced Scoring Examples,  Up: Advanced Scoring

7.15.1 Advanced Scoring Syntax
------------------------------

Ordinary scoring rules have a string as the first element in the rule.
Advanced scoring rules have a list as the first element.  The second
element is the score to be applied if the first element evaluated to a
non-`nil' value.

   These lists may consist of three logical operators, one redirection
operator, and various match operators.

   Logical operators:

`&'
`and'
     This logical operator will evaluate each of its arguments until it
     finds one that evaluates to `false', and then it'll stop.  If all
     arguments evaluate to `true' values, then this operator will return
     `true'.

`|'
`or'
     This logical operator will evaluate each of its arguments until it
     finds one that evaluates to `true'.  If no arguments are `true',
     then this operator will return `false'.

`!'
`not'
`'
     This logical operator only takes a single argument.  It returns the
     logical negation of the value of its argument.


   There is an "indirection operator" that will make its arguments
apply to the ancestors of the current article being scored.  For
instance, `1-' will make score rules apply to the parent of the current
article.  `2-' will make score rules apply to the grandparent of the
current article.  Alternatively, you can write `^^', where the number
of `^'s (carets) says how far back into the ancestry you want to go.

   Finally, we have the match operators.  These are the ones that do the
real work.  Match operators are header name strings followed by a match
and a match type.  A typical match operator looks like `("from" "Lars
Ingebrigtsen" s)'.  The header names are the same as when using simple
scoring, and the match types are also the same.


File: gnus,  Node: Advanced Scoring Examples,  Next: Advanced Scoring Tips,  Prev: Advanced Scoring Syntax,  Up: Advanced Scoring

7.15.2 Advanced Scoring Examples
--------------------------------

Please note that the following examples are score file rules.  To make
a complete score file from them, surround them with another pair of
parentheses.

   Let's say you want to increase the score of articles written by Lars
when he's talking about Gnus:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

   Quite simple, huh?

   When he writes long articles, he sometimes has something nice to say:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

   However, when he responds to things written by Reig Eigil Logge, you
really don't want to read what he's written:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigil Logge")))
      -100000)

   Everybody that follows up Redmondo when he writes about disappearing
socks should have their scores raised, but only when they talk about
white socks.  However, when Lars talks about socks, it's usually not
very interesting:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

   Suppose you're reading a high volume group and you're only interested
in replies. The plan is to score down all articles that don't have
subject that begin with "Re:", "Fw:" or "Fwd:" and then score up all
parents of articles that have subjects that begin with reply marks.

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

   The possibilities are endless.


File: gnus,  Node: Advanced Scoring Tips,  Prev: Advanced Scoring Examples,  Up: Advanced Scoring

7.15.3 Advanced Scoring Tips
----------------------------

The `&' and `|' logical operators do short-circuit logic.  That is,
they stop processing their arguments when it's clear what the result of
the operation will be.  For instance, if one of the arguments of an `&'
evaluates to `false', there's no point in evaluating the rest of the
arguments.  This means that you should put slow matches (`body',
`header') last and quick matches (`from', `subject') first.

   The indirection arguments (`1-' and so on) will make their arguments
work on previous generations of the thread.  If you say something like:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

   Then that means "score on the from header of the grandparent of the
current article".  An indirection is quite fast, but it's better to say:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

   than it is to say:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))


File: gnus,  Node: Score Decays,  Prev: Advanced Scoring,  Up: Scoring

7.16 Score Decays
=================

You may find that your scores have a tendency to grow without bounds,
especially if you're using adaptive scoring.  If scores get too big,
they lose all meaning--they simply max out and it's difficult to use
them in any sensible way.

   Gnus provides a mechanism for decaying scores to help with this
problem.  When score files are loaded and `gnus-decay-scores' is
non-`nil', Gnus will run the score files through the decaying mechanism
thereby lowering the scores of all non-permanent score rules.  If
`gnus-decay-scores' is a regexp, only score files matching this regexp
are treated.  E.g. you may set it to `\\.ADAPT\\'' if only _adaptive_
score files should be decayed.  The decay itself if performed by the
`gnus-decay-score-function' function, which is `gnus-decay-score' by
default.  Here's the definition of that function:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs's floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

   `gnus-score-decay-constant' is 3 by default and
`gnus-score-decay-scale' is 0.05.  This should cause the following:

  1. Scores between -3 and 3 will be set to 0 when this function is
     called.

  2. Scores with magnitudes between 3 and 60 will be shrunk by 3.

  3. Scores with magnitudes greater than 60 will be shrunk by 5% of the
     score.

   If you don't like this decay function, write your own.  It is called
with the score to be decayed as its only parameter, and it should return
the new score, which should be an integer.

   Gnus will try to decay scores once a day.  If you haven't run Gnus
for four days, Gnus will decay the scores four times, for instance.


File: gnus,  Node: Searching,  Next: Various,  Prev: Scoring,  Up: Top

8 Searching
***********

FIXME: Add a brief overview of Gnus search capabilities.  A brief
comparison of nnir, nnmairix, contrib/gnus-namazu would be nice as well.

   This chapter describes tools for searching groups and servers for
articles matching a query and then retrieving those articles. Gnus
provides a simpler mechanism for searching through articles in a
summary buffer to find those matching a pattern. *Note Searching for
Articles::.

* Menu:

* nnir::                     Searching with various engines.
* nnmairix::                 Searching with Mairix.


File: gnus,  Node: nnir,  Next: nnmairix,  Up: Searching

8.1 nnir
========

This section describes how to use `nnir' to search for articles within
gnus.

* Menu:

* What is nnir?::               What does `nnir' do?
* Basic Usage::                 How to perform simple searches.
* Setting up nnir::             How to set up `nnir'.


File: gnus,  Node: What is nnir?,  Next: Basic Usage,  Up: nnir

8.1.1 What is nnir?
-------------------

`nnir' is a Gnus interface to a number of tools for searching through
mail and news repositories. Different backends (like `nnimap' and
`nntp') work with different tools (called "engines" in `nnir' lingo),
but all use the same basic search interface.

   The `nnimap' and `gmane' search engines should work with no
configuration. Other engines require a local index that needs to be
created and maintained outside of Gnus.


File: gnus,  Node: Basic Usage,  Next: Setting up nnir,  Prev: What is nnir?,  Up: nnir

8.1.2 Basic Usage
-----------------

In the group buffer typing `G G' will search the group on the current
line by calling `gnus-group-make-nnir-group'.  This prompts for a query
string, creates an ephemeral `nnir' group containing the articles that
match this query, and takes you to a summary buffer showing these
articles. Articles may then be read, moved and deleted using the usual
commands.

   The `nnir' group made in this way is an `ephemeral' group, and some
changes are not permanent: aside from reading, moving, and deleting,
you can't act on the original article. But there is an alternative: you
can _warp_ to the original group for the article on the current line
with `A W', aka `gnus-warp-to-article'. Even better, the function
`gnus-summary-refer-thread', bound by default in summary buffers to `A
T', will first warp to the original group before it works its magic and
includes all the articles in the thread. From here you can read, move
and delete articles, but also copy them, alter article marks, whatever.
Go nuts.

   You say you want to search more than just the group on the current
line?  No problem: just process-mark the groups you want to search. You
want even more? Calling for an nnir search with the cursor on a topic
heading will search all the groups under that heading.

   Still not enough? OK, in the server buffer
`gnus-group-make-nnir-group' (now bound to `G') will search all groups
from the server on the current line. Too much? Want to ignore certain
groups when searching, like spam groups? Just customize
`nnir-ignored-newsgroups'.

   One more thing: individual search engines may have special search
features. You can access these special features by giving a prefix-arg
to `gnus-group-make-nnir-group'. If you are searching multiple groups
with different search engines you will be prompted for the special
search features for each engine separately.


File: gnus,  Node: Setting up nnir,  Prev: Basic Usage,  Up: nnir

8.1.3 Setting up nnir
---------------------

To set up nnir you may need to do some prep work. Firstly, you may need
to configure the search engines you plan to use. Some of them, like
`imap' and `gmane', need no special configuration. Others, like
`namazu' and `swish', require configuration as described below.
Secondly, you need to associate a search engine with a server or a
backend.

   If you just want to use the `imap' engine to search `nnimap'
servers, and the `gmane' engine to search `gmane' then you don't have
to do anything. But you might want to read the details of the query
language anyway.

* Menu:

* Associating Engines::                 How to associate engines.
* The imap Engine::                     Imap configuration and usage.
* The gmane Engine::                    Gmane configuration and usage.
* The swish++ Engine::                  Swish++ configuration and usage.
* The swish-e Engine::                  Swish-e configuration and usage.
* The namazu Engine::                   Namazu configuration and usage.
* The hyrex Engine::                    Hyrex configuration and usage.
* Customizations::                      User customizable settings.


File: gnus,  Node: Associating Engines,  Next: The imap Engine,  Up: Setting up nnir

8.1.3.1 Associating Engines
...........................

When searching a group, `nnir' needs to know which search engine to
use. You can configure a given server to use a particular engine by
setting the server variable `nnir-search-engine' to the engine name.
For example to use the `namazu' engine to search the server named
`home' you can use

     (setq gnus-secondary-select-methods
           '((nnml "home"
              (nnimap-address "localhost")
              (nnir-search-engine namazu))))

   Alternatively you might want to use a particular engine for all
servers with a given backend. For example, you might want to use the
`imap' engine for all servers using the `nnimap' backend. In this case
you can customize the variable `nnir-method-default-engines'. This is
an alist of pairs of the form `(backend . engine)'. By default this
variable is set to use the `imap' engine for all servers using the
`nnimap' backend, and the `gmane' backend for `nntp' servers. (Don't
worry, the `gmane' search engine won't actually try to search non-gmane
`nntp' servers.) But if you wanted to use `namazu' for all your servers
with an `nnimap' backend you could change this to

     '((nnimap . namazu)
       (nntp . gmane))


File: gnus,  Node: The imap Engine,  Next: The gmane Engine,  Prev: Associating Engines,  Up: Setting up nnir

8.1.3.2 The imap Engine
.......................

The `imap' engine requires no configuration.

   Queries using the `imap' engine follow a simple query language.  The
search is always case-insensitive and supports the following features
(inspired by the Google search input language):

`Boolean query operators'
     AND, OR, and NOT are supported, and parentheses can be used to
     control operator precedence, e.g. (emacs OR xemacs) AND linux.
     Note that operators must be written with all capital letters to be
     recognized. Also preceding a term with a - sign is equivalent to
     NOT term.

`Automatic AND queries'
     If you specify multiple words then they will be treated as an AND
     expression intended to match all components.

`Phrase searches'
     If you wrap your query in double-quotes then it will be treated as
     a literal string.


   By default the whole message will be searched. The query can be
limited to a specific part of a message by using a prefix-arg. After
inputting the query this will prompt (with completion) for a message
part.  Choices include "Whole message", "Subject", "From", and "To".
Any unrecognized input is interpreted as a header name. For example,
typing `Message-ID' in response to this prompt will limit the query to
the Message-ID header.

   Finally selecting "Imap" will interpret the query as a raw IMAP
search query. The format of such queries can be found in RFC3501.

   If you don't like the default of searching whole messages you can
customize `nnir-imap-default-search-key'. For example to use IMAP
queries by default

     (setq nnir-imap-default-search-key "Imap")


File: gnus,  Node: The gmane Engine,  Next: The swish++ Engine,  Prev: The imap Engine,  Up: Setting up nnir

8.1.3.3 The gmane Engine
........................

The `gmane' engine requires no configuration.

   Gmane queries follow a simple query language:

`Boolean query operators'
     AND, OR, NOT (or AND NOT), and XOR are supported, and brackets can
     be used to control operator precedence, e.g. (emacs OR xemacs) AND
     linux.  Note that operators must be written with all capital
     letters to be recognized.

`Required and excluded terms'
     + and - can be used to require or exclude terms, e.g. football
     -american

`Unicode handling'
     The search engine converts all text to utf-8, so searching should
     work in any language.

`Stopwords'
     Common English words (like 'the' and 'a') are ignored by default.
     You can override this by prefixing such words with a + (e.g. +the)
     or enclosing the word in quotes (e.g. "the").


   The query can be limited to articles by a specific author using a
prefix-arg. After inputting the query this will prompt for an author
name (or part of a name) to match.


File: gnus,  Node: The swish++ Engine,  Next: The swish-e Engine,  Prev: The gmane Engine,  Up: Setting up nnir

8.1.3.4 The swish++ Engine
..........................

FIXME: Say something more here.

   Documentation for swish++ may be found at the swish++ sourceforge
page: `http://swishplusplus.sourceforge.net'

`nnir-swish++-program'
     The name of the swish++ executable. Defaults to `search'

`nnir-swish++-additional-switches'
     A list of strings to be given as additional arguments to swish++.
     `nil' by default.

`nnir-swish++-remove-prefix'
     The prefix to remove from each file name returned by swish++ in
     order to get a group name. By default this is `$HOME/Mail'.



File: gnus,  Node: The swish-e Engine,  Next: The namazu Engine,  Prev: The swish++ Engine,  Up: Setting up nnir

8.1.3.5 The swish-e Engine
..........................

FIXME: Say something more here.

   Documentation for swish-e may be found at the swish-e homepage
`http://swish-e.org'

`nnir-swish-e-program'
     The name of the swish-e search program. Defaults to `swish-e'.

`nnir-swish-e-additional-switches'
     A list of strings to be given as additional arguments to swish-e.
     `nil' by default.

`nnir-swish-e-remove-prefix'
     The prefix to remove from each file name returned by swish-e in
     order to get a group name. By default this is `$HOME/Mail'.



File: gnus,  Node: The namazu Engine,  Next: The hyrex Engine,  Prev: The swish-e Engine,  Up: Setting up nnir

8.1.3.6 The namazu Engine
.........................

Using the namazu engine requires creating and maintaining index files.
One directory should contain all the index files, and nnir must be told
where to find them by setting the `nnir-namazu-index-directory'
variable.

   To work correctly the `nnir-namazu-remove-prefix' variable must also
be correct. This is the prefix to remove from each file name returned
by Namazu in order to get a proper group name (albeit with `/' instead
of `.').

   For example, suppose that Namazu returns file names such as
`/home/john/Mail/mail/misc/42'.  For this example, use the following
setting: `(setq nnir-namazu-remove-prefix "/home/john/Mail/")' Note the
trailing slash.  Removing this prefix from the directory gives
`mail/misc/42'.  `nnir' knows to remove the `/42' and to replace `/'
with `.' to arrive at the correct group name `mail.misc'.

   Extra switches may be passed to the namazu search command by setting
the variable `nnir-namazu-additional-switches'.  It is particularly
important not to pass any any switches to namazu that will change the
output format.  Good switches to use include `-sort', `-ascending',
`-early' and `-late'.  Refer to the Namazu documentation for further
information on valid switches.

   Mail must first be indexed  with the `mknmz' program.  Read the
documentation for namazu to create a configuration file. Here is an
example:

      package conf;  # Don't remove this line!

      # Paths which will not be indexed. Don't use `^' or `$' anchors.
      $EXCLUDE_PATH = "spam|sent";

      # Header fields which should be searchable. case-insensitive
      $REMAIN_HEADER = "from|date|message-id|subject";

      # Searchable fields. case-insensitive
      $SEARCH_FIELD = "from|date|message-id|subject";

      # The max length of a word.
      $WORD_LENG_MAX = 128;

      # The max length of a field.
      $MAX_FIELD_LENGTH = 256;

   For this example, mail is stored in the directories `~/Mail/mail/',
`~/Mail/lists/' and `~/Mail/archive/', so to index them go to the index
directory set in `nnir-namazu-index-directory' and issue the following
command:

     mknmz --mailnews ~/Mail/archive/ ~/Mail/mail/ ~/Mail/lists/

   For maximum searching efficiency you might want to have a cron job
run this command periodically, say every four hours.


File: gnus,  Node: The hyrex Engine,  Next: Customizations,  Prev: The namazu Engine,  Up: Setting up nnir

8.1.3.7 The hyrex Engine
........................

This engine is obsolete.


File: gnus,  Node: Customizations,  Prev: The hyrex Engine,  Up: Setting up nnir

8.1.3.8 Customizations
......................

`nnir-method-default-engines'
     Alist of server backend - search engine pairs. The default
     associations are
          (nnimap . imap)
          (nntp . gmane)

`nnir-ignored-newsgroups'
     A regexp to match newsgroups in the active file that should be
     skipped when searching all groups on a server.

`nnir-summary-line-format'
     The format specification to be used for lines in an nnir summary
     buffer.  All the items from `gnus-summary-line-format' are
     available, along with three items unique to nnir summary buffers:

          %Z    Search retrieval score value (integer)
          %G    Article original full group name (string)
          %g    Article original short group name (string)

     If nil (the default) this will use `gnus-summary-line-format'.

`nnir-retrieve-headers-override-function'
     If non-nil, a function that retrieves article headers rather than
     using the gnus built-in function.  This function takes an article
     list and group as arguments and populates the `nntp-server-buffer'
     with the retrieved headers. It should then return either 'nov or
     'headers indicating the retrieved header format. Failure to
     retrieve headers should return `nil'

     If this variable is nil, or if the provided function returns nil
     for a search result, `gnus-retrieve-headers' will be called
     instead."



File: gnus,  Node: nnmairix,  Prev: nnir,  Up: Searching

8.2 nnmairix
============

This paragraph describes how to set up mairix and the back end
`nnmairix' for indexing and searching your mail from within Gnus.
Additionally, you can create permanent "smart" groups which are bound
to mairix searches and are automatically updated.

* Menu:

* About mairix::                About the mairix mail search engine
* nnmairix requirements::       What you will need for using nnmairix
* What nnmairix does::          What does nnmairix actually do?
* Setting up mairix::           Set up your mairix installation
* Configuring nnmairix::        Set up the nnmairix back end
* nnmairix keyboard shortcuts:: List of available keyboard shortcuts
* Propagating marks::           How to propagate marks from nnmairix groups
* nnmairix tips and tricks::    Some tips, tricks and examples
* nnmairix caveats::            Some more stuff you might want to know


File: gnus,  Node: About mairix,  Next: nnmairix requirements,  Up: nnmairix

8.2.1 About mairix
------------------

Mairix is a tool for indexing and searching words in locally stored
mail.  It was written by Richard Curnow and is licensed under the GPL.
Mairix comes with most popular GNU/Linux distributions, but it also
runs under Windows (with cygwin), Mac OS X and Solaris.  The homepage
can be found at `http://www.rpcurnow.force9.co.uk/mairix/index.html'

   Though mairix might not be as flexible as other search tools like
swish++ or namazu, which you can use via the `nnir' back end, it has
the prime advantage of being incredibly fast.  On current systems, it
can easily search through headers and message bodies of thousands and
thousands of mails in well under a second.  Building the database
necessary for searching might take a minute or two, but only has to be
done once fully.  Afterwards, the updates are done incrementally and
therefore are really fast, too.  Additionally, mairix is very easy to
set up.

   For maximum speed though, mairix should be used with mails stored in
`Maildir' or `MH' format (this includes the `nnml' back end), although
it also works with mbox.  Mairix presents the search results by
populating a _virtual_ maildir/MH folder with symlinks which point to
the "real" message files (if mbox is used, copies are made).  Since
mairix already presents search results in such a virtual mail folder,
it is very well suited for using it as an external program for creating
_smart_ mail folders, which represent certain mail searches.


File: gnus,  Node: nnmairix requirements,  Next: What nnmairix does,  Prev: About mairix,  Up: nnmairix

8.2.2 nnmairix requirements
---------------------------

Mairix searches local mail--that means, mairix absolutely must have
direct access to your mail folders.  If your mail resides on another
server (e.g. an IMAP server) and you happen to have shell access,
`nnmairix' supports running mairix remotely, e.g. via ssh.

   Additionally, `nnmairix' only supports the following Gnus back ends:
`nnml', `nnmaildir', and `nnimap'.  You must use one of these back ends
for using `nnmairix'.  Other back ends, like `nnmbox', `nnfolder' or
`nnmh', won't work.

   If you absolutely must use mbox and still want to use `nnmairix',
you can set up a local IMAP server, which you then access via `nnimap'.
This is a rather massive setup for accessing some mbox files, so just
change to MH or Maildir already...  However, if you're really, really
passionate about using mbox, you might want to look into the package
`mairix.el', which comes with Emacs 23.


File: gnus,  Node: What nnmairix does,  Next: Setting up mairix,  Prev: nnmairix requirements,  Up: nnmairix

8.2.3 What nnmairix does
------------------------

The back end `nnmairix' enables you to call mairix from within Gnus,
either to query mairix with a search term or to update the database.
While visiting a message in the summary buffer, you can use several
pre-defined shortcuts for calling mairix, e.g. to quickly search for
all mails from the sender of the current message or to display the
whole thread associated with the message, even if the mails are in
different folders.

   Additionally, you can create permanent `nnmairix' groups which are
bound to certain mairix searches.  This way, you can easily create a
group containing mails from a certain sender, with a certain subject
line or even for one specific thread based on the Message-ID.  If you
check for new mail in these folders (e.g. by pressing `g' or `M-g'),
they automatically update themselves by calling mairix.

   You might ask why you need `nnmairix' at all, since mairix already
creates the group, populates it with links to the mails so that you can
then access it with Gnus, right?  Well, this _might_ work, but often
does not--at least not without problems.  Most probably you will get
strange article counts, and sometimes you might see mails which Gnus
claims have already been canceled and are inaccessible.  This is due to
the fact that Gnus isn't really amused when things are happening behind
its back.  Another problem can be the mail back end itself, e.g. if you
use mairix with an IMAP server (I had Dovecot complaining about corrupt
index files when mairix changed the contents of the search group).
Using `nnmairix' should circumvent these problems.

   `nnmairix' is not really a mail back end--it's actually more like a
wrapper, sitting between a "real" mail back end where mairix stores the
searches and the Gnus front end.  You can choose between three
different mail back ends for the mairix folders: `nnml', `nnmaildir' or
`nnimap'.  `nnmairix' will call the mairix binary so that the search
results are stored in folders named `zz_mairix-<NAME>-<NUMBER>' on this
mail back end, but it will present these folders in the Gnus front end
only with `<NAME>'.  You can use an existing mail back end where you
already store your mail, but if you're uncomfortable with `nnmairix'
creating new mail groups alongside your other mail, you can also create
e.g. a new `nnmaildir' or `nnml' server exclusively for mairix, but then
make sure those servers do not accidentally receive your new mail
(*note nnmairix caveats::).  A special case exists if you want to use
mairix remotely on an IMAP server with `nnimap'--here the mairix
folders and your other mail must be on the same `nnimap' back end.


File: gnus,  Node: Setting up mairix,  Next: Configuring nnmairix,  Prev: What nnmairix does,  Up: nnmairix

8.2.4 Setting up mairix
-----------------------

First: create a backup of your mail folders (*note nnmairix caveats::).

   Setting up mairix is easy: simply create a `.mairixrc' file with (at
least) the following entries:

     # Your Maildir/MH base folder
     base=~/Maildir

   This is the base folder for your mails.  All the following
directories are relative to this base folder.  If you want to use
`nnmairix' with `nnimap', this base directory has to point to the mail
directory where the IMAP server stores the mail folders!

     maildir= ... your maildir folders which should be indexed ...
     mh= ... your nnml/mh folders which should be indexed ...
     mbox = ... your mbox files which should be indexed ...

   This specifies all your mail folders and mbox files (relative to the
base directory!) you want to index with mairix.  Note that the `nnml'
back end saves mails in MH format, so you have to put those directories
in the `mh' line.  See the example at the end of this section and
mairixrc's man-page for further details.

     omit=zz_mairix-*

   This should make sure that you don't accidentally index the mairix
search results.  You can change the prefix of these folders with the
variable `nnmairix-group-prefix'.

     mformat= ... 'maildir' or 'mh' ...
     database= ... location of database file ...

   The `format' setting specifies the output format for the mairix
search folder.  Set this to `mh' if you want to access search results
with `nnml'.  Otherwise choose `maildir'.

   To summarize, here is my shortened `.mairixrc' file as an example:

     base=~/Maildir
     maildir=.personal:.work:.logcheck:.sent
     mh=../Mail/nnml/*...
     mbox=../mboxmail/mailarchive_year*
     mformat=maildir
     omit=zz_mairix-*
     database=~/.mairixdatabase

   In this case, the base directory is `~/Maildir', where all my Maildir
folders are stored.  As you can see, the folders are separated by
colons.  If you wonder why every folder begins with a dot: this is
because I use Dovecot as IMAP server, which again uses `Maildir++'
folders.  For testing nnmairix, I also have some `nnml' mail, which is
saved in `~/Mail/nnml'.  Since this has to be specified relative to the
`base' directory, the `../Mail' notation is needed.  Note that the line
ends in `*...', which means to recursively scan all files under this
directory.  Without the three dots, the wildcard `*' will not work
recursively.  I also have some old mbox files with archived mail lying
around in `~/mboxmail'.  The other lines should be obvious.

   See the man page for `mairixrc' for details and further options,
especially regarding wildcard usage, which may be a little different
than you are used to.

   Now simply call `mairix' to create the index for the first time.
Note that this may take a few minutes, but every following index will do
the updates incrementally and hence is very fast.


File: gnus,  Node: Configuring nnmairix,  Next: nnmairix keyboard shortcuts,  Prev: Setting up mairix,  Up: nnmairix

8.2.5 Configuring nnmairix
--------------------------

In group mode, type `G b c'
(`nnmairix-create-server-and-default-group').  This will ask you for all
necessary information and create a `nnmairix' server as a foreign
server.  You will have to specify the following:

   * The *name* of the `nnmairix' server--choose whatever you want.

   * The name of the *back end server* where mairix should store its
     searches.  This must be a full server name, like `nnml:mymail'.
     Just hit `TAB' to see the available servers.  Currently, servers
     which are accessed through `nnmaildir', `nnimap' and `nnml' are
     supported.  As explained above, for locally stored mails, this can
     be an existing server where you store your mails.  However, you
     can also create e.g. a new `nnmaildir' or `nnml' server
     exclusively for `nnmairix' in your secondary select methods (*note
     Finding the News::).  If you use a secondary `nnml' server just
     for mairix, make sure that you explicitly set the server variable
     `nnml-get-new-mail' to `nil', or you might lose mail (*note
     nnmairix caveats::).  If you want to use mairix remotely on an
     IMAP server, you have to choose the corresponding `nnimap' server
     here.

   * The *command* to call the mairix binary.  This will usually just
     be `mairix', but you can also choose something like `ssh SERVER
     mairix' if you want to call mairix remotely, e.g. on your IMAP
     server.  If you want to add some default options to mairix, you
     could do this here, but better use the variable
     `nnmairix-mairix-search-options' instead.

   * The name of the *default search group*.  This will be the group
     where all temporary mairix searches are stored, i.e. all searches
     which are not bound to permanent `nnmairix' groups.  Choose
     whatever you like.

   * If the mail back end is `nnimap' or `nnmaildir', you will be asked
     if you work with *Maildir++*, i.e. with hidden maildir folders
     (=beginning with a dot).  For example, you have to answer `yes'
     here if you work with the Dovecot IMAP server.  Otherwise, you
     should answer `no' here.



File: gnus,  Node: nnmairix keyboard shortcuts,  Next: Propagating marks,  Prev: Configuring nnmairix,  Up: nnmairix

8.2.6 nnmairix keyboard shortcuts
---------------------------------

In group mode:

`G b c'
     Creates `nnmairix' server and default search group for this server
     (`nnmairix-create-server-and-default-group').  You should have done
     this by now (*note Configuring nnmairix::).

`G b s'
     Prompts for query which is then sent to the mairix binary.  Search
     results are put into the default search group which is
     automatically displayed (`nnmairix-search').

`G b m'
     Allows you to create a mairix search or a permanent group more
     comfortably using graphical widgets, similar to a customization
     group.  Just try it to see how it works (`nnmairix-widget-search').

`G b i'
     Another command for creating a mairix query more comfortably, but
     uses only the minibuffer (`nnmairix-search-interactive').

`G b g'
     Creates a permanent group which is associated with a search query
     (`nnmairix-create-search-group').  The `nnmairix' back end
     automatically calls mairix when you update this group with `g' or
     `M-g'.

`G b q'
     Changes the search query for the `nnmairix' group under cursor
     (`nnmairix-group-change-query-this-group').

`G b t'
     Toggles the 'threads' parameter for the `nnmairix' group under
     cursor, i.e.  if you want see the whole threads of the found
     messages (`nnmairix-group-toggle-threads-this-group').

`G b u'
     Calls mairix binary for updating the database
     (`nnmairix-update-database').  The default parameters are `-F' and
     `-Q' for making this as fast as possible (see variable
     `nnmairix-mairix-update-options' for defining these default
     options).

`G b r'
     Keep articles in this `nnmairix' group always read or unread, or
     leave the marks unchanged
     (`nnmairix-group-toggle-readmarks-this-group').

`G b d'
     Recreate `nnmairix' group on the "real" mail back end
     (`nnmairix-group-delete-recreate-this-group').  You can do this if
     you always get wrong article counts with a `nnmairix' group.

`G b a'
     Toggles the `allow-fast' parameters for group under cursor
     (`nnmairix-group-toggle-allowfast-this-group').  The default
     behavior of `nnmairix' is to do a mairix search every time you
     update or enter the group.  With the `allow-fast' parameter set,
     mairix will only be called when you explicitly update the group,
     but not upon entering.  This makes entering the group faster, but
     it may also lead to dangling symlinks if something changed between
     updating and entering the group which is not yet in the mairix
     database.

`G b p'
     Toggle marks propagation for this group
     (`nnmairix-group-toggle-propmarks-this-group').  (*note
     Propagating marks::).

`G b o'
     Manually propagate marks (`nnmairix-propagate-marks'); needed only
     when `nnmairix-propagate-marks-upon-close' is set to `nil'.


   In summary mode:

`$ m'
     Allows you to create a mairix query or group based on the current
     message using graphical widgets (same as `nnmairix-widget-search')
     (`nnmairix-widget-search-from-this-article').

`$ g'
     Interactively creates a new search group with query based on the
     current message, but uses the minibuffer instead of graphical
     widgets (`nnmairix-create-search-group-from-message').

`$ t'
     Searches thread for the current article
     (`nnmairix-search-thread-this-article').  This is effectively a
     shortcut for calling `nnmairix-search' with `m:msgid' of the
     current article and enabled threads.

`$ f'
     Searches all messages from sender of the current article
     (`nnmairix-search-from-this-article').  This is a shortcut for
     calling `nnmairix-search' with `f:From'.

`$ o'
     (Only in `nnmairix' groups!) Tries determine the group this article
     originally came from and displays the article in this group, so
     that e.g. replying to this article the correct posting styles/group
     parameters are applied (`nnmairix-goto-original-article').  This
     function will use the registry if available, but can also parse the
     article file name as a fallback method.

`$ u'
     Remove possibly existing tick mark from original article
     (`nnmairix-remove-tick-mark-original-article').  (*note nnmairix
     tips and tricks::).



File: gnus,  Node: Propagating marks,  Next: nnmairix tips and tricks,  Prev: nnmairix keyboard shortcuts,  Up: nnmairix

8.2.7 Propagating marks
-----------------------

First of: you really need a patched mairix binary for using the marks
propagation feature efficiently. Otherwise, you would have to update
the mairix database all the time. You can get the patch at

   `http://www.randomsample.de/mairix-maildir-patch.tar'

   You need the mairix v0.21 source code for this patch; everything else
is explained in the accompanied readme file. If you don't want to use
marks propagation, you don't have to apply these patches, but they also
fix some annoyances regarding changing maildir flags, so it might still
be useful to you.

   With the patched mairix binary, you can use `nnmairix' as an
alternative to mail splitting (*note Fancy Mail Splitting::). For
example, instead of splitting all mails from `david@foobar.com' into a
group, you can simply create a search group with the query
`f:david@foobar.com'. This is actually what "smart folders" are all
about: simply put everything in one mail folder and dynamically create
searches instead of splitting. This is more flexible, since you can
dynamically change your folders any time you want to. This also implies
that you will usually read your mails in the `nnmairix' groups instead
of your "real" mail groups.

   There is one problem, though: say you got a new mail from
`david@foobar.com'; it will now show up in two groups, the "real" group
(your INBOX, for example) and in the `nnmairix' search group (provided
you have updated the mairix database). Now you enter the `nnmairix'
group and read the mail. The mail will be marked as read, but only in
the `nnmairix' group--in the "real" mail group it will be still shown
as unread.

   You could now catch up the mail group (*note Group Data::), but this
is tedious and error prone, since you may overlook mails you don't have
created `nnmairix' groups for. Of course, you could first use
`nnmairix-goto-original-article' (*note nnmairix keyboard shortcuts::)
and then read the mail in the original group, but that's even more
cumbersome.

   Clearly, the easiest way would be if marks could somehow be
automatically set for the original article. This is exactly what _marks
propagation_ is about.

   Marks propagation is inactive by default. You can activate it for a
certain `nnmairix' group with
`nnmairix-group-toggle-propmarks-this-group' (bound to `G b p'). This
function will warn you if you try to use it with your default search
group; the reason is that the default search group is used for
temporary searches, and it's easy to accidentally propagate marks from
this group. However, you can ignore this warning if you really want to.

   With marks propagation enabled, all the marks you set in a `nnmairix'
group should now be propagated to the original article. For example,
you can now tick an article (by default with `!') and this mark should
magically be set for the original article, too.

   A few more remarks which you may or may not want to know:

   Marks will not be set immediately, but only upon closing a group.
This not only makes marks propagation faster, it also avoids problems
with dangling symlinks when dealing with maildir files (since changing
flags will change the file name). You can also control when to
propagate marks via `nnmairix-propagate-marks-upon-close' (see the
doc-string for details).

   Obviously, `nnmairix' will have to look up the original group for
every article you want to set marks for. If available, `nnmairix' will
first use the registry for determining the original group. The registry
is very fast, hence you should really, really enable the registry when
using marks propagation. If you don't have to worry about RAM and disc
space, set `gnus-registry-max-entries' to a large enough value; to be on
the safe side, choose roughly the amount of mails you index with mairix.

   If you don't want to use the registry or the registry hasn't seen the
original article yet, `nnmairix' will use an additional mairix search
for determining the file name of the article. This, of course, is way
slower than the registry--if you set hundreds or even thousands of
marks this way, it might take some time. You can avoid this situation by
setting `nnmairix-only-use-registry' to t.

   Maybe you also want to propagate marks the other way round, i.e. if
you tick an article in a "real" mail group, you'd like to have the same
article in a `nnmairix' group ticked, too. For several good reasons,
this can only be done efficiently if you use maildir. To immediately
contradict myself, let me mention that it WON'T work with `nnmaildir',
since `nnmaildir' stores the marks externally and not in the file name.
Therefore, propagating marks to `nnmairix' groups will usually only
work if you use an IMAP server which uses maildir as its file format.

   If you work with this setup, just set
`nnmairix-propagate-marks-to-nnmairix-groups' to `t' and see what
happens. If you don't like what you see, just set it to `nil' again. One
problem might be that you get a wrong number of unread articles; this
usually happens when you delete or expire articles in the original
groups. When this happens, you can recreate the `nnmairix' group on the
back end using `G b d'.


File: gnus,  Node: nnmairix tips and tricks,  Next: nnmairix caveats,  Prev: Propagating marks,  Up: nnmairix

8.2.8 nnmairix tips and tricks
------------------------------

   * Checking Mail

     I put all my important mail groups at group level 1. The mairix
     groups have group level 5, so they do not get checked at start up
     (*note Group Levels::).

     I use the following to check for mails:

          (defun my-check-mail-mairix-update (level)
            (interactive "P")
            ;; if no prefix given, set level=1
            (gnus-group-get-new-news (or level 1))
            (nnmairix-update-groups "mairixsearch" t t)
            (gnus-group-list-groups))

          (define-key gnus-group-mode-map "g" 'my-check-mail-mairix-update)

     Instead of `"mairixsearch"' use the name of your `nnmairix'
     server. See the doc string for `nnmairix-update-groups' for
     details.

   * Example: search group for ticked articles

     For example, you can create a group for all ticked articles, where
     the articles always stay unread:

     Hit `G b g', enter group name (e.g. `important'), use `F:f' as
     query and do not include threads.

     Now activate marks propagation for this group by using `G b p'.
     Then activate the always-unread feature by using `G b r' twice.

     So far so good--but how do you remove the tick marks in the
     `nnmairix' group?  There are two options: You may simply use
     `nnmairix-remove-tick-mark-original-article' (bound to `$ u') to
     remove tick marks from the original article. The other possibility
     is to set `nnmairix-propagate-marks-to-nnmairix-groups' to `t',
     but see the above comments about this option.  If it works for
     you, the tick marks should also exist in the `nnmairix' group and
     you can remove them as usual, e.g. by marking an article as read.

     When you have removed a tick mark from the original article, this
     article should vanish from the `nnmairix' group after you have
     updated the mairix database and updated the group.  Fortunately,
     there is a function for doing exactly that:
     `nnmairix-update-groups'. See the previous code snippet and the
     doc string for details.

   * Dealing with auto-subscription of mail groups

     As described before, all `nnmairix' groups are in fact stored on
     the mail back end in the form `zz_mairix-<NAME>-<NUMBER>'. You can
     see them when you enter the back end server in the server buffer.
     You should not subscribe these groups! Unfortunately, these groups
     will usually get _auto-subscribed_ when you use `nnmaildir' or
     `nnml', i.e. you will suddenly see groups of the form `zz_mairix*'
     pop up in your group buffer. If this happens to you, simply kill
     these groups with C-k.  For avoiding this, turn off
     auto-subscription completely by setting the variable
     `gnus-auto-subscribed-groups' to `nil' (*note Filtering New
     Groups::), or if you like to keep this feature use the following
     kludge for turning it off for all groups beginning with `zz_':

          (setq gnus-auto-subscribed-groups
                "^\\(nnml\\|nnfolder\\|nnmbox\\|nnmh\\|nnbabyl\\|nnmaildir\\).*:\\([^z]\\|z$\\|\\z[^z]\\|zz$\\|zz[^_]\\|zz_$\\).*")



File: gnus,  Node: nnmairix caveats,  Prev: nnmairix tips and tricks,  Up: nnmairix

8.2.9 nnmairix caveats
----------------------

   * You can create a secondary `nnml' server just for nnmairix, but
     then you have to explicitly set the corresponding server variable
     `nnml-get-new-mail' to `nil'.  Otherwise, new mail might get put
     into this secondary server (and would never show up again).  Here's
     an example server definition:

          (nnml "mairix" (nnml-directory "mairix") (nnml-get-new-mail nil))

     (The `nnmaildir' back end also has a server variable
     `get-new-mail', but its default value is `nil', so you don't have
     to explicitly set it if you use a `nnmaildir' server just for
     mairix.)

   * If you use the Gnus registry: don't use the registry with
     `nnmairix' groups (put them in `gnus-registry-unfollowed-groups';
     this is the default).  Be _extra careful_ if you use
     `gnus-registry-split-fancy-with-parent'; mails which are split
     into `nnmairix' groups are usually gone for good as soon as you
     check the group for new mail (yes, it has happened to me...).

   * Therefore: _Never ever_ put "real" mails into `nnmairix' groups
     (you shouldn't be able to, anyway).

   * If you use the Gnus agent (*note Gnus Unplugged::): don't agentize
     `nnmairix' groups (though I have no idea what happens if you do).

   * mairix does only support us-ascii characters.

   * `nnmairix' uses a rather brute force method to force Gnus to
     completely reread the group on the mail back end after mairix was
     called--it simply deletes and re-creates the group on the mail
     back end. So far, this has worked for me without any problems, and
     I don't see how `nnmairix' could delete other mail groups than its
     own, but anyway: you really should have a backup of your mail
     folders.

   * All necessary information is stored in the group parameters (*note
     Group Parameters::). This has the advantage that no active file is
     needed, but also implies that when you kill a `nnmairix' group, it
     is gone for good.

   * If you create and kill a lot of `nnmairix' groups, the
     "zz_mairix-*" groups will accumulate on the mail back end server.
     To delete old groups which are no longer needed, call
     `nnmairix-purge-old-groups'. Note that this assumes that you don't
     save any "real" mail in folders of the form
     `zz_mairix-<NAME>-<NUMBER>'. You can change the prefix of
     `nnmairix' groups by changing the variable `nnmairix-group-prefix'.

   * The following only applies if you _don't_ use the mentioned patch
     for mairix (*note Propagating marks::):

     A problem can occur when using `nnmairix' with maildir folders and
     comes with the fact that maildir stores mail flags like `Seen' or
     `Replied' by appending chars `S' and `R' to the message file name,
     respectively. This implies that currently you would have to update
     the mairix database not only when new mail arrives, but also when
     mail flags are changing. The same applies to new mails which are
     indexed while they are still in the `new' folder but then get
     moved to `cur' when Gnus has seen the mail. If you don't update
     the database after this has happened, a mairix query can lead to
     symlinks pointing to non-existing files. In Gnus, these messages
     will usually appear with "(none)" entries in the header and can't
     be accessed. If this happens to you, using `G b u' and updating
     the group will usually fix this.



File: gnus,  Node: Various,  Next: The End,  Prev: Searching,  Up: Top

9 Various
*********

* Menu:

* Process/Prefix::              A convention used by many treatment commands.
* Interactive::                 Making Gnus ask you many questions.
* Symbolic Prefixes::           How to supply some Gnus functions with options.
* Formatting Variables::        You can specify what buffers should look like.
* Window Layout::               Configuring the Gnus buffer windows.
* Faces and Fonts::             How to change how faces look.
* Compilation::                 How to speed Gnus up.
* Mode Lines::                  Displaying information in the mode lines.
* Highlighting and Menus::      Making buffers look all nice and cozy.
* Daemons::                     Gnus can do things behind your back.
* Undo::                        Some actions can be undone.
* Predicate Specifiers::        Specifying predicates.
* Moderation::                  What to do if you're a moderator.
* Fetching a Group::            Starting Gnus just to read a group.
* Image Enhancements::          Modern versions of Emacs/XEmacs can display images.
* Fuzzy Matching::              What's the big fuzz?
* Thwarting Email Spam::        Simple ways to avoid unsolicited commercial email.
* Spam Package::                A package for filtering and processing spam.
* The Gnus Registry::           A package for tracking messages by Message-ID.
* Other modes::                 Interaction with other modes.
* Various Various::             Things that are really various.


File: gnus,  Node: Process/Prefix,  Next: Interactive,  Up: Various

9.1 Process/Prefix
==================

Many functions, among them functions for moving, decoding and saving
articles, use what is known as the "Process/Prefix convention".

   This is a method for figuring out what articles the user wants the
command to be performed on.

   It goes like this:

   If the numeric prefix is N, perform the operation on the next N
articles, starting with the current one.  If the numeric prefix is
negative, perform the operation on the previous N articles, starting
with the current one.

   If `transient-mark-mode' in non-`nil' and the region is active, all
articles in the region will be worked upon.

   If there is no numeric prefix, but some articles are marked with the
process mark, perform the operation on the articles marked with the
process mark.

   If there is neither a numeric prefix nor any articles marked with the
process mark, just perform the operation on the current article.

   Quite simple, really, but it needs to be made clear so that surprises
are avoided.

   Commands that react to the process mark will push the current list of
process marked articles onto a stack and will then clear all process
marked articles.  You can restore the previous configuration with the
`M P y' command (*note Setting Process Marks::).

   One thing that seems to shock & horrify lots of people is that, for
instance, `3 d' does exactly the same as `d' `d' `d'.  Since each `d'
(which marks the current article as read) by default goes to the next
unread article after marking, this means that `3 d' will mark the next
three unread articles as read, no matter what the summary buffer looks
like.  Set `gnus-summary-goto-unread' to `nil' for a more
straightforward action.

   Many commands do not use the process/prefix convention.  All commands
that do explicitly say so in this manual.  To apply the process/prefix
convention to commands that do not use it, you can use the `M-&'
command.  For instance, to mark all the articles in the group as
expirable, you could say `M P b M-& E'.


File: gnus,  Node: Interactive,  Next: Symbolic Prefixes,  Prev: Process/Prefix,  Up: Various

9.2 Interactive
===============

`gnus-novice-user'
     If this variable is non-`nil', you are either a newcomer to the
     World of Usenet, or you are very cautious, which is a nice thing
     to be, really.  You will be given questions of the type "Are you
     sure you want to do this?" before doing anything dangerous.  This
     is `t' by default.

`gnus-expert-user'
     If this variable is non-`nil', you will seldom be asked any
     questions by Gnus.  It will simply assume you know what you're
     doing, no matter how strange.  For example, quitting Gnus, exiting
     a group without an update, catching up with a group, deleting
     expired articles, and replying by mail to a news message will not
     require confirmation.

`gnus-interactive-catchup'
     Require confirmation before catching up a group if non-`nil'.  It
     is `t' by default.

`gnus-interactive-exit'
     If non-`nil', require a confirmation when exiting Gnus.  If
     `quiet', update any active summary buffers automatically without
     querying.  The default value is `t'.


File: gnus,  Node: Symbolic Prefixes,  Next: Formatting Variables,  Prev: Interactive,  Up: Various

9.3 Symbolic Prefixes
=====================

Quite a lot of Emacs commands react to the (numeric) prefix.  For
instance, `C-u 4 C-f' moves point four characters forward, and `C-u 9 0
0 I s s p' adds a permanent `Subject' substring score rule of 900 to
the current article.

   This is all nice and well, but what if you want to give a command
some additional information?  Well, what most commands do is interpret
the "raw" prefix in some special way.  `C-u 0 C-x C-s' means that one
doesn't want a backup file to be created when saving the current buffer,
for instance.  But what if you want to save without making a backup
file, and you want Emacs to flash lights and play a nice tune at the
same time?  You can't, and you're probably perfectly happy that way.

   I'm not, so I've added a second prefix--the "symbolic prefix".  The
prefix key is `M-i' (`gnus-symbolic-argument'), and the next character
typed in is the value.  You can stack as many `M-i' prefixes as you
want.  `M-i a C-M-u' means "feed the `C-M-u' command the symbolic
prefix `a'".  `M-i a M-i b C-M-u' means "feed the `C-M-u' command the
symbolic prefixes `a' and `b'".  You get the drift.

   Typing in symbolic prefixes to commands that don't accept them
doesn't hurt, but it doesn't do any good either.  Currently not many
Gnus functions make use of the symbolic prefix.

   If you're interested in how Gnus implements this, *note Extended
Interactive::.


File: gnus,  Node: Formatting Variables,  Next: Window Layout,  Prev: Symbolic Prefixes,  Up: Various

9.4 Formatting Variables
========================

Throughout this manual you've probably noticed lots of variables called
things like `gnus-group-line-format' and
`gnus-summary-mode-line-format'.  These control how Gnus is to output
lines in the various buffers.  There's quite a lot of them.
Fortunately, they all use the same syntax, so there's not that much to
be annoyed by.

   Here's an example format spec (from the group buffer): `%M%S%5y:
%(%g%)\n'.  We see that it is indeed extremely ugly, and that there are
lots of percentages everywhere.

* Menu:

* Formatting Basics::           A formatting variable is basically a format string.
* Mode Line Formatting::        Some rules about mode line formatting variables.
* Advanced Formatting::         Modifying output in various ways.
* User-Defined Specs::          Having Gnus call your own functions.
* Formatting Fonts::            Making the formatting look colorful and nice.
* Positioning Point::           Moving point to a position after an operation.
* Tabulation::                  Tabulating your output.
* Wide Characters::             Dealing with wide characters.

   Currently Gnus uses the following formatting variables:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format', `gnus-summary-mode-line-format',
`gnus-article-mode-line-format', `gnus-server-mode-line-format', and
`gnus-summary-pick-line-format'.

   All these format variables can also be arbitrary elisp forms.  In
that case, they will be `eval'ed to insert the required lines.

   Gnus includes a command to help you while creating your own format
specs.  `M-x gnus-update-format' will `eval' the current form, update
the spec in question and pop you to a buffer where you can examine the
resulting Lisp code to be run to generate the line.


File: gnus,  Node: Formatting Basics,  Next: Mode Line Formatting,  Up: Formatting Variables

9.4.1 Formatting Basics
-----------------------

Each `%' element will be replaced by some string or other when the
buffer in question is generated.  `%5y' means "insert the `y' spec, and
pad with spaces to get a 5-character field".

   As with normal C and Emacs Lisp formatting strings, the numerical
modifier between the `%' and the formatting type character will "pad"
the output so that it is always at least that long.  `%5y' will make
the field always (at least) five characters wide by padding with spaces
to the left.  If you say `%-5y', it will pad to the right instead.

   You may also wish to limit the length of the field to protect against
particularly wide values.  For that you can say `%4,6y', which means
that the field will never be more than 6 characters wide and never less
than 4 characters wide.

   Also Gnus supports some extended format specifications, such as
`%&user-date;'.


File: gnus,  Node: Mode Line Formatting,  Next: Advanced Formatting,  Prev: Formatting Basics,  Up: Formatting Variables

9.4.2 Mode Line Formatting
--------------------------

Mode line formatting variables (e.g., `gnus-summary-mode-line-format')
follow the same rules as other, buffer line oriented formatting
variables (*note Formatting Basics::) with the following two
differences:

  1. There must be no newline (`\n') at the end.

  2. The special `%%b' spec can be used to display the buffer name.
     Well, it's no spec at all, really--`%%' is just a way to quote `%'
     to allow it to pass through the formatting machinery unmangled, so
     that Emacs receives `%b', which is something the Emacs mode line
     display interprets to mean "show the buffer name".  For a full
     list of mode line specs Emacs understands, see the documentation
     of the `mode-line-format' variable.



File: gnus,  Node: Advanced Formatting,  Next: User-Defined Specs,  Prev: Mode Line Formatting,  Up: Formatting Variables

9.4.3 Advanced Formatting
-------------------------

It is frequently useful to post-process the fields in some way.
Padding, limiting, cutting off parts and suppressing certain values can
be achieved by using "tilde modifiers".  A typical tilde spec might
look like `%~(cut 3)~(ignore "0")y'.

   These are the valid modifiers:

`pad'
`pad-left'
     Pad the field to the left with spaces until it reaches the required
     length.

`pad-right'
     Pad the field to the right with spaces until it reaches the
     required length.

`max'
`max-left'
     Cut off characters from the left until it reaches the specified
     length.

`max-right'
     Cut off characters from the right until it reaches the specified
     length.

`cut'
`cut-left'
     Cut off the specified number of characters from the left.

`cut-right'
     Cut off the specified number of characters from the right.

`ignore'
     Return an empty string if the field is equal to the specified
     value.

`form'
     Use the specified form as the field value when the `@' spec is
     used.

     Here's an example:

          "~(form (current-time-string))@"


   Let's take an example.  The `%o' spec in the summary mode lines will
return a date in compact ISO8601 format--`19960809T230410'.  This is
quite a mouthful, so we want to shave off the century number and the
time, leaving us with a six-character date.  That would be `%~(cut-left
2)~(max-right 6)~(pad 6)o'.  (Cutting is done before maxing, and we
need the padding to ensure that the date is never less than 6
characters to make it look nice in columns.)

   Ignoring is done first; then cutting; then maxing; and then as the
very last operation, padding.

   If you use lots of these advanced thingies, you'll find that Gnus
gets quite slow.  This can be helped enormously by running `M-x
gnus-compile' when you are satisfied with the look of your lines.
*Note Compilation::.


File: gnus,  Node: User-Defined Specs,  Next: Formatting Fonts,  Prev: Advanced Formatting,  Up: Formatting Variables

9.4.4 User-Defined Specs
------------------------

All the specs allow for inserting user defined specifiers--`u'.  The
next character in the format string should be a letter.  Gnus will call
the function `gnus-user-format-function-'`X', where `X' is the letter
following `%u'.  The function will be passed a single parameter--what
the parameter means depends on what buffer it's being called from.  The
function should return a string, which will be inserted into the buffer
just like information from any other specifier.  This function may also
be called with dummy values, so it should protect against that.

   Also Gnus supports extended user-defined specs, such as `%u&foo;'.
Gnus will call the function `gnus-user-format-function-'`foo'.

   You can also use tilde modifiers (*note Advanced Formatting:: to
achieve much the same without defining new functions.  Here's an
example: `%~(form (count-lines (point-min) (point)))@'.  The form given
here will be evaluated to yield the current line number, and then
inserted.


File: gnus,  Node: Formatting Fonts,  Next: Positioning Point,  Prev: User-Defined Specs,  Up: Formatting Variables

9.4.5 Formatting Fonts
----------------------

There are specs for highlighting, and these are shared by all the format
variables.  Text inside the `%(' and `%)' specifiers will get the
special `mouse-face' property set, which means that it will be
highlighted (with `gnus-mouse-face') when you put the mouse pointer
over it.

   Text inside the `%{' and `%}' specifiers will have their normal
faces set using `gnus-face-0', which is `bold' by default.  If you say
`%1{', you'll get `gnus-face-1' instead, and so on.  Create as many
faces as you wish.  The same goes for the `mouse-face' specs--you can
say `%3(hello%)' to have `hello' mouse-highlighted with
`gnus-mouse-face-3'.

   Text inside the `%<<' and `%>>' specifiers will get the special
`balloon-help' property set to `gnus-balloon-face-0'.  If you say
`%1<<', you'll get `gnus-balloon-face-1' and so on.  The
`gnus-balloon-face-*' variables should be either strings or symbols
naming functions that return a string.  When the mouse passes over text
with this property set, a balloon window will appear and display the
string.  Please refer to *note Tooltips: (emacs)Tooltips, (in Emacs) or
the doc string of `balloon-help-mode' (in XEmacs) for more information
on this.  (For technical reasons, the guillemets have been approximated
as `<<' and `>>' in this paragraph.)

   Here's an alternative recipe for the group buffer:

     ;; Create three face types.
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; We want the article count to be in
     ;; a bold and green face.  So we create
     ;; a new face called `my-green-bold'.
     (copy-face 'bold 'my-green-bold)
     ;; Set the color.
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; Set the new & fancy format.
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

   I'm sure you'll be able to use this scheme to create totally
unreadable and extremely vulgar displays.  Have fun!

   Note that the `%(' specs (and friends) do not make any sense on the
mode-line variables.


File: gnus,  Node: Positioning Point,  Next: Tabulation,  Prev: Formatting Fonts,  Up: Formatting Variables

9.4.6 Positioning Point
-----------------------

Gnus usually moves point to a pre-defined place on each line in most
buffers.  By default, point move to the first colon character on the
line.  You can customize this behavior in three different ways.

   You can move the colon character to somewhere else on the line.

   You can redefine the function that moves the point to the colon.  The
function is called `gnus-goto-colon'.

   But perhaps the most convenient way to deal with this, if you don't
want to have a colon in your line, is to use the `%*' specifier.  If you
put a `%*' somewhere in your format line definition, Gnus will place
point there.


File: gnus,  Node: Tabulation,  Next: Wide Characters,  Prev: Positioning Point,  Up: Formatting Variables

9.4.7 Tabulation
----------------

You can usually line up your displays by padding and cutting your
strings.  However, when combining various strings of different size, it
can often be more convenient to just output the strings, and then worry
about lining up the following text afterwards.

   To do that, Gnus supplies tabulator specs--`%='.  There are two
different types--"hard tabulators" and "soft tabulators".

   `%50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, nothing will be inserted.  This
is the soft tabulator.

   `%-50=' will insert space characters to pad the line up to column
50.  If the text is already past column 50, the excess text past column
50 will be removed.  This is the hard tabulator.


File: gnus,  Node: Wide Characters,  Prev: Tabulation,  Up: Formatting Variables

9.4.8 Wide Characters
---------------------

Fixed width fonts in most countries have characters of the same width.
Some countries, however, use Latin characters mixed with wider
characters--most notable East Asian countries.

   The problem is that when formatting, Gnus assumes that if a string
is 10 characters wide, it'll be 10 Latin characters wide on the screen.
In these countries, that's not true.

   To help fix this, you can set `gnus-use-correct-string-widths' to
`t'.  This makes buffer generation slower, but the results will be
prettier.  The default value under XEmacs is `t' but `nil' for Emacs.


File: gnus,  Node: Window Layout,  Next: Faces and Fonts,  Prev: Formatting Variables,  Up: Various

9.5 Window Layout
=================

No, there's nothing here about X, so be quiet.

   If `gnus-use-full-window' non-`nil', Gnus will delete all other
windows and occupy the entire Emacs screen by itself.  It is `t' by
default.

   Setting this variable to `nil' kinda works, but there are glitches.
Use at your own peril.

   `gnus-buffer-configuration' describes how much space each Gnus
buffer should be given.  Here's an excerpt of this variable:

     ((group (vertical 1.0 (group 1.0 point)))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

   This is an alist.  The "key" is a symbol that names some action or
other.  For instance, when displaying the group buffer, the window
configuration function will use `group' as the key.  A full list of
possible names is listed below.

   The "value" (i.e., the "split") says how much space each buffer
should occupy.  To take the `article' split as an example -

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

   This "split" says that the summary buffer should occupy 25% of upper
half of the screen, and that it is placed over the article buffer.  As
you may have noticed, 100% + 25% is actually 125% (yup, I saw y'all
reaching for that calculator there).  However, the special number `1.0'
is used to signal that this buffer should soak up all the rest of the
space available after the rest of the buffers have taken whatever they
need.  There should be only one buffer with the `1.0' size spec per
split.

   Point will be put in the buffer that has the optional third element
`point'.  In a `frame' split, the last subsplit having a leaf split
where the tag `frame-focus' is a member (i.e. is the third or fourth
element in the list, depending on whether the `point' tag is present)
gets focus.

   Here's a more complicated example:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (article 1.0)))

   If the size spec is an integer instead of a floating point number,
then that number will be used to say how many lines a buffer should
occupy, not a percentage.

   If the "split" looks like something that can be `eval'ed (to be
precise--if the `car' of the split is a function or a subr), this split
will be `eval'ed.  If the result is non-`nil', it will be used as a
split.

   Not complicated enough for you?  Well, try this on for size:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0))
                  (vertical 1.0
                      (summary 0.25 point)
                      (article 1.0))))

   Whoops.  Two buffers with the mystery 100% tag.  And what's that
`horizontal' thingie?

   If the first element in one of the split is `horizontal', Gnus will
split the window horizontally, giving you two windows side-by-side.
Inside each of these strips you may carry on all you like in the normal
fashion.  The number following `horizontal' says what percentage of the
screen is to be given to this strip.

   For each split, there _must_ be one element that has the 100% tag.
The splitting is never accurate, and this buffer will eat any leftover
lines from the splits.

   To be slightly more formal, here's a definition of what a valid split
may look like:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

   The limitations are that the `frame' split can only appear as the
top-level split.  FORM should be an Emacs Lisp form that should return
a valid split.  We see that each split is fully recursive, and may
contain any number of `vertical' and `horizontal' splits.

   Finding the right sizes can be a bit complicated.  No window may be
less than `gnus-window-min-height' (default 1) characters high, and all
windows must be at least `gnus-window-min-width' (default 1) characters
wide.  Gnus will try to enforce this before applying the splits.  If
you want to use the normal Emacs window width/height limit, you can
just set these two variables to `nil'.

   If you're not familiar with Emacs terminology, `horizontal' and
`vertical' splits may work the opposite way of what you'd expect.
Windows inside a `horizontal' split are shown side-by-side, and windows
within a `vertical' split are shown above each other.

   If you want to experiment with window placement, a good tip is to
call `gnus-configure-frame' directly with a split.  This is the function
that does all the real work when splitting buffers.  Below is a pretty
nonsensical configuration with 5 windows; two for the group buffer and
three for the article buffer.  (I said it was nonsensical.)  If you
`eval' the statement below, you can get an idea of how that would look
straight away, without going through the normal Gnus channels.  Play
with it until you're satisfied, and then use `gnus-add-configuration'
to add your new creation to the buffer configuration list.

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

   You might want to have several frames as well.  No prob--just use the
`frame' split:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))

   This split will result in the familiar summary/article window
configuration in the first (or "main") frame, while a small additional
frame will be created where picons will be shown.  As you can see,
instead of the normal `1.0' top-level spec, each additional split
should have a frame parameter alist as the size spec.  *Note Frame
Parameters: (elisp)Frame Parameters.  Under XEmacs, a frame property
list will be accepted, too--for instance, `(height 5 width 15 left -1
top 1)' is such a plist.  The list of all possible keys for
`gnus-buffer-configuration' can be found in its default value.

   Note that the `message' key is used for both `gnus-group-mail' and
`gnus-summary-mail-other-window'.  If it is desirable to distinguish
between the two, something like this might be used:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

   One common desire for a multiple frame split is to have a separate
frame for composing mail and news while leaving the original frame
intact.  To accomplish that, something like the following can be done:

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

   Since the `gnus-buffer-configuration' variable is so long and
complicated, there's a function you can use to ease changing the config
of a single setting: `gnus-add-configuration'.  If, for instance, you
want to change the `article' setting, you could say:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

   You'd typically stick these `gnus-add-configuration' calls in your
`~/.gnus.el' file or in some startup hook--they should be run after
Gnus has been loaded.

   If all windows mentioned in the configuration are already visible,
Gnus won't change the window configuration.  If you always want to
force the "right" window configuration, you can set
`gnus-always-force-window-configuration' to non-`nil'.

   If you're using tree displays (*note Tree Display::), and the tree
window is displayed vertically next to another window, you may also want
to fiddle with `gnus-tree-minimize-window' to avoid having the windows
resized.

9.5.1 Window Configuration Names
--------------------------------

Here's a list of most of the currently known window configurations, and
when they're used:

`group'
     The group buffer.

`summary'
     Entering a group and showing only the summary.

`article'
     Selecting an article.

`server'
     The server buffer.

`browse'
     Browsing groups from the server buffer.

`message'
     Composing a (new) message.

`only-article'
     Showing only the article buffer.

`edit-article'
     Editing an article.

`edit-form'
     Editing group parameters and the like.

`edit-score'
     Editing a server definition.

`post'
     Composing a news message.

`reply'
     Replying or following up an article without yanking the text.

`forward'
     Forwarding a message.

`reply-yank'
     Replying or following up an article with yanking the text.

`mail-bound'
     Bouncing a message.

`pipe'
     Sending an article to an external process.

`bug'
     Sending a bug report.

`score-trace'
     Displaying the score trace.

`score-words'
     Displaying the score words.

`split-trace'
     Displaying the split trace.

`compose-bounce'
     Composing a bounce message.

`mml-preview'
     Previewing a MIME part.


9.5.2 Example Window Configurations
-----------------------------------

   * Narrow left hand side occupied by group buffer.  Right hand side
     split between summary buffer (top one-sixth) and article buffer
     (bottom).

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))



File: gnus,  Node: Faces and Fonts,  Next: Compilation,  Prev: Window Layout,  Up: Various

9.6 Faces and Fonts
===================

Fiddling with fonts and faces used to be very difficult, but these days
it is very simple.  You simply say `M-x customize-face', pick out the
face you want to alter, and alter it via the standard Customize
interface.


File: gnus,  Node: Compilation,  Next: Mode Lines,  Prev: Faces and Fonts,  Up: Various

9.7 Compilation
===============

Remember all those line format specification variables?
`gnus-summary-line-format', `gnus-group-line-format', and so on.  Now,
Gnus will of course heed whatever these variables are, but,
unfortunately, changing them will mean a quite significant slow-down.
(The default values of these variables have byte-compiled functions
associated with them, while the user-generated versions do not, of
course.)

   To help with this, you can run `M-x gnus-compile' after you've
fiddled around with the variables and feel that you're (kind of)
satisfied.  This will result in the new specs being byte-compiled, and
you'll get top speed again.  Gnus will save these compiled specs in the
`.newsrc.eld' file.  (User-defined functions aren't compiled by this
function, though--you should compile them yourself by sticking them
into the `~/.gnus.el' file and byte-compiling that file.)


File: gnus,  Node: Mode Lines,  Next: Highlighting and Menus,  Prev: Compilation,  Up: Various

9.8 Mode Lines
==============

`gnus-updated-mode-lines' says what buffers should keep their mode
lines updated.  It is a list of symbols.  Supported symbols include
`group', `article', `summary', `server', `browse', and `tree'.  If the
corresponding symbol is present, Gnus will keep that mode line updated
with information that may be pertinent.  If this variable is `nil',
screen refresh may be quicker.

   By default, Gnus displays information on the current article in the
mode lines of the summary and article buffers.  The information Gnus
wishes to display (e.g. the subject of the article) is often longer
than the mode lines, and therefore have to be cut off at some point.
The `gnus-mode-non-string-length' variable says how long the other
elements on the line is (i.e., the non-info part).  If you put
additional elements on the mode line (e.g. a clock), you should modify
this variable:

     (add-hook 'display-time-hook
               (lambda () (setq gnus-mode-non-string-length
                                (+ 21
                                   (if line-number-mode 5 0)
                                   (if column-number-mode 4 0)
                                   (length display-time-string)))))

   If this variable is `nil' (which is the default), the mode line
strings won't be chopped off, and they won't be padded either.  Note
that the default is unlikely to be desirable, as even the percentage
complete in the buffer may be crowded off the mode line; the user should
configure this variable appropriately for her configuration.


File: gnus,  Node: Highlighting and Menus,  Next: Daemons,  Prev: Mode Lines,  Up: Various

9.9 Highlighting and Menus
==========================

The `gnus-visual' variable controls most of the Gnus-prettifying
aspects.  If `nil', Gnus won't attempt to create menus or use fancy
colors or fonts.  This will also inhibit loading the `gnus-vis.el' file.

   This variable can be a list of visual properties that are enabled.
The following elements are valid, and are all included by default:

`group-highlight'
     Do highlights in the group buffer.

`summary-highlight'
     Do highlights in the summary buffer.

`article-highlight'
     Do highlights in the article buffer.

`highlight'
     Turn on highlighting in all buffers.

`group-menu'
     Create menus in the group buffer.

`summary-menu'
     Create menus in the summary buffers.

`article-menu'
     Create menus in the article buffer.

`browse-menu'
     Create menus in the browse buffer.

`server-menu'
     Create menus in the server buffer.

`score-menu'
     Create menus in the score buffers.

`menu'
     Create menus in all buffers.

   So if you only want highlighting in the article buffer and menus in
all buffers, you could say something like:

     (setq gnus-visual '(article-highlight menu))

   If you want highlighting only and no menus whatsoever, you'd say:

     (setq gnus-visual '(highlight))

   If `gnus-visual' is `t', highlighting and menus will be used in all
Gnus buffers.

   Other general variables that influence the look of all buffers
include:

`gnus-mouse-face'
     This is the face (i.e., font) used for mouse highlighting in Gnus.
     No mouse highlights will be done if `gnus-visual' is `nil'.


   There are hooks associated with the creation of all the different
menus:

`gnus-article-menu-hook'
     Hook called after creating the article mode menu.

`gnus-group-menu-hook'
     Hook called after creating the group mode menu.

`gnus-summary-menu-hook'
     Hook called after creating the summary mode menu.

`gnus-server-menu-hook'
     Hook called after creating the server mode menu.

`gnus-browse-menu-hook'
     Hook called after creating the browse mode menu.

`gnus-score-menu-hook'
     Hook called after creating the score mode menu.



File: gnus,  Node: Daemons,  Next: Undo,  Prev: Highlighting and Menus,  Up: Various

9.10 Daemons
============

Gnus, being larger than any program ever written (allegedly), does lots
of strange stuff that you may wish to have done while you're not
present.  For instance, you may want it to check for new mail once in a
while.  Or you may want it to close down all connections to all servers
when you leave Emacs idle.  And stuff like that.

   Gnus will let you do stuff like that by defining various "handlers".
Each handler consists of three elements:  A FUNCTION, a TIME, and an
IDLE parameter.

   Here's an example of a handler that closes connections when Emacs has
been idle for thirty minutes:

     (gnus-demon-close-connections nil 30)

   Here's a handler that scans for PGP headers every hour when Emacs is
idle:

     (gnus-demon-scan-pgp 60 t)

   This TIME parameter and that IDLE parameter work together in a
strange, but wonderful fashion.  Basically, if IDLE is `nil', then the
function will be called every TIME minutes.

   If IDLE is `t', then the function will be called after TIME minutes
only if Emacs is idle.  So if Emacs is never idle, the function will
never be called.  But once Emacs goes idle, the function will be called
every TIME minutes.

   If IDLE is a number and TIME is a number, the function will be
called every TIME minutes only when Emacs has been idle for IDLE
minutes.

   If IDLE is a number and TIME is `nil', the function will be called
once every time Emacs has been idle for IDLE minutes.

   And if TIME is a string, it should look like `07:31', and the
function will then be called once every day somewhere near that time.
Modified by the IDLE parameter, of course.

   (When I say "minute" here, I really mean `gnus-demon-timestep'
seconds.  This is 60 by default.  If you change that variable, all the
timings in the handlers will be affected.)

   So, if you want to add a handler, you could put something like this
in your `~/.gnus.el' file:

     (gnus-demon-add-handler 'gnus-demon-close-connections 30 t)

   Some ready-made functions to do this have been created:
`gnus-demon-add-disconnection', `gnus-demon-add-nntp-close-connection',
`gnus-demon-add-scan-timestamps', `gnus-demon-add-rescan', and
`gnus-demon-add-scanmail'.  Just put those functions in your
`~/.gnus.el' if you want those abilities.

   If you add handlers to `gnus-demon-handlers' directly, you should
run `gnus-demon-init' to make the changes take hold.  To cancel all
daemons, you can use the `gnus-demon-cancel' function.

   Note that adding daemons can be pretty naughty if you over do it.
Adding functions that scan all news and mail from all servers every two
seconds is a sure-fire way of getting booted off any respectable
system.  So behave.


File: gnus,  Node: Undo,  Next: Predicate Specifiers,  Prev: Daemons,  Up: Various

9.11 Undo
=========

It is very useful to be able to undo actions one has done.  In normal
Emacs buffers, it's easy enough--you just push the `undo' button.  In
Gnus buffers, however, it isn't that simple.

   The things Gnus displays in its buffer is of no value whatsoever to
Gnus--it's all just data designed to look nice to the user.  Killing a
group in the group buffer with `C-k' makes the line disappear, but
that's just a side-effect of the real action--the removal of the group
in question from the internal Gnus structures.  Undoing something like
that can't be done by the normal Emacs `undo' function.

   Gnus tries to remedy this somewhat by keeping track of what the user
does and coming up with actions that would reverse the actions the user
takes.  When the user then presses the `undo' key, Gnus will run the
code to reverse the previous action, or the previous actions.  However,
not all actions are easily reversible, so Gnus currently offers a few
key functions to be undoable.  These include killing groups, yanking
groups, and changing the list of read articles of groups.  That's it,
really.  More functions may be added in the future, but each added
function means an increase in data to be stored, so Gnus will never be
totally undoable.

   The undoability is provided by the `gnus-undo-mode' minor mode.  It
is used if `gnus-use-undo' is non-`nil', which is the default.  The
`C-M-_' key performs the `gnus-undo' command, which should feel kinda
like the normal Emacs `undo' command.


File: gnus,  Node: Predicate Specifiers,  Next: Moderation,  Prev: Undo,  Up: Various

9.12 Predicate Specifiers
=========================

Some Gnus variables are "predicate specifiers".  This is a special form
that allows flexible specification of predicates without having to type
all that much.

   These specifiers are lists consisting of functions, symbols and
lists.

   Here's an example:

     (or gnus-article-unseen-p
         gnus-article-unread-p)

   The available symbols are `or', `and' and `not'.  The functions all
take one parameter.

   Internally, Gnus calls `gnus-make-predicate' on these specifiers to
create a function that can be called.  This input parameter to this
function will be passed along to all the functions in the predicate
specifier.


File: gnus,  Node: Moderation,  Next: Fetching a Group,  Prev: Predicate Specifiers,  Up: Various

9.13 Moderation
===============

If you are a moderator, you can use the `gnus-mdrtn.el' package.  It is
not included in the standard Gnus package.  Write a mail to
`larsi@gnus.org' and state what group you moderate, and you'll get a
copy.

   The moderation package is implemented as a minor mode for summary
buffers.  Put

     (add-hook 'gnus-summary-mode-hook 'gnus-moderate)

   in your `~/.gnus.el' file.

   If you are the moderator of `rec.zoofle', this is how it's supposed
to work:

  1. You split your incoming mail by matching on
     `Newsgroups:.*rec.zoofle', which will put all the to-be-posted
     articles in some mail group--for instance, `nnml:rec.zoofle'.

  2. You enter that group once in a while and post articles using the
     `e' (edit-and-post) or `s' (just send unedited) commands.

  3. If, while reading the `rec.zoofle' newsgroup, you happen upon some
     articles that weren't approved by you, you can cancel them with the
     `c' command.

   To use moderation mode in these two groups, say:

     (setq gnus-moderated-list
           "^nnml:rec.zoofle$\\|^rec.zoofle$")


File: gnus,  Node: Fetching a Group,  Next: Image Enhancements,  Prev: Moderation,  Up: Various

9.14 Fetching a Group
=====================

It is sometimes convenient to be able to just say "I want to read this
group and I don't care whether Gnus has been started or not".  This is
perhaps more useful for people who write code than for users, but the
command `gnus-fetch-group' provides this functionality in any case.  It
takes the group name as a parameter.


File: gnus,  Node: Image Enhancements,  Next: Fuzzy Matching,  Prev: Fetching a Group,  Up: Various

9.15 Image Enhancements
=======================

XEmacs, as well as Emacs 21(1) and up, are able to display pictures and
stuff, so Gnus has taken advantage of that.

* Menu:

* X-Face::                      Display a funky, teensy black-and-white image.
* Face::                        Display a funkier, teensier colored image.
* Smileys::                     Show all those happy faces the way they were meant to be shown.
* Picons::                      How to display pictures of what you're reading.
* Gravatars::                   Display the avatar of people you read.
* XVarious::                    Other XEmacsy Gnusey variables.

   ---------- Footnotes ----------

   (1) Emacs 21 on MS Windows doesn't support images, Emacs 22 does.


File: gnus,  Node: X-Face,  Next: Face,  Up: Image Enhancements

9.15.1 X-Face
-------------

`X-Face' headers describe a 48x48 pixel black-and-white (1 bit depth)
image that's supposed to represent the author of the message.  It seems
to be supported by an ever-growing number of mail and news readers.

   Viewing an `X-Face' header either requires an Emacs that has
`compface' support (which most XEmacs versions have), or that you have
suitable conversion or display programs installed.  If your Emacs has
image support the default action is to display the face before the
`From' header.  If there's no native `X-Face' support, Gnus will try to
convert the `X-Face' header using external programs from the `pbmplus'
package and friends, see below.  For XEmacs it's faster if XEmacs has
been compiled with `X-Face' support.  The default action under Emacs
without image support is to fork off the `display' program.

   On a GNU/Linux system, the `display' program is included in the
ImageMagick package.  For external conversion programs look for packages
with names like `netpbm', `libgr-progs' and `compface'.  On Windows,
you may use the packages `netpbm' and `compface' from
`http://gnuwin32.sourceforge.net'.  You need to add the `bin' directory
to your `PATH' environment variable.

   The variable `gnus-article-x-face-command' controls which programs
are used to display the `X-Face' header.  If this variable is a string,
this string will be executed in a sub-shell.  If it is a function, this
function will be called with the face as the argument.  If
`gnus-article-x-face-too-ugly' (which is a regexp) matches the `From'
header, the face will not be shown.

   (Note: `x-face' is used in the variable/function names, not `xface').

Face and variable:

`gnus-x-face'
     Face to show X-Face.  The colors from this face are used as the
     foreground and background colors of the displayed X-Faces.  The
     default colors are black and white.

`gnus-face-properties-alist'
     Alist of image types and properties applied to Face (*note Face::)
     and X-Face images.  The default value is `((pbm . (:face
     gnus-x-face)) (png . nil))' for Emacs or `((xface . (:face
     gnus-x-face)))' for XEmacs.  Here are examples:

          ;; Specify the altitude of Face and X-Face images in the From header.
          (setq gnus-face-properties-alist
                '((pbm . (:face gnus-x-face :ascent 80))
                  (png . (:ascent 80))))

          ;; Show Face and X-Face images as pressed buttons.
          (setq gnus-face-properties-alist
                '((pbm . (:face gnus-x-face :relief -2))
                  (png . (:relief -2))))

     *note Image Descriptors: (elisp)Image Descriptors. for the valid
     properties for various image types.  Currently, `pbm' is used for
     X-Face images and `png' is used for Face images in Emacs.  Only
     the `:face' property is effective on the `xface' image type in
     XEmacs if it is built with the `libcompface' library.

   If you use posting styles, you can use an `x-face-file' entry in
`gnus-posting-styles', *Note Posting Styles::.  If you don't, Gnus
provides a few convenience functions and variables to allow easier
insertion of X-Face headers in outgoing messages.  You also need the
above mentioned ImageMagick, netpbm or other image conversion packages
(depending the values of the variables below) for these functions.

   `gnus-random-x-face' goes through all the `pbm' files in
`gnus-x-face-directory' and picks one at random, and then converts it
to the X-Face format by using the `gnus-convert-pbm-to-x-face-command'
shell command.  The `pbm' files should be 48x48 pixels big.  It returns
the X-Face header data as a string.

   `gnus-insert-random-x-face-header' calls `gnus-random-x-face' and
inserts a `X-Face' header with the randomly generated data.

   `gnus-x-face-from-file' takes a GIF file as the parameter, and then
converts the file to X-Face format by using the
`gnus-convert-image-to-x-face-command' shell command.

   Here's how you would typically use the first function.  Put something
like the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . gnus-random-x-face))))

   Using the last function would be something like this:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . (lambda ()
                                     (gnus-x-face-from-file
                                      "~/My-face.gif"))))))


File: gnus,  Node: Face,  Next: Smileys,  Prev: X-Face,  Up: Image Enhancements

9.15.2 Face
-----------

`Face' headers are essentially a funkier version of `X-Face' ones. They
describe a 48x48 pixel colored image that's supposed to represent the
author of the message.

   The contents of a `Face' header must be a base64 encoded PNG image.
See `http://quimby.gnus.org/circus/face/' for the precise
specifications.

   The `gnus-face-properties-alist' variable affects the appearance of
displayed Face images.  *Note X-Face::.

   Viewing a `Face' header requires an Emacs that is able to display
PNG images.

   Gnus provides a few convenience functions and variables to allow
easier insertion of Face headers in outgoing messages.

   `gnus-convert-png-to-face' takes a 48x48 PNG image, no longer than
726 bytes long, and converts it to a face.

   `gnus-face-from-file' takes a JPEG file as the parameter, and then
converts the file to Face format by using the
`gnus-convert-image-to-face-command' shell command.

   Here's how you would typically use this function. Put something like
the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(Face . (lambda ()
                                   (gnus-face-from-file "~/face.jpg"))))))


File: gnus,  Node: Smileys,  Next: Picons,  Prev: Face,  Up: Image Enhancements

9.15.3 Smileys
--------------

"Smiley" is a package separate from Gnus, but since Gnus is currently
the only package that uses Smiley, it is documented here.

   In short--to use Smiley in Gnus, put the following in your
`~/.gnus.el' file:

     (setq gnus-treat-display-smileys t)

   Smiley maps text smiley faces--`:-)', `8-)', `:-(' and the like--to
pictures and displays those instead of the text smiley faces.  The
conversion is controlled by a list of regexps that matches text and
maps that to file names.

   The alist used is specified by the `smiley-regexp-alist' variable.
The first item in each element is the regexp to be matched; the second
element is the regexp match group that is to be replaced by the
picture; and the third element is the name of the file to be displayed.

   The following variables customize the appearance of the smileys:

`smiley-style'
     Specifies the smiley style.  Predefined smiley styles include
     `low-color' (small 13x14 pixel, three-color images), `medium'
     (more colorful images, 16x16 pixel), and `grayscale' (grayscale
     images, 14x14 pixel).  The default depends on the height of the
     default face.

`smiley-data-directory'
     Where Smiley will look for smiley faces files.  You shouldn't set
     this variable anymore.  Customize `smiley-style' instead.

`gnus-smiley-file-types'
     List of suffixes on smiley file names to try.



File: gnus,  Node: Picons,  Next: Gravatars,  Prev: Smileys,  Up: Image Enhancements

9.15.4 Picons
-------------

So...  You want to slow down your news reader even more!  This is a
good way to do so.  It's also a great way to impress people staring
over your shoulder as you read news.

   What are Picons?  To quote directly from the Picons Web site:

     "Picons" is short for "personal icons".  They're small,
     constrained images used to represent users and domains on the net,
     organized into databases so that the appropriate image for a given
     e-mail address can be found.  Besides users and domains, there are
     picon databases for Usenet newsgroups and weather forecasts.  The
     picons are in either monochrome `XBM' format or color `XPM' and
     `GIF' formats.

   For instructions on obtaining and installing the picons databases,
point your Web browser at
`http://www.cs.indiana.edu/picons/ftp/index.html'.

   If you are using Debian GNU/Linux, saying `apt-get install picons.*'
will install the picons where Gnus can find them.

   To enable displaying picons, simply make sure that
`gnus-picon-databases' points to the directory containing the Picons
databases.

   The variable `gnus-picon-style' controls how picons are displayed.
If `inline', the textual representation is replaced.  If `right',
picons are added right to the textual representation.

   The following variables offer control over where things are located.

`gnus-picon-databases'
     The location of the picons database.  This is a list of directories
     containing the `news', `domains', `users' (and so on)
     subdirectories.  Defaults to `("/usr/lib/picon"
     "/usr/local/faces")'.

`gnus-picon-news-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     newsgroups faces.  `("news")' is the default.

`gnus-picon-user-directories'
     List of subdirectories to search in `gnus-picon-databases' for user
     faces.  `("users" "usenix" "local" "misc")' is the default.

`gnus-picon-domain-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     domain name faces.  Defaults to `("domains")'.  Some people may
     want to add `"unknown"' to this list.

`gnus-picon-file-types'
     Ordered list of suffixes on picon file names to try.  Defaults to
     `("xpm" "gif" "xbm")' minus those not built-in your Emacs.

`gnus-picon-inhibit-top-level-domains'
     If non-`nil' (which is the default), don't display picons for
     things like `.net' and `.de', which aren't usually very
     interesting.



File: gnus,  Node: Gravatars,  Next: XVarious,  Prev: Picons,  Up: Image Enhancements

9.15.5 Gravatars
----------------

A gravatar is an image registered to an e-mail address.

   You can submit yours on-line at `http://www.gravatar.com'.

   The following variables offer control over how things are displayed.

`gnus-gravatar-size'
     The size in pixels of gravatars. Gravatars are always square, so
     one number for the size is enough.

`gnus-gravatar-properties'
     List of image properties applied to Gravatar images.

`gnus-gravatar-too-ugly'
     Regexp that matches mail addresses or names of people of which
     avatars should not be displayed, or `nil'.  It default to the
     value of `gnus-article-x-face-too-ugly' (*note X-Face::).


   If you want to see them in the From field, set:
     (setq gnus-treat-from-gravatar 'head)

   If you want to see them in the Cc and To fields, set:

     (setq gnus-treat-mail-gravatar 'head)


File: gnus,  Node: XVarious,  Prev: Gravatars,  Up: Image Enhancements

9.15.6 Various XEmacs Variables
-------------------------------

`gnus-xmas-glyph-directory'
     This is where Gnus will look for pictures.  Gnus will normally
     auto-detect this directory, but you may set it manually if you
     have an unusual directory structure.

`gnus-xmas-modeline-glyph'
     A glyph displayed in all Gnus mode lines.  It is a tiny gnu head by
     default.


9.15.6.1 Toolbar
................

`gnus-use-toolbar'
     This variable specifies the position to display the toolbar.  If
     `nil', don't display toolbars.  If it is non-`nil', it should be
     one of the symbols `default', `top', `bottom', `right', and
     `left'.  `default' means to use the default toolbar, the rest mean
     to display the toolbar on the place which those names show.  The
     default is `default'.

`gnus-toolbar-thickness'
     Cons of the height and the width specifying the thickness of a
     toolbar.  The height is used for the toolbar displayed on the top
     or the bottom, the width is used for the toolbar displayed on the
     right or the left.  The default is that of the default toolbar.

`gnus-group-toolbar'
     The toolbar in the group buffer.

`gnus-summary-toolbar'
     The toolbar in the summary buffer.

`gnus-summary-mail-toolbar'
     The toolbar in the summary buffer of mail groups.



File: gnus,  Node: Fuzzy Matching,  Next: Thwarting Email Spam,  Prev: Image Enhancements,  Up: Various

9.16 Fuzzy Matching
===================

Gnus provides "fuzzy matching" of `Subject' lines when doing things
like scoring, thread gathering and thread comparison.

   As opposed to regular expression matching, fuzzy matching is very
fuzzy.  It's so fuzzy that there's not even a definition of what
"fuzziness" means, and the implementation has changed over time.

   Basically, it tries to remove all noise from lines before comparing.
`Re: ', parenthetical remarks, white space, and so on, are filtered out
of the strings before comparing the results.  This often leads to
adequate results--even when faced with strings generated by text
manglers masquerading as newsreaders.


File: gnus,  Node: Thwarting Email Spam,  Next: Spam Package,  Prev: Fuzzy Matching,  Up: Various

9.17 Thwarting Email Spam
=========================

In these last days of the Usenet, commercial vultures are hanging about
and grepping through news like crazy to find email addresses they can
foist off their scams and products to.  As a reaction to this, many
people have started putting nonsense addresses into their `From' lines.
I think this is counterproductive--it makes it difficult for people to
send you legitimate mail in response to things you write, as well as
making it difficult to see who wrote what.  This rewriting may perhaps
be a bigger menace than the unsolicited commercial email itself in the
end.

   The biggest problem I have with email spam is that it comes in under
false pretenses.  I press `g' and Gnus merrily informs me that I have
10 new emails.  I say "Golly gee!  Happy is me!" and select the mail
group, only to find two pyramid schemes, seven advertisements ("New!
Miracle tonic for growing full, lustrous hair on your toes!")  and one
mail asking me to repent and find some god.

   This is annoying.  Here's what you can do about it.

* Menu:

* The problem of spam::         Some background, and some solutions
* Anti-Spam Basics::            Simple steps to reduce the amount of spam.
* SpamAssassin::                How to use external anti-spam tools.
* Hashcash::                    Reduce spam by burning CPU time.


File: gnus,  Node: The problem of spam,  Next: Anti-Spam Basics,  Up: Thwarting Email Spam

9.17.1 The problem of spam
--------------------------

First, some background on spam.

   If you have access to e-mail, you are familiar with spam (technically
termed UCE, Unsolicited Commercial E-mail).  Simply put, it exists
because e-mail delivery is very cheap compared to paper mail, so only a
very small percentage of people need to respond to an UCE to make it
worthwhile to the advertiser.  Ironically, one of the most common spams
is the one offering a database of e-mail addresses for further
spamming.  Senders of spam are usually called _spammers_, but terms
like _vermin_, _scum_, _sociopaths_, and _morons_ are in common use as
well.

   Spam comes from a wide variety of sources.  It is simply impossible
to dispose of all spam without discarding useful messages.  A good
example is the TMDA system, which requires senders unknown to you to
confirm themselves as legitimate senders before their e-mail can reach
you.  Without getting into the technical side of TMDA, a downside is
clearly that e-mail from legitimate sources may be discarded if those
sources can't or won't confirm themselves through the TMDA system.
Another problem with TMDA is that it requires its users to have a basic
understanding of e-mail delivery and processing.

   The simplest approach to filtering spam is filtering, at the mail
server or when you sort through incoming mail.  If you get 200 spam
messages per day from `random-address@vmadmin.com', you block
`vmadmin.com'.  If you get 200 messages about `VIAGRA', you discard all
messages with `VIAGRA' in the message.  If you get lots of spam from
Bulgaria, for example, you try to filter all mail from Bulgarian IPs.

   This, unfortunately, is a great way to discard legitimate e-mail.
The risks of blocking a whole country (Bulgaria, Norway, Nigeria, China,
etc.) or even a continent (Asia, Africa, Europe, etc.) from contacting
you should be obvious, so don't do it if you have the choice.

   In another instance, the very informative and useful RISKS digest has
been blocked by overzealous mail filters because it *contained* words
that were common in spam messages.  Nevertheless, in isolated cases,
with great care, direct filtering of mail can be useful.

   Another approach to filtering e-mail is the distributed spam
processing, for instance DCC implements such a system.  In essence, N
systems around the world agree that a machine X in Ghana, Estonia, or
California is sending out spam e-mail, and these N systems enter X or
the spam e-mail from X into a database.  The criteria for spam
detection vary--it may be the number of messages sent, the content of
the messages, and so on.  When a user of the distributed processing
system wants to find out if a message is spam, he consults one of those
N systems.

   Distributed spam processing works very well against spammers that
send a large number of messages at once, but it requires the user to
set up fairly complicated checks.  There are commercial and free
distributed spam processing systems.  Distributed spam processing has
its risks as well.  For instance legitimate e-mail senders have been
accused of sending spam, and their web sites and mailing lists have
been shut down for some time because of the incident.

   The statistical approach to spam filtering is also popular.  It is
based on a statistical analysis of previous spam messages.  Usually the
analysis is a simple word frequency count, with perhaps pairs of words
or 3-word combinations thrown into the mix.  Statistical analysis of
spam works very well in most of the cases, but it can classify
legitimate e-mail as spam in some cases.  It takes time to run the
analysis, the full message must be analyzed, and the user has to store
the database of spam analysis.  Statistical analysis on the server is
gaining popularity.  This has the advantage of letting the user Just
Read Mail, but has the disadvantage that it's harder to tell the server
that it has misclassified mail.

   Fighting spam is not easy, no matter what anyone says.  There is no
magic switch that will distinguish Viagra ads from Mom's e-mails.  Even
people are having a hard time telling spam apart from non-spam, because
spammers are actively looking to fool us into thinking they are Mom,
essentially.  Spamming is irritating, irresponsible, and idiotic
behavior from a bunch of people who think the world owes them a favor.
We hope the following sections will help you in fighting the spam
plague.


File: gnus,  Node: Anti-Spam Basics,  Next: SpamAssassin,  Prev: The problem of spam,  Up: Thwarting Email Spam

9.17.2 Anti-Spam Basics
-----------------------

One way of dealing with spam is having Gnus split out all spam into a
`spam' mail group (*note Splitting Mail::).

   First, pick one (1) valid mail address that you can be reached at,
and put it in your `From' header of all your news articles.  (I've
chosen `larsi@trym.ifi.uio.no', but for many addresses on the form
`larsi+usenet@ifi.uio.no' will be a better choice.  Ask your sysadmin
whether your sendmail installation accepts keywords in the local part
of the mail address.)

     (setq message-default-news-headers
           "From: Lars Magne Ingebrigtsen <larsi@trym.ifi.uio.no>\n")

   Then put the following split rule in `nnmail-split-fancy' (*note
Fancy Mail Splitting::):

     (...
      (to "larsi@trym.ifi.uio.no"
          (| ("subject" "re:.*" "misc")
             ("references" ".*@.*" "misc")
             "spam"))
      ...)

   This says that all mail to this address is suspect, but if it has a
`Subject' that starts with a `Re:' or has a `References' header, it's
probably ok.  All the rest goes to the `spam' group.  (This idea
probably comes from Tim Pierce.)

   In addition, many mail spammers talk directly to your SMTP server
and do not include your email address explicitly in the `To' header.
Why they do this is unknown--perhaps it's to thwart this thwarting
scheme?  In any case, this is trivial to deal with--you just put
anything not addressed to you in the `spam' group by ending your fancy
split rule in this way:

     (
      ...
      (to "larsi" "misc")
      "spam")

   In my experience, this will sort virtually everything into the right
group.  You still have to check the `spam' group from time to time to
check for legitimate mail, though.  If you feel like being a good net
citizen, you can even send off complaints to the proper authorities on
each unsolicited commercial email--at your leisure.

   This works for me.  It allows people an easy way to contact me (they
can just press `r' in the usual way), and I'm not bothered at all with
spam.  It's a win-win situation.  Forging `From' headers to point to
non-existent domains is yucky, in my opinion.

   Be careful with this approach.  Spammers are wise to it.


File: gnus,  Node: SpamAssassin,  Next: Hashcash,  Prev: Anti-Spam Basics,  Up: Thwarting Email Spam

9.17.3 SpamAssassin, Vipul's Razor, DCC, etc
--------------------------------------------

The days where the hints in the previous section were sufficient in
avoiding spam are coming to an end.  There are many tools out there
that claim to reduce the amount of spam you get.  This section could
easily become outdated fast, as new products replace old, but
fortunately most of these tools seem to have similar interfaces.  Even
though this section will use SpamAssassin as an example, it should be
easy to adapt it to most other tools.

   Note that this section does not involve the `spam.el' package, which
is discussed in the next section.  If you don't care for all the
features of `spam.el', you can make do with these simple recipes.

   If the tool you are using is not installed on the mail server, you
need to invoke it yourself.  Ideas on how to use the `:postscript' mail
source parameter (*note Mail Source Specifiers::) follow.

     (setq mail-sources
           '((file :prescript "formail -bs spamassassin < /var/mail/%u")
             (pop :user "jrl"
                  :server "pophost"
                  :postscript
                  "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))

   Once you manage to process your incoming spool somehow, thus making
the mail contain e.g. a header indicating it is spam, you are ready to
filter it out.  Using normal split methods (*note Splitting Mail::):

     (setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                                  ...))

   Or using fancy split methods (*note Fancy Mail Splitting::):

     (setq nnmail-split-methods 'nnmail-split-fancy
           nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                                  ...))

   Some people might not like the idea of piping the mail through
various programs using a `:prescript' (if some program is buggy, you
might lose all mail).  If you are one of them, another solution is to
call the external tools during splitting.  Example fancy split method:

     (setq nnmail-split-fancy '(| (: kevin-spamassassin)
                                  ...))
     (defun kevin-spamassassin ()
       (save-excursion
         (save-restriction
           (widen)
           (if (eq 1 (call-process-region (point-min) (point-max)
                                          "spamc" nil nil nil "-c"))
               "spam"))))

   Note that with the nnimap back end, message bodies will not be
downloaded by default.  You need to set `nnimap-split-download-body' to
`t' to do that (*note Client-Side IMAP Splitting::).

   That is about it.  As some spam is likely to get through anyway, you
might want to have a nifty function to call when you happen to read
spam.  And here is the nifty function:

     (defun my-gnus-raze-spam ()
       "Submit SPAM to Vipul's Razor, then mark it as expirable."
       (interactive)
       (gnus-summary-save-in-pipe "razor-report -f -d" t)
       (gnus-summary-mark-as-expirable 1))


File: gnus,  Node: Hashcash,  Prev: SpamAssassin,  Up: Thwarting Email Spam

9.17.4 Hashcash
---------------

A novel technique to fight spam is to require senders to do something
costly and demonstrably unique for each message they send.  This has
the obvious drawback that you cannot rely on everyone in the world
using this technique, since it is not part of the Internet standards,
but it may be useful in smaller communities.

   While the tools in the previous section work well in practice, they
work only because the tools are constantly maintained and updated as
new form of spam appears.  This means that a small percentage of spam
will always get through.  It also means that somewhere, someone needs
to read lots of spam to update these tools.  Hashcash avoids that, but
instead prefers that everyone you contact through e-mail supports the
scheme.  You can view the two approaches as pragmatic vs dogmatic.  The
approaches have their own advantages and disadvantages, but as often in
the real world, a combination of them is stronger than either one of
them separately.

   The "something costly" is to burn CPU time, more specifically to
compute a hash collision up to a certain number of bits.  The resulting
hashcash cookie is inserted in a `X-Hashcash:' header.  For more
details, and for the external application `hashcash' you need to
install to use this feature, see `http://www.hashcash.org/'.  Even more
information can be found at `http://www.camram.org/'.

   If you wish to generate hashcash for each message you send, you can
customize `message-generate-hashcash' (*note Mail Headers:
(message)Mail Headers.), as in:

     (setq message-generate-hashcash t)

   You will need to set up some additional variables as well:

`hashcash-default-payment'
     This variable indicates the default number of bits the hash
     collision should consist of.  By default this is 20.  Suggested
     useful values include 17 to 29.

`hashcash-payment-alist'
     Some receivers may require you to spend burn more CPU time than the
     default.  This variable contains a list of `(ADDR AMOUNT)' cells,
     where ADDR is the receiver (email address or newsgroup) and AMOUNT
     is the number of bits in the collision that is needed.  It can
     also contain `(ADDR STRING AMOUNT)' cells, where the STRING is the
     string to use (normally the email address or newsgroup name is
     used).

`hashcash-path'
     Where the `hashcash' binary is installed.  This variable should be
     automatically set by `executable-find', but if it's `nil' (usually
     because the `hashcash' binary is not in your path) you'll get a
     warning when you check hashcash payments and an error when you
     generate hashcash payments.


   Gnus can verify hashcash cookies, although this can also be done by
hand customized mail filtering scripts.  To verify a hashcash cookie in
a message, use the `mail-check-payment' function in the `hashcash.el'
library.  You can also use the `spam.el' package with the
`spam-use-hashcash' back end to validate hashcash cookies in incoming
mail and filter mail accordingly (*note Anti-spam Hashcash Payments::).


File: gnus,  Node: Spam Package,  Next: The Gnus Registry,  Prev: Thwarting Email Spam,  Up: Various

9.18 Spam Package
=================

The Spam package provides Gnus with a centralized mechanism for
detecting and filtering spam.  It filters new mail, and processes
messages according to whether they are spam or ham.  ("Ham" is the name
used throughout this manual to indicate non-spam messages.)

* Menu:

* Spam Package Introduction::
* Filtering Incoming Mail::
* Detecting Spam in Groups::
* Spam and Ham Processors::
* Spam Package Configuration Examples::
* Spam Back Ends::
* Extending the Spam package::
* Spam Statistics Package::


File: gnus,  Node: Spam Package Introduction,  Next: Filtering Incoming Mail,  Up: Spam Package

9.18.1 Spam Package Introduction
--------------------------------

You must read this section to understand how the Spam package works.
Do not skip, speed-read, or glance through this section.

   Make sure you read the section on the `spam.el' sequence of events.
See *Note Extending the Spam package::.

   To use the Spam package, you *must* first run the function
`spam-initialize':

     (spam-initialize)

   This autoloads `spam.el' and installs the various hooks necessary to
let the Spam package do its job.  In order to make use of the Spam
package, you have to set up certain group parameters and variables,
which we will describe below.  All of the variables controlling the
Spam package can be found in the `spam' customization group.

   There are two "contact points" between the Spam package and the rest
of Gnus: checking new mail for spam, and leaving a group.

   Checking new mail for spam is done in one of two ways: while
splitting incoming mail, or when you enter a group.

   The first way, checking for spam while splitting incoming mail, is
suited to mail back ends such as `nnml' or `nnimap', where new mail
appears in a single spool file.  The Spam package processes incoming
mail, and sends mail considered to be spam to a designated "spam"
group.  *Note Filtering Incoming Mail::.

   The second way is suited to back ends such as `nntp', which have no
incoming mail spool, or back ends where the server is in charge of
splitting incoming mail.  In this case, when you enter a Gnus group,
the unseen or unread messages in that group are checked for spam.
Detected spam messages are marked as spam.  *Note Detecting Spam in
Groups::.

   In either case, you have to tell the Spam package what method to use
to detect spam messages.  There are several methods, or "spam back
ends" (not to be confused with Gnus back ends!) to choose from: spam
"blacklists" and "whitelists", dictionary-based filters, and so forth.
*Note Spam Back Ends::.

   In the Gnus summary buffer, messages that have been identified as
spam always appear with a `$' symbol.

   The Spam package divides Gnus groups into three categories: ham
groups, spam groups, and unclassified groups.  You should mark each of
the groups you subscribe to as either a ham group or a spam group,
using the `spam-contents' group parameter (*note Group Parameters::).
Spam groups have a special property: when you enter a spam group, all
unseen articles are marked as spam.  Thus, mail split into a spam group
is automatically marked as spam.

   Identifying spam messages is only half of the Spam package's job.
The second half comes into play whenever you exit a group buffer.  At
this point, the Spam package does several things:

   First, it calls "spam and ham processors" to process the articles
according to whether they are spam or ham.  There is a pair of spam and
ham processors associated with each spam back end, and what the
processors do depends on the back end.  At present, the main role of
spam and ham processors is for dictionary-based spam filters: they add
the contents of the messages in the group to the filter's dictionary,
to improve its ability to detect future spam.  The `spam-process' group
parameter specifies what spam processors to use.  *Note Spam and Ham
Processors::.

   If the spam filter failed to mark a spam message, you can mark it
yourself, so that the message is processed as spam when you exit the
group:

`$'
`M-d'
`M s x'
`S x'
     Mark current article as spam, showing it with the `$' mark
     (`gnus-summary-mark-as-spam').

Similarly, you can unmark an article if it has been erroneously marked
as spam.  *Note Setting Marks::.

   Normally, a ham message found in a non-ham group is not processed as
ham--the rationale is that it should be moved into a ham group for
further processing (see below).  However, you can force these articles
to be processed as ham by setting `spam-process-ham-in-spam-groups' and
`spam-process-ham-in-nonham-groups'.

   The second thing that the Spam package does when you exit a group is
to move ham articles out of spam groups, and spam articles out of ham
groups.  Ham in a spam group is moved to the group specified by the
variable `gnus-ham-process-destinations', or the group parameter
`ham-process-destination'.  Spam in a ham group is moved to the group
specified by the variable `gnus-spam-process-destinations', or the
group parameter `spam-process-destination'.  If these variables are not
set, the articles are left in their current group.  If an article
cannot be moved (e.g., with a read-only backend such as NNTP), it is
copied.

   If an article is moved to another group, it is processed again when
you visit the new group.  Normally, this is not a problem, but if you
want each article to be processed only once, load the
`gnus-registry.el' package and set the variable `spam-log-to-registry'
to `t'.  *Note Spam Package Configuration Examples::.

   Normally, spam groups ignore `gnus-spam-process-destinations'.
However, if you set `spam-move-spam-nonspam-groups-only' to `nil', spam
will also be moved out of spam groups, depending on the
`spam-process-destination' parameter.

   The final thing the Spam package does is to mark spam articles as
expired, which is usually the right thing to do.

   If all this seems confusing, don't worry.  Soon it will be as natural
as typing Lisp one-liners on a neural interface... err, sorry, that's
50 years in the future yet.  Just trust us, it's not so bad.


File: gnus,  Node: Filtering Incoming Mail,  Next: Detecting Spam in Groups,  Prev: Spam Package Introduction,  Up: Spam Package

9.18.2 Filtering Incoming Mail
------------------------------

To use the Spam package to filter incoming mail, you must first set up
fancy mail splitting.  *Note Fancy Mail Splitting::.  The Spam package
defines a special splitting function that you can add to your fancy
split variable (either `nnmail-split-fancy' or `nnimap-split-fancy',
depending on your mail back end):

     (: spam-split)

The `spam-split' function scans incoming mail according to your chosen
spam back end(s), and sends messages identified as spam to a spam
group.  By default, the spam group is a group named `spam', but you can
change this by customizing `spam-split-group'.  Make sure the contents
of `spam-split-group' are an unqualified group name.  For instance, in
an `nnimap' server `your-server', the value `spam' means
`nnimap+your-server:spam'.  The value `nnimap+server:spam' is therefore
wrong--it gives the group `nnimap+your-server:nnimap+server:spam'.

   `spam-split' does not modify the contents of messages in any way.

   Note for IMAP users: if you use the `spam-check-bogofilter',
`spam-check-ifile', and `spam-check-stat' spam back ends, you should
also set the variable `nnimap-split-download-body' to `t'.  These spam
back ends are most useful when they can "scan" the full message body.
By default, the nnimap back end only retrieves the message headers;
`nnimap-split-download-body' tells it to retrieve the message bodies as
well.  We don't set this by default because it will slow IMAP down, and
that is not an appropriate decision to make on behalf of the user.
*Note Client-Side IMAP Splitting::.

   You have to specify one or more spam back ends for `spam-split' to
use, by setting the `spam-use-*' variables.  *Note Spam Back Ends::.
Normally, `spam-split' simply uses all the spam back ends you enabled
in this way.  However, you can tell `spam-split' to use only some of
them.  Why this is useful?  Suppose you are using the
`spam-use-regex-headers' and `spam-use-blackholes' spam back ends, and
the following split rule:

      nnimap-split-fancy '(|
                           (any "ding" "ding")
                           (: spam-split)
                           ;; default mailbox
                           "mail")

The problem is that you want all ding messages to make it to the ding
folder.  But that will let obvious spam (for example, spam detected by
SpamAssassin, and `spam-use-regex-headers') through, when it's sent to
the ding list.  On the other hand, some messages to the ding list are
from a mail server in the blackhole list, so the invocation of
`spam-split' can't be before the ding rule.

   The solution is to let SpamAssassin headers supersede ding rules, and
perform the other `spam-split' rules (including a second invocation of
the regex-headers check) after the ding rule.  This is done by passing
a parameter to `spam-split':

     nnimap-split-fancy
           '(|
             ;; spam detected by `spam-use-regex-headers' goes to `regex-spam'
             (: spam-split "regex-spam" 'spam-use-regex-headers)
             (any "ding" "ding")
             ;; all other spam detected by spam-split goes to `spam-split-group'
             (: spam-split)
             ;; default mailbox
             "mail")

This lets you invoke specific `spam-split' checks depending on your
particular needs, and target the results of those checks to a
particular spam group.  You don't have to throw all mail into all the
spam tests.  Another reason why this is nice is that messages to
mailing lists you have rules for don't have to have resource-intensive
blackhole checks performed on them.  You could also specify different
spam checks for your nnmail split vs. your nnimap split.  Go crazy.

   You should set the `spam-use-*' variables for whatever spam back
ends you intend to use.  The reason is that when loading `spam.el',
some conditional loading is done depending on what `spam-use-xyz'
variables you have set.  *Note Spam Back Ends::.


File: gnus,  Node: Detecting Spam in Groups,  Next: Spam and Ham Processors,  Prev: Filtering Incoming Mail,  Up: Spam Package

9.18.3 Detecting Spam in Groups
-------------------------------

To detect spam when visiting a group, set the group's `spam-autodetect'
and `spam-autodetect-methods' group parameters.  These are accessible
with `G c' or `G p', as usual (*note Group Parameters::).

   You should set the `spam-use-*' variables for whatever spam back
ends you intend to use.  The reason is that when loading `spam.el',
some conditional loading is done depending on what `spam-use-xyz'
variables you have set.

   By default, only unseen articles are processed for spam.  You can
force Gnus to recheck all messages in the group by setting the variable
`spam-autodetect-recheck-messages' to `t'.

   If you use the `spam-autodetect' method of checking for spam, you
can specify different spam detection methods for different groups.  For
instance, the `ding' group may have `spam-use-BBDB' as the
autodetection method, while the `suspect' group may have the
`spam-use-blacklist' and `spam-use-bogofilter' methods enabled.  Unlike
with `spam-split', you don't have any control over the _sequence_ of
checks, but this is probably unimportant.


File: gnus,  Node: Spam and Ham Processors,  Next: Spam Package Configuration Examples,  Prev: Detecting Spam in Groups,  Up: Spam Package

9.18.4 Spam and Ham Processors
------------------------------

Spam and ham processors specify special actions to take when you exit a
group buffer.  Spam processors act on spam messages, and ham processors
on ham messages.  At present, the main role of these processors is to
update the dictionaries of dictionary-based spam back ends such as
Bogofilter (*note Bogofilter::) and the Spam Statistics package (*note
Spam Statistics Filtering::).

   The spam and ham processors that apply to each group are determined
by the group's`spam-process' group parameter.  If this group parameter
is not defined, they are determined by the variable
`gnus-spam-process-newsgroups'.

   Gnus learns from the spam you get.  You have to collect your spam in
one or more spam groups, and set or customize the variable
`spam-junk-mailgroups' as appropriate.  You can also declare groups to
contain spam by setting their group parameter `spam-contents' to
`gnus-group-spam-classification-spam', or by customizing the
corresponding variable `gnus-spam-newsgroup-contents'.  The
`spam-contents' group parameter and the `gnus-spam-newsgroup-contents'
variable can also be used to declare groups as _ham_ groups if you set
their classification to `gnus-group-spam-classification-ham'.  If
groups are not classified by means of `spam-junk-mailgroups',
`spam-contents', or `gnus-spam-newsgroup-contents', they are considered
_unclassified_.  All groups are unclassified by default.

   In spam groups, all messages are considered to be spam by default:
they get the `$' mark (`gnus-spam-mark') when you enter the group.  If
you have seen a message, had it marked as spam, then unmarked it, it
won't be marked as spam when you enter the group thereafter.  You can
disable that behavior, so all unread messages will get the `$' mark, if
you set the `spam-mark-only-unseen-as-spam' parameter to `nil'.  You
should remove the `$' mark when you are in the group summary buffer for
every message that is not spam after all.  To remove the `$' mark, you
can use `M-u' to "unread" the article, or `d' for declaring it read the
non-spam way.  When you leave a group, all spam-marked (`$') articles
are sent to a spam processor which will study them as spam samples.

   Messages may also be deleted in various other ways, and unless
`ham-marks' group parameter gets overridden below, marks `R' and `r'
for default read or explicit delete, marks `X' and `K' for automatic or
explicit kills, as well as mark `Y' for low scores, are all considered
to be associated with articles which are not spam.  This assumption
might be false, in particular if you use kill files or score files as
means for detecting genuine spam, you should then adjust the
`ham-marks' group parameter.

 -- Variable: ham-marks
     You can customize this group or topic parameter to be the list of
     marks you want to consider ham.  By default, the list contains the
     deleted, read, killed, kill-filed, and low-score marks (the idea is
     that these articles have been read, but are not spam).  It can be
     useful to also include the tick mark in the ham marks.  It is not
     recommended to make the unread mark a ham mark, because it normally
     indicates a lack of classification.  But you can do it, and we'll
     be happy for you.

 -- Variable: spam-marks
     You can customize this group or topic parameter to be the list of
     marks you want to consider spam.  By default, the list contains
     only the spam mark.  It is not recommended to change that, but you
     can if you really want to.

   When you leave _any_ group, regardless of its `spam-contents'
classification, all spam-marked articles are sent to a spam processor,
which will study these as spam samples.  If you explicit kill a lot,
you might sometimes end up with articles marked `K' which you never
saw, and which might accidentally contain spam.  Best is to make sure
that real spam is marked with `$', and nothing else.

   When you leave a _spam_ group, all spam-marked articles are marked
as expired after processing with the spam processor.  This is not done
for _unclassified_ or _ham_ groups.  Also, any *ham* articles in a spam
group will be moved to a location determined by either the
`ham-process-destination' group parameter or a match in the
`gnus-ham-process-destinations' variable, which is a list of regular
expressions matched with group names (it's easiest to customize this
variable with `M-x customize-variable <RET>
gnus-ham-process-destinations').  Each group name list is a standard
Lisp list, if you prefer to customize the variable manually.  If the
`ham-process-destination' parameter is not set, ham articles are left
in place.  If the `spam-mark-ham-unread-before-move-from-spam-group'
parameter is set, the ham articles are marked as unread before being
moved.

   If ham can not be moved--because of a read-only back end such as
NNTP, for example, it will be copied.

   Note that you can use multiples destinations per group or regular
expression!  This enables you to send your ham to a regular mail group
and to a _ham training_ group.

   When you leave a _ham_ group, all ham-marked articles are sent to a
ham processor, which will study these as non-spam samples.

   By default the variable `spam-process-ham-in-spam-groups' is `nil'.
Set it to `t' if you want ham found in spam groups to be processed.
Normally this is not done, you are expected instead to send your ham to
a ham group and process it there.

   By default the variable `spam-process-ham-in-nonham-groups' is
`nil'.  Set it to `t' if you want ham found in non-ham (spam or
unclassified) groups to be processed.  Normally this is not done, you
are expected instead to send your ham to a ham group and process it
there.

   When you leave a _ham_ or _unclassified_ group, all *spam* articles
are moved to a location determined by either the
`spam-process-destination' group parameter or a match in the
`gnus-spam-process-destinations' variable, which is a list of regular
expressions matched with group names (it's easiest to customize this
variable with `M-x customize-variable <RET>
gnus-spam-process-destinations').  Each group name list is a standard
Lisp list, if you prefer to customize the variable manually.  If the
`spam-process-destination' parameter is not set, the spam articles are
only expired.  The group name is fully qualified, meaning that if you
see `nntp:servername' before the group name in the group buffer then
you need it here as well.

   If spam can not be moved--because of a read-only back end such as
NNTP, for example, it will be copied.

   Note that you can use multiples destinations per group or regular
expression!  This enables you to send your spam to multiple _spam
training_ groups.

   The problem with processing ham and spam is that Gnus doesn't track
this processing by default.  Enable the `spam-log-to-registry' variable
so `spam.el' will use `gnus-registry.el' to track what articles have
been processed, and avoid processing articles multiple times.  Keep in
mind that if you limit the number of registry entries, this won't work
as well as it does without a limit.

   Set this variable if you want only unseen articles in spam groups to
be marked as spam.  By default, it is set.  If you set it to `nil',
unread articles will also be marked as spam.

   Set this variable if you want ham to be unmarked before it is moved
out of the spam group.  This is very useful when you use something like
the tick mark `!' to mark ham--the article will be placed in your
`ham-process-destination', unmarked as if it came fresh from the mail
server.

   When autodetecting spam, this variable tells `spam.el' whether only
unseen articles or all unread articles should be checked for spam.  It
is recommended that you leave it off.


File: gnus,  Node: Spam Package Configuration Examples,  Next: Spam Back Ends,  Prev: Spam and Ham Processors,  Up: Spam Package

9.18.5 Spam Package Configuration Examples
------------------------------------------

Ted's setup
...........

From Ted Zlatanov <tzz@lifelogs.com>.
     ;; for `gnus-registry-split-fancy-with-parent' and spam autodetection
     ;; see `gnus-registry.el' for more information
     (gnus-registry-initialize)
     (spam-initialize)

     (setq
      spam-log-to-registry t     ; for spam autodetection
      spam-use-BBDB t
      spam-use-regex-headers t   ; catch X-Spam-Flag (SpamAssassin)
      ;; all groups with `spam' in the name contain spam
      gnus-spam-newsgroup-contents
       '(("spam" gnus-group-spam-classification-spam))
      ;; see documentation for these
      spam-move-spam-nonspam-groups-only nil
      spam-mark-only-unseen-as-spam t
      spam-mark-ham-unread-before-move-from-spam-group t
      ;; understand what this does before you copy it to your own setup!
      ;; for nnimap you'll probably want to set nnimap-split-methods, see the manual
      nnimap-split-fancy '(|
                           ;; trace references to parents and put in their group
                           (: gnus-registry-split-fancy-with-parent)
                           ;; this will catch server-side SpamAssassin tags
                           (: spam-split 'spam-use-regex-headers)
                           (any "ding" "ding")
                           ;; note that spam by default will go to `spam'
                           (: spam-split)
                           ;; default mailbox
                           "mail"))

     ;; my parameters, set with `G p'

     ;; all nnml groups, and all nnimap groups except
     ;; `nnimap+mail.lifelogs.com:train' and
     ;; `nnimap+mail.lifelogs.com:spam': any spam goes to nnimap training,
     ;; because it must have been detected manually

     ((spam-process-destination . "nnimap+mail.lifelogs.com:train"))

     ;; all NNTP groups
     ;; autodetect spam with the blacklist and ham with the BBDB
     ((spam-autodetect-methods spam-use-blacklist spam-use-BBDB)
     ;; send all spam to the training group
      (spam-process-destination . "nnimap+mail.lifelogs.com:train"))

     ;; only some NNTP groups, where I want to autodetect spam
     ((spam-autodetect . t))

     ;; my nnimap `nnimap+mail.lifelogs.com:spam' group

     ;; this is a spam group
     ((spam-contents gnus-group-spam-classification-spam)

      ;; any spam (which happens when I enter for all unseen messages,
      ;; because of the `gnus-spam-newsgroup-contents' setting above), goes to
      ;; `nnimap+mail.lifelogs.com:train' unless I mark it as ham

      (spam-process-destination "nnimap+mail.lifelogs.com:train")

      ;; any ham goes to my `nnimap+mail.lifelogs.com:mail' folder, but
      ;; also to my `nnimap+mail.lifelogs.com:trainham' folder for training

      (ham-process-destination "nnimap+mail.lifelogs.com:mail"
                               "nnimap+mail.lifelogs.com:trainham")
      ;; in this group, only `!' marks are ham
      (ham-marks
       (gnus-ticked-mark))
      ;; remembers senders in the blacklist on the way out--this is
      ;; definitely not needed, it just makes me feel better
      (spam-process (gnus-group-spam-exit-processor-blacklist)))

     ;; Later, on the IMAP server I use the `train' group for training
     ;; SpamAssassin to recognize spam, and the `trainham' group fora
     ;; recognizing ham--but Gnus has nothing to do with it.

Using `spam.el' on an IMAP server with a statistical filter on the server
.........................................................................

From Reiner Steib <reiner.steib@gmx.de>.

   My provider has set up bogofilter (in combination with DCC) on the
mail server (IMAP).  Recognized spam goes to `spam.detected', the rest
goes through the normal filter rules, i.e. to `some.folder' or to
`INBOX'.  Training on false positives or negatives is done by copying
or moving the article to `training.ham' or `training.spam'
respectively.  A cron job on the server feeds those to bogofilter with
the suitable ham or spam options and deletes them from the
`training.ham' and `training.spam' folders.

   With the following entries in `gnus-parameters', `spam.el' does most
of the job for me:

        ("nnimap:spam\\.detected"
         (gnus-article-sort-functions '(gnus-article-sort-by-chars))
         (ham-process-destination "nnimap:INBOX" "nnimap:training.ham")
         (spam-contents gnus-group-spam-classification-spam))
        ("nnimap:\\(INBOX\\|other-folders\\)"
         (spam-process-destination . "nnimap:training.spam")
         (spam-contents gnus-group-spam-classification-ham))

   * The Spam folder:

     In the folder `spam.detected', I have to check for false positives
     (i.e. legitimate mails, that were wrongly judged as spam by
     bogofilter or DCC).

     Because of the `gnus-group-spam-classification-spam' entry, all
     messages are marked as spam (with `$').  When I find a false
     positive, I mark the message with some other ham mark
     (`ham-marks', *note Spam and Ham Processors::).  On group exit,
     those messages are copied to both groups, `INBOX' (where I want to
     have the article) and `training.ham' (for training bogofilter) and
     deleted from the `spam.detected' folder.

     The `gnus-article-sort-by-chars' entry simplifies detection of
     false positives for me.  I receive lots of worms (sweN, ...), that
     all have a similar size.  Grouping them by size (i.e. chars) makes
     finding other false positives easier.  (Of course worms aren't spam
     (UCE, UBE) strictly speaking.  Anyhow, bogofilter is an excellent
     tool for filtering those unwanted mails for me.)

   * Ham folders:

     In my ham folders, I just hit `S x' (`gnus-summary-mark-as-spam')
     whenever I see an unrecognized spam mail (false negative).  On
     group exit, those messages are moved to `training.spam'.

Reporting spam articles in Gmane groups with `spam-report.el'
.............................................................

From Reiner Steib <reiner.steib@gmx.de>.

   With following entry in `gnus-parameters', `S x'
(`gnus-summary-mark-as-spam') marks articles in `gmane.*' groups as
spam and reports the to Gmane at group exit:

        ("^gmane\\."
         (spam-process (gnus-group-spam-exit-processor-report-gmane)))

   Additionally, I use `(setq spam-report-gmane-use-article-number nil)'
because I don't read the groups directly from news.gmane.org, but
through my local news server (leafnode).  I.e. the article numbers are
not the same as on news.gmane.org, thus `spam-report.el' has to check
the `X-Report-Spam' header to find the correct number.


File: gnus,  Node: Spam Back Ends,  Next: Extending the Spam package,  Prev: Spam Package Configuration Examples,  Up: Spam Package

9.18.6 Spam Back Ends
---------------------

The spam package offers a variety of back ends for detecting spam.
Each back end defines a set of methods for detecting spam (*note
Filtering Incoming Mail::, *note Detecting Spam in Groups::), and a
pair of spam and ham processors (*note Spam and Ham Processors::).

* Menu:

* Blacklists and Whitelists::
* BBDB Whitelists::
* Gmane Spam Reporting::
* Anti-spam Hashcash Payments::
* Blackholes::
* Regular Expressions Header Matching::
* Bogofilter::
* SpamAssassin back end::
* ifile spam filtering::
* Spam Statistics Filtering::
* SpamOracle::


File: gnus,  Node: Blacklists and Whitelists,  Next: BBDB Whitelists,  Up: Spam Back Ends

9.18.6.1 Blacklists and Whitelists
..................................

 -- Variable: spam-use-blacklist
     Set this variable to `t' if you want to use blacklists when
     splitting incoming mail.  Messages whose senders are in the
     blacklist will be sent to the `spam-split-group'.  This is an
     explicit filter, meaning that it acts only on mail senders
     _declared_ to be spammers.


 -- Variable: spam-use-whitelist
     Set this variable to `t' if you want to use whitelists when
     splitting incoming mail.  Messages whose senders are not in the
     whitelist will be sent to the next spam-split rule.  This is an
     explicit filter, meaning that unless someone is in the whitelist,
     their messages are not assumed to be spam or ham.


 -- Variable: spam-use-whitelist-exclusive
     Set this variable to `t' if you want to use whitelists as an
     implicit filter, meaning that every message will be considered spam
     unless the sender is in the whitelist.  Use with care.


 -- Variable: gnus-group-spam-exit-processor-blacklist
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     spam-marked articles will be added to the blacklist.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-blacklist', it is recommended that
     you use `(spam spam-use-blacklist)'.  Everything will work the
     same way, we promise.


 -- Variable: gnus-group-ham-exit-processor-whitelist
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     ham-marked articles in _ham_ groups will be added to the whitelist.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-whitelist',
     it is recommended that you use `(ham spam-use-whitelist)'.
     Everything will work the same way, we promise.


   Blacklists are lists of regular expressions matching addresses you
consider to be spam senders.  For instance, to block mail from any
sender at `vmadmin.com', you can put `vmadmin.com' in your blacklist.
You start out with an empty blacklist.  Blacklist entries use the Emacs
regular expression syntax.

   Conversely, whitelists tell Gnus what addresses are considered
legitimate.  All messages from whitelisted addresses are considered
non-spam.  Also see *note BBDB Whitelists::.  Whitelist entries use the
Emacs regular expression syntax.

   The blacklist and whitelist file locations can be customized with the
`spam-directory' variable (`~/News/spam' by default), or the
`spam-whitelist' and `spam-blacklist' variables directly.  The
whitelist and blacklist files will by default be in the
`spam-directory' directory, named `whitelist' and `blacklist'
respectively.


File: gnus,  Node: BBDB Whitelists,  Next: Gmane Spam Reporting,  Prev: Blacklists and Whitelists,  Up: Spam Back Ends

9.18.6.2 BBDB Whitelists
........................

 -- Variable: spam-use-BBDB
     Analogous to `spam-use-whitelist' (*note Blacklists and
     Whitelists::), but uses the BBDB as the source of whitelisted
     addresses, without regular expressions.  You must have the BBDB
     loaded for `spam-use-BBDB' to work properly.  Messages whose
     senders are not in the BBDB will be sent to the next spam-split
     rule.  This is an explicit filter, meaning that unless someone is
     in the BBDB, their messages are not assumed to be spam or ham.


 -- Variable: spam-use-BBDB-exclusive
     Set this variable to `t' if you want to use the BBDB as an
     implicit filter, meaning that every message will be considered spam
     unless the sender is in the BBDB.  Use with care.  Only sender
     addresses in the BBDB will be allowed through; all others will be
     classified as spammers.

     While `spam-use-BBDB-exclusive' _can_ be used as an alias for
     `spam-use-BBDB' as far as `spam.el' is concerned, it is _not_ a
     separate back end.  If you set `spam-use-BBDB-exclusive' to t,
     _all_ your BBDB splitting will be exclusive.


 -- Variable: gnus-group-ham-exit-processor-BBDB
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     ham-marked articles in _ham_ groups will be added to the BBDB.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-BBDB', it
     is recommended that you use `(ham spam-use-BBDB)'.  Everything
     will work the same way, we promise.



File: gnus,  Node: Gmane Spam Reporting,  Next: Anti-spam Hashcash Payments,  Prev: BBDB Whitelists,  Up: Spam Back Ends

9.18.6.3 Gmane Spam Reporting
.............................

 -- Variable: gnus-group-spam-exit-processor-report-gmane
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the spam-marked
     articles groups will be reported to the Gmane administrators via a
     HTTP request.

     Gmane can be found at `http://gmane.org'.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-report-gmane', it is recommended
     that you use `(spam spam-use-gmane)'.  Everything will work the
     same way, we promise.


 -- Variable: spam-report-gmane-use-article-number
     This variable is `t' by default.  Set it to `nil' if you are
     running your own news server, for instance, and the local article
     numbers don't correspond to the Gmane article numbers.  When
     `spam-report-gmane-use-article-number' is `nil', `spam-report.el'
     will fetch the number from the article headers.


 -- Variable: spam-report-user-mail-address
     Mail address exposed in the User-Agent spam reports to Gmane.  It
     allows the Gmane administrators to contact you in case of
     misreports.  The default is `user-mail-address'.



File: gnus,  Node: Anti-spam Hashcash Payments,  Next: Blackholes,  Prev: Gmane Spam Reporting,  Up: Spam Back Ends

9.18.6.4 Anti-spam Hashcash Payments
....................................

 -- Variable: spam-use-hashcash
     Similar to `spam-use-whitelist' (*note Blacklists and
     Whitelists::), but uses hashcash tokens for whitelisting messages
     instead of the sender address.  Messages without a hashcash payment
     token will be sent to the next spam-split rule.  This is an
     explicit filter, meaning that unless a hashcash token is found,
     the messages are not assumed to be spam or ham.



File: gnus,  Node: Blackholes,  Next: Regular Expressions Header Matching,  Prev: Anti-spam Hashcash Payments,  Up: Spam Back Ends

9.18.6.5 Blackholes
...................

 -- Variable: spam-use-blackholes
     This option is disabled by default.  You can let Gnus consult the
     blackhole-type distributed spam processing systems (DCC, for
     instance) when you set this option.  The variable
     `spam-blackhole-servers' holds the list of blackhole servers Gnus
     will consult.  The current list is fairly comprehensive, but make
     sure to let us know if it contains outdated servers.

     The blackhole check uses the `dig.el' package, but you can tell
     `spam.el' to use `dns.el' instead for better performance if you
     set `spam-use-dig' to `nil'.  It is not recommended at this time
     to set `spam-use-dig' to `nil' despite the possible performance
     improvements, because some users may be unable to use it, but you
     can try it and see if it works for you.


 -- Variable: spam-blackhole-servers
     The list of servers to consult for blackhole checks.


 -- Variable: spam-blackhole-good-server-regex
     A regular expression for IPs that should not be checked against the
     blackhole server list.  When set to `nil', it has no effect.


 -- Variable: spam-use-dig
     Use the `dig.el' package instead of the `dns.el' package.  The
     default setting of `t' is recommended.


   Blackhole checks are done only on incoming mail.  There is no spam or
ham processor for blackholes.


File: gnus,  Node: Regular Expressions Header Matching,  Next: Bogofilter,  Prev: Blackholes,  Up: Spam Back Ends

9.18.6.6 Regular Expressions Header Matching
............................................

 -- Variable: spam-use-regex-headers
     This option is disabled by default.  You can let Gnus check the
     message headers against lists of regular expressions when you set
     this option.  The variables `spam-regex-headers-spam' and
     `spam-regex-headers-ham' hold the list of regular expressions.
     Gnus will check against the message headers to determine if the
     message is spam or ham, respectively.


 -- Variable: spam-regex-headers-spam
     The list of regular expressions that, when matched in the headers
     of the message, positively identify it as spam.


 -- Variable: spam-regex-headers-ham
     The list of regular expressions that, when matched in the headers
     of the message, positively identify it as ham.


   Regular expression header checks are done only on incoming mail.
There is no specific spam or ham processor for regular expressions.


File: gnus,  Node: Bogofilter,  Next: SpamAssassin back end,  Prev: Regular Expressions Header Matching,  Up: Spam Back Ends

9.18.6.7 Bogofilter
...................

 -- Variable: spam-use-bogofilter
     Set this variable if you want `spam-split' to use Eric Raymond's
     speedy Bogofilter.

     With a minimum of care for associating the `$' mark for spam
     articles only, Bogofilter training all gets fairly automatic.  You
     should do this until you get a few hundreds of articles in each
     category, spam or not.  The command `S t' in summary mode, either
     for debugging or for curiosity, shows the _spamicity_ score of the
     current article (between 0.0 and 1.0).

     Bogofilter determines if a message is spam based on a specific
     threshold.  That threshold can be customized, consult the
     Bogofilter documentation.

     If the `bogofilter' executable is not in your path, Bogofilter
     processing will be turned off.

     You should not enable this if you use
     `spam-use-bogofilter-headers'.


`M s t'
`S t'
     Get the Bogofilter spamicity score (`spam-bogofilter-score').

 -- Variable: spam-use-bogofilter-headers
     Set this variable if you want `spam-split' to use Eric Raymond's
     speedy Bogofilter, looking only at the message headers.  It works
     similarly to `spam-use-bogofilter', but the `X-Bogosity' header
     must be in the message already.  Normally you would do this with a
     procmail recipe or something similar; consult the Bogofilter
     installation documents for details.

     You should not enable this if you use `spam-use-bogofilter'.


 -- Variable: gnus-group-spam-exit-processor-bogofilter
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, spam-marked articles
     will be added to the Bogofilter spam database.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-bogofilter', it is recommended
     that you use `(spam spam-use-bogofilter)'.  Everything will work
     the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-bogofilter
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the ham-marked
     articles in _ham_ groups will be added to the Bogofilter database
     of non-spam messages.

     _WARNING_

     Instead of the obsolete
     `gnus-group-ham-exit-processor-bogofilter', it is recommended that
     you use `(ham spam-use-bogofilter)'.  Everything will work the
     same way, we promise.

 -- Variable: spam-bogofilter-database-directory
     This is the directory where Bogofilter will store its databases.
     It is not specified by default, so Bogofilter will use its own
     default database directory.


   The Bogofilter mail classifier is similar to `ifile' in intent and
purpose.  A ham and a spam processor are provided, plus the
`spam-use-bogofilter' and `spam-use-bogofilter-headers' variables to
indicate to spam-split that Bogofilter should either be used, or has
already been used on the article.  The 0.9.2.1 version of Bogofilter
was used to test this functionality.


File: gnus,  Node: SpamAssassin back end,  Next: ifile spam filtering,  Prev: Bogofilter,  Up: Spam Back Ends

9.18.6.8 SpamAssassin back end
..............................

 -- Variable: spam-use-spamassassin
     Set this variable if you want `spam-split' to use SpamAssassin.

     SpamAssassin assigns a score to each article based on a set of
     rules and tests, including a Bayesian filter.  The Bayesian filter
     can be trained by associating the `$' mark for spam articles.  The
     spam score can be viewed by using the command `S t' in summary
     mode.

     If you set this variable, each article will be processed by
     SpamAssassin when `spam-split' is called.  If your mail is
     preprocessed by SpamAssassin, and you want to just use the
     SpamAssassin headers, set `spam-use-spamassassin-headers' instead.

     You should not enable this if you use
     `spam-use-spamassassin-headers'.


 -- Variable: spam-use-spamassassin-headers
     Set this variable if your mail is preprocessed by SpamAssassin and
     want `spam-split' to split based on the SpamAssassin headers.

     You should not enable this if you use `spam-use-spamassassin'.


 -- Variable: spam-spamassassin-program
     This variable points to the SpamAssassin executable.  If you have
     `spamd' running, you can set this variable to the `spamc'
     executable for faster processing.  See the SpamAssassin
     documentation for more information on `spamd'/`spamc'.


   SpamAssassin is a powerful and flexible spam filter that uses a wide
variety of tests to identify spam.  A ham and a spam processors are
provided, plus the `spam-use-spamassassin' and
`spam-use-spamassassin-headers' variables to indicate to spam-split
that SpamAssassin should be either used, or has already been used on
the article.  The 2.63 version of SpamAssassin was used to test this
functionality.


File: gnus,  Node: ifile spam filtering,  Next: Spam Statistics Filtering,  Prev: SpamAssassin back end,  Up: Spam Back Ends

9.18.6.9 ifile spam filtering
.............................

 -- Variable: spam-use-ifile
     Enable this variable if you want `spam-split' to use `ifile', a
     statistical analyzer similar to Bogofilter.


 -- Variable: spam-ifile-all-categories
     Enable this variable if you want `spam-use-ifile' to give you all
     the ifile categories, not just spam/non-spam.  If you use this,
     make sure you train ifile as described in its documentation.


 -- Variable: spam-ifile-spam-category
     This is the category of spam messages as far as ifile is concerned.
     The actual string used is irrelevant, but you probably want to
     leave the default value of `spam'.

 -- Variable: spam-ifile-database
     This is the filename for the ifile database.  It is not specified
     by default, so ifile will use its own default database name.


   The ifile mail classifier is similar to Bogofilter in intent and
purpose.  A ham and a spam processor are provided, plus the
`spam-use-ifile' variable to indicate to spam-split that ifile should
be used.  The 1.2.1 version of ifile was used to test this
functionality.


File: gnus,  Node: Spam Statistics Filtering,  Next: SpamOracle,  Prev: ifile spam filtering,  Up: Spam Back Ends

9.18.6.10 Spam Statistics Filtering
...................................

This back end uses the Spam Statistics Emacs Lisp package to perform
statistics-based filtering (*note Spam Statistics Package::).  Before
using this, you may want to perform some additional steps to initialize
your Spam Statistics dictionary.  *Note Creating a spam-stat
dictionary::.

 -- Variable: spam-use-stat

 -- Variable: gnus-group-spam-exit-processor-stat
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the spam-marked
     articles will be added to the spam-stat database of spam messages.

     _WARNING_

     Instead of the obsolete `gnus-group-spam-exit-processor-stat', it
     is recommended that you use `(spam spam-use-stat)'.  Everything
     will work the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-stat
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the ham-marked
     articles in _ham_ groups will be added to the spam-stat database
     of non-spam messages.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-stat', it
     is recommended that you use `(ham spam-use-stat)'.  Everything
     will work the same way, we promise.

   This enables `spam.el' to cooperate with `spam-stat.el'.
`spam-stat.el' provides an internal (Lisp-only) spam database, which
unlike ifile or Bogofilter does not require external programs.  A spam
and a ham processor, and the `spam-use-stat' variable for `spam-split'
are provided.


File: gnus,  Node: SpamOracle,  Prev: Spam Statistics Filtering,  Up: Spam Back Ends

9.18.6.11 Using SpamOracle with Gnus
....................................

An easy way to filter out spam is to use SpamOracle.  SpamOracle is an
statistical mail filtering tool written by Xavier Leroy and needs to be
installed separately.

   There are several ways to use SpamOracle with Gnus.  In all cases,
your mail is piped through SpamOracle in its _mark_ mode.  SpamOracle
will then enter an `X-Spam' header indicating whether it regards the
mail as a spam mail or not.

   One possibility is to run SpamOracle as a `:prescript' from the
*Note Mail Source Specifiers::, (*note SpamAssassin::).  This method has
the advantage that the user can see the _X-Spam_ headers.

   The easiest method is to make `spam.el' (*note Spam Package::) call
SpamOracle.

   To enable SpamOracle usage by `spam.el', set the variable
`spam-use-spamoracle' to `t' and configure the `nnmail-split-fancy' or
`nnimap-split-fancy'.  *Note Spam Package::.  In this example the
`INBOX' of an nnimap server is filtered using SpamOracle.  Mails
recognized as spam mails will be moved to `spam-split-group', `Junk' in
this case.  Ham messages stay in `INBOX':

     (setq spam-use-spamoracle t
           spam-split-group "Junk"
           ;; for nnimap you'll probably want to set nnimap-split-methods, see the manual
           nnimap-split-inbox '("INBOX")
           nnimap-split-fancy '(| (: spam-split) "INBOX"))

 -- Variable: spam-use-spamoracle
     Set to `t' if you want Gnus to enable spam filtering using
     SpamOracle.

 -- Variable: spam-spamoracle-binary
     Gnus uses the SpamOracle binary called `spamoracle' found in the
     user's PATH.  Using the variable `spam-spamoracle-binary', this
     can be customized.

 -- Variable: spam-spamoracle-database
     By default, SpamOracle uses the file `~/.spamoracle.db' as a
     database to store its analysis.  This is controlled by the variable
     `spam-spamoracle-database' which defaults to `nil'.  That means
     the default SpamOracle database will be used.  In case you want
     your database to live somewhere special, set
     `spam-spamoracle-database' to this path.

   SpamOracle employs a statistical algorithm to determine whether a
message is spam or ham.  In order to get good results, meaning few
false hits or misses, SpamOracle needs training.  SpamOracle learns the
characteristics of your spam mails.  Using the _add_ mode (training
mode) one has to feed good (ham) and spam mails to SpamOracle.  This
can be done by pressing `|' in the Summary buffer and pipe the mail to
a SpamOracle process or using `spam.el''s spam- and ham-processors,
which is much more convenient.  For a detailed description of spam- and
ham-processors, *Note Spam Package::.

 -- Variable: gnus-group-spam-exit-processor-spamoracle
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameter or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is added
     to a group's `spam-process' parameter, spam-marked articles will be
     sent to SpamOracle as spam samples.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-spamoracle', it is recommended
     that you use `(spam spam-use-spamoracle)'.  Everything will work
     the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-spamoracle
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameter or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is added
     to a group's `spam-process' parameter, the ham-marked articles in
     _ham_ groups will be sent to the SpamOracle as samples of ham
     messages.

     _WARNING_

     Instead of the obsolete
     `gnus-group-ham-exit-processor-spamoracle', it is recommended that
     you use `(ham spam-use-spamoracle)'.  Everything will work the
     same way, we promise.

   _Example:_ These are the Group Parameters of a group that has been
classified as a ham group, meaning that it should only contain ham
messages.
      ((spam-contents gnus-group-spam-classification-ham)
       (spam-process ((ham spam-use-spamoracle)
                      (spam spam-use-spamoracle))))
   For this group the `spam-use-spamoracle' is installed for both ham
and spam processing.  If the group contains spam message (e.g. because
SpamOracle has not had enough sample messages yet) and the user marks
some messages as spam messages, these messages will be processed by
SpamOracle.  The processor sends the messages to SpamOracle as new
samples for spam.


File: gnus,  Node: Extending the Spam package,  Next: Spam Statistics Package,  Prev: Spam Back Ends,  Up: Spam Package

9.18.7 Extending the Spam package
---------------------------------

Say you want to add a new back end called blackbox.  For filtering
incoming mail, provide the following:

  1. Code

          (defvar spam-use-blackbox nil
            "True if blackbox should be used.")

     Write `spam-check-blackbox' if Blackbox can check incoming mail.

     Write `spam-blackbox-register-routine' and
     `spam-blackbox-unregister-routine' using the bogofilter
     register/unregister routines as a start, or other
     register/unregister routines more appropriate to Blackbox, if
     Blackbox can register/unregister spam and ham.

  2. Functionality

     The `spam-check-blackbox' function should return `nil' or
     `spam-split-group', observing the other conventions.  See the
     existing `spam-check-*' functions for examples of what you can do,
     and stick to the template unless you fully understand the reasons
     why you aren't.


   For processing spam and ham messages, provide the following:

  1. Code

     Note you don't have to provide a spam or a ham processor.  Only
     provide them if Blackbox supports spam or ham processing.

     Also, ham and spam processors are being phased out as single
     variables.  Instead the form `(spam spam-use-blackbox)' or `(ham
     spam-use-blackbox)' is favored.  For now, spam/ham processor
     variables are still around but they won't be for long.

          (defvar gnus-group-spam-exit-processor-blackbox "blackbox-spam"
            "The Blackbox summary exit spam processor.
          Only applicable to spam groups.")

          (defvar gnus-group-ham-exit-processor-blackbox "blackbox-ham"
            "The whitelist summary exit ham processor.
          Only applicable to non-spam (unclassified and ham) groups.")

  2. Gnus parameters

     Add
          (const :tag "Spam: Blackbox" (spam spam-use-blackbox))
          (const :tag "Ham: Blackbox"  (ham spam-use-blackbox))
     to the `spam-process' group parameter in `gnus.el'.  Make sure you
     do it twice, once for the parameter and once for the variable
     customization.

     Add
          (variable-item spam-use-blackbox)
     to the `spam-autodetect-methods' group parameter in `gnus.el' if
     Blackbox can check incoming mail for spam contents.

     Finally, use the appropriate `spam-install-*-backend' function in
     `spam.el'.  Here are the available functions.

       1. `spam-install-backend-alias'

          This function will simply install an alias for a back end
          that does everything like the original back end.  It is
          currently only used to make `spam-use-BBDB-exclusive' act
          like `spam-use-BBDB'.

       2. `spam-install-nocheck-backend'

          This function installs a back end that has no check function,
          but can register/unregister ham or spam.  The
          `spam-use-gmane' back end is such a back end.

       3. `spam-install-checkonly-backend'

          This function will install a back end that can only check
          incoming mail for spam contents.  It can't register or
          unregister messages.  `spam-use-blackholes' and
          `spam-use-hashcash' are such back ends.

       4. `spam-install-statistical-checkonly-backend'

          This function installs a statistical back end (one which
          requires the full body of a message to check it) that can
          only check incoming mail for contents.  `spam-use-regex-body'
          is such a filter.

       5. `spam-install-statistical-backend'

          This function install a statistical back end with incoming
          checks and registration/unregistration routines.
          `spam-use-bogofilter' is set up this way.

       6. `spam-install-backend'

          This is the most normal back end installation, where a back
          end that can check and register/unregister messages is set up
          without statistical abilities.  The `spam-use-BBDB' is such a
          back end.

       7. `spam-install-mover-backend'

          Mover back ends are internal to `spam.el' and specifically
          move articles around when the summary is exited.  You will
          very probably never install such a back end.



File: gnus,  Node: Spam Statistics Package,  Prev: Extending the Spam package,  Up: Spam Package

9.18.8 Spam Statistics Package
------------------------------

Paul Graham has written an excellent essay about spam filtering using
statistics: A Plan for Spam (http://www.paulgraham.com/spam.html).  In
it he describes the inherent deficiency of rule-based filtering as used
by SpamAssassin, for example: Somebody has to write the rules, and
everybody else has to install these rules.  You are always late.  It
would be much better, he argues, to filter mail based on whether it
somehow resembles spam or non-spam.  One way to measure this is word
distribution.  He then goes on to describe a solution that checks
whether a new mail resembles any of your other spam mails or not.

   The basic idea is this:  Create a two collections of your mail, one
with spam, one with non-spam.  Count how often each word appears in
either collection, weight this by the total number of mails in the
collections, and store this information in a dictionary.  For every
word in a new mail, determine its probability to belong to a spam or a
non-spam mail.  Use the 15 most conspicuous words, compute the total
probability of the mail being spam.  If this probability is higher than
a certain threshold, the mail is considered to be spam.

   The Spam Statistics package adds support to Gnus for this kind of
filtering.  It can be used as one of the back ends of the Spam package
(*note Spam Package::), or by itself.

   Before using the Spam Statistics package, you need to set it up.
First, you need two collections of your mail, one with spam, one with
non-spam.  Then you need to create a dictionary using these two
collections, and save it.  And last but not least, you need to use this
dictionary in your fancy mail splitting rules.

* Menu:

* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::


File: gnus,  Node: Creating a spam-stat dictionary,  Next: Splitting mail using spam-stat,  Up: Spam Statistics Package

9.18.8.1 Creating a spam-stat dictionary
........................................

Before you can begin to filter spam based on statistics, you must
create these statistics based on two mail collections, one with spam,
one with non-spam.  These statistics are then stored in a dictionary
for later use.  In order for these statistics to be meaningful, you
need several hundred emails in both collections.

   Gnus currently supports only the nnml back end for automated
dictionary creation.  The nnml back end stores all mails in a
directory, one file per mail.  Use the following:

 -- Function: spam-stat-process-spam-directory
     Create spam statistics for every file in this directory.  Every
     file is treated as one spam mail.

 -- Function: spam-stat-process-non-spam-directory
     Create non-spam statistics for every file in this directory.  Every
     file is treated as one non-spam mail.

   Usually you would call `spam-stat-process-spam-directory' on a
directory such as `~/Mail/mail/spam' (this usually corresponds to the
group `nnml:mail.spam'), and you would call
`spam-stat-process-non-spam-directory' on a directory such as
`~/Mail/mail/misc' (this usually corresponds to the group
`nnml:mail.misc').

   When you are using IMAP, you won't have the mails available locally,
so that will not work.  One solution is to use the Gnus Agent to cache
the articles.  Then you can use directories such as
`"~/News/agent/nnimap/mail.yourisp.com/personal_spam"' for
`spam-stat-process-spam-directory'.  *Note Agent as Cache::.

 -- Variable: spam-stat
     This variable holds the hash-table with all the statistics--the
     dictionary we have been talking about.  For every word in either
     collection, this hash-table stores a vector describing how often
     the word appeared in spam and often it appeared in non-spam mails.

   If you want to regenerate the statistics from scratch, you need to
reset the dictionary.

 -- Function: spam-stat-reset
     Reset the `spam-stat' hash-table, deleting all the statistics.

   When you are done, you must save the dictionary.  The dictionary may
be rather large.  If you will not update the dictionary incrementally
(instead, you will recreate it once a month, for example), then you can
reduce the size of the dictionary by deleting all words that did not
appear often enough or that do not clearly belong to only spam or only
non-spam mails.

 -- Function: spam-stat-reduce-size
     Reduce the size of the dictionary.  Use this only if you do not
     want to update the dictionary incrementally.

 -- Function: spam-stat-save
     Save the dictionary.

 -- Variable: spam-stat-file
     The filename used to store the dictionary.  This defaults to
     `~/.spam-stat.el'.


File: gnus,  Node: Splitting mail using spam-stat,  Next: Low-level interface to the spam-stat dictionary,  Prev: Creating a spam-stat dictionary,  Up: Spam Statistics Package

9.18.8.2 Splitting mail using spam-stat
.......................................

This section describes how to use the Spam statistics _independently_
of the *Note Spam Package::.

   First, add the following to your `~/.gnus.el' file:

     (require 'spam-stat)
     (spam-stat-load)

   This will load the necessary Gnus code, and the dictionary you
created.

   Next, you need to adapt your fancy splitting rules:  You need to
determine how to use `spam-stat'.  The following examples are for the
nnml back end.  Using the nnimap back end works just as well.  Just use
`nnimap-split-fancy' instead of `nnmail-split-fancy'.

   In the simplest case, you only have two groups, `mail.misc' and
`mail.spam'.  The following expression says that mail is either spam or
it should go into `mail.misc'.  If it is spam, then
`spam-stat-split-fancy' will return `mail.spam'.

     (setq nnmail-split-fancy
           `(| (: spam-stat-split-fancy)
               "mail.misc"))

 -- Variable: spam-stat-split-fancy-spam-group
     The group to use for spam.  Default is `mail.spam'.

   If you also filter mail with specific subjects into other groups, use
the following expression.  Only mails not matching the regular
expression are considered potential spam.

     (setq nnmail-split-fancy
           `(| ("Subject" "\\bspam-stat\\b" "mail.emacs")
               (: spam-stat-split-fancy)
               "mail.misc"))

   If you want to filter for spam first, then you must be careful when
creating the dictionary.  Note that `spam-stat-split-fancy' must
consider both mails in `mail.emacs' and in `mail.misc' as non-spam,
therefore both should be in your collection of non-spam mails, when
creating the dictionary!

     (setq nnmail-split-fancy
           `(| (: spam-stat-split-fancy)
               ("Subject" "\\bspam-stat\\b" "mail.emacs")
               "mail.misc"))

   You can combine this with traditional filtering.  Here, we move all
HTML-only mails into the `mail.spam.filtered' group.  Note that since
`spam-stat-split-fancy' will never see them, the mails in
`mail.spam.filtered' should be neither in your collection of spam mails,
nor in your collection of non-spam mails, when creating the dictionary!

     (setq nnmail-split-fancy
           `(| ("Content-Type" "text/html" "mail.spam.filtered")
               (: spam-stat-split-fancy)
               ("Subject" "\\bspam-stat\\b" "mail.emacs")
               "mail.misc"))


File: gnus,  Node: Low-level interface to the spam-stat dictionary,  Prev: Splitting mail using spam-stat,  Up: Spam Statistics Package

9.18.8.3 Low-level interface to the spam-stat dictionary
........................................................

The main interface to using `spam-stat', are the following functions:

 -- Function: spam-stat-buffer-is-spam
     Called in a buffer, that buffer is considered to be a new spam
     mail.  Use this for new mail that has not been processed before.

 -- Function: spam-stat-buffer-is-no-spam
     Called in a buffer, that buffer is considered to be a new non-spam
     mail.  Use this for new mail that has not been processed before.

 -- Function: spam-stat-buffer-change-to-spam
     Called in a buffer, that buffer is no longer considered to be
     normal mail but spam.  Use this to change the status of a mail
     that has already been processed as non-spam.

 -- Function: spam-stat-buffer-change-to-non-spam
     Called in a buffer, that buffer is no longer considered to be spam
     but normal mail.  Use this to change the status of a mail that has
     already been processed as spam.

 -- Function: spam-stat-save
     Save the hash table to the file.  The filename used is stored in
     the variable `spam-stat-file'.

 -- Function: spam-stat-load
     Load the hash table from a file.  The filename used is stored in
     the variable `spam-stat-file'.

 -- Function: spam-stat-score-word
     Return the spam score for a word.

 -- Function: spam-stat-score-buffer
     Return the spam score for a buffer.

 -- Function: spam-stat-split-fancy
     Use this function for fancy mail splitting.  Add the rule `(:
     spam-stat-split-fancy)' to `nnmail-split-fancy'

   Make sure you load the dictionary before using it.  This requires the
following in your `~/.gnus.el' file:

     (require 'spam-stat)
     (spam-stat-load)

   Typical test will involve calls to the following functions:

     Reset: (setq spam-stat (make-hash-table :test 'equal))
     Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
     Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
     Save table: (spam-stat-save)
     File size: (nth 7 (file-attributes spam-stat-file))
     Number of words: (hash-table-count spam-stat)
     Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
     Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")
     Reduce table size: (spam-stat-reduce-size)
     Save table: (spam-stat-save)
     File size: (nth 7 (file-attributes spam-stat-file))
     Number of words: (hash-table-count spam-stat)
     Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
     Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")

   Here is how you would create your dictionary:

     Reset: (setq spam-stat (make-hash-table :test 'equal))
     Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
     Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
     Repeat for any other non-spam group you need...
     Reduce table size: (spam-stat-reduce-size)
     Save table: (spam-stat-save)


File: gnus,  Node: The Gnus Registry,  Next: Other modes,  Prev: Spam Package,  Up: Various

9.19 The Gnus Registry
======================

The Gnus registry is a package that tracks messages by their Message-ID
across all backends.  This allows Gnus users to do several cool things,
be the envy of the locals, get free haircuts, and be experts on world
issues.  Well, maybe not all of those, but the features are pretty cool.

   Although they will be explained in detail shortly, here's a quick
list of said features in case your attention span is...  never mind.

  1. Split messages to their parent

     This keeps discussions in the same group.  You can use the subject
     and the sender in addition to the Message-ID.  Several strategies
     are available.

  2. Refer to messages by ID

     Commands like `gnus-summary-refer-parent-article' can take
     advantage of the registry to jump to the referred article,
     regardless of the group the message is in.

  3. Store custom flags and keywords

     The registry can store custom flags and keywords for a message.
     For instance, you can mark a message "To-Do" this way and the flag
     will persist whether the message is in the nnimap, nnml, nnmaildir,
     etc. backends.

  4. Store arbitrary data

     Through a simple ELisp API, the registry can remember any data for
     a message.  A built-in inverse map, when activated, allows quick
     lookups of all messages matching a particular set of criteria.

* Menu:

* Gnus Registry Setup::
* Fancy splitting to parent::
* Registry Article Refer Method::
* Store custom flags and keywords::
* Store arbitrary data::


File: gnus,  Node: Gnus Registry Setup,  Next: Fancy splitting to parent,  Up: The Gnus Registry

9.19.1 Gnus Registry Setup
--------------------------

Fortunately, setting up the Gnus registry is pretty easy:

     (setq gnus-registry-max-entries 2500)

     (gnus-registry-initialize)

   This adds registry saves to Gnus newsrc saves (which happen on exit
and when you press `s' from the `*Group*' buffer.  It also adds
registry calls to article actions in Gnus (copy, move, etc.)  so it's
not easy to undo the initialization.  See `gnus-registry-initialize'
for the gory details.

   Here are other settings used by the author of the registry
(understand what they do before you copy them blindly).

     (setq
      gnus-registry-split-strategy 'majority
      gnus-registry-ignored-groups '(("nntp" t)
                                     ("nnrss" t)
                                     ("spam" t)
                                     ("train" t))
      gnus-registry-max-entries 500000
      ;; this is the default
      gnus-registry-track-extra '(sender subject))

   They say: keep a lot of messages around, track messages by sender and
subject (not just parent Message-ID), and when the registry splits
incoming mail, use a majority rule to decide where messages should go
if there's more than one possibility.  In addition, the registry should
ignore messages in groups that match "nntp", "nnrss", "spam", or
"train."

   You are doubtless impressed by all this, but you ask: "I am a Gnus
user, I customize to live.  Give me more."  Here you go, these are the
general settings.

 -- Variable: gnus-registry-unfollowed-groups
     The groups that will not be followed by
     `gnus-registry-split-fancy-with-parent'.  They will still be
     remembered by the registry.  This is a list of regular expressions.
     By default any group name that ends with "delayed", "drafts",
     "queue", or "INBOX", belongs to the nnmairix backend, or contains
     the word "archive" is not followed.

 -- Variable: gnus-registry-max-entries
     The number (an integer or `nil' for unlimited) of entries the
     registry will keep.

 -- Variable: gnus-registry-max-pruned-entries
     The maximum number (an integer or `nil' for unlimited) of entries
     the registry will keep after pruning.

 -- Variable: gnus-registry-cache-file
     The file where the registry will be stored between Gnus sessions.
     By default the file name is `.gnus.registry.eioio' in the same
     directory as your `.newsrc.eld'.


File: gnus,  Node: Registry Article Refer Method,  Next: Store custom flags and keywords,  Prev: Fancy splitting to parent,  Up: The Gnus Registry

9.19.2 Fetching by `Message-ID' Using the Registry
--------------------------------------------------

The registry knows how to map each `Message-ID' to the group it's in.
This can be leveraged to enhance the "article refer method", the thing
that tells Gnus how to look up an article given its Message-ID (*note
Finding the Parent::).

   The `nnregistry' refer method does exactly that.  It has the
advantage that an article may be found regardless of the group it's
in--provided its `Message-ID' is known to the registry.  It can be
enabled by augmenting the start-up file with something along these
lines:

     ;; Keep enough entries to have a good hit rate when referring to an
     ;; article using the registry.  Use long group names so that Gnus
     ;; knows where the article is.
     (setq gnus-registry-max-entries 2500)

     (gnus-registry-initialize)

     (setq gnus-refer-article-method
           '(current
             (nnregistry)
             (nnweb "gmane" (nnweb-type gmane))))

   The example above instructs Gnus to first look up the article in the
current group, or, alternatively, using the registry, and finally, if
all else fails, using Gmane.


File: gnus,  Node: Fancy splitting to parent,  Next: Registry Article Refer Method,  Prev: Gnus Registry Setup,  Up: The Gnus Registry

9.19.3 Fancy splitting to parent
--------------------------------

Simply put, this lets you put followup e-mail where it belongs.

   Every message has a Message-ID, which is unique, and the registry
remembers it.  When the message is moved or copied, the registry will
notice this and offer the new group as a choice to the splitting
strategy.

   When a followup is made, usually it mentions the original message's
Message-ID in the headers.  The registry knows this and uses that
mention to find the group where the original message lives.  You only
have to put a rule like this:

     (setq nnimap-my-split-fancy '(|

           ;; split to parent: you need this
           (: gnus-registry-split-fancy-with-parent)

           ;; other rules, as an example
           (: spam-split)
           ;; default mailbox
           "mail")

   in your fancy split setup.  In addition, you may want to customize
the following variables.

 -- Variable: gnus-registry-track-extra
     This is a list of symbols, so it's best to change it from the
     Customize interface.  By default it's `(subject sender)', which
     may work for you.  It can be annoying if your mail flow is large
     and people don't stick to the same groups.

 -- Variable: gnus-registry-split-strategy
     This is a symbol, so it's best to change it from the Customize
     interface.  By default it's `nil', but you may want to set it to
     `majority' or `first' to split by sender or subject based on the
     majority of matches or on the first found.  I find `majority'
     works best.


File: gnus,  Node: Store custom flags and keywords,  Next: Store arbitrary data,  Prev: Registry Article Refer Method,  Up: The Gnus Registry

9.19.4 Store custom flags and keywords
--------------------------------------

The registry lets you set custom flags and keywords per message.  You
can use the Gnus->Registry Marks menu or the `M M x' keyboard
shortcuts, where `x' is the first letter of the mark's name.

 -- Variable: gnus-registry-marks
     The custom marks that the registry can use.  You can modify the
     default list, if you like.  If you do, you'll have to exit Emacs
     before they take effect (you can also unload the registry and
     reload it or evaluate the specific macros you'll need, but you
     probably don't want to bother).  Use the Customize interface to
     modify the list.

     By default this list has the `Important', `Work', `Personal',
     `To-Do', and `Later' marks.  They all have keyboard shortcuts like
     `M M i' for Important, using the first letter.

 -- Function: gnus-registry-mark-article
     Call this function to mark an article with a custom registry mark.
     It will offer the available marks for completion.

   You can use `defalias' to install a summary line formatting function
that will show the registry marks.  There are two flavors of this
function, either showing the marks as single characters, using their
`:char' property, or showing the marks as full strings.

     ;; show the marks as single characters (see the :char property in
     ;; `gnus-registry-marks'):
     ;; (defalias 'gnus-user-format-function-M 'gnus-registry-article-marks-to-chars)

     ;; show the marks by name (see `gnus-registry-marks'):
     ;; (defalias 'gnus-user-format-function-M 'gnus-registry-article-marks-to-names)


File: gnus,  Node: Store arbitrary data,  Prev: Store custom flags and keywords,  Up: The Gnus Registry

9.19.5 Store arbitrary data
---------------------------

The registry has a simple API that uses a Message-ID as the key to
store arbitrary data (as long as it can be converted to a list for
storage).

 -- Function: gnus-registry-set-id-key (id key value)
     Store `value' under `key' for message `id'.

 -- Function: gnus-registry-get-id-key (id key)
     Get the data under `key' for message `id'.

 -- Variable: gnus-registry-extra-entries-precious
     If any extra entries are precious, their presence will make the
     registry keep the whole entry forever, even if there are no groups
     for the Message-ID and if the size limit of the registry is
     reached.  By default this is just `(marks)' so the custom registry
     marks are precious.


File: gnus,  Node: Other modes,  Next: Various Various,  Prev: The Gnus Registry,  Up: Various

9.20 Interaction with other modes
=================================

9.20.1 Dired
------------

`gnus-dired-minor-mode' provides some useful functions for dired
buffers.  It is enabled with
     (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)

`C-c C-m C-a'
     Send dired's marked files as an attachment (`gnus-dired-attach').
     You will be prompted for a message buffer.

`C-c C-m C-l'
     Visit a file according to the appropriate mailcap entry
     (`gnus-dired-find-file-mailcap').  With prefix, open file in a new
     buffer.

`C-c C-m C-p'
     Print file according to the mailcap entry (`gnus-dired-print').  If
     there is no print command, print in a PostScript image.


File: gnus,  Node: Various Various,  Prev: Other modes,  Up: Various

9.21 Various Various
====================

`gnus-home-directory'
     All Gnus file and directory variables will be initialized from this
     variable, which defaults to `~/'.

`gnus-directory'
     Most Gnus storage file and directory variables will be initialized
     from this variable, which defaults to the `SAVEDIR' environment
     variable, or `~/News/' if that variable isn't set.

     Note that Gnus is mostly loaded when the `~/.gnus.el' file is read.
     This means that other directory variables that are initialized
     from this variable won't be set properly if you set this variable
     in `~/.gnus.el'.  Set this variable in `.emacs' instead.

`gnus-default-directory'
     Not related to the above variable at all--this variable says what
     the default directory of all Gnus buffers should be.  If you issue
     commands like `C-x C-f', the prompt you'll get starts in the
     current buffer's default directory.  If this variable is `nil'
     (which is the default), the default directory will be the default
     directory of the buffer you were in when you started Gnus.

`gnus-verbose'
     This variable is an integer between zero and ten.  The higher the
     value, the more messages will be displayed.  If this variable is
     zero, Gnus will never flash any messages, if it is seven (which is
     the default), most important messages will be shown, and if it is
     ten, Gnus won't ever shut up, but will flash so many messages it
     will make your head swim.

`gnus-verbose-backends'
     This variable works the same way as `gnus-verbose', but it applies
     to the Gnus back ends instead of Gnus proper.

`gnus-add-timestamp-to-message'
     This variable controls whether to add timestamps to messages that
     are controlled by `gnus-verbose' and `gnus-verbose-backends' and
     are issued.  The default value is `nil' which means never to add
     timestamp.  If it is `log', add timestamps to only the messages
     that go into the `*Messages*' buffer (in XEmacs, it is the
     ` *Message-Log*' buffer).  If it is neither `nil' nor `log', add
     timestamps not only to log messages but also to the ones displayed
     in the echo area.

`nnheader-max-head-length'
     When the back ends read straight heads of articles, they all try
     to read as little as possible.  This variable (default 8192)
     specifies the absolute max length the back ends will try to read
     before giving up on finding a separator line between the head and
     the body.  If this variable is `nil', there is no upper read
     bound.  If it is `t', the back ends won't try to read the articles
     piece by piece, but read the entire articles.  This makes sense
     with some versions of `ange-ftp' or `efs'.

`nnheader-head-chop-length'
     This variable (default 2048) says how big a piece of each article
     to read when doing the operation described above.

`nnheader-file-name-translation-alist'
     This is an alist that says how to translate characters in file
     names.  For instance, if `:' is invalid as a file character in
     file names on your system (you OS/2 user you), you could say
     something like:

          (setq nnheader-file-name-translation-alist
                '((?: . ?_)))

     In fact, this is the default value for this variable on OS/2 and MS
     Windows (phooey) systems.

`gnus-hidden-properties'
     This is a list of properties to use to hide "invisible" text.  It
     is `(invisible t intangible t)' by default on most systems, which
     makes invisible text invisible and intangible.

`gnus-parse-headers-hook'
     A hook called before parsing headers.  It can be used, for
     instance, to gather statistics on the headers fetched, or perhaps
     you'd like to prune some headers.  I don't see why you'd want
     that, though.

`gnus-shell-command-separator'
     String used to separate two shell commands.  The default is `;'.

`gnus-invalid-group-regexp'
     Regexp to match "invalid" group names when querying user for a
     group name.  The default value catches some *really* invalid group
     names who could possibly mess up Gnus internally (like allowing
     `:' in a group name, which is normally used to delimit method and
     group).

     IMAP users might want to allow `/' in group names though.

`gnus-safe-html-newsgroups'
     Groups in which links in html articles are considered all safe.
     The value may be a regexp matching those groups, a list of group
     names, or `nil'.  This overrides `mm-w3m-safe-url-regexp'.  The
     default value is `"\\`nnrss[+:]"'.  This is effective only when
     emacs-w3m renders html articles, i.e., in the case
     `mm-text-html-renderer' is set to `w3m'.  *Note Display
     Customization: (emacs-mime)Display Customization.



File: gnus,  Node: The End,  Next: Appendices,  Prev: Various,  Up: Top

10 The End
**********

Well, that's the manual--you can get on with your life now.  Keep in
touch.  Say hello to your cats from me.

   My *ghod*--I just can't stand goodbyes.  Sniffle.

   Ol' Charles Reznikoff said it pretty well, so I leave the floor to
him:

     *Te Deum*


     Not because of victories
     I sing,
     having none,
     but for the common sunshine,
     the breeze,
     the largess of the spring.


     Not for victory
     but for the day's work done
     as well as I was able;
     not for a seat upon the dais
     but at the common table.


File: gnus,  Node: Appendices,  Next: GNU Free Documentation License,  Prev: The End,  Up: Top

11 Appendices
*************

* Menu:

* XEmacs::                      Requirements for installing under XEmacs.
* History::                     How Gnus got where it is today.
* On Writing Manuals::          Why this is not a beginner's guide.
* Terminology::                 We use really difficult, like, words here.
* Customization::               Tailoring Gnus to your needs.
* Troubleshooting::             What you might try if things do not work.
* Gnus Reference Guide::        Rilly, rilly technical stuff.
* Emacs for Heathens::          A short introduction to Emacsian terms.
* Frequently Asked Questions::  The Gnus FAQ


File: gnus,  Node: XEmacs,  Next: History,  Up: Appendices

11.1 XEmacs
===========

XEmacs is distributed as a collection of packages.  You should install
whatever packages the Gnus XEmacs package requires.  The current
requirements are `gnus', `mail-lib', `xemacs-base', `eterm',
`sh-script', `net-utils', `os-utils', `dired', `mh-e', `sieve',
`ps-print', `W3', `pgg', `mailcrypt', `ecrypto', and `sasl'.


File: gnus,  Node: History,  Next: On Writing Manuals,  Prev: XEmacs,  Up: Appendices

11.2 History
============

GNUS was written by Masanobu UMEDA.  When autumn crept up in '94, Lars
Magne Ingebrigtsen grew bored and decided to rewrite Gnus.

   If you want to investigate the person responsible for this outrage,
you can point your (feh!) web browser to `http://quimby.gnus.org/'.
This is also the primary distribution point for the new and spiffy
versions of Gnus, and is known as The Site That Destroys Newsrcs And
Drives People Mad.

   During the first extended alpha period of development, the new Gnus
was called "(ding) Gnus".  "(ding)" is, of course, short for "ding is
not Gnus", which is a total and utter lie, but who cares?  (Besides,
the "Gnus" in this abbreviation should probably be pronounced "news" as
UMEDA intended, which makes it a more appropriate name, don't you
think?)

   In any case, after spending all that energy on coming up with a new
and spunky name, we decided that the name was _too_ spunky, so we
renamed it back again to "Gnus".  But in mixed case.  "Gnus" vs.
"GNUS".  New vs. old.

* Menu:

* Gnus Versions::               What Gnus versions have been released.
* Why?::                        What's the point of Gnus?
* Compatibility::               Just how compatible is Gnus with GNUS?
* Conformity::                  Gnus tries to conform to all standards.
* Emacsen::                     Gnus can be run on a few modern Emacsen.
* Gnus Development::            How Gnus is developed.
* Contributors::                Oodles of people.
* New Features::                Pointers to some of the new stuff in Gnus.


File: gnus,  Node: Gnus Versions,  Next: Why?,  Up: History

11.2.1 Gnus Versions
--------------------

The first "proper" release of Gnus 5 was done in November 1995 when it
was included in the Emacs 19.30 distribution (132 (ding) Gnus releases
plus 15 Gnus 5.0 releases).

   In May 1996 the next Gnus generation (aka. "September Gnus" (after 99
releases)) was released under the name "Gnus 5.2" (40 releases).

   On July 28th 1996 work on Red Gnus was begun, and it was released on
January 25th 1997 (after 84 releases) as "Gnus 5.4" (67 releases).

   On September 13th 1997, Quassia Gnus was started and lasted 37
releases.  It was released as "Gnus 5.6" on March 8th 1998 (46
releases).

   Gnus 5.6 begat Pterodactyl Gnus on August 29th 1998 and was released
as "Gnus 5.8" (after 99 releases and a CVS repository) on December 3rd
1999.

   On the 26th of October 2000, Oort Gnus was begun and was released as
Gnus 5.10 on May 1st 2003 (24 releases).

   On the January 4th 2004, No Gnus was begun.

   On April 19, 2010 Gnus development was moved to Git.  See
http://git.gnus.org for details (http://www.gnus.org will be updated
with the information when possible).

   If you happen upon a version of Gnus that has a prefixed name -
"(ding) Gnus", "September Gnus", "Red Gnus", "Quassia Gnus",
"Pterodactyl Gnus", "Oort Gnus", "No Gnus" - don't panic.  Don't let it
know that you're frightened.  Back away.  Slowly.  Whatever you do,
don't run.  Walk away, calmly, until you're out of its reach.  Find a
proper released version of Gnus and snuggle up to that instead.


File: gnus,  Node: Why?,  Next: Compatibility,  Prev: Gnus Versions,  Up: History

11.2.2 Why?
-----------

What's the point of Gnus?

   I want to provide a "rad", "happening", "way cool" and "hep"
newsreader, that lets you do anything you can think of.  That was my
original motivation, but while working on Gnus, it has become clear to
me that this generation of newsreaders really belong in the stone age.
Newsreaders haven't developed much since the infancy of the net.  If the
volume continues to rise with the current rate of increase, all current
newsreaders will be pretty much useless.  How do you deal with
newsgroups that have thousands of new articles each day?  How do you
keep track of millions of people who post?

   Gnus offers no real solutions to these questions, but I would very
much like to see Gnus being used as a testing ground for new methods of
reading and fetching news.  Expanding on UMEDA-san's wise decision to
separate the newsreader from the back ends, Gnus now offers a simple
interface for anybody who wants to write new back ends for fetching mail
and news from different sources.  I have added hooks for customizations
everywhere I could imagine it being useful.  By doing so, I'm inviting
every one of you to explore and invent.

   May Gnus never be complete.  `C-u 100 M-x all-hail-emacs' and `C-u
100 M-x all-hail-xemacs'.


File: gnus,  Node: Compatibility,  Next: Conformity,  Prev: Why?,  Up: History

11.2.3 Compatibility
--------------------

Gnus was designed to be fully compatible with GNUS.  Almost all key
bindings have been kept.  More key bindings have been added, of course,
but only in one or two obscure cases have old bindings been changed.

   Our motto is:

                         In a cloud bones of steel.

   All commands have kept their names.  Some internal functions have
changed their names.

   The `gnus-uu' package has changed drastically.  *Note Decoding
Articles::.

   One major compatibility question is the presence of several summary
buffers.  All variables relevant while reading a group are buffer-local
to the summary buffer they belong in.  Although many important
variables have their values copied into their global counterparts
whenever a command is executed in the summary buffer, this change might
lead to incorrect values being used unless you are careful.

   All code that relies on knowledge of GNUS internals will probably
fail.  To take two examples: Sorting `gnus-newsrc-alist' (or changing
it in any way, as a matter of fact) is strictly verboten.  Gnus
maintains a hash table that points to the entries in this alist (which
speeds up many functions), and changing the alist directly will lead to
peculiar results.

   Old hilit19 code does not work at all.  In fact, you should probably
remove all hilit code from all Gnus hooks (`gnus-group-prepare-hook'
and `gnus-summary-prepare-hook').  Gnus provides various integrated
functions for highlighting.  These are faster and more accurate.  To
make life easier for everybody, Gnus will by default remove all hilit
calls from all hilit hooks.  Uncleanliness!  Away!

   Packages like `expire-kill' will no longer work.  As a matter of
fact, you should probably remove all old GNUS packages (and other code)
when you start using Gnus.  More likely than not, Gnus already does
what you have written code to make GNUS do.  (Snicker.)

   Even though old methods of doing things are still supported, only the
new methods are documented in this manual.  If you detect a new method
of doing something while reading this manual, that does not mean you
have to stop doing it the old way.

   Gnus understands all GNUS startup files.

   Overall, a casual user who hasn't written much code that depends on
GNUS internals should suffer no problems.  If problems occur, please
let me know by issuing that magic command `M-x gnus-bug'.

   If you are in the habit of sending bug reports _very_ often, you may
find the helpful help buffer annoying after a while.  If so, set
`gnus-bug-create-help-buffer' to `nil' to avoid having it pop up at you.


File: gnus,  Node: Conformity,  Next: Emacsen,  Prev: Compatibility,  Up: History

11.2.4 Conformity
-----------------

No rebels without a clue here, ma'am.  We conform to all standards known
to (wo)man.  Except for those standards and/or conventions we disagree
with, of course.

*RFC (2)822*
     There are no known breaches of this standard.

*RFC 1036*
     There are no known breaches of this standard, either.

*Son-of-RFC 1036*
     We do have some breaches to this one.

    _X-Newsreader_
    _User-Agent_
          These are considered to be "vanity headers", while I consider
          them to be consumer information.  After seeing so many badly
          formatted articles coming from `tin' and `Netscape' I know
          not to use either of those for posting articles.  I would not
          have known that if it wasn't for the `X-Newsreader' header.

*USEFOR*
     USEFOR is an IETF working group writing a successor to RFC 1036,
     based on Son-of-RFC 1036.  They have produced a number of drafts
     proposing various changes to the format of news articles.  The
     Gnus towers will look into implementing the changes when the draft
     is accepted as an RFC.

*MIME - RFC 2045-2049 etc*
     All the various MIME RFCs are supported.

*Disposition Notifications - RFC 2298*
     Message Mode is able to request notifications from the receiver.

*PGP - RFC 1991 and RFC 2440*
     RFC 1991 is the original PGP message specification, published as
     an informational RFC.  RFC 2440 was the follow-up, now called Open
     PGP, and put on the Standards Track.  Both document a non-MIME
     aware PGP format.  Gnus supports both encoding (signing and
     encryption) and decoding (verification and decryption).

*PGP/MIME - RFC 2015/3156*
     RFC 2015 (superseded by 3156 which references RFC 2440 instead of
     RFC 1991) describes the MIME-wrapping around the RFC 1991/2440
     format.  Gnus supports both encoding and decoding.

*S/MIME - RFC 2633*
     RFC 2633 describes the S/MIME format.

*IMAP - RFC 1730/2060, RFC 2195, RFC 2086, RFC 2359, RFC 2595, RFC 1731*
     RFC 1730 is IMAP version 4, updated somewhat by RFC 2060 (IMAP 4
     revision 1).  RFC 2195 describes CRAM-MD5 authentication for IMAP.
     RFC 2086 describes access control lists (ACLs) for IMAP.  RFC 2359
     describes a IMAP protocol enhancement.  RFC 2595 describes the
     proper TLS integration (STARTTLS) with IMAP.  RFC 1731 describes
     the GSSAPI/Kerberos4 mechanisms for IMAP.


   If you ever notice Gnus acting non-compliant with regards to the
texts mentioned above, don't hesitate to drop a note to Gnus Towers and
let us know.


File: gnus,  Node: Emacsen,  Next: Gnus Development,  Prev: Conformity,  Up: History

11.2.5 Emacsen
--------------

This version of Gnus should work on:

   * Emacs 21.1 and up.

   * XEmacs 21.4 and up.


   This Gnus version will absolutely not work on any Emacsen older than
that.  Not reliably, at least.  Older versions of Gnus may work on older
Emacs versions.  Particularly, Gnus 5.10.8 should also work on Emacs
20.7 and XEmacs 21.1.


File: gnus,  Node: Gnus Development,  Next: Contributors,  Prev: Emacsen,  Up: History

11.2.6 Gnus Development
-----------------------

Gnus is developed in a two-phased cycle.  The first phase involves much
discussion on the development mailing list `ding@gnus.org', where people
propose changes and new features, post patches and new back ends.  This
phase is called the "alpha" phase, since the Gnusae released in this
phase are "alpha releases", or (perhaps more commonly in other circles)
"snapshots".  During this phase, Gnus is assumed to be unstable and
should not be used by casual users.  Gnus alpha releases have names
like "Oort Gnus" and "No Gnus".  *Note Gnus Versions::.

   After futzing around for 10-100 alpha releases, Gnus is declared
"frozen", and only bug fixes are applied.  Gnus loses the prefix, and
is called things like "Gnus 5.10.1" instead.  Normal people are
supposed to be able to use these, and these are mostly discussed on the
`gnu.emacs.gnus' newsgroup.  This newgroup is mirrored to the mailing
list `info-gnus-english@gnu.org' which is carried on Gmane as
`gmane.emacs.gnus.user'.  These releases are finally integrated in
Emacs.

   Some variable defaults differ between alpha Gnusae and released
Gnusae, in particular, `mail-source-delete-incoming'.  This is to
prevent lossage of mail if an alpha release hiccups while handling the
mail.  *Note Mail Source Customization::.

   The division of discussion between the ding mailing list and the Gnus
newsgroup is not purely based on publicity concerns.  It's true that
having people write about the horrible things that an alpha Gnus release
can do (sometimes) in a public forum may scare people off, but more
importantly, talking about new experimental features that have been
introduced may confuse casual users.  New features are frequently
introduced, fiddled with, and judged to be found wanting, and then
either discarded or totally rewritten.  People reading the mailing list
usually keep up with these rapid changes, while people on the newsgroup
can't be assumed to do so.

   So if you have problems with or questions about the alpha versions,
direct those to the ding mailing list `ding@gnus.org'.  This list is
also available on Gmane as `gmane.emacs.gnus.general'.

   Some variable defaults differ between alpha Gnusae and released
Gnusae, in particular, `mail-source-delete-incoming'.  This is to
prevent lossage of mail if an alpha release hiccups while handling the
mail.  *Note Mail Source Customization::.


File: gnus,  Node: Contributors,  Next: New Features,  Prev: Gnus Development,  Up: History

11.2.7 Contributors
-------------------

The new Gnus version couldn't have been done without the help of all the
people on the (ding) mailing list.  Every day for over a year I have
gotten billions of nice bug reports from them, filling me with joy,
every single one of them.  Smooches.  The people on the list have been
tried beyond endurance, what with my "oh, that's a neat idea <type
type>, yup, I'll release it right away <ship off> no wait, that doesn't
work at all <type type>, yup, I'll ship that one off right away <ship
off> no, wait, that absolutely does not work" policy for releases.
Micro$oft--bah.  Amateurs.  I'm _much_ worse.  (Or is that "worser"?
"much worser"?  "worsest"?)

   I would like to take this opportunity to thank the Academy for...
oops, wrong show.

   * Masanobu UMEDA--the writer of the original GNUS.

   * Shenghuo Zhu--uudecode.el, mm-uu.el, rfc1843.el, nnwarchive and
     many, many other things connected with MIME and other types of
     en/decoding, as well as general bug fixing, new functionality and
     stuff.

   * Per Abrahamsen--custom, scoring, highlighting and SOUP code (as
     well as numerous other things).

   * Luis Fernandes--design and graphics.

   * Joe Reiss--creator of the smiley faces.

   * Justin Sheehy--the FAQ maintainer.

   * Erik Naggum--help, ideas, support, code and stuff.

   * Wes Hardaker--`gnus-picon.el' and the manual section on "picons"
     (*note Picons::).

   * Kim-Minh Kaplan--further work on the picon code.

   * Brad Miller--`gnus-gl.el' and the GroupLens manual section.

   * Sudish Joseph--innumerable bug fixes.

   * Ilja Weis--`gnus-topic.el'.

   * Steven L. Baur--lots and lots and lots of bug detection and fixes.

   * Vladimir Alexiev--the refcard and reference booklets.

   * Felix Lee & Jamie Zawinski--I stole some pieces from the XGnus
     distribution by Felix Lee and JWZ.

   * Scott Byer--`nnfolder.el' enhancements & rewrite.

   * Peter Mutsaers--orphan article scoring code.

   * Ken Raeburn--POP mail support.

   * Hallvard B Furuseth--various bits and pieces, especially dealing
     with .newsrc files.

   * Brian Edmonds--`gnus-bbdb.el'.

   * David Moore--rewrite of `nnvirtual.el' and many other things.

   * Kevin Davidson--came up with the name "ding", so blame him.

   * Franois Pinard--many, many interesting and thorough bug reports,
     as well as autoconf support.


   This manual was proof-read by Adrian Aichner, with Ricardo Nassif,
Mark Borges, and Jost Krieger proof-reading parts of the manual.

   The following people have contributed many patches and suggestions:

   Christopher Davis, Andrew Eskilsson, Kai Grossjohann, Kevin Greiner,
Jesper Harder, Paul Jarc, Simon Josefsson, David Kgedal, Richard Pieri,
Fabrice Popineau, Daniel Quinlan, Michael Shields, Reiner Steib, Jason
L. Tibbitts, III, Jack Vinson, Katsumi Yamaoka, and Teodor Zlatanov.

   Also thanks to the following for patches and stuff:

   Jari Aalto, Adrian Aichner, Vladimir Alexiev, Russ Allbery, Peter
Arius, Matt Armstrong, Marc Auslander, Miles Bader, Alexei V. Barantsev,
Frank Bennett, Robert Bihlmeyer, Chris Bone, Mark Borges, Mark Boyns,
Lance A. Brown, Rob Browning, Kees de Bruin, Martin Buchholz, Joe
Buehler, Kevin Buhr, Alastair Burt, Joao Cachopo, Zlatko Calusic,
Massimo Campostrini, Castor, David Charlap, Dan Christensen, Kevin
Christian, Jae-you Chung, James H. Cloos, Jr., Laura Conrad, Michael R.
Cook, Glenn Coombs, Andrew J. Cosgriff, Neil Crellin, Frank D. Cringle,
Geoffrey T. Dairiki, Andre Deparade, Ulrik Dickow, Dave Disser, Rui-Tao
Dong, Joev Dubach, Michael Welsh Duggan, Dave Edmondson, Paul Eggert,
Mark W. Eichin, Karl Eichwalder, Enami Tsugutomo, Michael Ernst, Luc
Van Eycken, Sam Falkner, Nelson Jose dos Santos Ferreira, Sigbjorn
Finne, Sven Fischer, Paul Fisher, Decklin Foster, Gary D. Foster, Paul
Franklin, Guy Geens, Arne Georg Gleditsch, David S. Goldberg,
Michelangelo Grigni, Dale Hagglund, D. Hall, Magnus Hammerin, Kenichi
Handa, Raja R. Harinath, Yoshiki Hayashi, P. E. Jareth Hein, Hisashige
Kenji, Scott Hofmann, Tassilo Horn, Marc Horowitz, Gunnar Horrigmo,
Richard Hoskins, Brad Howes, Miguel de Icaza, Franois Felix Ingrand,
Tatsuya Ichikawa, Ishikawa Ichiro, Lee Iverson, Iwamuro Motonori,
Rajappa Iyer, Andreas Jaeger, Adam P. Jenkins, Randell Jesup, Fred
Johansen, Gareth Jones, Greg Klanderman, Karl Kleinpaste, Michael
Klingbeil, Peter Skov Knudsen, Shuhei Kobayashi, Petr Konecny, Koseki
Yoshinori, Thor Kristoffersen, Jens Lautenbacher, Martin Larose,
Seokchan Lee, Joerg Lenneis, Carsten Leonhardt, James LewisMoss,
Christian Limpach, Markus Linnala, Dave Love, Mike McEwan, Tonny Madsen,
Shlomo Mahlab, Nat Makarevitch, Istvan Marko, David Martin, Jason R.
Mastaler, Gordon Matzigkeit, Timo Metzemakers, Richard Mlynarik, Lantz
Moore, Morioka Tomohiko, Erik Toubro Nielsen, Hrvoje Niksic, Andy
Norman, Fred Oberhauser, C. R. Oldham, Alexandre Oliva, Ken Olstad,
Masaharu Onishi, Hideki Ono, Ettore Perazzoli, William Perry, Stephen
Peters, Jens-Ulrik Holger Petersen, Ulrich Pfeifer, Matt Pharr, Andy
Piper, John McClary Prevost, Bill Pringlemeir, Mike Pullen, Jim Radford,
Colin Rafferty, Lasse Rasinen, Lars Balker Rasmussen, Joe Reiss, Renaud
Rioboo, Roland B. Roberts, Bart Robinson, Christian von Roques, Markus
Rost, Jason Rumney, Wolfgang Rupprecht, Jay Sachs, Dewey M. Sasser,
Conrad Sauerwald, Loren Schall, Dan Schmidt, Ralph Schleicher, Philippe
Schnoebelen, Andreas Schwab, Randal L. Schwartz, Danny Siu, Matt
Simmons, Paul D. Smith, Jeff Sparkes, Toby Speight, Michael Sperber,
Darren Stalder, Richard Stallman, Greg Stark, Sam Steingold, Paul
Stevenson, Jonas Steverud, Paul Stodghill, Kiyokazu Suto, Kurt Swanson,
Samuel Tardieu, Teddy, Chuck Thompson, Tozawa Akihiko, Philippe Troin,
James Troup, Trung Tran-Duc, Jack Twilley, Aaron M. Ucko, Aki Vehtari,
Didier Verna, Vladimir Volovich, Jan Vroonhof, Stefan Waldherr, Pete
Ware, Barry A. Warsaw, Christoph Wedler, Joe Wells, Lee Willis, and
Lloyd Zusman.

   For a full overview of what each person has done, the ChangeLogs
included in the Gnus alpha distributions should give ample reading
(550kB and counting).

   Apologies to everybody that I've forgotten, of which there are many,
I'm sure.

   Gee, that's quite a list of people.  I guess that must mean that
there actually are people who are using Gnus.  Who'd'a thunk it!


File: gnus,  Node: New Features,  Prev: Contributors,  Up: History

11.2.8 New Features
-------------------

* Menu:

* ding Gnus::                   New things in Gnus 5.0/5.1, the first new Gnus.
* September Gnus::              The Thing Formally Known As Gnus 5.2/5.3.
* Red Gnus::                    Third time best---Gnus 5.4/5.5.
* Quassia Gnus::                Two times two is four, or Gnus 5.6/5.7.
* Pterodactyl Gnus::            Pentad also starts with P, AKA Gnus 5.8/5.9.
* Oort Gnus::                   It's big.  It's far out.  Gnus 5.10/5.11.
* No Gnus::                     Very punny.

   These lists are, of course, just _short_ overviews of the _most_
important new features.  No, really.  There are tons more.  Yes, we
have feeping creaturism in full effect.


File: gnus,  Node: ding Gnus,  Next: September Gnus,  Up: New Features

11.2.8.1 (ding) Gnus
....................

New features in Gnus 5.0/5.1:

   * The look of all buffers can be changed by setting format-like
     variables (*note Group Buffer Format:: and *note Summary Buffer
     Format::).

   * Local spool and several NNTP servers can be used at once (*note
     Select Methods::).

   * You can combine groups into virtual groups (*note Virtual
     Groups::).

   * You can read a number of different mail formats (*note Getting
     Mail::).  All the mail back ends implement a convenient mail
     expiry scheme (*note Expiring Mail::).

   * Gnus can use various strategies for gathering threads that have
     lost their roots (thereby gathering loose sub-threads into one
     thread) or it can go back and retrieve enough headers to build a
     complete thread (*note Customizing Threading::).

   * Killed groups can be displayed in the group buffer, and you can
     read them as well (*note Listing Groups::).

   * Gnus can do partial group updates--you do not have to retrieve the
     entire active file just to check for new articles in a few groups
     (*note The Active File::).

   * Gnus implements a sliding scale of subscribedness to groups (*note
     Group Levels::).

   * You can score articles according to any number of criteria (*note
     Scoring::).  You can even get Gnus to find out how to score
     articles for you (*note Adaptive Scoring::).

   * Gnus maintains a dribble buffer that is auto-saved the normal Emacs
     manner, so it should be difficult to lose much data on what you
     have read if your machine should go down (*note Auto Save::).

   * Gnus now has its own startup file (`~/.gnus.el') to avoid
     cluttering up the `.emacs' file.

   * You can set the process mark on both groups and articles and
     perform operations on all the marked items (*note
     Process/Prefix::).

   * You can list subsets of groups according to, well, anything (*note
     Listing Groups::).

   * You can browse foreign servers and subscribe to groups from those
     servers (*note Browse Foreign Server::).

   * Gnus can fetch articles, asynchronously, on a second connection to
     the server (*note Asynchronous Fetching::).

   * You can cache articles locally (*note Article Caching::).

   * The uudecode functions have been expanded and generalized (*note
     Decoding Articles::).

   * You can still post uuencoded articles, which was a little-known
     feature of GNUS' past (*note Uuencoding and Posting::).

   * Fetching parents (and other articles) now actually works without
     glitches (*note Finding the Parent::).

   * Gnus can fetch FAQs and group descriptions (*note Group
     Information::).

   * Digests (and other files) can be used as the basis for groups
     (*note Document Groups::).

   * Articles can be highlighted and customized (*note Customizing
     Articles::).

   * URLs and other external references can be buttonized (*note
     Article Buttons::).

   * You can do lots of strange stuff with the Gnus window & frame
     configuration (*note Window Layout::).




Local Variables:
coding: iso-8859-1
End:
