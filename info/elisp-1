This is /home/cyd/emacs/doc/lispref/../../info/elisp, produced by
makeinfo version 4.13 from /home/cyd/emacs/doc/lispref/elisp.texi.

This is the `GNU Emacs Lisp Reference Manual' corresponding to Emacs
version 24.1.

Copyright (C) 1990-1996, 1998-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "GNU General Public
     License," with the Front-Cover texts being "A GNU Manual," and
     with the Back-Cover Texts as in (a) below.  A copy of the license
     is included in the section entitled "GNU Free Documentation
     License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION GNU Emacs Lisp
START-INFO-DIR-ENTRY
* Elisp: (elisp).       The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY


File: elisp,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Emacs Lisp
**********

This is the `GNU Emacs Lisp Reference Manual' corresponding to Emacs
version 24.1.

Copyright (C) 1990-1996, 1998-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "GNU General Public
     License," with the Front-Cover texts being "A GNU Manual," and
     with the Back-Cover Texts as in (a) below.  A copy of the license
     is included in the section entitled "GNU Free Documentation
     License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

* Menu:

* Introduction::            Introduction and conventions used.

* Lisp Data Types::         Data types of objects in Emacs Lisp.
* Numbers::                 Numbers and arithmetic functions.
* Strings and Characters::  Strings, and functions that work on them.
* Lists::                   Lists, cons cells, and related functions.
* Sequences Arrays Vectors::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* Hash Tables::             Very fast lookup-tables.
* Symbols::                 Symbols represent names, uniquely.

* Evaluation::              How Lisp expressions are evaluated.
* Control Structures::      Conditionals, loops, nonlocal exits.
* Variables::               Using symbols in programs to stand for values.
* Functions::               A function is a Lisp program
                              that can be invoked from other functions.
* Macros::                  Macros are a way to extend the Lisp language.
* Customization::           Making variables and faces customizable.

* Loading::                 Reading files of Lisp code into Lisp.
* Byte Compilation::        Compilation makes programs run faster.
* Advising Functions::      Adding to the definition of a function.
* Debugging::               Tools and tips for debugging Lisp programs.

* Read and Print::          Converting Lisp objects to text and back.
* Minibuffers::             Using the minibuffer to read input.
* Command Loop::            How the editor command loop works,
                              and how you can call its subroutines.
* Keymaps::                 Defining the bindings from keys to commands.
* Modes::                   Defining major and minor modes.
* Documentation::           Writing and using documentation strings.

* Files::                   Accessing files.
* Backups and Auto-Saving:: Controlling how backups and auto-save
                              files are made.
* Buffers::                 Creating and using buffer objects.
* Windows::                 Manipulating windows and displaying buffers.
* Frames::                  Making multiple system-level windows.
* Positions::               Buffer positions and motion functions.
* Markers::                 Markers represent positions and update
                              automatically when the text is changed.

* Text::                    Examining and changing text in buffers.
* Non-ASCII Characters::    Non-ASCII text in buffers and strings.
* Searching and Matching::  Searching buffers for strings or regexps.
* Syntax Tables::           The syntax table controls word and list parsing.
* Abbrevs::                 How Abbrev mode works, and its data structures.

* Processes::               Running and communicating with subprocesses.
* Display::                 Features for controlling the screen display.
* System Interface::        Getting the user id, system type, environment
                              variables, and other such things.

* Packaging::               Preparing Lisp code for distribution.

Appendices

* Antinews::                Info for users downgrading to Emacs 23.
* GNU Free Documentation License:: The license for this documentation.
* GPL::                     Conditions for copying and changing GNU Emacs.
* Tips::                    Advice and coding conventions for Emacs Lisp.
* GNU Emacs Internals::     Building and dumping Emacs;
                              internal data structures.
* Standard Errors::         List of some standard error symbols.
* Standard Keymaps::        List of some standard keymaps.
* Standard Hooks::          List of some standard hook variables.

* Index::                   Index including concepts, functions, variables,
                              and other terms.



 --- The Detailed Node Listing ---
 ---------------------------------

Here are other nodes that are subnodes of those already listed,
mentioned here so you can get to them in one step:

Introduction

* Caveats::                 Flaws and a request for help.
* Lisp History::            Emacs Lisp is descended from Maclisp.
* Conventions::             How the manual is formatted.
* Version Info::            Which Emacs version is running?
* Acknowledgements::        The authors, editors, and sponsors of this manual.

Conventions

* Some Terms::              Explanation of terms we use in this manual.
* nil and t::               How the symbols `nil' and `t' are used.
* Evaluation Notation::     The format we use for examples of evaluation.
* Printing Notation::       The format we use when examples print text.
* Error Messages::          The format we use for examples of errors.
* Buffer Text Notation::    The format we use for buffer contents in examples.
* Format of Descriptions::  Notation for describing functions, variables, etc.

Format of Descriptions

* A Sample Function Description::  A description of an imaginary
                                     function, `foo'.
* A Sample Variable Description::  A description of an imaginary
                                     variable, `electric-future-map'.

Lisp Data Types

* Printed Representation::  How Lisp objects are represented as text.
* Comments::                Comments and their formatting conventions.
* Programming Types::       Types found in all Lisp systems.
* Editing Types::           Types specific to Emacs.
* Circular Objects::        Read syntax for circular structure.
* Type Predicates::         Tests related to types.
* Equality Predicates::     Tests of equality between any two objects.

Programming Types

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                          control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of `t' or `nil'.
* Hash Table Type::     Super-fast lookup tables.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                          functions.

Character Type

* Basic Char Syntax::       Syntax for regular characters.
* General Escape Syntax::   How to specify characters by their codes.
* Ctl-Char Syntax::         Syntax for control characters.
* Meta-Char Syntax::        Syntax for meta-characters.
* Other Char Bits::         Syntax for hyper-, super-, and alt-characters.

Cons Cell and List Types

* Box Diagrams::            Drawing pictures of lists.
* Dotted Pair Notation::    A general syntax for cons cells.
* Association List Type::   A specially constructed list.

String Type

* Syntax for Strings::      How to specify Lisp strings.
* Non-ASCII in Strings::    International characters in strings.
* Nonprinting Characters::  Literal unprintable characters in strings.
* Text Props and Strings::  Strings with text properties.

Editing Types

* Buffer Type::             The basic object of editing.
* Marker Type::             A position in a buffer.
* Window Type::             Buffers are displayed in windows.
* Frame Type::              Windows subdivide frames.
* Terminal Type::           A terminal device displays frames.
* Window Configuration Type::  Recording the way a frame is subdivided.
* Frame Configuration Type::   Recording the status of all frames.
* Process Type::            A subprocess of Emacs running on the underlying OS.
* Stream Type::             Receive or send characters.
* Keymap Type::             What function a keystroke invokes.
* Overlay Type::            How an overlay is represented.
* Font Type::               Fonts for displaying text.

Numbers

* Integer Basics::          Representation and range of integers.
* Float Basics::            Representation and range of floating point.
* Predicates on Numbers::   Testing for numbers.
* Comparison of Numbers::   Equality and inequality predicates.
* Numeric Conversions::     Converting float to integer and vice versa.
* Arithmetic Operations::   How to add, subtract, multiply and divide.
* Rounding Operations::     Explicitly rounding floating point numbers.
* Bitwise Operations::      Logical and, or, not, shifting.
* Math Functions::          Trig, exponential and logarithmic functions.
* Random Numbers::          Obtaining random integers, predictable or not.

Strings and Characters

* String Basics::           Basic properties of strings and characters.
* Predicates for Strings::  Testing whether an object is a string or char.
* Creating Strings::        Functions to allocate new strings.
* Modifying Strings::       Altering the contents of an existing string.
* Text Comparison::         Comparing characters or strings.
* String Conversion::       Converting to and from characters and strings.
* Formatting Strings::      `format': Emacs's analogue of `printf'.
* Case Conversion::         Case conversion functions.
* Case Tables::             Customizing case conversion.

Lists

* Cons Cells::              How lists are made out of cons cells.
* List-related Predicates:: Is this object a list?  Comparing two lists.
* List Elements::           Extracting the pieces of a list.
* Building Lists::          Creating list structure.
* List Variables::          Modifying lists stored in variables.
* Modifying Lists::         Storing new pieces into an existing list.
* Sets And Lists::          A list can represent a finite mathematical set.
* Association Lists::       A list can represent a finite relation or mapping.

Modifying Existing List Structure

* Setcar::                  Replacing an element in a list.
* Setcdr::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* Rearrangement::           Reordering the elements in a list; combining lists.

Sequences, Arrays, and Vectors

* Sequence Functions::      Functions that accept any kind of sequence.
* Arrays::                  Characteristics of arrays in Emacs Lisp.
* Array Functions::         Functions specifically for arrays.
* Vectors::                 Special characteristics of Emacs Lisp vectors.
* Vector Functions::        Functions specifically for vectors.
* Char-Tables::             How to work with char-tables.
* Bool-Vectors::            How to work with bool-vectors.
* Rings::                   Managing a fixed-size ring of objects.

Hash Tables

* Creating Hash::           Functions to create hash tables.
* Hash Access::             Reading and writing the hash table contents.
* Defining Hash::           Defining new comparison methods.
* Other Hash::              Miscellaneous.

Symbols

* Symbol Components::       Symbols have names, values, function definitions
                              and property lists.
* Definitions::             A definition says how a symbol will be used.
* Creating Symbols::        How symbols are kept unique.
* Property Lists::          Each symbol has a property list
                              for recording miscellaneous information.

Property Lists

* Plists and Alists::       Comparison of the advantages of property
                              lists and association lists.
* Symbol Plists::           Functions to access symbols' property lists.
* Other Plists::            Accessing property lists stored elsewhere.

Evaluation

* Intro Eval::              Evaluation in the scheme of things.
* Forms::                   How various sorts of objects are evaluated.
* Quoting::                 Avoiding evaluation (to put constants in
                              the program).
* Backquote::               Easier construction of list structure.
* Eval::                    How to invoke the Lisp interpreter explicitly.

Kinds of Forms

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Indirection::    When a symbol appears as the car of a list,
                              we find the real function via the symbol.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           "Special forms" are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.

Control Structures

* Sequencing::              Evaluation in textual order.
* Conditionals::            `if', `cond', `when', `unless'.
* Combining Conditions::    `and', `or', `not'.
* Iteration::               `while' loops.
* Nonlocal Exits::          Jumping out of a sequence.

Nonlocal Exits

* Catch and Throw::         Nonlocal exits for the program's own purposes.
* Examples of Catch::       Showing how such nonlocal exits can be written.
* Errors::                  How errors are signaled and handled.
* Cleanups::                Arranging to run a cleanup form if an
                              error happens.

Errors

* Signaling Errors::        How to report an error.
* Processing of Errors::    What Emacs does when you report an error.
* Handling Errors::         How you can trap errors and continue execution.
* Error Symbols::           How errors are classified for trapping them.

Variables

* Global Variables::        Variable values that exist permanently, everywhere.
* Constant Variables::      Certain "variables" have values that never change.
* Local Variables::         Variable values that exist only temporarily.
* Void Variables::          Symbols that lack values.
* Defining Variables::      A definition says a symbol is used as a variable.
* Tips for Defining::       Things you should think about when you
                              define a variable.
* Accessing Variables::     Examining values of variables whose names
                              are known only at run time.
* Setting Variables::       Storing new values in variables.
* Variable Scoping::        How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.
* File Local Variables::    Handling local variable lists in files.
* Directory Local Variables:: Local variables common to all files in a
                                directory.
* Variable Aliases::        Variables that are aliases for other variables.
* Variables with Restricted Values::  Non-constant variables whose value can
                                        _not_ be an arbitrary Lisp object.

Scoping Rules for Variable Bindings

* Dynamic Binding::         The default for binding local variables in Emacs.
* Dynamic Binding Tips::    Avoiding problems with dynamic binding.
* Lexical Binding::         A different type of local variable binding.
* Using Lexical Binding::   How to enable lexical binding.

Buffer-Local Variables

* Intro to Buffer-Local::   Introduction and concepts.
* Creating Buffer-Local::   Creating and destroying buffer-local bindings.
* Default Value::           The default value is seen in buffers
                              that don't have their own buffer-local values.

Functions

* What Is a Function::      Lisp functions vs. primitives; terminology.
* Lambda Expressions::      How functions are expressed as Lisp objects.
* Function Names::          A symbol can serve as the name of a function.
* Defining Functions::      Lisp expressions for defining functions.
* Calling Functions::       How to use an existing function.
* Mapping Functions::       Applying a function to each element of a list, etc.
* Anonymous Functions::     Lambda expressions are functions with no names.
* Function Cells::          Accessing or setting the function definition
                              of a symbol.
* Closures::                Functions that enclose a lexical environment.
* Obsolete Functions::      Declaring functions obsolete.
* Inline Functions::        Defining functions that the compiler
                              will expand inline.
* Declaring Functions::     Telling the compiler that a function is defined.
* Function Safety::         Determining whether a function is safe to call.
* Related Topics::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

Lambda Expressions

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

Macros

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Problems with Macros::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.
* Indenting Macros::        Specifying how to indent macro calls.

Common Problems Using Macros

* Wrong Time::             Do the work in the expansion, not in the macro.
* Argument Evaluation::    The expansion should evaluate each macro arg once.
* Surprising Local Vars::  Local variable bindings in the expansion
                              require special care.
* Eval During Expansion::  Don't evaluate them; put them in the expansion.
* Repeated Expansion::     Avoid depending on how many times expansion is done.

Customization Settings

* Common Keywords::         Common keyword arguments for all kinds of
                              customization declarations.
* Group Definitions::       Writing customization group definitions.
* Variable Definitions::    Declaring user options.
* Customization Types::     Specifying the type of a user option.
* Applying Customizations:: Functions to apply customization settings.
* Custom Themes::           Writing Custom themes.

Customization Types

* Simple Types::            Simple customization types: sexp, integer, etc.
* Composite Types::         Build new types from other types or data.
* Splicing into Lists::     Splice elements into list with `:inline'.
* Type Keywords::           Keyword-argument pairs in a customization type.
* Defining New Types::      Give your type a name.

Loading

* How Programs Do Loading:: The `load' function and others.
* Load Suffixes::           Details about the suffixes that `load' tries.
* Library Search::          Finding a library to load.
* Loading Non-ASCII::       Non-ASCII characters in Emacs Lisp files.
* Autoload::                Setting up a function to autoload.
* Repeated Loading::        Precautions about loading a file twice.
* Named Features::          Loading a library if it isn't already loaded.
* Where Defined::           Finding which file defined a certain symbol.
* Unloading::               How to "unload" a library that was loaded.
* Hooks for Loading::       Providing code to be run when
                              particular libraries are loaded.

Byte Compilation

* Speed of Byte-Code::      An example of speedup from byte compilation.
* Compilation Functions::   Byte compilation functions.
* Docs and Compilation::    Dynamic loading of documentation strings.
* Dynamic Loading::         Dynamic loading of individual functions.
* Eval During Compile::     Code to be evaluated when you compile.
* Compiler Errors::         Handling compiler error messages.
* Byte-Code Objects::       The data type used for byte-compiled functions.
* Disassembly::             Disassembling byte-code; how to read byte-code.

Advising Emacs Lisp Functions

* Simple Advice::           A simple example to explain the basics of advice.
* Defining Advice::         Detailed description of `defadvice'.
* Around-Advice::           Wrapping advice around a function's definition.
* Computed Advice::         ...is to `defadvice' as `fset' is to `defun'.
* Activation of Advice::    Advice doesn't do anything until you activate it.
* Enabling Advice::         You can enable or disable each piece of advice.
* Preactivation::           Preactivation is a way of speeding up the
                              loading of compiled advice.
* Argument Access in Advice:: How advice can access the function's arguments.
* Combined Definition::     How advice is implemented.

Debugging Lisp Programs

* Debugger::                A debugger for the Emacs Lisp evaluator.
* Edebug::                  A source-level Emacs Lisp debugger.
* Syntax Errors::           How to find syntax errors.
* Test Coverage::           Ensuring you have tested all branches in your code.

The Lisp Debugger

* Error Debugging::         Entering the debugger when an error happens.
* Infinite Loops::          Stopping and debugging a program that doesn't exit.
* Function Debugging::      Entering it when a certain function is called.
* Explicit Debug::          Entering it at a certain point in the program.
* Using Debugger::          What the debugger does; what you see while in it.
* Debugger Commands::       Commands used while in the debugger.
* Invoking the Debugger::   How to call the function `debug'.
* Internals of Debugger::   Subroutines of the debugger, and global variables.

Edebug

* Using Edebug::            Introduction to use of Edebug.
* Instrumenting::           You must instrument your code
                              in order to debug it with Edebug.
* Edebug Execution Modes::  Execution modes, stopping more or less often.
* Jumping::                 Commands to jump to a specified place.
* Edebug Misc::             Miscellaneous commands.
* Breaks::                  Setting breakpoints to make the program stop.
* Trapping Errors::         Trapping errors with Edebug.
* Edebug Views::            Views inside and outside of Edebug.
* Edebug Eval::             Evaluating expressions within Edebug.
* Eval List::               Expressions whose values are displayed
                              each time you enter Edebug.
* Printing in Edebug::      Customization of printing.
* Trace Buffer::            How to produce trace output in a buffer.
* Coverage Testing::        How to test evaluation coverage.
* The Outside Context::     Data that Edebug saves and restores.
* Edebug and Macros::       Specifying how to handle macro calls.
* Edebug Options::          Option variables for customizing Edebug.

Breaks

* Breakpoints::             Breakpoints at stop points.
* Global Break Condition::  Breaking on an event.
* Source Breakpoints::      Embedding breakpoints in source code.

The Outside Context

* Checking Whether to Stop::When Edebug decides what to do.
* Edebug Display Update::   When Edebug updates the display.
* Edebug Recursive Edit::   When Edebug stops execution.

Edebug and Macros

* Instrumenting Macro Calls::The basic problem.
* Specification List::      How to specify complex patterns of evaluation.
* Backtracking::            What Edebug does when matching fails.
* Specification Examples::  To help understand specifications.

Debugging Invalid Lisp Syntax

* Excess Open::             How to find a spurious open paren or missing close.
* Excess Close::            How to find a spurious close paren or missing open.

Reading and Printing Lisp Objects

* Streams Intro::           Overview of streams, reading and printing.
* Input Streams::           Various data types that can be used as
                              input streams.
* Input Functions::         Functions to read Lisp objects from text.
* Output Streams::          Various data types that can be used as
                              output streams.
* Output Functions::        Functions to print Lisp objects as text.
* Output Variables::        Variables that control what the printing
                              functions do.

Minibuffers

* Intro to Minibuffers::    Basic information about minibuffers.
* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.
* Minibuffer History::      Recording previous minibuffer inputs
                              so the user can reuse them.
* Initial Input::           Specifying initial contents for the minibuffer.
* Completion::              How to invoke and customize completion.
* Yes-or-No Queries::       Asking a question with a simple answer.
* Multiple Queries::        Asking a series of similar questions.
* Reading a Password::      Reading a password from the terminal.
* Minibuffer Commands::     Commands used as key bindings in minibuffers.
* Minibuffer Windows::      Operating on the special minibuffer windows.
* Minibuffer Contents::     How such commands access the minibuffer text.
* Recursive Mini::          Whether recursive entry to minibuffer is allowed.
* Minibuffer Misc::         Various customization hooks and variables.

Completion

* Basic Completion::        Low-level functions for completing strings.
* Minibuffer Completion::   Invoking the minibuffer with completion.
* Completion Commands::     Minibuffer commands that do completion.
* High-Level Completion::   Convenient special cases of completion
                              (reading buffer names, variable names, etc.).
* Reading File Names::      Using completion to read file names and
                              shell commands.
* Completion Variables::    Variables controlling completion behavior.
* Programmed Completion::   Writing your own completion function.
* Completion in Buffers::   Completing text in ordinary buffers.

Command Loop

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Distinguish Interactive::     Making a command distinguish interactive calls.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Adjusting Point::     Adjustment of point after a command.
* Input Events::        What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How C-g works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

Defining Commands

* Using Interactive::       General rules for `interactive'.
* Interactive Codes::       The standard letter-codes for reading arguments
                              in various ways.
* Interactive Examples::    Examples of how to read interactive arguments.

Input Events

* Keyboard Events::         Ordinary characters--keys with symbols on them.
* Function Keys::           Function keys--keys with names, not symbols.
* Mouse Events::            Overview of mouse events.
* Click Events::            Pushing and releasing a mouse button.
* Drag Events::             Moving the mouse before releasing the button.
* Button-Down Events::      A button was pushed and not yet released.
* Repeat Events::           Double and triple click (or drag, or down).
* Motion Events::           Just moving the mouse, not pushing a button.
* Focus Events::            Moving the mouse between frames.
* Misc Events::             Other events the system can generate.
* Event Examples::          Examples of the lists for mouse events.
* Classifying Events::      Finding the modifier keys in an event symbol.
                              Event types.
* Accessing Mouse::         Functions to extract info from mouse events.
* Accessing Scroll::        Functions to get info from scroll bar events.
* Strings of Events::       Special considerations for putting
                              keyboard character events in a string.

Reading Input

* Key Sequence Input::      How to read one key sequence.
* Reading One Event::       How to read just one event.
* Event Mod::               How Emacs modifies events as they are read.
* Invoking the Input Method::   How reading an event uses the input method.
* Quoted Character Input::  Asking the user to specify a character.
* Event Input Misc::        How to reread or throw away input events.

Keymaps

* Key Sequences::           Key sequences as Lisp objects.
* Keymap Basics::           Basic concepts of keymaps.
* Format of Keymaps::       What a keymap looks like as a Lisp object.
* Creating Keymaps::        Functions to create and copy keymaps.
* Inheritance and Keymaps:: How one keymap can inherit the bindings
                              of another keymap.
* Prefix Keys::             Defining a key with a keymap as its definition.
* Active Keymaps::          How Emacs searches the active keymaps
                              for a key binding.
* Searching Keymaps::       A pseudo-Lisp summary of searching active maps.
* Controlling Active Maps:: Each buffer has a local keymap
                               to override the standard (global) bindings.
                               A minor mode can also override them.
* Key Lookup::              Finding a key's binding in one keymap.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::   Redefining a key in a keymap.
* Remapping Commands::      A keymap can translate one command to another.
* Translation Keymaps::     Keymaps for translating sequences of events.
* Key Binding Commands::    Interactive interfaces for redefining keys.
* Scanning Keymaps::        Looking through all keymaps, for printing help.
* Menu Keymaps::            Defining a menu as a keymap.

Menu Keymaps

* Defining Menus::          How to make a keymap that defines a menu.
* Mouse Menus::             How users actuate the menu with the mouse.
* Keyboard Menus::          How users actuate the menu with the keyboard.
* Menu Example::            Making a simple menu.
* Menu Bar::                How to customize the menu bar.
* Tool Bar::                A tool bar is a row of images.
* Modifying Menus::         How to add new items to a menu.

Defining Menus

* Simple Menu Items::       A simple kind of menu key binding,
                              limited in capabilities.
* Extended Menu Items::     More powerful menu item definitions
                              let you specify keywords to enable
                              various features.
* Menu Separators::         Drawing a horizontal line through a menu.
* Alias Menu Items::        Using command aliases in menu items.
* Toolkit Differences::     Not all toolkits provide the same features.

Major and Minor Modes

* Hooks::              How to use hooks; how to write code that provides hooks.
* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Imenu::              Providing a menu of definitions made in a buffer.
* Font Lock Mode::     How modes can highlight text according to syntax.
* Auto-Indentation::   How to teach Emacs to indent for a major mode.
* Desktop Save Mode::  How modes can have buffer state saved between
                         Emacs sessions.

Hooks

* Running Hooks::      How to run a hook.
* Setting Hooks::      How to put functions on a hook, or remove them.

Major Modes

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.
* Derived Modes::           Defining a new major mode based on another major
                              mode.
* Basic Major Modes::       Modes that other modes are often derived from.
* Mode Hooks::              Hooks run at the end of major mode functions.
* Tabulated List Mode::     Parent mode for buffers containing tabulated data.
* Generic Modes::           Defining a simple major mode that supports
                              comment syntax and Font Lock mode.
* Example Major Modes::     Text mode and Lisp modes.

Minor Modes

* Minor Mode Conventions::  Tips for writing a minor mode.
* Keymaps and Minor Modes:: How a minor mode can have its own keymap.
* Defining Minor Modes::    A convenient facility for defining minor modes.

Mode Line Format

* Mode Line Basics::        Basic ideas of mode line control.
* Mode Line Data::          The data structure that controls the mode line.
* Mode Line Top::           The top level variable, mode-line-format.
* Mode Line Variables::     Variables used in that data structure.
* %-Constructs::            Putting information into a mode line.
* Properties in Mode::      Using text properties in the mode line.
* Header Lines::            Like a mode line, but at the top.
* Emulating Mode Line::     Formatting text as the mode line would.

Font Lock Mode

* Font Lock Basics::        Overview of customizing Font Lock.
* Search-based Fontification::  Fontification based on regexps.
* Customizing Keywords::    Customizing search-based fontification.
* Other Font Lock Variables::   Additional customization facilities.
* Levels of Font Lock::     Each mode can define alternative levels
                              so that the user can select more or less.
* Precalculated Fontification:: How Lisp programs that produce the buffer
                                  contents can also specify how to fontify it.
* Faces for Font Lock::     Special faces specifically for Font Lock.
* Syntactic Font Lock::     Fontification based on syntax tables.
* Multiline Font Lock::     How to coerce Font Lock into properly
                              highlighting multiline constructs.

Multiline Font Lock Constructs

* Font Lock Multiline::     Marking multiline chunks with a text property.
* Region to Refontify::     Controlling which region gets refontified
                              after a buffer change.

Automatic Indentation of code

* SMIE::                    A simple minded indentation engine.

Simple Minded Indentation Engine

* SMIE setup::              SMIE setup and features.
* Operator Precedence Grammars:: A very simple parsing technique.
* SMIE Grammar::            Defining the grammar of a language.
* SMIE Lexer::              Defining tokens.
* SMIE Tricks::             Working around the parser's limitations.
* SMIE Indentation::        Specifying indentation rules.
* SMIE Indentation Helpers:: Helper functions for indentation rules.
* SMIE Indentation Example:: Sample indentation rules.

Documentation

* Documentation Basics::    Where doc strings are defined and stored.
* Accessing Documentation:: How Lisp programs can access doc strings.
* Keys in Documentation::   Substituting current key bindings.
* Describing Characters::   Making printable descriptions of
                              non-printing characters and key sequences.
* Help Functions::          Subroutines used by Emacs help facilities.

Files

* Visiting Files::          Reading files into Emacs buffers for editing.
* Saving Buffers::          Writing changed buffers back into files.
* Reading from Files::      Reading files into buffers without visiting.
* Writing to Files::        Writing new files from parts of buffers.
* File Locks::              Locking and unlocking files, to prevent
                              simultaneous editing by two people.
* Information about Files:: Testing existence, accessibility, size of files.
* Changing Files::          Renaming files, changing permissions, etc.
* File Names::              Decomposing and expanding file names.
* Contents of Directories:: Getting a list of the files in a directory.
* Create/Delete Dirs::      Creating and Deleting Directories.
* Magic File Names::        Special handling for certain file names.
* Format Conversion::       Conversion to and from various file formats.

Visiting Files

* Visiting Functions::      The usual interface functions for visiting.
* Subroutines of Visiting:: Lower-level subroutines that they use.

Information about Files

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A symbolic link?
* Truenames::               Eliminating symbolic links from a file name.
* File Attributes::         How large is it?  Any other names?  Etc.
* Locating Files::          How to find a file in standard places.

File Names

* File Name Components::    The directory part of a file name, and the rest.
* Relative File Names::     Some file names are relative to a current directory.
* Directory Names::         A directory's name as a directory
                              is different from its name as a file.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.
* Standard File Names::     If your package uses a fixed file name,
                              how to handle various operating systems simply.

File Format Conversion

* Format Conversion Overview::   `insert-file-contents' and `write-region'.
* Format Conversion Round-Trip:: Using `format-alist'.
* Format Conversion Piecemeal::  Specifying non-paired conversion.

Backups and Auto-Saving

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               `revert-buffer', and how to customize
                              what it does.

Backup Files

* Making Backups::          How Emacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

Buffers

* Buffer Basics::           What is a buffer?
* Current Buffer::          Designating a buffer as current
                              so that primitives will access its contents.
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is "modified" if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              "behind Emacs's back".
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* The Buffer List::         How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Indirect Buffers::        An indirect buffer shares text with some
                              other buffer.
* Swapping Text::           Swapping text between two buffers.
* Buffer Gap::              The gap in the buffer.

Windows

* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window's size.
* Resizing Windows::        Changing the sizes of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer.
* Choosing Window::         How to choose a window for displaying a buffer.
* Display Action Functions:: Subroutines for `display-buffer'.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Window History::          Each window remembers the buffers displayed in it.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Quitting Windows::        How to restore the state prior to displaying a
                              buffer.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Converting coordinates to windows.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.

Frames

* Creating Frames::         Creating additional frames.
* Multiple Terminals::      Displaying on several different devices.
* Frame Parameters::        Controlling frame size, position, font, etc.
* Terminal Parameters::     Parameters common for all frames on terminal.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::         Frames last until explicitly deleted.
* Finding All Frames::      How to examine all existing frames.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::             Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising a frame makes it hide other windows;
                              lowering it makes the others hide it.
* Frame Configurations::    Saving the state of all frames.
* Mouse Tracking::          Getting events that say when the mouse moves.
* Mouse Position::          Asking where the mouse is, or moving it.
* Pop-Up Menus::            Displaying a menu for the user to select from.
* Dialog Boxes::            Displaying a box to ask yes or no.
* Pointer Shape::           Specifying the shape of the mouse pointer.
* Window System Selections::Transferring text to and from other X clients.
* Drag and Drop::               Internals of Drag-and-Drop implementation.
* Color Names::             Getting the definitions of color names.
* Text Terminal Colors::    Defining colors for text terminals.
* Resources::               Getting resource values from the server.
* Display Feature Testing:: Determining the features of a terminal.

Frame Parameters

* Parameter Access::        How to change a frame's parameters.
* Initial Parameters::      Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Size and Position::       Changing the size and position of a frame.
* Geometry::                Parsing geometry specifications.

Window Frame Parameters

* Basic Parameters::        Parameters that are fundamental.
* Position Parameters::     The position of the frame on the screen.
* Size Parameters::         Frame's size.
* Layout Parameters::       Size of parts of the frame, and
                              enabling or disabling some parts.
* Buffer Parameters::       Which buffers have been or should be shown.
* Management Parameters::   Communicating with the window manager.
* Cursor Parameters::       Controlling the cursor appearance.
* Font and Color Parameters:: Fonts and colors for the frame text.

Positions

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

Motion

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

Markers

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::Finding the marker's buffer or character position.
* Marker Insertion Types::  Two ways a marker can relocate when you
                              insert where it points.
* Moving Markers::          Moving the marker to a new buffer or position.
* The Mark::                How "the mark" is implemented with a marker.
* The Region::              How to access "the region".

Text

* Near Point::              Examining text in the vicinity of point.
* Buffer Contents::         Examining text in a general fashion.
* Comparing Text::          Comparing substrings of buffers.
* Insertion::               Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::                Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::           Where removed text sometimes is saved for
                              later use.
* Undo::                    Undoing changes to the text of a buffer.
* Maintaining Undo::        How to enable and disable undo information.
                              How to control how much information is kept.
* Filling::                 Functions for explicit filling.
* Margins::                 How to specify margins for filling commands.
* Adaptive Fill::           Adaptive Fill mode chooses a fill prefix
                              from context.
* Auto Filling::            How auto-fill mode is implemented to break lines.
* Sorting::                 Functions for sorting parts of the buffer.
* Columns::                 Computing horizontal positions, and using them.
* Indentation::             Functions to insert or adjust indentation.
* Case Changes::            Case conversion of parts of the buffer.
* Text Properties::         Assigning Lisp property lists to text characters.
* Substitution::            Replacing a given character wherever it appears.
* Transposition::           Swapping two portions of a buffer.
* Registers::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* Base 64::                 Conversion to or from base 64 encoding.
* Checksum/Hash::           Computing cryptographic hashes.
* Parsing HTML/XML::        Parsing HTML and XML.
* Atomic Changes::          Installing several buffer changes "atomically".
* Change Hooks::            Supplying functions to be run when text is changed.

The Kill Ring

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yanking::                 How yanking is done.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::     Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill ring data.

Indentation

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

Text Properties

* Examining Properties::    Looking at the properties of one character.
* Changing Properties::     Setting the properties of a range of text.
* Property Search::         Searching for where a property changes value.
* Special Properties::      Particular properties with special meanings.
* Format Properties::       Properties for representing formatting of text.
* Sticky Properties::       How inserted text gets properties from
                              neighboring text.
* Lazy Properties::         Computing text properties in a lazy fashion
                              only when text is examined.
* Clickable Text::          Using text properties to make regions of text
                              do something when you click on them.
* Fields::                  The `field' property defines
                              fields within the buffer.
* Not Intervals::           Why text properties do not use
                              Lisp-visible text intervals.

Non-ASCII Characters

* Text Representations::    How Emacs represents text.
* Converting Representations::  Converting unibyte to multibyte and vice versa.
* Selecting a Representation::  Treating a byte sequence as unibyte or multi.
* Character Codes::         How unibyte and multibyte relate to
                                codes of individual characters.
* Character Properties::    Character attributes that define their
                                behavior and handling.
* Character Sets::          The space of possible character codes
                                is divided into various character sets.
* Scanning Charsets::       Which character sets are used in a buffer?
* Translation of Characters::   Translation tables are used for conversion.
* Coding Systems::          Coding systems are conversions for saving files.
* Input Methods::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* Locales::                 Interacting with the POSIX locale.

Coding Systems

* Coding System Basics::    Basic concepts.
* Encoding and I/O::        How file I/O functions handle coding systems.
* Lisp and Coding Systems:: Functions to operate on coding system names.
* User-Chosen Coding Systems::  Asking the user to choose a coding system.
* Default Coding Systems::  Controlling the default choices.
* Specifying Coding Systems::   Requesting a particular coding system
                                    for a single file operation.
* Explicit Encoding::       Encoding or decoding text without doing I/O.
* Terminal I/O Encoding::   Use of encoding for terminal I/O.
* MS-DOS File Types::       How DOS "text" and "binary" files
                                relate to coding systems.

Searching and Matching

* String Search::           Search for an exact match.
* Searching and Case::      Case-independent or case-significant searching.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* POSIX Regexps::           Searching POSIX-style for the longest match.
* Match Data::              Finding out which part of the text matched,
                              after a string or regexp search.
* Search and Replace::      Commands that loop, searching and replacing.
* Standard Regexps::        Useful regexps for finding sentences, pages,...

Regular Expressions

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.
* Regexp Functions::        Functions for operating on regular expressions.

Syntax of Regular Expressions

* Regexp Special::          Special characters in regular expressions.
* Char Classes::            Character classes used in regular expressions.
* Regexp Backslash::        Backslash-sequences in regular expressions.

The Match Data

* Replacing Match::         Replacing a substring that was matched.
* Simple Match Data::       Accessing single items of match data,
                              such as where a particular subexpression started.
* Entire Match Data::       Accessing the entire match data at once, as a list.
* Saving Match Data::       Saving and restoring the match data.

Syntax Tables

* Syntax Basics::           Basic concepts of syntax tables.
* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Syntax Properties::       Overriding syntax with text properties.
* Motion and Syntax::       Moving over characters with certain syntaxes.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Standard Syntax Tables::  Syntax tables used by various major modes.
* Syntax Table Internals::  How syntax table information is stored.
* Categories::              Another way of classifying character syntax.

Syntax Descriptors

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

Parsing Expressions

* Motion via Parsing::      Motion functions that work by parsing.
* Position Parse::          Determining the syntactic state of a position.
* Parser State::            How Emacs represents a syntactic state.
* Low-Level Parsing::       Parsing across a specified region.
* Control Parsing::         Parameters that affect parsing.

Abbrevs and Abbrev Expansion

* Abbrev Tables::           Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Abbrev Files::            Saving abbrevs in files.
* Abbrev Expansion::        Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.
* Abbrev Properties::       How to read and set abbrev properties.
                            Which properties have which effect.
* Abbrev Table Properties:: How to read and set abbrev table properties.
                            Which properties have which effect.

Processes

* Subprocess Creation::     Functions that start subprocesses.
* Shell Arguments::         Quoting an argument to pass it to a shell.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Query Before Exit::       Whether to query if exiting will kill a process.
* System Processes::        Accessing other processes running on your system.
* Transaction Queues::      Transaction-based communication with subprocesses.
* Network::                 Opening network connections.
* Network Servers::         Network servers let Emacs accept net connections.
* Datagrams::               UDP network connections.
* Low-Level Network::       Lower-level but more general function
                              to create connections and servers.
* Misc Network::            Additional relevant functions for net connections.
* Serial Ports::            Communicating with serial ports.
* Byte Packing::            Using bindat to pack and unpack binary data.

Receiving Output from Processes

* Process Buffers::         If no filter, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Decoding Output::         Filters can get unibyte or multibyte strings.
* Accepting Output::        How to wait until process output arrives.

Low-Level Network Access

* Network Processes::       Using `make-network-process'.
* Network Options::         Further control over network connections.
* Network Feature Testing:: Determining which network features work on
                              the machine you are using.

Packing and Unpacking Byte Arrays

* Bindat Spec::             Describing data layout.
* Bindat Functions::        Doing the unpacking and packing.
* Bindat Examples::         Samples of what bindat.el can do for you!

Emacs Display

* Refresh Screen::          Clearing the screen and redrawing everything on it.
* Forcing Redisplay::       Forcing redisplay.
* Truncation::              Folding or wrapping long text lines.
* The Echo Area::           Displaying messages at the bottom of the screen.
* Warnings::                Displaying warning messages for the user.
* Invisible Text::          Hiding part of the buffer text.
* Selective Display::       Hiding part of the buffer text (the old way).
* Temporary Displays::      Displays that go away automatically.
* Overlays::                Use overlays to highlight parts of the buffer.
* Width::                   How wide a character or string is on the screen.
* Line Height::             Controlling the height of lines.
* Faces::                   A face defines a graphics style
                              for text characters: font, colors, etc.
* Fringes::                 Controlling window fringes.
* Scroll Bars::             Controlling vertical scroll bars.
* Display Property::        Enabling special display features.
* Images::                  Displaying images in Emacs buffers.
* Buttons::                 Adding clickable buttons to Emacs buffers.
* Abstract Display::        Emacs's Widget for Object Collections.
* Blinking::                How Emacs shows the matching open parenthesis.
* Character Display::   How Emacs displays individual characters.
* Beeping::                 Audible signal to the user.
* Window Systems::          Which window system is being used.
* Bidirectional Display::   Display of bidirectional scripts, such as
                              Arabic and Farsi.

The Echo Area

* Displaying Messages::     Explicitly displaying text in the echo area.
* Progress::                Informing user about progress of a long operation.
* Logging Messages::        Echo area messages are logged for the user.
* Echo Area Customization:: Controlling the echo area.

Reporting Warnings

* Warning Basics::          Warnings concepts and functions to report them.
* Warning Variables::       Variables programs bind to customize
                              their warnings.
* Warning Options::         Variables users set to control display of warnings.
* Delayed Warnings::        Deferring a warning until the end of a command.

Overlays

* Managing Overlays::       Creating and moving overlays.
* Overlay Properties::      How to read and set properties.
                              What properties do to the screen display.
* Finding Overlays::        Searching for overlays.

Faces

* Defining Faces::          How to define a face.
* Face Attributes::         What is in a face?
* Attribute Functions::     Functions to examine and set face attributes.
* Displaying Faces::        How Emacs combines the faces specified for
                              a character.
* Face Remapping::         Remapping faces to alternative definitions.
* Face Functions::          How to define and examine faces.
* Auto Faces::              Hook for automatic face assignment.
* Basic Faces::         Faces that are defined by default.
* Font Selection::          Finding the best available font for a face.
* Font Lookup::             Looking up the names of available fonts
                              and information about them.
* Fontsets::                A fontset is a collection of fonts
                              that handle a range of character sets.
* Low-Level Font::          Lisp representation for character display fonts.

Fringes

* Fringe Size/Pos::         Specifying where to put the window fringes.
* Fringe Indicators::       Displaying indicator icons in the window fringes.
* Fringe Cursors::          Displaying cursors in the right fringe.
* Fringe Bitmaps::          Specifying bitmaps for fringe indicators.
* Customizing Bitmaps::     Specifying your own bitmaps to use in the fringes.
* Overlay Arrow::           Display of an arrow to indicate position.

The `display' Property

* Replacing Specs::         Display specs that replace the text.
* Specified Space::         Displaying one space with a specified width.
* Pixel Specification::     Specifying space width or height in pixels.
* Other Display Specs::     Displaying an image; adjusting the height,
                              spacing, and other properties of text.
* Display Margins::         Displaying text or images to the side of
                              the main text.

Images

* Image Formats::           Supported image formats.
* Image Descriptors::       How to specify an image for use in `:display'.
* XBM Images::              Special features for XBM format.
* XPM Images::              Special features for XPM format.
* GIF Images::              Special features for GIF format.
* TIFF Images::             Special features for TIFF format.
* PostScript Images::       Special features for PostScript format.
* ImageMagick Images::      Special features available through ImageMagick.
* Other Image Types::       Various other formats are supported.
* Defining Images::         Convenient ways to define an image for later use.
* Showing Images::          Convenient ways to display an image once
                              it is defined.
* Animated Images::         Some image formats can be animated.
* Image Cache::             Internal mechanisms of image display.

Buttons

* Button Properties::       Button properties with special meanings.
* Button Types::            Defining common properties for classes of buttons.
* Making Buttons::          Adding buttons to Emacs buffers.
* Manipulating Buttons::    Getting and setting properties of buttons.
* Button Buffer Commands::  Buffer-wide commands and bindings for buttons.

Abstract Display

* Abstract Display Functions::  Functions in the Ewoc package.
* Abstract Display Example::    Example of using Ewoc.

Character Display

* Usual Display::       The usual conventions for displaying characters.
* Display Tables::      What a display table consists of.
* Active Display Table::  How Emacs selects a display table to use.
* Glyphs::              How to define a glyph, and what glyphs mean.
* Glyphless Chars::     How glyphless characters are drawn.

Operating System Interface

* Starting Up::             Customizing Emacs startup processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* User Identification::     Finding the name and user id of the user.
* Time of Day::             Getting the current time.
* Time Conversion::         Converting a time from numeric form to
                              calendrical data and vice versa.
* Time Parsing::            Converting a time from numeric form to text
                              and vice versa.
* Processor Run Time::      Getting the run time used by Emacs.
* Time Calculations::       Adding, subtracting, comparing times, etc.
* Timers::                  Setting a timer to call a function at a
                              certain time.
* Idle Timers::             Setting a timer to call a function when Emacs has
                              been idle for a certain length of time.
* Terminal Input::          Accessing and recording terminal input.
* Terminal Output::         Controlling and recording terminal output.
* Sound Output::            Playing sounds on the computer's speaker.
* X11 Keysyms::             Operating on key symbols for X Windows.
* Batch Mode::              Running Emacs without terminal interaction.
* Session Management::      Saving and restoring state with
                              X Session Management.
* Notifications::           Desktop notifications.
* Dynamic Libraries::       On-demand loading of support libraries.

Starting Up Emacs

* Startup Summary::         Sequence of actions Emacs performs at startup.
* Init File::               Details on reading the init file.
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command-Line Arguments::  How command-line arguments are processed,
                              and how you can customize them.

Getting Out of Emacs

* Killing Emacs::           Exiting Emacs irreversibly.
* Suspending Emacs::        Exiting Emacs reversibly.

Terminal Input

* Input Modes::             Options for how input is processed.
* Recording Input::         Saving histories of recent or all input events.

Preparing Lisp code for distribution

* Packaging Basics::        The basic concepts of Emacs Lisp packages.
* Simple Packages::         How to package a single .el file.
* Multi-file Packages::     How to package multiple files.
* Package Archives::        Maintaining package archives.

Tips and Conventions

* Coding Conventions::      Conventions for clean and robust programs.
* Key Binding Conventions:: Which keys should be bound by which programs.
* Programming Tips::        Making Emacs code fit smoothly in Emacs.
* Compilation Tips::        Making compiled code run fast.
* Warning Tips::            Turning off compiler warnings.
* Documentation Tips::      Writing readable documentation strings.
* Comment Tips::            Conventions for writing comments.
* Library Headers::         Standard headers for library packages.

GNU Emacs Internals

* Building Emacs::          How the dumped Emacs is made.
* Pure Storage::            Kludge to make preloaded Lisp functions shareable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.
* Memory Usage::            Info about total size of Lisp objects made so far.
* Writing Emacs Primitives::  Writing C code for Emacs.
* Object Internals::        Data formats of buffers, windows, processes.

Object Internals

* Buffer Internals::        Components of a buffer structure.
* Window Internals::        Components of a window structure.
* Process Internals::       Components of a process structure.


File: elisp,  Node: Introduction,  Next: Lisp Data Types,  Prev: Top,  Up: Top

1 Introduction
**************

Most of the GNU Emacs text editor is written in the programming
language called Emacs Lisp.  You can write new code in Emacs Lisp and
install it as an extension to the editor.  However, Emacs Lisp is more
than a mere "extension language"; it is a full computer programming
language in its own right.  You can use it as you would any other
programming language.

   Because Emacs Lisp is designed for use in an editor, it has special
features for scanning and parsing text as well as features for handling
files, buffers, displays, subprocesses, and so on.  Emacs Lisp is
closely integrated with the editing facilities; thus, editing commands
are functions that can also conveniently be called from Lisp programs,
and parameters for customization are ordinary Lisp variables.

   This manual attempts to be a full description of Emacs Lisp.  For a
beginner's introduction to Emacs Lisp, see `An Introduction to Emacs
Lisp Programming', by Bob Chassell, also published by the Free Software
Foundation.  This manual presumes considerable familiarity with the use
of Emacs for editing; see `The GNU Emacs Manual' for this basic
information.

   Generally speaking, the earlier chapters describe features of Emacs
Lisp that have counterparts in many programming languages, and later
chapters describe features that are peculiar to Emacs Lisp or relate
specifically to editing.

   This is the `GNU Emacs Lisp Reference Manual', corresponding to
Emacs version 24.1.

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgements::    The authors, editors, and sponsors of this manual.


File: elisp,  Node: Caveats,  Next: Lisp History,  Up: Introduction

1.1 Caveats
===========

This manual has gone through numerous drafts.  It is nearly complete
but not flawless.  There are a few topics that are not covered, either
because we consider them secondary (such as most of the individual
modes) or because they are yet to be written.  Because we are not able
to deal with them completely, we have left out several parts
intentionally.

   The manual should be fully correct in what it does cover, and it is
therefore open to criticism on anything it says--from specific examples
and descriptive text, to the ordering of chapters and sections.  If
something is confusing, or you find that you have to look at the sources
or experiment to learn something not covered in the manual, then perhaps
the manual should be fixed.  Please let us know.

   As you use this manual, we ask that you send corrections as soon as
you find them.  If you think of a simple, real life example for a
function or group of functions, please make an effort to write it up
and send it in.  Please reference any comments to the node name and
function or variable name, as appropriate.  Also state the number of
the edition you are criticizing.

   Please send comments and corrections using `M-x report-emacs-bug'.


File: elisp,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

1.2 Lisp History
================

Lisp (LISt Processing language) was first developed in the late 1950s
at the Massachusetts Institute of Technology for research in artificial
intelligence.  The great power of the Lisp language makes it ideal for
other purposes as well, such as writing editing commands.

   Dozens of Lisp implementations have been built over the years, each
with its own idiosyncrasies.  Many of them were inspired by Maclisp,
which was written in the 1960s at MIT's Project MAC.  Eventually the
implementers of the descendants of Maclisp came together and developed a
standard for Lisp systems, called Common Lisp.  In the meantime, Gerry
Sussman and Guy Steele at MIT developed a simplified but very powerful
dialect of Lisp, called Scheme.

   GNU Emacs Lisp is largely inspired by Maclisp, and a little by Common
Lisp.  If you know Common Lisp, you will notice many similarities.
However, many features of Common Lisp have been omitted or simplified
in order to reduce the memory requirements of GNU Emacs.  Sometimes the
simplifications are so drastic that a Common Lisp user might be very
confused.  We will occasionally point out how GNU Emacs Lisp differs
from Common Lisp.  If you don't know Common Lisp, don't worry about it;
this manual is self-contained.

   A certain amount of Common Lisp emulation is available via the `cl'
library.  *Note Overview: (cl)Top.

   Emacs Lisp is not at all influenced by Scheme; but the GNU project
has an implementation of Scheme, called Guile.  We use it in all new GNU
software that calls for extensibility.


File: elisp,  Node: Conventions,  Next: Version Info,  Prev: Lisp History,  Up: Introduction

1.3 Conventions
===============

This section explains the notational conventions that are used in this
manual.  You may want to skip this section and refer back to it later.

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.


File: elisp,  Node: Some Terms,  Next: nil and t,  Up: Conventions

1.3.1 Some Terms
----------------

Throughout this manual, the phrases "the Lisp reader" and "the Lisp
printer" refer to those routines in Lisp that convert textual
representations of Lisp objects into actual Lisp objects, and vice
versa.  *Note Printed Representation::, for more details.  You, the
person reading this manual, are thought of as "the programmer" and are
addressed as "you".  "The user" is the person who uses Lisp programs,
including those you write.

   Examples of Lisp code are formatted like this: `(list 1 2 3)'.
Names that represent metasyntactic variables, or arguments to a function
being described, are formatted like this: FIRST-NUMBER.


File: elisp,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

1.3.2 `nil' and `t'
-------------------

In Emacs Lisp, the symbol `nil' has three separate meanings: it is a
symbol with the name `nil'; it is the logical truth value FALSE; and it
is the empty list--the list of zero elements.  When used as a variable,
`nil' always has the value `nil'.

   As far as the Lisp reader is concerned, `()' and `nil' are
identical: they stand for the same object, the symbol `nil'.  The
different ways of writing the symbol are intended entirely for human
readers.  After the Lisp reader has read either `()' or `nil', there is
no way to determine which representation was actually written by the
programmer.

   In this manual, we write `()' when we wish to emphasize that it
means the empty list, and we write `nil' when we wish to emphasize that
it means the truth value FALSE.  That is a good convention to use in
Lisp programs also.

     (cons 'foo ())                ; Emphasize the empty list
     (setq foo-flag nil)           ; Emphasize the truth value FALSE

   In contexts where a truth value is expected, any non-`nil' value is
considered to be TRUE.  However, `t' is the preferred way to represent
the truth value TRUE.  When you need to choose a value which represents
TRUE, and there is no other basis for choosing, use `t'.  The symbol
`t' always has the value `t'.

   In Emacs Lisp, `nil' and `t' are special symbols that always
evaluate to themselves.  This is so that you do not need to quote them
to use them as constants in a program.  An attempt to change their
values results in a `setting-constant' error.  *Note Constant
Variables::.

 -- Function: booleanp object
     Return non-`nil' if OBJECT is one of the two canonical boolean
     values: `t' or `nil'.


File: elisp,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

1.3.3 Evaluation Notation
-------------------------

A Lisp expression that you can evaluate is called a "form".  Evaluating
a form always produces a result, which is a Lisp object.  In the
examples in this manual, this is indicated with `=>':

     (car '(1 2))
          => 1

You can read this as "`(car '(1 2))' evaluates to 1".

   When a form is a macro call, it expands into a new form for Lisp to
evaluate.  We show the result of the expansion with `==>'.  We may or
may not show the result of the evaluation of the expanded form.

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

   Sometimes to help describe one form we show another form that
produces identical results.  The exact equivalence of two forms is
indicated with `=='.

     (make-sparse-keymap) == (list 'keymap)


File: elisp,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

1.3.4 Printing Notation
-----------------------

Many of the examples in this manual print text when they are evaluated.
If you execute example code in a Lisp Interaction buffer (such as the
buffer `*scratch*'), the printed text is inserted into the buffer.  If
you execute the example by other means (such as by evaluating the
function `eval-region'), the printed text is displayed in the echo area.

   Examples in this manual indicate printed text with `-|',
irrespective of where that text goes.  The value returned by evaluating
the form follows on a separate line with `=>'.

     (progn (prin1 'foo) (princ "\n") (prin1 'bar))
          -| foo
          -| bar
          => bar


File: elisp,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

1.3.5 Error Messages
--------------------

Some examples signal errors.  This normally displays an error message
in the echo area.  We show the error message on a line starting with
`error-->'.  Note that `error-->' itself does not appear in the echo
area.

     (+ 23 'x)
     error--> Wrong type argument: number-or-marker-p, x


File: elisp,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

1.3.6 Buffer Text Notation
--------------------------

Some examples describe modifications to the contents of a buffer, by
showing the "before" and "after" versions of the text.  These examples
show the contents of the buffer in question between two lines of dashes
containing the buffer name.  In addition, `-!-' indicates the location
of point.  (The symbol for point, of course, is not part of the text in
the buffer; it indicates the place _between_ two characters where point
is currently located.)

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------


File: elisp,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

1.3.7 Format of Descriptions
----------------------------

Functions, variables, macros, commands, user options, and special forms
are described in this manual in a uniform format.  The first line of a
description contains the name of the item followed by its arguments, if
any.  The category--function, variable, or whatever--appears at the
beginning of the line.  The description follows on succeeding lines,
sometimes with examples.

* Menu:

* A Sample Function Description::       A description of an imaginary
                                          function, `foo'.
* A Sample Variable Description::       A description of an imaginary
                                          variable,
                                          `electric-future-map'.


File: elisp,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Up: Format of Descriptions

1.3.7.1 A Sample Function Description
.....................................

In a function description, the name of the function being described
appears first.  It is followed on the same line by a list of argument
names.  These names are also used in the body of the description, to
stand for the values of the arguments.

   The appearance of the keyword `&optional' in the argument list
indicates that the subsequent arguments may be omitted (omitted
arguments default to `nil').  Do not write `&optional' when you call
the function.

   The keyword `&rest' (which must be followed by a single argument
name) indicates that any number of arguments can follow.  The single
argument name following `&rest' will receive, as its value, a list of
all the remaining arguments passed to the function.  Do not write
`&rest' when you call the function.

   Here is a description of an imaginary function `foo':

 -- Function: foo integer1 &optional integer2 &rest integers
     The function `foo' subtracts INTEGER1 from INTEGER2, then adds all
     the rest of the arguments to the result.  If INTEGER2 is not
     supplied, then the number 19 is used by default.

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     More generally,

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

   Any argument whose name contains the name of a type (e.g., INTEGER,
INTEGER1 or BUFFER) is expected to be of that type.  A plural of a type
(such as BUFFERS) often means a list of objects of that type.
Arguments named OBJECT may be of any type.  (*Note Lisp Data Types::,
for a list of Emacs object types.)  Arguments with other sorts of names
(e.g., NEW-FILE) are discussed specifically in the description of the
function.  In some sections, features common to the arguments of
several functions are described at the beginning.

   *Note Lambda Expressions::, for a more complete description of
optional and rest arguments.

   Command, macro, and special form descriptions have the same format,
but the word `Function' is replaced by `Command', `Macro', or `Special
Form', respectively.  Commands are simply functions that may be called
interactively; macros process their arguments differently from functions
(the arguments are not evaluated), but are presented the same way.

   The descriptions of macros and special forms use a more complex
notation to specify optional and repeated arguments, because they can
break the argument list down into separate arguments in more
complicated ways.  `[OPTIONAL-ARG]' means that OPTIONAL-ARG is optional
and `REPEATED-ARGS...' stands for zero or more arguments.  Parentheses
are used when several arguments are grouped into additional levels of
list structure.  Here is an example:

 -- Special Form: count-loop (VAR [FROM TO [INC]]) BODY...
     This imaginary special form implements a loop that executes the
     BODY forms and then increments the variable VAR on each iteration.
     On the first iteration, the variable has the value FROM; on
     subsequent iterations, it is incremented by one (or by INC if that
     is given).  The loop exits before executing BODY if VAR equals TO.
     Here is an example:

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     If FROM and TO are omitted, VAR is bound to `nil' before the loop
     begins, and the loop exits if VAR is non-`nil' at the beginning of
     an iteration.  Here is an example:

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     In this special form, the arguments FROM and TO are optional, but
     must both be present or both absent.  If they are present, INC may
     optionally be specified as well.  These arguments are grouped with
     the argument VAR into a list, to distinguish them from BODY, which
     includes all remaining elements of the form.


File: elisp,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

1.3.7.2 A Sample Variable Description
.....................................

A "variable" is a name that can hold a value.  Although nearly all
variables can be set by the user, certain variables exist specifically
so that users can change them; these are called "user options".
Ordinary variables and user options are described using a format like
that for functions except that there are no arguments.

   Here is a description of the imaginary `electric-future-map'
variable.

 -- Variable: electric-future-map
     The value of this variable is a full keymap used by Electric
     Command Future mode.  The functions in this map allow you to edit
     commands you have not yet thought about executing.

   User option descriptions have the same format, but `Variable' is
replaced by `User Option'.


File: elisp,  Node: Version Info,  Next: Acknowledgements,  Prev: Conventions,  Up: Introduction

1.4 Version Information
=======================

These facilities provide information about which version of Emacs is in
use.

 -- Command: emacs-version &optional here
     This function returns a string describing the version of Emacs
     that is running.  It is useful to include this string in bug
     reports.

          (emacs-version)
            => "GNU Emacs 23.1 (i686-pc-linux-gnu, GTK+ Version 2.14.4)
                       of 2009-06-01 on cyd.mit.edu"

     If HERE is non-`nil', it inserts the text in the buffer before
     point, and returns `nil'.  When this function is called
     interactively, it prints the same information in the echo area, but
     giving a prefix argument makes HERE non-`nil'.

 -- Variable: emacs-build-time
     The value of this variable indicates the time at which Emacs was
     built.  It is a list of three integers, like the value of
     `current-time' (*note Time of Day::).

          emacs-build-time
               => (18846 52016 156039)

 -- Variable: emacs-version
     The value of this variable is the version of Emacs being run.  It
     is a string such as `"23.1.1"'.  The last number in this string is
     not really part of the Emacs release version number; it is
     incremented each time you build Emacs in any given directory.  A
     value with four numeric components, such as `"22.0.91.1"',
     indicates an unreleased test version.

 -- Variable: emacs-major-version
     The major version number of Emacs, as an integer.  For Emacs
     version 23.1, the value is 23.

 -- Variable: emacs-minor-version
     The minor version number of Emacs, as an integer.  For Emacs
     version 23.1, the value is 1.


File: elisp,  Node: Acknowledgements,  Prev: Version Info,  Up: Introduction

1.5 Acknowledgements
====================

This manual was originally written by Robert Krawitz, Bil Lewis, Dan
LaLiberte, Richard M. Stallman and Chris Welty, the volunteers of the
GNU manual group, in an effort extending over several years.  Robert J.
Chassell helped to review and edit the manual, with the support of the
Defense Advanced Research Projects Agency, ARPA Order 6082, arranged by
Warren A. Hunt, Jr. of Computational Logic, Inc.  Additional sections
have since been written by Miles Bader, Lars Brinkhoff, Chong Yidong,
Kenichi Handa, Lute Kamstra, Juri Linkov, Glenn Morris, Thien-Thi
Nguyen, Dan Nicolaescu, Martin Rudalics, Kim F. Storm, Luc Teirlinck,
and Eli Zaretskii, and others.

   Corrections were supplied by Drew Adams, Juanma Barranquero, Karl
Berry, Jim Blandy, Bard Bloom, Stephane Boucher, David Boyes, Alan
Carroll, Richard Davis, Lawrence R. Dodd, Peter Doornbosch, David A.
Duff, Chris Eich, Beverly Erlebacher, David Eckelkamp, Ralf Fassel,
Eirik Fuller, Stephen Gildea, Bob Glickstein, Eric Hanchrow, Jesper
Harder, George Hartzell, Nathan Hess, Masayuki Ida, Dan Jacobson, Jak
Kirman, Bob Knighten, Frederick M. Korz, Joe Lammens, Glenn M. Lewis,
K. Richard Magill, Brian Marick, Roland McGrath, Stefan Monnier, Skip
Montanaro, John Gardiner Myers, Thomas A. Peterson, Francesco Potorti,
Friedrich Pukelsheim, Arnold D. Robbins, Raul Rockwell, Jason Rumney,
Per Starbck, Shinichirou Sugou, Kimmo Suominen, Edward Tharp, Bill
Trost, Rickard Westman, Jean White, Eduard Wiebe, Matthew Wilding, Carl
Witty, Dale Worley, Rusty Wright, and David D. Zuhn.

   For a more complete list of contributors, please see the relevant
ChangeLog file in the Emacs sources.


File: elisp,  Node: Lisp Data Types,  Next: Numbers,  Prev: Introduction,  Up: Top

2 Lisp Data Types
*****************

A Lisp "object" is a piece of data used and manipulated by Lisp
programs.  For our purposes, a "type" or "data type" is a set of
possible objects.

   Every object belongs to at least one type.  Objects of the same type
have similar structures and may usually be used in the same contexts.
Types can overlap, and objects can belong to two or more types.
Consequently, we can ask whether an object belongs to a particular type,
but not for "the" type of an object.

   A few fundamental object types are built into Emacs.  These, from
which all other types are constructed, are called "primitive types".
Each object belongs to one and only one primitive type.  These types
include "integer", "float", "cons", "symbol", "string", "vector",
"hash-table", "subr", and "byte-code function", plus several special
types, such as "buffer", that are related to editing.  (*Note Editing
Types::.)

   Each primitive type has a corresponding Lisp function that checks
whether an object is a member of that type.

   Lisp is unlike many other languages in that its objects are
"self-typing": the primitive type of each object is implicit in the
object itself.  For example, if an object is a vector, nothing can
treat it as a number; Lisp knows it is a vector, not a number.

   In most languages, the programmer must declare the data type of each
variable, and the type is known by the compiler but not represented in
the data.  Such type declarations do not exist in Emacs Lisp.  A Lisp
variable can have any type of value, and it remembers whatever value
you store in it, type and all.  (Actually, a small number of Emacs Lisp
variables can only take on values of a certain type.  *Note Variables
with Restricted Values::.)

   This chapter describes the purpose, printed representation, and read
syntax of each of the standard types in GNU Emacs Lisp.  Details on how
to use these types can be found in later chapters.

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Circular Objects::            Read syntax for circular structure.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.


File: elisp,  Node: Printed Representation,  Next: Comments,  Up: Lisp Data Types

2.1 Printed Representation and Read Syntax
==========================================

The "printed representation" of an object is the format of the output
generated by the Lisp printer (the function `prin1') for that object.
Every data type has a unique printed representation.  The "read syntax"
of an object is the format of the input accepted by the Lisp reader
(the function `read') for that object.  This is not necessarily unique;
many kinds of object have more than one syntax.  *Note Read and Print::.

   In most cases, an object's printed representation is also a read
syntax for the object.  However, some types have no read syntax, since
it does not make sense to enter objects of these types as constants in
a Lisp program.  These objects are printed in "hash notation", which
consists of the characters `#<', a descriptive string (typically the
type name followed by the name of the object), and a closing `>'.  For
example:

     (current-buffer)
          => #<buffer objects.texi>

Hash notation cannot be read at all, so the Lisp reader signals the
error `invalid-read-syntax' whenever it encounters `#<'.  

   In other languages, an expression is text; it has no other form.  In
Lisp, an expression is primarily a Lisp object and only secondarily the
text that is the object's read syntax.  Often there is no need to
emphasize this distinction, but you must keep it in the back of your
mind, or you will occasionally be very confused.

   When you evaluate an expression interactively, the Lisp interpreter
first reads the textual representation of it, producing a Lisp object,
and then evaluates that object (*note Evaluation::).  However,
evaluation and reading are separate activities.  Reading returns the
Lisp object represented by the text that is read; the object may or may
not be evaluated later.  *Note Input Functions::, for a description of
`read', the basic function for reading objects.


File: elisp,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Lisp Data Types

2.2 Comments
============

A "comment" is text that is written in a program only for the sake of
humans that read the program, and that has no effect on the meaning of
the program.  In Lisp, a semicolon (`;') starts a comment if it is not
within a string or character constant.  The comment continues to the
end of line.  The Lisp reader discards comments; they do not become
part of the Lisp objects which represent the program within the Lisp
system.

   The `#@COUNT' construct, which skips the next COUNT characters, is
useful for program-generated comments containing binary data.  The
Emacs Lisp byte compiler uses this in its output files (*note Byte
Compilation::).  It isn't meant for source files, however.

   *Note Comment Tips::, for conventions for formatting comments.


File: elisp,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Lisp Data Types

2.3 Programming Types
=====================

There are two general categories of types in Emacs Lisp: those having
to do with Lisp programming, and those having to do with editing.  The
former exist in many Lisp implementations, in one form or another.  The
latter are unique to Emacs Lisp.

* Menu:

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of `t' or `nil'.
* Hash Table Type::     Super-fast lookup tables.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.


File: elisp,  Node: Integer Type,  Next: Floating Point Type,  Up: Programming Types

2.3.1 Integer Type
------------------

The range of values for integers in Emacs Lisp is -536870912 to
536870911 (30 bits; i.e., -2**29 to 2**29 - 1) on typical 32-bit
machines.  (Some machines provide a wider range.)  Emacs Lisp
arithmetic functions do not check for overflow.  Thus `(1+ 536870911)'
is -536870912 if Emacs integers are 30 bits.

   The read syntax for integers is a sequence of (base ten) digits with
an optional sign at the beginning and an optional period at the end.
The printed representation produced by the Lisp interpreter never has a
leading `+' or a final `.'.

     -1               ; The integer -1.
     1                ; The integer 1.
     1.               ; Also the integer 1.
     +1               ; Also the integer 1.

As a special exception, if a sequence of digits specifies an integer
too large or too small to be a valid integer object, the Lisp reader
reads it as a floating-point number (*note Floating Point Type::).  For
instance, if Emacs integers are 30 bits, `536870912' is read as the
floating-point number `536870912.0'.

   *Note Numbers::, for more information.


File: elisp,  Node: Floating Point Type,  Next: Character Type,  Prev: Integer Type,  Up: Programming Types

2.3.2 Floating Point Type
-------------------------

Floating point numbers are the computer equivalent of scientific
notation; you can think of a floating point number as a fraction
together with a power of ten.  The precise number of significant
figures and the range of possible exponents is machine-specific; Emacs
uses the C data type `double' to store the value, and internally this
records a power of 2 rather than a power of 10.

   The printed representation for floating point numbers requires either
a decimal point (with at least one digit following), an exponent, or
both.  For example, `1500.0', `15e2', `15.0e2', `1.5e3', and `.15e4'
are five ways of writing a floating point number whose value is 1500.
They are all equivalent.

   *Note Numbers::, for more information.


File: elisp,  Node: Character Type,  Next: Symbol Type,  Prev: Floating Point Type,  Up: Programming Types

2.3.3 Character Type
--------------------

A "character" in Emacs Lisp is nothing more than an integer.  In other
words, characters are represented by their character codes.  For
example, the character `A' is represented as the integer 65.

   Individual characters are used occasionally in programs, but it is
more common to work with _strings_, which are sequences composed of
characters.  *Note String Type::.

   Characters in strings and buffers are currently limited to the range
of 0 to 4194303--twenty two bits (*note Character Codes::).  Codes 0
through 127 are ASCII codes; the rest are non-ASCII (*note Non-ASCII
Characters::).  Characters that represent keyboard input have a much
wider range, to encode modifier keys such as Control, Meta and Shift.

   There are special functions for producing a human-readable textual
description of a character for the sake of messages.  *Note Describing
Characters::.

* Menu:

* Basic Char Syntax::      Syntax for regular characters.
* General Escape Syntax::  How to specify characters by their codes.
* Ctl-Char Syntax::        Syntax for control characters.
* Meta-Char Syntax::       Syntax for meta-characters.
* Other Char Bits::        Syntax for hyper-, super-, and alt-characters.


File: elisp,  Node: Basic Char Syntax,  Next: General Escape Syntax,  Up: Character Type

2.3.3.1 Basic Char Syntax
.........................

Since characters are really integers, the printed representation of a
character is a decimal number.  This is also a possible read syntax for
a character, but writing characters that way in Lisp programs is not
clear programming.  You should _always_ use the special read syntax
formats that Emacs Lisp provides for characters.  These syntax formats
start with a question mark.

   The usual read syntax for alphanumeric characters is a question mark
followed by the character; thus, `?A' for the character `A', `?B' for
the character `B', and `?a' for the character `a'.

   For example:

     ?Q => 81     ?q => 113

   You can use the same syntax for punctuation characters, but it is
often a good idea to add a `\' so that the Emacs commands for editing
Lisp code don't get confused.  For example, `?\(' is the way to write
the open-paren character.  If the character is `\', you _must_ use a
second `\' to quote it: `?\\'.

   You can express the characters control-g, backspace, tab, newline,
vertical tab, formfeed, space, return, del, and escape as `?\a', `?\b',
`?\t', `?\n', `?\v', `?\f', `?\s', `?\r', `?\d', and `?\e',
respectively.  (`?\s' followed by a dash has a different meaning--it
applies the "super" modifier to the following character.)  Thus,

     ?\a => 7                 ; control-g, `C-g'
     ?\b => 8                 ; backspace, <BS>, `C-h'
     ?\t => 9                 ; tab, <TAB>, `C-i'
     ?\n => 10                ; newline, `C-j'
     ?\v => 11                ; vertical tab, `C-k'
     ?\f => 12                ; formfeed character, `C-l'
     ?\r => 13                ; carriage return, <RET>, `C-m'
     ?\e => 27                ; escape character, <ESC>, `C-['
     ?\s => 32                ; space character, <SPC>
     ?\\ => 92                ; backslash character, `\'
     ?\d => 127               ; delete character, <DEL>

   These sequences which start with backslash are also known as "escape
sequences", because backslash plays the role of an "escape character";
this terminology has nothing to do with the character <ESC>.  `\s' is
meant for use in character constants; in string constants, just write
the space.

   A backslash is allowed, and harmless, preceding any character without
a special escape meaning; thus, `?\+' is equivalent to `?+'.  There is
no reason to add a backslash before most characters.  However, you
should add a backslash before any of the characters `()\|;'`"#.,' to
avoid confusing the Emacs commands for editing Lisp code.  You can also
add a backslash before whitespace characters such as space, tab,
newline and formfeed.  However, it is cleaner to use one of the easily
readable escape sequences, such as `\t' or `\s', instead of an actual
whitespace character such as a tab or a space.  (If you do write
backslash followed by a space, you should write an extra space after
the character constant to separate it from the following text.)


File: elisp,  Node: General Escape Syntax,  Next: Ctl-Char Syntax,  Prev: Basic Char Syntax,  Up: Character Type

2.3.3.2 General Escape Syntax
.............................

In addition to the specific escape sequences for special important
control characters, Emacs provides several types of escape syntax that
you can use to specify non-ASCII text characters.

   You can specify characters by their Unicode values.  `?\uNNNN'
represents a character that maps to the Unicode code point `U+NNNN' (by
convention, Unicode code points are given in hexadecimal).  There is a
slightly different syntax for specifying characters with code points
higher than `U+FFFF': `\U00NNNNNN' represents the character whose code
point is `U+NNNNNN'.  The Unicode Standard only defines code points up
to `U+10FFFF', so if you specify a code point higher than that, Emacs
signals an error.

   This peculiar and inconvenient syntax was adopted for compatibility
with other programming languages.  Unlike some other languages, Emacs
Lisp supports this syntax only in character literals and strings.

   The most general read syntax for a character represents the
character code in either octal or hex.  To use octal, write a question
mark followed by a backslash and the octal character code (up to three
octal digits); thus, `?\101' for the character `A', `?\001' for the
character `C-a', and `?\002' for the character `C-b'.  Although this
syntax can represent any ASCII character, it is preferred only when the
precise octal value is more important than the ASCII representation.

     ?\012 => 10         ?\n => 10         ?\C-j => 10
     ?\101 => 65         ?A => 65

   To use hex, write a question mark followed by a backslash, `x', and
the hexadecimal character code.  You can use any number of hex digits,
so you can represent any character code in this way.  Thus, `?\x41' for
the character `A', `?\x1' for the character `C-a', and `?\xe0' for the
Latin-1 character `a' with grave accent.


File: elisp,  Node: Ctl-Char Syntax,  Next: Meta-Char Syntax,  Prev: General Escape Syntax,  Up: Character Type

2.3.3.3 Control-Character Syntax
................................

Control characters can be represented using yet another read syntax.
This consists of a question mark followed by a backslash, caret, and the
corresponding non-control character, in either upper or lower case.  For
example, both `?\^I' and `?\^i' are valid read syntax for the character
`C-i', the character whose value is 9.

   Instead of the `^', you can use `C-'; thus, `?\C-i' is equivalent to
`?\^I' and to `?\^i':

     ?\^I => 9     ?\C-I => 9

   In strings and buffers, the only control characters allowed are those
that exist in ASCII; but for keyboard input purposes, you can turn any
character into a control character with `C-'.  The character codes for
these non-ASCII control characters include the 2**26 bit as well as the
code for the corresponding non-control character.  Ordinary text
terminals have no way of generating non-ASCII control characters, but
you can generate them straightforwardly using X and other window
systems.

   For historical reasons, Emacs treats the <DEL> character as the
control equivalent of `?':

     ?\^? => 127     ?\C-? => 127

As a result, it is currently not possible to represent the character
`Control-?', which is a meaningful input character under X, using
`\C-'.  It is not easy to change this, as various Lisp files refer to
<DEL> in this way.

   For representing control characters to be found in files or strings,
we recommend the `^' syntax; for control characters in keyboard input,
we prefer the `C-' syntax.  Which one you use does not affect the
meaning of the program, but may guide the understanding of people who
read it.


File: elisp,  Node: Meta-Char Syntax,  Next: Other Char Bits,  Prev: Ctl-Char Syntax,  Up: Character Type

2.3.3.4 Meta-Character Syntax
.............................

A "meta character" is a character typed with the <META> modifier key.
The integer that represents such a character has the 2**27 bit set.  We
use high bits for this and other modifiers to make possible a wide
range of basic character codes.

   In a string, the 2**7 bit attached to an ASCII character indicates a
meta character; thus, the meta characters that can fit in a string have
codes in the range from 128 to 255, and are the meta versions of the
ordinary ASCII characters.  *Note Strings of Events::, for details
about <META>-handling in strings.

   The read syntax for meta characters uses `\M-'.  For example,
`?\M-A' stands for `M-A'.  You can use `\M-' together with octal
character codes (see below), with `\C-', or with any other syntax for a
character.  Thus, you can write `M-A' as `?\M-A', or as `?\M-\101'.
Likewise, you can write `C-M-b' as `?\M-\C-b', `?\C-\M-b', or
`?\M-\002'.


File: elisp,  Node: Other Char Bits,  Prev: Meta-Char Syntax,  Up: Character Type

2.3.3.5 Other Character Modifier Bits
.....................................

The case of a graphic character is indicated by its character code; for
example, ASCII distinguishes between the characters `a' and `A'.  But
ASCII has no way to represent whether a control character is upper case
or lower case.  Emacs uses the 2**25 bit to indicate that the shift key
was used in typing a control character.  This distinction is possible
only when you use X terminals or other special terminals; ordinary text
terminals do not report the distinction.  The Lisp syntax for the shift
bit is `\S-'; thus, `?\C-\S-o' or `?\C-\S-O' represents the
shifted-control-o character.

   The X Window System defines three other modifier bits that can be set
in a character: "hyper", "super" and "alt".  The syntaxes for these
bits are `\H-', `\s-' and `\A-'.  (Case is significant in these
prefixes.)  Thus, `?\H-\M-\A-x' represents `Alt-Hyper-Meta-x'.  (Note
that `\s' with no following `-' represents the space character.)
Numerically, the bit values are 2**22 for alt, 2**23 for super and
2**24 for hyper.


File: elisp,  Node: Symbol Type,  Next: Sequence Type,  Prev: Character Type,  Up: Programming Types

2.3.4 Symbol Type
-----------------

A "symbol" in GNU Emacs Lisp is an object with a name.  The symbol name
serves as the printed representation of the symbol.  In ordinary Lisp
use, with one single obarray (*note Creating Symbols::), a symbol's
name is unique--no two symbols have the same name.

   A symbol can serve as a variable, as a function name, or to hold a
property list.  Or it may serve only to be distinct from all other Lisp
objects, so that its presence in a data structure may be recognized
reliably.  In a given context, usually only one of these uses is
intended.  But you can use one symbol in all of these ways,
independently.

   A symbol whose name starts with a colon (`:') is called a "keyword
symbol".  These symbols automatically act as constants, and are
normally used only by comparing an unknown symbol with a few specific
alternatives.  *Note Constant Variables::.

   A symbol name can contain any characters whatever.  Most symbol names
are written with letters, digits, and the punctuation characters
`-+=*/'.  Such names require no special punctuation; the characters of
the name suffice as long as the name does not look like a number.  (If
it does, write a `\' at the beginning of the name to force
interpretation as a symbol.)  The characters `_~!@$%^&:<>{}?' are less
often used but also require no special punctuation.  Any other
characters may be included in a symbol's name by escaping them with a
backslash.  In contrast to its use in strings, however, a backslash in
the name of a symbol simply quotes the single character that follows the
backslash.  For example, in a string, `\t' represents a tab character;
in the name of a symbol, however, `\t' merely quotes the letter `t'.
To have a symbol with a tab character in its name, you must actually
use a tab (preceded with a backslash).  But it's rare to do such a
thing.

     Common Lisp note: In Common Lisp, lower case letters are always
     "folded" to upper case, unless they are explicitly escaped.  In
     Emacs Lisp, upper case and lower case letters are distinct.

   Here are several examples of symbol names.  Note that the `+' in the
fifth example is escaped to prevent it from being read as a number.
This is not necessary in the fourth example because the rest of the name
makes it invalid as a number.

     foo                 ; A symbol named `foo'.
     FOO                 ; A symbol named `FOO', different from `foo'.
     1+                  ; A symbol named `1+'
                         ;   (not `+1', which is an integer).
     \+1                 ; A symbol named `+1'
                         ;   (not a very readable name).
     \(*\ 1\ 2\)         ; A symbol named `(* 1 2)' (a worse name).
     +-*/_~!@$%^&=:<>{}  ; A symbol named `+-*/_~!@$%^&=:<>{}'.
                         ;   These characters need not be escaped.

   As an exception to the rule that a symbol's name serves as its
printed representation, `##' is the printed representation for an
interned symbol whose name is an empty string.  Furthermore, `#:FOO' is
the printed representation for an uninterned symbol whose name is FOO.
(Normally, the Lisp reader interns all symbols; *note Creating
Symbols::.)


File: elisp,  Node: Sequence Type,  Next: Cons Cell Type,  Prev: Symbol Type,  Up: Programming Types

2.3.5 Sequence Types
--------------------

A "sequence" is a Lisp object that represents an ordered set of
elements.  There are two kinds of sequence in Emacs Lisp: "lists" and
"arrays".

   Lists are the most commonly-used sequences.  A list can hold
elements of any type, and its length can be easily changed by adding or
removing elements.  See the next subsection for more about lists.

   Arrays are fixed-length sequences.  They are further subdivided into
strings, vectors, char-tables and bool-vectors.  Vectors can hold
elements of any type, whereas string elements must be characters, and
bool-vector elements must be `t' or `nil'.  Char-tables are like
vectors except that they are indexed by any valid character code.  The
characters in a string can have text properties like characters in a
buffer (*note Text Properties::), but vectors do not support text
properties, even when their elements happen to be characters.

   Lists, strings and the other array types also share important
similarities.  For example, all have a length L, and all have elements
which can be indexed from zero to L minus one.  Several functions,
called sequence functions, accept any kind of sequence.  For example,
the function `length' reports the length of any kind of sequence.
*Note Sequences Arrays Vectors::.

   It is generally impossible to read the same sequence twice, since
sequences are always created anew upon reading.  If you read the read
syntax for a sequence twice, you get two sequences with equal contents.
There is one exception: the empty list `()' always stands for the same
object, `nil'.


File: elisp,  Node: Cons Cell Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

2.3.6 Cons Cell and List Types
------------------------------

A "cons cell" is an object that consists of two slots, called the CAR
slot and the CDR slot.  Each slot can "hold" any Lisp object.  We also
say that "the CAR of this cons cell is" whatever object its CAR slot
currently holds, and likewise for the CDR.

   A "list" is a series of cons cells, linked together so that the CDR
slot of each cons cell holds either the next cons cell or the empty
list.  The empty list is actually the symbol `nil'.  *Note Lists::, for
details.  Because most cons cells are used as part of lists, we refer
to any structure made out of cons cells as a "list structure".

     A note to C programmers: a Lisp list thus works as a "linked list"
     built up of cons cells.  Because pointers in Lisp are implicit, we
     do not distinguish between a cons cell slot "holding" a value
     versus "pointing to" the value.

   Because cons cells are so central to Lisp, we also have a word for
"an object which is not a cons cell".  These objects are called "atoms".

   The read syntax and printed representation for lists are identical,
and consist of a left parenthesis, an arbitrary number of elements, and
a right parenthesis.  Here are examples of lists:

     (A 2 "A")            ; A list of three elements.
     ()                   ; A list of no elements (the empty list).
     nil                  ; A list of no elements (the empty list).
     ("A ()")             ; A list of one element: the string `"A ()"'.
     (A ())               ; A list of two elements: `A' and the empty list.
     (A nil)              ; Equivalent to the previous.
     ((A B C))            ; A list of one element
                          ;   (which is a list of three elements).

   Upon reading, each object inside the parentheses becomes an element
of the list.  That is, a cons cell is made for each element.  The CAR
slot of the cons cell holds the element, and its CDR slot refers to the
next cons cell of the list, which holds the next element in the list.
The CDR slot of the last cons cell is set to hold `nil'.

   The names CAR and CDR derive from the history of Lisp.  The original
Lisp implementation ran on an IBM 704 computer which divided words into
two parts, called the "address" part and the "decrement"; CAR was an
instruction to extract the contents of the address part of a register,
and CDR an instruction to extract the contents of the decrement.  By
contrast, "cons cells" are named for the function `cons' that creates
them, which in turn was named for its purpose, the construction of
cells.

* Menu:

* Box Diagrams::                Drawing pictures of lists.
* Dotted Pair Notation::        A general syntax for cons cells.
* Association List Type::       A specially constructed list.


File: elisp,  Node: Box Diagrams,  Next: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.1 Drawing Lists as Box Diagrams
.....................................

A list can be illustrated by a diagram in which the cons cells are
shown as pairs of boxes, like dominoes.  (The Lisp reader cannot read
such an illustration; unlike the textual notation, which can be
understood by both humans and computers, the box illustrations can be
understood only by humans.)  This picture represents the three-element
list `(rose violet buttercup)':

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

   In this diagram, each box represents a slot that can hold or refer to
any Lisp object.  Each pair of boxes represents a cons cell.  Each arrow
represents a reference to a Lisp object, either an atom or another cons
cell.

   In this example, the first box, which holds the CAR of the first
cons cell, refers to or "holds" `rose' (a symbol).  The second box,
holding the CDR of the first cons cell, refers to the next pair of
boxes, the second cons cell.  The CAR of the second cons cell is
`violet', and its CDR is the third cons cell.  The CDR of the third
(and last) cons cell is `nil'.

   Here is another diagram of the same list, `(rose violet buttercup)',
sketched in a different manner:

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

   A list with no elements in it is the "empty list"; it is identical
to the symbol `nil'.  In other words, `nil' is both a symbol and a list.

   Here is the list `(A ())', or equivalently `(A nil)', depicted with
boxes and arrows:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil

   Here is a more complex illustration, showing the three-element list,
`((pine needles) oak maple)', the first element of which is a
two-element list:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles

   The same list represented in the second box notation looks like this:

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------


File: elisp,  Node: Dotted Pair Notation,  Next: Association List Type,  Prev: Box Diagrams,  Up: Cons Cell Type

2.3.6.2 Dotted Pair Notation
............................

"Dotted pair notation" is a general syntax for cons cells that
represents the CAR and CDR explicitly.  In this syntax, `(A . B)'
stands for a cons cell whose CAR is the object A and whose CDR is the
object B.  Dotted pair notation is more general than list syntax
because the CDR does not have to be a list.  However, it is more
cumbersome in cases where list syntax would work.  In dotted pair
notation, the list `(1 2 3)' is written as `(1 .  (2 . (3 . nil)))'.
For `nil'-terminated lists, you can use either notation, but list
notation is usually clearer and more convenient.  When printing a list,
the dotted pair notation is only used if the CDR of a cons cell is not
a list.

   Here's an example using boxes to illustrate dotted pair notation.
This example shows the pair `(rose . violet)':

         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

   You can combine dotted pair notation with list notation to represent
conveniently a chain of cons cells with a non-`nil' final CDR.  You
write a dot after the last element of the list, followed by the CDR of
the final cons cell.  For example, `(rose violet . buttercup)' is
equivalent to `(rose . (violet . buttercup))'.  The object looks like
this:

         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   The syntax `(rose . violet . buttercup)' is invalid because there is
nothing that it could mean.  If anything, it would say to put
`buttercup' in the CDR of a cons cell whose CDR is already used for
`violet'.

   The list `(rose violet)' is equivalent to `(rose . (violet))', and
looks like this:

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   Similarly, the three-element list `(rose violet buttercup)' is
equivalent to `(rose . (violet . (buttercup)))'.  It looks like this:

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup


File: elisp,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.3 Association List Type
.............................

An "association list" or "alist" is a specially-constructed list whose
elements are cons cells.  In each element, the CAR is considered a
"key", and the CDR is considered an "associated value".  (In some
cases, the associated value is stored in the CAR of the CDR.)
Association lists are often used as stacks, since it is easy to add or
remove associations at the front of the list.

   For example,

     (setq alist-of-colors
           '((rose . red) (lily . white) (buttercup . yellow)))

sets the variable `alist-of-colors' to an alist of three elements.  In
the first element, `rose' is the key and `red' is the value.

   *Note Association Lists::, for a further explanation of alists and
for functions that work on alists.  *Note Hash Tables::, for another
kind of lookup table, which is much faster for handling a large number
of keys.


File: elisp,  Node: Array Type,  Next: String Type,  Prev: Cons Cell Type,  Up: Programming Types

2.3.7 Array Type
----------------

An "array" is composed of an arbitrary number of slots for holding or
referring to other Lisp objects, arranged in a contiguous block of
memory.  Accessing any element of an array takes approximately the same
amount of time.  In contrast, accessing an element of a list requires
time proportional to the position of the element in the list.  (Elements
at the end of a list take longer to access than elements at the
beginning of a list.)

   Emacs defines four types of array: strings, vectors, bool-vectors,
and char-tables.

   A string is an array of characters and a vector is an array of
arbitrary objects.  A bool-vector can hold only `t' or `nil'.  These
kinds of array may have any length up to the largest integer.
Char-tables are sparse arrays indexed by any valid character code; they
can hold arbitrary objects.

   The first element of an array has index zero, the second element has
index 1, and so on.  This is called "zero-origin" indexing.  For
example, an array of four elements has indices 0, 1, 2, and 3.  The
largest possible index value is one less than the length of the array.
Once an array is created, its length is fixed.

   All Emacs Lisp arrays are one-dimensional.  (Most other programming
languages support multidimensional arrays, but they are not essential;
you can get the same effect with nested one-dimensional arrays.)  Each
type of array has its own read syntax; see the following sections for
details.

   The array type is a subset of the sequence type, and contains the
string type, the vector type, the bool-vector type, and the char-table
type.


File: elisp,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

2.3.8 String Type
-----------------

A "string" is an array of characters.  Strings are used for many
purposes in Emacs, as can be expected in a text editor; for example, as
the names of Lisp symbols, as messages for the user, and to represent
text extracted from buffers.  Strings in Lisp are constants: evaluation
of a string returns the same string.

   *Note Strings and Characters::, for functions that operate on
strings.

* Menu:

* Syntax for Strings::      How to specify Lisp strings.
* Non-ASCII in Strings::    International characters in strings.
* Nonprinting Characters::  Literal unprintable characters in strings.
* Text Props and Strings::  Strings with text properties.


File: elisp,  Node: Syntax for Strings,  Next: Non-ASCII in Strings,  Up: String Type

2.3.8.1 Syntax for Strings
..........................

The read syntax for a string is a double-quote, an arbitrary number of
characters, and another double-quote, `"like this"'.  To include a
double-quote in a string, precede it with a backslash; thus, `"\""' is
a string containing just a single double-quote character.  Likewise,
you can include a backslash by preceding it with another backslash,
like this: `"this \\ is a single embedded backslash"'.

   The newline character is not special in the read syntax for strings;
if you write a new line between the double-quotes, it becomes a
character in the string.  But an escaped newline--one that is preceded
by `\'--does not become part of the string; i.e., the Lisp reader
ignores an escaped newline while reading a string.  An escaped space
`\ ' is likewise ignored.

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          => "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."


File: elisp,  Node: Non-ASCII in Strings,  Next: Nonprinting Characters,  Prev: Syntax for Strings,  Up: String Type

2.3.8.2 Non-ASCII Characters in Strings
.......................................

You can include a non-ASCII international character in a string
constant by writing it literally.  There are two text representations
for non-ASCII characters in Emacs strings (and in buffers): unibyte and
multibyte (*note Text Representations::).  If the string constant is
read from a multibyte source, such as a multibyte buffer or string, or
a file that would be visited as multibyte, then Emacs reads the
non-ASCII character as a multibyte character and automatically makes
the string a multibyte string.  If the string constant is read from a
unibyte source, then Emacs reads the non-ASCII character as unibyte,
and makes the string unibyte.

   Instead of writing a non-ASCII character literally into a multibyte
string, you can write it as its character code using a hex escape,
`\xNNNNNNN', with as many digits as necessary.  (Multibyte non-ASCII
character codes are all greater than 256.)  You can also specify a
character in a multibyte string using the `\u' or `\U' Unicode escape
syntax (*note General Escape Syntax::).  In either case, any character
which is not a valid hex digit terminates the construct.  If the next
character in the string could be interpreted as a hex digit, write `\ '
(backslash and space) to terminate the hex escape--for example,
`\xe0\ ' represents one character, `a' with grave accent.  `\ ' in a
string constant is just like backslash-newline; it does not contribute
any character to the string, but it does terminate the preceding hex
escape.  Using any hex escape in a string (even for an ASCII character)
automatically forces the string to be multibyte.

   You can represent a unibyte non-ASCII character with its character
code, which must be in the range from 128 (0200 octal) to 255 (0377
octal).  If you write all such character codes in octal and the string
contains no other characters forcing it to be multibyte, this produces
a unibyte string.


File: elisp,  Node: Nonprinting Characters,  Next: Text Props and Strings,  Prev: Non-ASCII in Strings,  Up: String Type

2.3.8.3 Nonprinting Characters in Strings
.........................................

You can use the same backslash escape-sequences in a string constant as
in character literals (but do not use the question mark that begins a
character constant).  For example, you can write a string containing the
nonprinting characters tab and `C-a', with commas and spaces between
them, like this: `"\t, \C-a"'.  *Note Character Type::, for a
description of the read syntax for characters.

   However, not all of the characters you can write with backslash
escape-sequences are valid in strings.  The only control characters that
a string can hold are the ASCII control characters.  Strings do not
distinguish case in ASCII control characters.

   Properly speaking, strings cannot hold meta characters; but when a
string is to be used as a key sequence, there is a special convention
that provides a way to represent meta versions of ASCII characters in a
string.  If you use the `\M-' syntax to indicate a meta character in a
string constant, this sets the 2**7 bit of the character in the string.
If the string is used in `define-key' or `lookup-key', this numeric
code is translated into the equivalent meta character.  *Note Character
Type::.

   Strings cannot hold characters that have the hyper, super, or alt
modifiers.


File: elisp,  Node: Text Props and Strings,  Prev: Nonprinting Characters,  Up: String Type

2.3.8.4 Text Properties in Strings
..................................

A string can hold properties for the characters it contains, in
addition to the characters themselves.  This enables programs that copy
text between strings and buffers to copy the text's properties with no
special effort.  *Note Text Properties::, for an explanation of what
text properties mean.  Strings with text properties use a special read
and print syntax:

     #("CHARACTERS" PROPERTY-DATA...)

where PROPERTY-DATA consists of zero or more elements, in groups of
three as follows:

     BEG END PLIST

The elements BEG and END are integers, and together specify a range of
indices in the string; PLIST is the property list for that range.  For
example,

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

represents a string whose textual contents are `foo bar', in which the
first three characters have a `face' property with value `bold', and
the last three have a `face' property with value `italic'.  (The fourth
character has no text properties, so its property list is `nil'.  It is
not actually necessary to mention ranges with `nil' as the property
list, since any characters not mentioned in any range will default to
having no properties.)


File: elisp,  Node: Vector Type,  Next: Char-Table Type,  Prev: String Type,  Up: Programming Types

2.3.9 Vector Type
-----------------

A "vector" is a one-dimensional array of elements of any type.  It
takes a constant amount of time to access any element of a vector.  (In
a list, the access time of an element is proportional to the distance of
the element from the beginning of the list.)

   The printed representation of a vector consists of a left square
bracket, the elements, and a right square bracket.  This is also the
read syntax.  Like numbers and strings, vectors are considered constants
for evaluation.

     [1 "two" (three)]      ; A vector of three elements.
          => [1 "two" (three)]

   *Note Vectors::, for functions that work with vectors.


File: elisp,  Node: Char-Table Type,  Next: Bool-Vector Type,  Prev: Vector Type,  Up: Programming Types

2.3.10 Char-Table Type
----------------------

A "char-table" is a one-dimensional array of elements of any type,
indexed by character codes.  Char-tables have certain extra features to
make them more useful for many jobs that involve assigning information
to character codes--for example, a char-table can have a parent to
inherit from, a default value, and a small number of extra slots to use
for special purposes.  A char-table can also specify a single value for
a whole character set.

   The printed representation of a char-table is like a vector except
that there is an extra `#^' at the beginning.

   *Note Char-Tables::, for special functions to operate on char-tables.
Uses of char-tables include:

   * Case tables (*note Case Tables::).

   * Character category tables (*note Categories::).

   * Display tables (*note Display Tables::).

   * Syntax tables (*note Syntax Tables::).


File: elisp,  Node: Bool-Vector Type,  Next: Hash Table Type,  Prev: Char-Table Type,  Up: Programming Types

2.3.11 Bool-Vector Type
-----------------------

A "bool-vector" is a one-dimensional array whose elements must be `t'
or `nil'.

   The printed representation of a bool-vector is like a string, except
that it begins with `#&' followed by the length.  The string constant
that follows actually specifies the contents of the bool-vector as a
bitmap--each "character" in the string contains 8 bits, which specify
the next 8 elements of the bool-vector (1 stands for `t', and 0 for
`nil').  The least significant bits of the character correspond to the
lowest indices in the bool-vector.

     (make-bool-vector 3 t)
          => #&3"^G"
     (make-bool-vector 3 nil)
          => #&3"^@"

These results make sense, because the binary code for `C-g' is 111 and
`C-@' is the character with code 0.

   If the length is not a multiple of 8, the printed representation
shows extra elements, but these extras really make no difference.  For
instance, in the next example, the two bool-vectors are equal, because
only the first 3 bits are used:

     (equal #&3"\377" #&3"\007")
          => t


File: elisp,  Node: Hash Table Type,  Next: Function Type,  Prev: Bool-Vector Type,  Up: Programming Types

2.3.12 Hash Table Type
----------------------

A hash table is a very fast kind of lookup table, somewhat like an
alist in that it maps keys to corresponding values, but much faster.
The printed representation of a hash table specifies its properties and
contents, like this:

     (make-hash-table)
          => #s(hash-table size 65 test eql rehash-size 1.5
                                  rehash-threshold 0.8 data ())

*Note Hash Tables::, for more information about hash tables.


File: elisp,  Node: Function Type,  Next: Macro Type,  Prev: Hash Table Type,  Up: Programming Types

2.3.13 Function Type
--------------------

Lisp functions are executable code, just like functions in other
programming languages.  In Lisp, unlike most languages, functions are
also Lisp objects.  A non-compiled function in Lisp is a lambda
expression: that is, a list whose first element is the symbol `lambda'
(*note Lambda Expressions::).

   In most programming languages, it is impossible to have a function
without a name.  In Lisp, a function has no intrinsic name.  A lambda
expression can be called as a function even though it has no name; to
emphasize this, we also call it an "anonymous function" (*note
Anonymous Functions::).  A named function in Lisp is just a symbol with
a valid function in its function cell (*note Defining Functions::).

   Most of the time, functions are called when their names are written
in Lisp expressions in Lisp programs.  However, you can construct or
obtain a function object at run time and then call it with the primitive
functions `funcall' and `apply'.  *Note Calling Functions::.


File: elisp,  Node: Macro Type,  Next: Primitive Function Type,  Prev: Function Type,  Up: Programming Types

2.3.14 Macro Type
-----------------

A "Lisp macro" is a user-defined construct that extends the Lisp
language.  It is represented as an object much like a function, but with
different argument-passing semantics.  A Lisp macro has the form of a
list whose first element is the symbol `macro' and whose CDR is a Lisp
function object, including the `lambda' symbol.

   Lisp macro objects are usually defined with the built-in `defmacro'
function, but any list that begins with `macro' is a macro as far as
Emacs is concerned.  *Note Macros::, for an explanation of how to write
a macro.

   *Warning*: Lisp macros and keyboard macros (*note Keyboard Macros::)
are entirely different things.  When we use the word "macro" without
qualification, we mean a Lisp macro, not a keyboard macro.


File: elisp,  Node: Primitive Function Type,  Next: Byte-Code Type,  Prev: Macro Type,  Up: Programming Types

2.3.15 Primitive Function Type
------------------------------

A "primitive function" is a function callable from Lisp but written in
the C programming language.  Primitive functions are also called
"subrs" or "built-in functions".  (The word "subr" is derived from
"subroutine".)  Most primitive functions evaluate all their arguments
when they are called.  A primitive function that does not evaluate all
its arguments is called a "special form" (*note Special Forms::).

   It does not matter to the caller of a function whether the function
is primitive.  However, this does matter if you try to redefine a
primitive with a function written in Lisp.  The reason is that the
primitive function may be called directly from C code.  Calls to the
redefined function from Lisp will use the new definition, but calls
from C code may still use the built-in definition.  Therefore, *we
discourage redefinition of primitive functions*.

   The term "function" refers to all Emacs functions, whether written
in Lisp or C.  *Note Function Type::, for information about the
functions written in Lisp.

   Primitive functions have no read syntax and print in hash notation
with the name of the subroutine.

     (symbol-function 'car)          ; Access the function cell
                                     ;   of the symbol.
          => #<subr car>
     (subrp (symbol-function 'car))  ; Is this a primitive function?
          => t                       ; Yes.


File: elisp,  Node: Byte-Code Type,  Next: Autoload Type,  Prev: Primitive Function Type,  Up: Programming Types

2.3.16 Byte-Code Function Type
------------------------------

"Byte-code function objects" are produced by byte-compiling Lisp code
(*note Byte Compilation::).  Internally, a byte-code function object is
much like a vector; however, the evaluator handles this data type
specially when it appears in a function call.  *Note Byte-Code
Objects::.

   The printed representation and read syntax for a byte-code function
object is like that for a vector, with an additional `#' before the
opening `['.


File: elisp,  Node: Autoload Type,  Prev: Byte-Code Type,  Up: Programming Types

2.3.17 Autoload Type
--------------------

An "autoload object" is a list whose first element is the symbol
`autoload'.  It is stored as the function definition of a symbol, where
it serves as a placeholder for the real definition.  The autoload
object says that the real definition is found in a file of Lisp code
that should be loaded when necessary.  It contains the name of the file,
plus some other information about the real definition.

   After the file has been loaded, the symbol should have a new function
definition that is not an autoload object.  The new definition is then
called as if it had been there to begin with.  From the user's point of
view, the function call works as expected, using the function definition
in the loaded file.

   An autoload object is usually created with the function `autoload',
which stores the object in the function cell of a symbol.  *Note
Autoload::, for more details.


File: elisp,  Node: Editing Types,  Next: Circular Objects,  Prev: Programming Types,  Up: Lisp Data Types

2.4 Editing Types
=================

The types in the previous section are used for general programming
purposes, and most of them are common to most Lisp dialects.  Emacs Lisp
provides several additional data types for purposes connected with
editing.

* Menu:

* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::          Windows subdivide frames.
* Terminal Type::       A terminal device displays frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A subprocess of Emacs running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.
* Font Type::           Fonts for displaying text.


File: elisp,  Node: Buffer Type,  Next: Marker Type,  Up: Editing Types

2.4.1 Buffer Type
-----------------

A "buffer" is an object that holds text that can be edited (*note
Buffers::).  Most buffers hold the contents of a disk file (*note
Files::) so they can be edited, but some are used for other purposes.
Most buffers are also meant to be seen by the user, and therefore
displayed, at some time, in a window (*note Windows::).  But a buffer
need not be displayed in any window.  Each buffer has a designated
position called "point" (*note Positions::); most editing commands act
on the contents of the current buffer in the neighborhood of point.  At
any time, one buffer is the "current buffer".

   The contents of a buffer are much like a string, but buffers are not
used like strings in Emacs Lisp, and the available operations are
different.  For example, you can insert text efficiently into an
existing buffer, altering the buffer's contents, whereas "inserting"
text into a string requires concatenating substrings, and the result is
an entirely new string object.

   Many of the standard Emacs functions manipulate or test the
characters in the current buffer; a whole chapter in this manual is
devoted to describing these functions (*note Text::).

   Several other data structures are associated with each buffer:

   * a local syntax table (*note Syntax Tables::);

   * a local keymap (*note Keymaps::); and,

   * a list of buffer-local variable bindings (*note Buffer-Local
     Variables::).

   * overlays (*note Overlays::).

   * text properties for the text in the buffer (*note Text
     Properties::).

The local keymap and variable list contain entries that individually
override global bindings or values.  These are used to customize the
behavior of programs in different buffers, without actually changing the
programs.

   A buffer may be "indirect", which means it shares the text of
another buffer, but presents it differently.  *Note Indirect Buffers::.

   Buffers have no read syntax.  They print in hash notation, showing
the buffer name.

     (current-buffer)
          => #<buffer objects.texi>


File: elisp,  Node: Marker Type,  Next: Window Type,  Prev: Buffer Type,  Up: Editing Types

2.4.2 Marker Type
-----------------

A "marker" denotes a position in a specific buffer.  Markers therefore
have two components: one for the buffer, and one for the position.
Changes in the buffer's text automatically relocate the position value
as necessary to ensure that the marker always points between the same
two characters in the buffer.

   Markers have no read syntax.  They print in hash notation, giving the
current character position and the name of the buffer.

     (point-marker)
          => #<marker at 10779 in objects.texi>

   *Note Markers::, for information on how to test, create, copy, and
move markers.


File: elisp,  Node: Window Type,  Next: Frame Type,  Prev: Marker Type,  Up: Editing Types

2.4.3 Window Type
-----------------

A "window" describes the portion of the terminal screen that Emacs uses
to display a buffer.  Every window has one associated buffer, whose
contents appear in the window.  By contrast, a given buffer may appear
in one window, no window, or several windows.

   Though many windows may exist simultaneously, at any time one window
is designated the "selected window".  This is the window where the
cursor is (usually) displayed when Emacs is ready for a command.  The
selected window usually displays the current buffer, but this is not
necessarily the case.

   Windows are grouped on the screen into frames; each window belongs to
one and only one frame.  *Note Frame Type::.

   Windows have no read syntax.  They print in hash notation, giving the
window number and the name of the buffer being displayed.  The window
numbers exist to identify windows uniquely, since the buffer displayed
in any given window can change frequently.

     (selected-window)
          => #<window 1 on objects.texi>

   *Note Windows::, for a description of the functions that work on
windows.


File: elisp,  Node: Frame Type,  Next: Terminal Type,  Prev: Window Type,  Up: Editing Types

2.4.4 Frame Type
----------------

A "frame" is a screen area that contains one or more Emacs windows; we
also use the term "frame" to refer to the Lisp object that Emacs uses
to refer to the screen area.

   Frames have no read syntax.  They print in hash notation, giving the
frame's title, plus its address in core (useful to identify the frame
uniquely).

     (selected-frame)
          => #<frame emacs@psilocin.gnu.org 0xdac80>

   *Note Frames::, for a description of the functions that work on
frames.


File: elisp,  Node: Terminal Type,  Next: Window Configuration Type,  Prev: Frame Type,  Up: Editing Types

2.4.5 Terminal Type
-------------------

A "terminal" is a device capable of displaying one or more Emacs frames
(*note Frame Type::).

   Terminals have no read syntax.  They print in hash notation giving
the terminal's ordinal number and its TTY device file name.

     (get-device-terminal nil)
          => #<terminal 1 on /dev/tty>


File: elisp,  Node: Window Configuration Type,  Next: Frame Configuration Type,  Prev: Terminal Type,  Up: Editing Types

2.4.6 Window Configuration Type
-------------------------------

A "window configuration" stores information about the positions, sizes,
and contents of the windows in a frame, so you can recreate the same
arrangement of windows later.

   Window configurations do not have a read syntax; their print syntax
looks like `#<window-configuration>'.  *Note Window Configurations::,
for a description of several functions related to window configurations.


File: elisp,  Node: Frame Configuration Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

2.4.7 Frame Configuration Type
------------------------------

A "frame configuration" stores information about the positions, sizes,
and contents of the windows in all frames.  It is not a primitive
type--it is actually a list whose CAR is `frame-configuration' and
whose CDR is an alist.  Each alist element describes one frame, which
appears as the CAR of that element.

   *Note Frame Configurations::, for a description of several functions
related to frame configurations.


File: elisp,  Node: Process Type,  Next: Stream Type,  Prev: Frame Configuration Type,  Up: Editing Types

2.4.8 Process Type
------------------

The word "process" usually means a running program.  Emacs itself runs
in a process of this sort.  However, in Emacs Lisp, a process is a Lisp
object that designates a subprocess created by the Emacs process.
Programs such as shells, GDB, ftp, and compilers, running in
subprocesses of Emacs, extend the capabilities of Emacs.    An Emacs
subprocess takes textual input from Emacs and returns textual output to
Emacs for further manipulation.  Emacs can also send signals to the
subprocess.

   Process objects have no read syntax.  They print in hash notation,
giving the name of the process:

     (process-list)
          => (#<process shell>)

   *Note Processes::, for information about functions that create,
delete, return information about, send input or signals to, and receive
output from processes.


File: elisp,  Node: Stream Type,  Next: Keymap Type,  Prev: Process Type,  Up: Editing Types

2.4.9 Stream Type
-----------------

A "stream" is an object that can be used as a source or sink for
characters--either to supply characters for input or to accept them as
output.  Many different types can be used this way: markers, buffers,
strings, and functions.  Most often, input streams (character sources)
obtain characters from the keyboard, a buffer, or a file, and output
streams (character sinks) send characters to a buffer, such as a
`*Help*' buffer, or to the echo area.

   The object `nil', in addition to its other meanings, may be used as
a stream.  It stands for the value of the variable `standard-input' or
`standard-output'.  Also, the object `t' as a stream specifies input
using the minibuffer (*note Minibuffers::) or output in the echo area
(*note The Echo Area::).

   Streams have no special printed representation or read syntax, and
print as whatever primitive type they are.

   *Note Read and Print::, for a description of functions related to
streams, including parsing and printing functions.


File: elisp,  Node: Keymap Type,  Next: Overlay Type,  Prev: Stream Type,  Up: Editing Types

2.4.10 Keymap Type
------------------

A "keymap" maps keys typed by the user to commands.  This mapping
controls how the user's command input is executed.  A keymap is actually
a list whose CAR is the symbol `keymap'.

   *Note Keymaps::, for information about creating keymaps, handling
prefix keys, local as well as global keymaps, and changing key bindings.


File: elisp,  Node: Overlay Type,  Next: Font Type,  Prev: Keymap Type,  Up: Editing Types

2.4.11 Overlay Type
-------------------

An "overlay" specifies properties that apply to a part of a buffer.
Each overlay applies to a specified range of the buffer, and contains a
property list (a list whose elements are alternating property names and
values).  Overlay properties are used to present parts of the buffer
temporarily in a different display style.  Overlays have no read
syntax, and print in hash notation, giving the buffer name and range of
positions.

   *Note Overlays::, for information on how you can create and use
overlays.


File: elisp,  Node: Font Type,  Prev: Overlay Type,  Up: Editing Types

2.4.12 Font Type
----------------

A "font" specifies how to display text on a graphical terminal.  There
are actually three separate font types--"font objects", "font specs",
and "font entities"--each of which has slightly different properties.
None of them have a read syntax; their print syntax looks like
`#<font-object>', `#<font-spec>', and `#<font-entity>' respectively.
*Note Low-Level Font::, for a description of these Lisp objects.


File: elisp,  Node: Circular Objects,  Next: Type Predicates,  Prev: Editing Types,  Up: Lisp Data Types

2.5 Read Syntax for Circular Objects
====================================

To represent shared or circular structures within a complex of Lisp
objects, you can use the reader constructs `#N=' and `#N#'.

   Use `#N=' before an object to label it for later reference;
subsequently, you can use `#N#' to refer the same object in another
place.  Here, N is some integer.  For example, here is how to make a
list in which the first element recurs as the third element:

     (#1=(a) b #1#)

This differs from ordinary syntax such as this

     ((a) b (a))

which would result in a list whose first and third elements look alike
but are not the same Lisp object.  This shows the difference:

     (prog1 nil
       (setq x '(#1=(a) b #1#)))
     (eq (nth 0 x) (nth 2 x))
          => t
     (setq x '((a) b (a)))
     (eq (nth 0 x) (nth 2 x))
          => nil

   You can also use the same syntax to make a circular structure, which
appears as an "element" within itself.  Here is an example:

     #1=(a #1#)

This makes a list whose second element is the list itself.  Here's how
you can see that it really works:

     (prog1 nil
       (setq x '#1=(a #1#)))
     (eq x (cadr x))
          => t

   The Lisp printer can produce this syntax to record circular and
shared structure in a Lisp object, if you bind the variable
`print-circle' to a non-`nil' value.  *Note Output Variables::.


File: elisp,  Node: Type Predicates,  Next: Equality Predicates,  Prev: Circular Objects,  Up: Lisp Data Types

2.6 Type Predicates
===================

The Emacs Lisp interpreter itself does not perform type checking on the
actual arguments passed to functions when they are called.  It could
not do so, since function arguments in Lisp do not have declared data
types, as they do in other programming languages.  It is therefore up to
the individual function to test whether each actual argument belongs to
a type that the function can use.

   All built-in functions do check the types of their actual arguments
when appropriate, and signal a `wrong-type-argument' error if an
argument is of the wrong type.  For example, here is what happens if you
pass an argument to `+' that it cannot handle:

     (+ 2 'a)
          error--> Wrong type argument: number-or-marker-p, a

   If you want your program to handle different types differently, you
must do explicit type checking.  The most common way to check the type
of an object is to call a "type predicate" function.  Emacs has a type
predicate for each type, as well as some predicates for combinations of
types.

   A type predicate function takes one argument; it returns `t' if the
argument belongs to the appropriate type, and `nil' otherwise.
Following a general Lisp convention for predicate functions, most type
predicates' names end with `p'.

   Here is an example which uses the predicates `listp' to check for a
list and `symbolp' to check for a symbol.

     (defun add-on (x)
       (cond ((symbolp x)
              ;; If X is a symbol, put it on LIST.
              (setq list (cons x list)))
             ((listp x)
              ;; If X is a list, add its elements to LIST.
              (setq list (append x list)))
             (t
              ;; We handle only symbols and lists.
              (error "Invalid argument %s in add-on" x))))

   Here is a table of predefined type predicates, in alphabetical order,
with references to further information.

`atom'
     *Note atom: List-related Predicates.

`arrayp'
     *Note arrayp: Array Functions.

`bool-vector-p'
     *Note bool-vector-p: Bool-Vectors.

`bufferp'
     *Note bufferp: Buffer Basics.

`byte-code-function-p'
     *Note byte-code-function-p: Byte-Code Type.

`case-table-p'
     *Note case-table-p: Case Tables.

`char-or-string-p'
     *Note char-or-string-p: Predicates for Strings.

`char-table-p'
     *Note char-table-p: Char-Tables.

`commandp'
     *Note commandp: Interactive Call.

`consp'
     *Note consp: List-related Predicates.

`custom-variable-p'
     *Note custom-variable-p: Variable Definitions.

`display-table-p'
     *Note display-table-p: Display Tables.

`floatp'
     *Note floatp: Predicates on Numbers.

`fontp'
     *Note Low-Level Font::.

`frame-configuration-p'
     *Note frame-configuration-p: Frame Configurations.

`frame-live-p'
     *Note frame-live-p: Deleting Frames.

`framep'
     *Note framep: Frames.

`functionp'
     *Note functionp: Functions.

`hash-table-p'
     *Note hash-table-p: Other Hash.

`integer-or-marker-p'
     *Note integer-or-marker-p: Predicates on Markers.

`integerp'
     *Note integerp: Predicates on Numbers.

`keymapp'
     *Note keymapp: Creating Keymaps.

`keywordp'
     *Note Constant Variables::.

`listp'
     *Note listp: List-related Predicates.

`markerp'
     *Note markerp: Predicates on Markers.

`wholenump'
     *Note wholenump: Predicates on Numbers.

`nlistp'
     *Note nlistp: List-related Predicates.

`numberp'
     *Note numberp: Predicates on Numbers.

`number-or-marker-p'
     *Note number-or-marker-p: Predicates on Markers.

`overlayp'
     *Note overlayp: Overlays.

`processp'
     *Note processp: Processes.

`sequencep'
     *Note sequencep: Sequence Functions.

`stringp'
     *Note stringp: Predicates for Strings.

`subrp'
     *Note subrp: Function Cells.

`symbolp'
     *Note symbolp: Symbols.

`syntax-table-p'
     *Note syntax-table-p: Syntax Tables.

`vectorp'
     *Note vectorp: Vectors.

`window-configuration-p'
     *Note window-configuration-p: Window Configurations.

`window-live-p'
     *Note window-live-p: Deleting Windows.

`windowp'
     *Note windowp: Basic Windows.

`booleanp'
     *Note booleanp: nil and t.

`string-or-null-p'
     *Note string-or-null-p: Predicates for Strings.

   The most general way to check the type of an object is to call the
function `type-of'.  Recall that each object belongs to one and only
one primitive type; `type-of' tells you which one (*note Lisp Data
Types::).  But `type-of' knows nothing about non-primitive types.  In
most cases, it is more convenient to use type predicates than `type-of'.

 -- Function: type-of object
     This function returns a symbol naming the primitive type of
     OBJECT.  The value is one of the symbols `bool-vector', `buffer',
     `char-table', `compiled-function', `cons', `float', `font-entity',
     `font-object', `font-spec', `frame', `hash-table', `integer',
     `marker', `overlay', `process', `string', `subr', `symbol',
     `vector', `window', or `window-configuration'.

          (type-of 1)
               => integer
          (type-of 'nil)
               => symbol
          (type-of '())    ; `()' is `nil'.
               => symbol
          (type-of '(x))
               => cons


File: elisp,  Node: Equality Predicates,  Prev: Type Predicates,  Up: Lisp Data Types

2.7 Equality Predicates
=======================

Here we describe functions that test for equality between two objects.
Other functions test equality of contents between objects of specific
types, e.g. strings.  For these predicates, see the appropriate chapter
describing the data type.

 -- Function: eq object1 object2
     This function returns `t' if OBJECT1 and OBJECT2 are the same
     object, and `nil' otherwise.

     If OBJECT1 and OBJECT2 are integers with the same value, they are
     considered to be the same object (i.e. `eq' returns `t').  If
     OBJECT1 and OBJECT2 are symbols with the same name, they are
     normally the same object--but see *note Creating Symbols:: for
     exceptions.  For other types (e.g. lists, vectors, strings), two
     arguments with the same contents or elements are not necessarily
     `eq' to each other: they are `eq' only if they are the same
     object, meaning that a change in the contents of one will be
     reflected by the same change in the contents of the other.

          (eq 'foo 'foo)
               => t

          (eq 456 456)
               => t

          (eq "asdf" "asdf")
               => nil

          (eq "" "")
               => t
          ;; This exception occurs because Emacs Lisp
          ;; makes just one multibyte empty string, to save space.

          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (setq foo '(1 (2 (3))))
               => (1 (2 (3)))
          (eq foo foo)
               => t
          (eq foo '(1 (2 (3))))
               => nil

          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (eq (point-marker) (point-marker))
               => nil

     The `make-symbol' function returns an uninterned symbol, distinct
     from the symbol that is used if you write the name in a Lisp
     expression.  Distinct symbols with the same name are not `eq'.
     *Note Creating Symbols::.

          (eq (make-symbol "foo") 'foo)
               => nil

 -- Function: equal object1 object2
     This function returns `t' if OBJECT1 and OBJECT2 have equal
     components, and `nil' otherwise.  Whereas `eq' tests if its
     arguments are the same object, `equal' looks inside nonidentical
     arguments to see if their elements or contents are the same.  So,
     if two objects are `eq', they are `equal', but the converse is not
     always true.

          (equal 'foo 'foo)
               => t

          (equal 456 456)
               => t

          (equal "asdf" "asdf")
               => t
          (eq "asdf" "asdf")
               => nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               => t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (equal [(1 2) 3] [(1 2) 3])
               => t
          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (equal (point-marker) (point-marker))
               => t

          (eq (point-marker) (point-marker))
               => nil

     Comparison of strings is case-sensitive, but does not take account
     of text properties--it compares only the characters in the strings.
     *Note Text Properties::.  Use `equal-including-properties' to also
     compare text properties.  For technical reasons, a unibyte string
     and a multibyte string are `equal' if and only if they contain the
     same sequence of character codes and all these codes are either in
     the range 0 through 127 (ASCII) or 160 through 255
     (`eight-bit-graphic').  (*note Text Representations::).

          (equal "asdf" "ASDF")
               => nil

     However, two distinct buffers are never considered `equal', even if
     their textual contents are the same.

   The test for equality is implemented recursively; for example, given
two cons cells X and Y, `(equal X Y)' returns `t' if and only if both
the expressions below return `t':

     (equal (car X) (car Y))
     (equal (cdr X) (cdr Y))

   Because of this recursive method, circular lists may therefore cause
infinite recursion (leading to an error).

 -- Function: equal-including-properties object1 object2
     This function behaves like `equal' in all cases but also requires
     that for two strings to be equal, they have the same text
     properties.

          (equal "asdf" (propertize "asdf" '(asdf t)))
               => t
          (equal-including-properties "asdf"
                                      (propertize "asdf" '(asdf t)))
               => nil


File: elisp,  Node: Numbers,  Next: Strings and Characters,  Prev: Lisp Data Types,  Up: Top

3 Numbers
*********

GNU Emacs supports two numeric data types: "integers" and "floating
point numbers".  Integers are whole numbers such as -3, 0, 7, 13, and
511.  Their values are exact.  Floating point numbers are numbers with
fractional parts, such as -4.5, 0.0, or 2.71828.  They can also be
expressed in exponential notation: 1.5e2 equals 150; in this example,
`e2' stands for ten to the second power, and that is multiplied by 1.5.
Floating point values are not exact; they have a fixed, limited amount
of precision.

* Menu:

* Integer Basics::            Representation and range of integers.
* Float Basics::              Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Numeric Conversions::       Converting float to integer and vice versa.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Rounding Operations::       Explicitly rounding floating point numbers.
* Bitwise Operations::        Logical and, or, not, shifting.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.


File: elisp,  Node: Integer Basics,  Next: Float Basics,  Up: Numbers

3.1 Integer Basics
==================

The range of values for an integer depends on the machine.  The minimum
range is -536870912 to 536870911 (30 bits; i.e., -2**29 to 2**29 - 1),
but some machines provide a wider range.  Many examples in this chapter
assume that an integer has 30 bits and that floating point numbers are
IEEE double precision.  

   The Lisp reader reads an integer as a sequence of digits with
optional initial sign and optional final period.  An integer that is
out of the Emacs range is treated as a floating-point number.

      1               ; The integer 1.
      1.              ; The integer 1.
     +1               ; Also the integer 1.
     -1               ; The integer -1.
      1073741825      ; The floating point number 1073741825.0.
      0               ; The integer 0.
     -0               ; The integer 0.

   The syntax for integers in bases other than 10 uses `#' followed by
a letter that specifies the radix: `b' for binary, `o' for octal, `x'
for hex, or `RADIXr' to specify radix RADIX.  Case is not significant
for the letter that specifies the radix.  Thus, `#bINTEGER' reads
INTEGER in binary, and `#RADIXrINTEGER' reads INTEGER in radix RADIX.
Allowed values of RADIX run from 2 to 36.  For example:

     #b101100 => 44
     #o54 => 44
     #x2c => 44
     #24r1k => 44

   To understand how various functions work on integers, especially the
bitwise operators (*note Bitwise Operations::), it is often helpful to
view the numbers in their binary form.

   In 30-bit binary, the decimal integer 5 looks like this:

     0000...000101 (30 bits total)

(The `...' stands for enough bits to fill out a 30-bit word; in this
case, `...' stands for twenty 0 bits.  Later examples also use the
`...' notation to make binary integers easier to read.)

   The integer -1 looks like this:

     1111...111111 (30 bits total)

-1 is represented as 30 ones.  (This is called "two's complement"
notation.)

   The negative integer, -5, is creating by subtracting 4 from -1.  In
binary, the decimal integer 4 is 100.  Consequently, -5 looks like this:

     1111...111011 (30 bits total)

   In this implementation, the largest 30-bit binary integer value is
536,870,911 in decimal.  In binary, it looks like this:

     0111...111111 (30 bits total)

   Since the arithmetic functions do not check whether integers go
outside their range, when you add 1 to 536,870,911, the value is the
negative integer -536,870,912:

     (+ 1 536870911)
          => -536870912
          => 1000...000000 (30 bits total)

   Many of the functions described in this chapter accept markers for
arguments in place of numbers.  (*Note Markers::.)  Since the actual
arguments to such functions may be either numbers or markers, we often
give these arguments the name NUMBER-OR-MARKER.  When the argument
value is a marker, its position value is used and its buffer is ignored.

 -- Variable: most-positive-fixnum
     The value of this variable is the largest integer that Emacs Lisp
     can handle.

 -- Variable: most-negative-fixnum
     The value of this variable is the smallest integer that Emacs Lisp
     can handle.  It is negative.

   *Note max-char: Character Codes, for the maximum value of a valid
character codepoint.


File: elisp,  Node: Float Basics,  Next: Predicates on Numbers,  Prev: Integer Basics,  Up: Numbers

3.2 Floating Point Basics
=========================

Floating point numbers are useful for representing numbers that are not
integral.  The precise range of floating point numbers is
machine-specific; it is the same as the range of the C data type
`double' on the machine you are using.  Emacs uses the IEEE floating
point standard where possible (the standard is supported by most modern
computers).

   The read syntax for floating point numbers requires either a decimal
point (with at least one digit following), an exponent, or both.  For
example, `1500.0', `15e2', `15.0e2', `1.5e3', and `.15e4' are five ways
of writing a floating point number whose value is 1500.  They are all
equivalent.  You can also use a minus sign to write negative floating
point numbers, as in `-1.0'.

   Emacs Lisp treats `-0.0' as equal to ordinary zero (with respect to
`equal' and `='), even though the two are distinguishable in the IEEE
floating point standard.

   The IEEE floating point standard supports positive infinity and
negative infinity as floating point values.  It also provides for a
class of values called NaN or "not-a-number"; numerical functions
return such values in cases where there is no correct answer.  For
example, `(/ 0.0 0.0)' returns a NaN.  (NaN values can also carry a
sign, but for practical purposes there's no significant difference
between different NaN values in Emacs Lisp.)  Here are the read
syntaxes for these special floating point values:

positive infinity
     `1.0e+INF'

negative infinity
     `-1.0e+INF'

Not-a-number
     `0.0e+NaN' or `-0.0e+NaN'.

 -- Function: isnan number
     This predicate tests whether its argument is NaN, and returns `t'
     if so, `nil' otherwise.  The argument must be a number.

   The following functions are specialized for handling floating point
numbers:

 -- Function: frexp x
     This function returns a cons cell `(SIG . EXP)', where SIG and EXP
     are respectively the significand and exponent of the floating
     point number X:

          X = SIG * 2^EXP

     SIG is a floating point number between 0.5 (inclusive) and 1.0
     (exclusive).  If X is zero, the return value is `(0 . 0)'.

 -- Function: ldexp sig &optional exp
     This function returns a floating point number corresponding to the
     significand SIG and exponent EXP.

 -- Function: copysign x1 x2
     This function copies the sign of X2 to the value of X1, and
     returns the result.  X1 and X2 must be floating point numbers.

 -- Function: logb number
     This function returns the binary exponent of NUMBER.  More
     precisely, the value is the logarithm of NUMBER base 2, rounded
     down to an integer.

          (logb 10)
               => 3
          (logb 10.0e20)
               => 69


File: elisp,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Float Basics,  Up: Numbers

3.3 Type Predicates for Numbers
===============================

The functions in this section test for numbers, or for a specific type
of number.  The functions `integerp' and `floatp' can take any type of
Lisp object as argument (they would not be of much use otherwise), but
the `zerop' predicate requires a number as its argument.  See also
`integer-or-marker-p' and `number-or-marker-p', in *note Predicates on
Markers::.

 -- Function: floatp object
     This predicate tests whether its argument is a floating point
     number and returns `t' if so, `nil' otherwise.

 -- Function: integerp object
     This predicate tests whether its argument is an integer, and
     returns `t' if so, `nil' otherwise.

 -- Function: numberp object
     This predicate tests whether its argument is a number (either
     integer or floating point), and returns `t' if so, `nil' otherwise.

 -- Function: natnump object
     This predicate (whose name comes from the phrase "natural number")
     tests to see whether its argument is a nonnegative integer, and
     returns `t' if so, `nil' otherwise.  0 is considered non-negative.

     This is a synonym for `natnump'.

 -- Function: zerop number
     This predicate tests whether its argument is zero, and returns `t'
     if so, `nil' otherwise.  The argument must be a number.

     `(zerop x)' is equivalent to `(= x 0)'.


File: elisp,  Node: Comparison of Numbers,  Next: Numeric Conversions,  Prev: Predicates on Numbers,  Up: Numbers

3.4 Comparison of Numbers
=========================

To test numbers for numerical equality, you should normally use `=',
not `eq'.  There can be many distinct floating point number objects
with the same numeric value.  If you use `eq' to compare them, then you
test whether two values are the same _object_.  By contrast, `='
compares only the numeric values of the objects.

   At present, each integer value has a unique Lisp object in Emacs
Lisp.  Therefore, `eq' is equivalent to `=' where integers are
concerned.  It is sometimes convenient to use `eq' for comparing an
unknown value with an integer, because `eq' does not report an error if
the unknown value is not a number--it accepts arguments of any type.
By contrast, `=' signals an error if the arguments are not numbers or
markers.  However, it is a good idea to use `=' if you can, even for
comparing integers, just in case we change the representation of
integers in a future Emacs version.

   Sometimes it is useful to compare numbers with `equal'; it treats
two numbers as equal if they have the same data type (both integers, or
both floating point) and the same value.  By contrast, `=' can treat an
integer and a floating point number as equal.  *Note Equality
Predicates::.

   There is another wrinkle: because floating point arithmetic is not
exact, it is often a bad idea to check for equality of two floating
point values.  Usually it is better to test for approximate equality.
Here's a function to do this:

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (or (and (= x 0) (= y 0))
           (< (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))

     Common Lisp note: Comparing numbers in Common Lisp always requires
     `=' because Common Lisp implements multi-word integers, and two
     distinct integer objects can have the same numeric value.  Emacs
     Lisp can have just one integer object for any given value because
     it has a limited range of integer values.

 -- Function: = number-or-marker1 number-or-marker2
     This function tests whether its arguments are numerically equal,
     and returns `t' if so, `nil' otherwise.

 -- Function: eql value1 value2
     This function acts like `eq' except when both arguments are
     numbers.  It compares numbers by type and numeric value, so that
     `(eql 1.0 1)' returns `nil', but `(eql 1.0 1.0)' and `(eql 1 1)'
     both return `t'.

 -- Function: /= number-or-marker1 number-or-marker2
     This function tests whether its arguments are numerically equal,
     and returns `t' if they are not, and `nil' if they are.

 -- Function: < number-or-marker1 number-or-marker2
     This function tests whether its first argument is strictly less
     than its second argument.  It returns `t' if so, `nil' otherwise.

 -- Function: <= number-or-marker1 number-or-marker2
     This function tests whether its first argument is less than or
     equal to its second argument.  It returns `t' if so, `nil'
     otherwise.

 -- Function: > number-or-marker1 number-or-marker2
     This function tests whether its first argument is strictly greater
     than its second argument.  It returns `t' if so, `nil' otherwise.

 -- Function: >= number-or-marker1 number-or-marker2
     This function tests whether its first argument is greater than or
     equal to its second argument.  It returns `t' if so, `nil'
     otherwise.

 -- Function: max number-or-marker &rest numbers-or-markers
     This function returns the largest of its arguments.  If any of the
     arguments is floating-point, the value is returned as floating
     point, even if it was given as an integer.

          (max 20)
               => 20
          (max 1 2.5)
               => 2.5
          (max 1 3 2.5)
               => 3.0

 -- Function: min number-or-marker &rest numbers-or-markers
     This function returns the smallest of its arguments.  If any of
     the arguments is floating-point, the value is returned as floating
     point, even if it was given as an integer.

          (min -4 1)
               => -4

 -- Function: abs number
     This function returns the absolute value of NUMBER.


File: elisp,  Node: Numeric Conversions,  Next: Arithmetic Operations,  Prev: Comparison of Numbers,  Up: Numbers

3.5 Numeric Conversions
=======================

To convert an integer to floating point, use the function `float'.

 -- Function: float number
     This returns NUMBER converted to floating point.  If NUMBER is
     already a floating point number, `float' returns it unchanged.

   There are four functions to convert floating point numbers to
integers; they differ in how they round.  All accept an argument NUMBER
and an optional argument DIVISOR.  Both arguments may be integers or
floating point numbers.  DIVISOR may also be `nil'.  If DIVISOR is
`nil' or omitted, these functions convert NUMBER to an integer, or
return it unchanged if it already is an integer.  If DIVISOR is
non-`nil', they divide NUMBER by DIVISOR and convert the result to an
integer.  An `arith-error' results if DIVISOR is 0.

 -- Function: truncate number &optional divisor
     This returns NUMBER, converted to an integer by rounding towards
     zero.

          (truncate 1.2)
               => 1
          (truncate 1.7)
               => 1
          (truncate -1.2)
               => -1
          (truncate -1.7)
               => -1

 -- Function: floor number &optional divisor
     This returns NUMBER, converted to an integer by rounding downward
     (towards negative infinity).

     If DIVISOR is specified, this uses the kind of division operation
     that corresponds to `mod', rounding downward.

          (floor 1.2)
               => 1
          (floor 1.7)
               => 1
          (floor -1.2)
               => -2
          (floor -1.7)
               => -2
          (floor 5.99 3)
               => 1

 -- Function: ceiling number &optional divisor
     This returns NUMBER, converted to an integer by rounding upward
     (towards positive infinity).

          (ceiling 1.2)
               => 2
          (ceiling 1.7)
               => 2
          (ceiling -1.2)
               => -1
          (ceiling -1.7)
               => -1

 -- Function: round number &optional divisor
     This returns NUMBER, converted to an integer by rounding towards
     the nearest integer.  Rounding a value equidistant between two
     integers may choose the integer closer to zero, or it may prefer
     an even integer, depending on your machine.

          (round 1.2)
               => 1
          (round 1.7)
               => 2
          (round -1.2)
               => -1
          (round -1.7)
               => -2


File: elisp,  Node: Arithmetic Operations,  Next: Rounding Operations,  Prev: Numeric Conversions,  Up: Numbers

3.6 Arithmetic Operations
=========================

Emacs Lisp provides the traditional four arithmetic operations:
addition, subtraction, multiplication, and division.  Remainder and
modulus functions supplement the division functions.  The functions to
add or subtract 1 are provided because they are traditional in Lisp and
commonly used.

   All of these functions except `%' return a floating point value if
any argument is floating.

   It is important to note that in Emacs Lisp, arithmetic functions do
not check for overflow.  Thus `(1+ 536870911)' may evaluate to
-536870912, depending on your hardware.

 -- Function: 1+ number-or-marker
     This function returns NUMBER-OR-MARKER plus 1.  For example,

          (setq foo 4)
               => 4
          (1+ foo)
               => 5

     This function is not analogous to the C operator `++'--it does not
     increment a variable.  It just computes a sum.  Thus, if we
     continue,

          foo
               => 4

     If you want to increment the variable, you must use `setq', like
     this:

          (setq foo (1+ foo))
               => 5

 -- Function: 1- number-or-marker
     This function returns NUMBER-OR-MARKER minus 1.

 -- Function: + &rest numbers-or-markers
     This function adds its arguments together.  When given no
     arguments, `+' returns 0.

          (+)
               => 0
          (+ 1)
               => 1
          (+ 1 2 3 4)
               => 10

 -- Function: - &optional number-or-marker &rest more-numbers-or-markers
     The `-' function serves two purposes: negation and subtraction.
     When `-' has a single argument, the value is the negative of the
     argument.  When there are multiple arguments, `-' subtracts each of
     the MORE-NUMBERS-OR-MARKERS from NUMBER-OR-MARKER, cumulatively.
     If there are no arguments, the result is 0.

          (- 10 1 2 3 4)
               => 0
          (- 10)
               => -10
          (-)
               => 0

 -- Function: * &rest numbers-or-markers
     This function multiplies its arguments together, and returns the
     product.  When given no arguments, `*' returns 1.

          (*)
               => 1
          (* 1)
               => 1
          (* 1 2 3 4)
               => 24

 -- Function: / dividend divisor &rest divisors
     This function divides DIVIDEND by DIVISOR and returns the
     quotient.  If there are additional arguments DIVISORS, then it
     divides DIVIDEND by each divisor in turn.  Each argument may be a
     number or a marker.

     If all the arguments are integers, then the result is an integer
     too.  This means the result has to be rounded.  On most machines,
     the result is rounded towards zero after each division, but some
     machines may round differently with negative arguments.  This is
     because the Lisp function `/' is implemented using the C division
     operator, which also permits machine-dependent rounding.  As a
     practical matter, all known machines round in the standard fashion.

     If you divide an integer by 0, an `arith-error' error is signaled.
     (*Note Errors::.)  Floating point division by zero returns either
     infinity or a NaN if your machine supports IEEE floating point;
     otherwise, it signals an `arith-error' error.

          (/ 6 2)
               => 3
          (/ 5 2)
               => 2
          (/ 5.0 2)
               => 2.5
          (/ 5 2.0)
               => 2.5
          (/ 5.0 2.0)
               => 2.5
          (/ 25 3 2)
               => 4
          (/ -17 6)
               => -2   (could in theory be -3 on some machines)

 -- Function: % dividend divisor
     This function returns the integer remainder after division of
     DIVIDEND by DIVISOR.  The arguments must be integers or markers.

     For negative arguments, the remainder is in principle
     machine-dependent since the quotient is; but in practice, all
     known machines behave alike.

     An `arith-error' results if DIVISOR is 0.

          (% 9 4)
               => 1
          (% -9 4)
               => -1
          (% 9 -4)
               => 1
          (% -9 -4)
               => -1

     For any two integers DIVIDEND and DIVISOR,

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND.

 -- Function: mod dividend divisor
     This function returns the value of DIVIDEND modulo DIVISOR; in
     other words, the remainder after division of DIVIDEND by DIVISOR,
     but with the same sign as DIVISOR.  The arguments must be numbers
     or markers.

     Unlike `%', `mod' returns a well-defined result for negative
     arguments.  It also permits floating point arguments; it rounds the
     quotient downward (towards minus infinity) to an integer, and uses
     that quotient to compute the remainder.

     An `arith-error' results if DIVISOR is 0.

          (mod 9 4)
               => 1
          (mod -9 4)
               => 3
          (mod 9 -4)
               => -3
          (mod -9 -4)
               => -1
          (mod 5.5 2.5)
               => .5

     For any two numbers DIVIDEND and DIVISOR,

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     always equals DIVIDEND, subject to rounding error if either
     argument is floating point.  For `floor', see *note Numeric
     Conversions::.


File: elisp,  Node: Rounding Operations,  Next: Bitwise Operations,  Prev: Arithmetic Operations,  Up: Numbers

3.7 Rounding Operations
=======================

The functions `ffloor', `fceiling', `fround', and `ftruncate' take a
floating point argument and return a floating point result whose value
is a nearby integer.  `ffloor' returns the nearest integer below;
`fceiling', the nearest integer above; `ftruncate', the nearest integer
in the direction towards zero; `fround', the nearest integer.

 -- Function: ffloor float
     This function rounds FLOAT to the next lower integral value, and
     returns that value as a floating point number.

 -- Function: fceiling float
     This function rounds FLOAT to the next higher integral value, and
     returns that value as a floating point number.

 -- Function: ftruncate float
     This function rounds FLOAT towards zero to an integral value, and
     returns that value as a floating point number.

 -- Function: fround float
     This function rounds FLOAT to the nearest integral value, and
     returns that value as a floating point number.


File: elisp,  Node: Bitwise Operations,  Next: Math Functions,  Prev: Rounding Operations,  Up: Numbers

3.8 Bitwise Operations on Integers
==================================

In a computer, an integer is represented as a binary number, a sequence
of "bits" (digits which are either zero or one).  A bitwise operation
acts on the individual bits of such a sequence.  For example,
"shifting" moves the whole sequence left or right one or more places,
reproducing the same pattern "moved over".

   The bitwise operations in Emacs Lisp apply only to integers.

 -- Function: lsh integer1 count
     `lsh', which is an abbreviation for "logical shift", shifts the
     bits in INTEGER1 to the left COUNT places, or to the right if
     COUNT is negative, bringing zeros into the vacated bits.  If COUNT
     is negative, `lsh' shifts zeros into the leftmost
     (most-significant) bit, producing a positive result even if
     INTEGER1 is negative.  Contrast this with `ash', below.

     Here are two examples of `lsh', shifting a pattern of bits one
     place to the left.  We show only the low-order eight bits of the
     binary pattern; the rest are all zero.

          (lsh 5 1)
               => 10
          ;; Decimal 5 becomes decimal 10.
          00000101 => 00001010

          (lsh 7 1)
               => 14
          ;; Decimal 7 becomes decimal 14.
          00000111 => 00001110

     As the examples illustrate, shifting the pattern of bits one place
     to the left produces a number that is twice the value of the
     previous number.

     Shifting a pattern of bits two places to the left produces results
     like this (with 8-bit binary numbers):

          (lsh 3 2)
               => 12
          ;; Decimal 3 becomes decimal 12.
          00000011 => 00001100

     On the other hand, shifting one place to the right looks like this:

          (lsh 6 -1)
               => 3
          ;; Decimal 6 becomes decimal 3.
          00000110 => 00000011

          (lsh 5 -1)
               => 2
          ;; Decimal 5 becomes decimal 2.
          00000101 => 00000010

     As the example illustrates, shifting one place to the right
     divides the value of a positive integer by two, rounding downward.

     The function `lsh', like all Emacs Lisp arithmetic functions, does
     not check for overflow, so shifting left can discard significant
     bits and change the sign of the number.  For example, left shifting
     536,870,911 produces -2 in the 30-bit implementation:

          (lsh 536870911 1)          ; left shift
               => -2

     In binary, the argument looks like this:

          ;; Decimal 536,870,911
          0111...111111 (30 bits total)

     which becomes the following when left shifted:

          ;; Decimal -2
          1111...111110 (30 bits total)

 -- Function: ash integer1 count
     `ash' ("arithmetic shift") shifts the bits in INTEGER1 to the left
     COUNT places, or to the right if COUNT is negative.

     `ash' gives the same results as `lsh' except when INTEGER1 and
     COUNT are both negative.  In that case, `ash' puts ones in the
     empty bit positions on the left, while `lsh' puts zeros in those
     bit positions.

     Thus, with `ash', shifting the pattern of bits one place to the
     right looks like this:

          (ash -6 -1) => -3
          ;; Decimal -6 becomes decimal -3.
          1111...111010 (30 bits total)
               =>
          1111...111101 (30 bits total)

     In contrast, shifting the pattern of bits one place to the right
     with `lsh' looks like this:

          (lsh -6 -1) => 536870909
          ;; Decimal -6 becomes decimal 536,870,909.
          1111...111010 (30 bits total)
               =>
          0111...111101 (30 bits total)

     Here are other examples:

                             ;         30-bit binary values

          (lsh 5 2)          ;   5  =  0000...000101
               => 20         ;      =  0000...010100
          (ash 5 2)
               => 20
          (lsh -5 2)         ;  -5  =  1111...111011
               => -20        ;      =  1111...101100
          (ash -5 2)
               => -20
          (lsh 5 -2)         ;   5  =  0000...000101
               => 1          ;      =  0000...000001
          (ash 5 -2)
               => 1
          (lsh -5 -2)        ;  -5  =  1111...111011
               => 268435454
                             ;      =  0011...111110
          (ash -5 -2)        ;  -5  =  1111...111011
               => -2         ;      =  1111...111110

 -- Function: logand &rest ints-or-markers
     This function returns the "logical and" of the arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in
     all the arguments.  ("Set" means that the value of the bit is 1
     rather than 0.)

     For example, using 4-bit binary numbers, the "logical and" of 13
     and 12 is 12: 1101 combined with 1100 produces 1100.  In both the
     binary numbers, the leftmost two bits are set (i.e., they are
     1's), so the leftmost two bits of the returned value are set.
     However, for the rightmost two bits, each is zero in at least one
     of the arguments, so the rightmost two bits of the returned value
     are 0's.

     Therefore,

          (logand 13 12)
               => 12

     If `logand' is not passed any argument, it returns a value of -1.
     This number is an identity element for `logand' because its binary
     representation consists entirely of ones.  If `logand' is passed
     just one argument, it returns that argument.

                             ;        30-bit binary values

          (logand 14 13)     ; 14  =  0000...001110
                             ; 13  =  0000...001101
               => 12         ; 12  =  0000...001100

          (logand 14 13 4)   ; 14  =  0000...001110
                             ; 13  =  0000...001101
                             ;  4  =  0000...000100
               => 4          ;  4  =  0000...000100

          (logand)
               => -1         ; -1  =  1111...111111

 -- Function: logior &rest ints-or-markers
     This function returns the "inclusive or" of its arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in at
     least one of the arguments.  If there are no arguments, the result
     is zero, which is an identity element for this operation.  If
     `logior' is passed just one argument, it returns that argument.

                             ;        30-bit binary values

          (logior 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               => 13         ; 13  =  0000...001101

          (logior 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               => 15         ; 15  =  0000...001111

 -- Function: logxor &rest ints-or-markers
     This function returns the "exclusive or" of its arguments: the Nth
     bit is set in the result if, and only if, the Nth bit is set in an
     odd number of the arguments.  If there are no arguments, the
     result is 0, which is an identity element for this operation.  If
     `logxor' is passed just one argument, it returns that argument.

                             ;        30-bit binary values

          (logxor 12 5)      ; 12  =  0000...001100
                             ;  5  =  0000...000101
               => 9          ;  9  =  0000...001001

          (logxor 12 5 7)    ; 12  =  0000...001100
                             ;  5  =  0000...000101
                             ;  7  =  0000...000111
               => 14         ; 14  =  0000...001110

 -- Function: lognot integer
     This function returns the logical complement of its argument: the
     Nth bit is one in the result if, and only if, the Nth bit is zero
     in INTEGER, and vice-versa.

          (lognot 5)
               => -6
          ;;  5  =  0000...000101 (30 bits total)
          ;; becomes
          ;; -6  =  1111...111010 (30 bits total)


File: elisp,  Node: Math Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

3.9 Standard Mathematical Functions
===================================

These mathematical functions allow integers as well as floating point
numbers as arguments.

 -- Function: sin arg
 -- Function: cos arg
 -- Function: tan arg
     These are the ordinary trigonometric functions, with argument
     measured in radians.

 -- Function: asin arg
     The value of `(asin ARG)' is a number between -pi/2 and pi/2
     (inclusive) whose sine is ARG; if, however, ARG is out of range
     (outside [-1, 1]), it signals a `domain-error' error.

 -- Function: acos arg
     The value of `(acos ARG)' is a number between 0 and pi (inclusive)
     whose cosine is ARG; if, however, ARG is out of range (outside
     [-1, 1]), it signals a `domain-error' error.

 -- Function: atan y &optional x
     The value of `(atan Y)' is a number between -pi/2 and pi/2
     (exclusive) whose tangent is Y.  If the optional second argument X
     is given, the value of `(atan y x)' is the angle in radians
     between the vector `[X, Y]' and the `X' axis.

 -- Function: exp arg
     This is the exponential function; it returns e to the power ARG.

 -- Function: log arg &optional base
     This function returns the logarithm of ARG, with base BASE.  If
     you don't specify BASE, the natural base e is used.  If ARG is
     negative, it signals a `domain-error' error.

 -- Function: log10 arg
     This function returns the logarithm of ARG, with base 10.  If ARG
     is negative, it signals a `domain-error' error.  `(log10 X)' ==
     `(log X 10)', at least approximately.

 -- Function: expt x y
     This function returns X raised to power Y.  If both arguments are
     integers and Y is positive, the result is an integer; in this
     case, overflow causes truncation, so watch out.

 -- Function: sqrt arg
     This returns the square root of ARG.  If ARG is negative, it
     signals a `domain-error' error.

   In addition, Emacs defines the following common mathematical
constants:

 -- Variable: float-e
     The mathematical constant e (2.71828...).

 -- Variable: float-pi
     The mathematical constant pi (3.14159...).


File: elisp,  Node: Random Numbers,  Prev: Math Functions,  Up: Numbers

3.10 Random Numbers
===================

A deterministic computer program cannot generate true random numbers.
For most purposes, "pseudo-random numbers" suffice.  A series of
pseudo-random numbers is generated in a deterministic fashion.  The
numbers are not truly random, but they have certain properties that
mimic a random series.  For example, all possible values occur equally
often in a pseudo-random series.

   In Emacs, pseudo-random numbers are generated from a "seed" number.
Starting from any given seed, the `random' function always generates
the same sequence of numbers.  Emacs always starts with the same seed
value, so the sequence of values of `random' is actually the same in
each Emacs run!  For example, in one operating system, the first call
to `(random)' after you start Emacs always returns -1457731, and the
second one always returns -7692030.  This repeatability is helpful for
debugging.

   If you want random numbers that don't always come out the same,
execute `(random t)'.  This chooses a new seed based on the current
time of day and on Emacs's process ID number.

 -- Function: random &optional limit
     This function returns a pseudo-random integer.  Repeated calls
     return a series of pseudo-random integers.

     If LIMIT is a positive integer, the value is chosen to be
     nonnegative and less than LIMIT.

     If LIMIT is `t', it means to choose a new seed based on the
     current time of day and on Emacs's process ID number.

     On some machines, any integer representable in Lisp may be the
     result of `random'.  On other machines, the result can never be
     larger than a certain maximum or less than a certain (negative)
     minimum.


File: elisp,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

4 Strings and Characters
************************

A string in Emacs Lisp is an array that contains an ordered sequence of
characters.  Strings are used as names of symbols, buffers, and files;
to send messages to users; to hold text being copied between buffers;
and for many other purposes.  Because strings are so important, Emacs
Lisp has many functions expressly for manipulating them.  Emacs Lisp
programs use strings more often than individual characters.

   *Note Strings of Events::, for special considerations for strings of
keyboard character events.

* Menu:

* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Modifying Strings::         Altering the contents of an existing string.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting to and from characters and strings.
* Formatting Strings::        `format': Emacs's analogue of `printf'.
* Case Conversion::           Case conversion functions.
* Case Tables::               Customizing case conversion.


File: elisp,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

4.1 String and Character Basics
===============================

Characters are represented in Emacs Lisp as integers; whether an
integer is a character or not is determined only by how it is used.
Thus, strings really contain integers.  *Note Character Codes::, for
details about character representation in Emacs.

   The length of a string (like any array) is fixed, and cannot be
altered once the string exists.  Strings in Lisp are _not_ terminated
by a distinguished character code.  (By contrast, strings in C are
terminated by a character with ASCII code 0.)

   Since strings are arrays, and therefore sequences as well, you can
operate on them with the general array and sequence functions.  (*Note
Sequences Arrays Vectors::.)  For example, you can access or change
individual characters in a string using the functions `aref' and `aset'
(*note Array Functions::).  However, note that `length' should _not_ be
used for computing the width of a string on display; use `string-width'
(*note Width::) instead.

   There are two text representations for non-ASCII characters in Emacs
strings (and in buffers): unibyte and multibyte (*note Text
Representations::).  For most Lisp programming, you don't need to be
concerned with these two representations.

   Sometimes key sequences are represented as unibyte strings.  When a
unibyte string is a key sequence, string elements in the range 128 to
255 represent meta characters (which are large integers) rather than
character codes in the range 128 to 255.  Strings cannot hold
characters that have the hyper, super or alt modifiers; they can hold
ASCII control characters, but no other control characters.  They do not
distinguish case in ASCII control characters.  If you want to store
such characters in a sequence, such as a key sequence, you must use a
vector instead of a string.  *Note Character Type::, for more
information about keyboard input characters.

   Strings are useful for holding regular expressions.  You can also
match regular expressions against strings with `string-match' (*note
Regexp Search::).  The functions `match-string' (*note Simple Match
Data::) and `replace-match' (*note Replacing Match::) are useful for
decomposing and modifying strings after matching regular expressions
against them.

   Like a buffer, a string can contain text properties for the
characters in it, as well as the characters themselves.  *Note Text
Properties::.  All the Lisp primitives that copy text from strings to
buffers or other strings also copy the properties of the characters
being copied.

   *Note Text::, for information about functions that display strings or
copy them into buffers.  *Note Character Type::, and *note String
Type::, for information about the syntax of characters and strings.
*Note Non-ASCII Characters::, for functions to convert between text
representations and to encode and decode character codes.


File: elisp,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

4.2 The Predicates for Strings
==============================

For more information about general sequence and array predicates, see
*note Sequences Arrays Vectors::, and *note Arrays::.

 -- Function: stringp object
     This function returns `t' if OBJECT is a string, `nil' otherwise.

 -- Function: string-or-null-p object
     This function returns `t' if OBJECT is a string or `nil'.  It
     returns `nil' otherwise.

 -- Function: char-or-string-p object
     This function returns `t' if OBJECT is a string or a character
     (i.e., an integer), `nil' otherwise.


File: elisp,  Node: Creating Strings,  Next: Modifying Strings,  Prev: Predicates for Strings,  Up: Strings and Characters

4.3 Creating Strings
====================

The following functions create strings, either from scratch, or by
putting strings together, or by taking them apart.

 -- Function: make-string count character
     This function returns a string made up of COUNT repetitions of
     CHARACTER.  If COUNT is negative, an error is signaled.

          (make-string 5 ?x)
               => "xxxxx"
          (make-string 0 ?x)
               => ""

     Other functions to compare with this one include `make-vector'
     (*note Vectors::) and `make-list' (*note Building Lists::).

 -- Function: string &rest characters
     This returns a string containing the characters CHARACTERS.

          (string ?a ?b ?c)
               => "abc"

 -- Function: substring string start &optional end
     This function returns a new string which consists of those
     characters from STRING in the range from (and including) the
     character at the index START up to (but excluding) the character
     at the index END.  The first character is at index zero.

          (substring "abcdefg" 0 3)
               => "abc"

     In the above example, the index for `a' is 0, the index for `b' is
     1, and the index for `c' is 2.  The index 3--which is the fourth
     character in the string--marks the character position up to which
     the substring is copied.  Thus, `abc' is copied from the string
     `"abcdefg"'.

     A negative number counts from the end of the string, so that -1
     signifies the index of the last character of the string.  For
     example:

          (substring "abcdefg" -3 -1)
               => "ef"

     In this example, the index for `e' is -3, the index for `f' is -2,
     and the index for `g' is -1.  Therefore, `e' and `f' are included,
     and `g' is excluded.

     When `nil' is used for END, it stands for the length of the
     string.  Thus,

          (substring "abcdefg" -3 nil)
               => "efg"

     Omitting the argument END is equivalent to specifying `nil'.  It
     follows that `(substring STRING 0)' returns a copy of all of
     STRING.

          (substring "abcdefg" 0)
               => "abcdefg"

     But we recommend `copy-sequence' for this purpose (*note Sequence
     Functions::).

     If the characters copied from STRING have text properties, the
     properties are copied into the new string also.  *Note Text
     Properties::.

     `substring' also accepts a vector for the first argument.  For
     example:

          (substring [a b (c) "d"] 1 3)
               => [b (c)]

     A `wrong-type-argument' error is signaled if START is not an
     integer or if END is neither an integer nor `nil'.  An
     `args-out-of-range' error is signaled if START indicates a
     character following END, or if either integer is out of range for
     STRING.

     Contrast this function with `buffer-substring' (*note Buffer
     Contents::), which returns a string containing a portion of the
     text in the current buffer.  The beginning of a string is at index
     0, but the beginning of a buffer is at index 1.

 -- Function: substring-no-properties string &optional start end
     This works like `substring' but discards all text properties from
     the value.  Also, START may be omitted or `nil', which is
     equivalent to 0.  Thus, `(substring-no-properties STRING)' returns
     a copy of STRING, with all text properties removed.

 -- Function: concat &rest sequences
     This function returns a new string consisting of the characters in
     the arguments passed to it (along with their text properties, if
     any).  The arguments may be strings, lists of numbers, or vectors
     of numbers; they are not themselves changed.  If `concat' receives
     no arguments, it returns an empty string.

          (concat "abc" "-def")
               => "abc-def"
          (concat "abc" (list 120 121) [122])
               => "abcxyz"
          ;; `nil' is an empty sequence.
          (concat "abc" nil "-def")
               => "abc-def"
          (concat "The " "quick brown " "fox.")
               => "The quick brown fox."
          (concat)
               => ""

     This function always constructs a new string that is not `eq' to
     any existing string, except when the result is the empty string (to
     save space, Emacs makes only one empty multibyte string).

     For information about other concatenation functions, see the
     description of `mapconcat' in *note Mapping Functions::, `vconcat'
     in *note Vector Functions::, and `append' in *note Building
     Lists::.  For concatenating individual command-line arguments into
     a string to be used as a shell command, see *note
     combine-and-quote-strings: Shell Arguments.

 -- Function: split-string string &optional separators omit-nulls
     This function splits STRING into substrings based on the regular
     expression SEPARATORS (*note Regular Expressions::).  Each match
     for SEPARATORS defines a splitting point; the substrings between
     splitting points are made into a list, which is returned.

     If OMIT-NULLS is `nil' (or omitted), the result contains null
     strings whenever there are two consecutive matches for SEPARATORS,
     or a match is adjacent to the beginning or end of STRING.  If
     OMIT-NULLS is `t', these null strings are omitted from the result.

     If SEPARATORS is `nil' (or omitted), the default is the value of
     `split-string-default-separators'.

     As a special case, when SEPARATORS is `nil' (or omitted), null
     strings are always omitted from the result.  Thus:

          (split-string "  two words ")
               => ("two" "words")

     The result is not `("" "two" "words" "")', which would rarely be
     useful.  If you need such a result, use an explicit value for
     SEPARATORS:

          (split-string "  two words "
                        split-string-default-separators)
               => ("" "two" "words" "")

     More examples:

          (split-string "Soup is good food" "o")
               => ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o" t)
               => ("S" "up is g" "d f" "d")
          (split-string "Soup is good food" "o+")
               => ("S" "up is g" "d f" "d")

     Empty matches do count, except that `split-string' will not look
     for a final empty match when it already reached the end of the
     string using a non-empty match or when STRING is empty:

          (split-string "aooob" "o*")
               => ("" "a" "" "b" "")
          (split-string "ooaboo" "o*")
               => ("" "" "a" "b" "")
          (split-string "" "")
               => ("")

     However, when SEPARATORS can match the empty string, OMIT-NULLS is
     usually `t', so that the subtleties in the three previous examples
     are rarely relevant:

          (split-string "Soup is good food" "o*" t)
               => ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "" t)
               => ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
          (split-string "" "" t)
               => nil

     Somewhat odd, but predictable, behavior can occur for certain
     "non-greedy" values of SEPARATORS that can prefer empty matches
     over non-empty matches.  Again, such values rarely occur in
     practice:

          (split-string "ooo" "o*" t)
               => nil
          (split-string "ooo" "\\|o+" t)
               => ("o" "o" "o")

     If you need to split a string into a list of individual
     command-line arguments suitable for `call-process' or
     `start-process', see *note split-string-and-unquote: Shell
     Arguments.

 -- Variable: split-string-default-separators
     The default value of SEPARATORS for `split-string'.  Its usual
     value is `"[ \f\t\n\r\v]+"'.


File: elisp,  Node: Modifying Strings,  Next: Text Comparison,  Prev: Creating Strings,  Up: Strings and Characters

4.4 Modifying Strings
=====================

The most basic way to alter the contents of an existing string is with
`aset' (*note Array Functions::).  `(aset STRING IDX CHAR)' stores CHAR
into STRING at index IDX.  Each character occupies one or more bytes,
and if CHAR needs a different number of bytes from the character
already present at that index, `aset' signals an error.

   A more powerful function is `store-substring':

 -- Function: store-substring string idx obj
     This function alters part of the contents of the string STRING, by
     storing OBJ starting at index IDX.  The argument OBJ may be either
     a character or a (smaller) string.

     Since it is impossible to change the length of an existing string,
     it is an error if OBJ doesn't fit within STRING's actual length,
     or if any new character requires a different number of bytes from
     the character currently present at that point in STRING.

   To clear out a string that contained a password, use `clear-string':

 -- Function: clear-string string
     This makes STRING a unibyte string and clears its contents to
     zeros.  It may also change STRING's length.


File: elisp,  Node: Text Comparison,  Next: String Conversion,  Prev: Modifying Strings,  Up: Strings and Characters

4.5 Comparison of Characters and Strings
========================================

 -- Function: char-equal character1 character2
     This function returns `t' if the arguments represent the same
     character, `nil' otherwise.  This function ignores differences in
     case if `case-fold-search' is non-`nil'.

          (char-equal ?x ?x)
               => t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               => nil

 -- Function: string= string1 string2
     This function returns `t' if the characters of the two strings
     match exactly.  Symbols are also allowed as arguments, in which
     case the symbol names are used.  Case is always significant,
     regardless of `case-fold-search'.

     This function is equivalent to `equal' for comparing two strings
     (*note Equality Predicates::).  In particular, the text properties
     of the two strings are ignored.  But if either argument is not a
     string or symbol, an error is signaled.

          (string= "abc" "abc")
               => t
          (string= "abc" "ABC")
               => nil
          (string= "ab" "ABC")
               => nil

     For technical reasons, a unibyte and a multibyte string are
     `equal' if and only if they contain the same sequence of character
     codes and all these codes are either in the range 0 through 127
     (ASCII) or 160 through 255 (`eight-bit-graphic').  However, when a
     unibyte string is converted to a multibyte string, all characters
     with codes in the range 160 through 255 are converted to
     characters with higher codes, whereas ASCII characters remain
     unchanged.  Thus, a unibyte string and its conversion to multibyte
     are only `equal' if the string is all ASCII.  Character codes 160
     through 255 are not entirely proper in multibyte text, even though
     they can occur.  As a consequence, the situation where a unibyte
     and a multibyte string are `equal' without both being all ASCII is
     a technical oddity that very few Emacs Lisp programmers ever get
     confronted with.  *Note Text Representations::.

 -- Function: string-equal string1 string2
     `string-equal' is another name for `string='.

 -- Function: string< string1 string2
     This function compares two strings a character at a time.  It
     scans both the strings at the same time to find the first pair of
     corresponding characters that do not match.  If the lesser
     character of these two is the character from STRING1, then STRING1
     is less, and this function returns `t'.  If the lesser character
     is the one from STRING2, then STRING1 is greater, and this
     function returns `nil'.  If the two strings match entirely, the
     value is `nil'.

     Pairs of characters are compared according to their character
     codes.  Keep in mind that lower case letters have higher numeric
     values in the ASCII character set than their upper case
     counterparts; digits and many punctuation characters have a lower
     numeric value than upper case letters.  An ASCII character is less
     than any non-ASCII character; a unibyte non-ASCII character is
     always less than any multibyte non-ASCII character (*note Text
     Representations::).

          (string< "abc" "abd")
               => t
          (string< "abd" "abc")
               => nil
          (string< "123" "abc")
               => t

     When the strings have different lengths, and they match up to the
     length of STRING1, then the result is `t'.  If they match up to
     the length of STRING2, the result is `nil'.  A string of no
     characters is less than any other string.

          (string< "" "abc")
               => t
          (string< "ab" "abc")
               => t
          (string< "abc" "")
               => nil
          (string< "abc" "ab")
               => nil
          (string< "" "")
               => nil

     Symbols are also allowed as arguments, in which case their print
     names are used.

 -- Function: string-lessp string1 string2
     `string-lessp' is another name for `string<'.

 -- Function: string-prefix-p string1 string2 &optional ignore-case
     This function returns non-`nil' if STRING1 is a prefix of STRING2;
     i.e., if STRING2 starts with STRING1.  If the optional argument
     IGNORE-CASE is non-`nil', the comparison ignores case differences.

 -- Function: compare-strings string1 start1 end1 string2 start2 end2
          &optional ignore-case
     This function compares the specified part of STRING1 with the
     specified part of STRING2.  The specified part of STRING1 runs
     from index START1 up to index END1 (`nil' means the end of the
     string).  The specified part of STRING2 runs from index START2 up
     to index END2 (`nil' means the end of the string).

     The strings are both converted to multibyte for the comparison
     (*note Text Representations::) so that a unibyte string and its
     conversion to multibyte are always regarded as equal.  If
     IGNORE-CASE is non-`nil', then case is ignored, so that upper case
     letters can be equal to lower case letters.

     If the specified portions of the two strings match, the value is
     `t'.  Otherwise, the value is an integer which indicates how many
     leading characters agree, and which string is less.  Its absolute
     value is one plus the number of characters that agree at the
     beginning of the two strings.  The sign is negative if STRING1 (or
     its specified portion) is less.

 -- Function: assoc-string key alist &optional case-fold
     This function works like `assoc', except that KEY must be a string
     or symbol, and comparison is done using `compare-strings'.
     Symbols are converted to strings before testing.  If CASE-FOLD is
     non-`nil', it ignores case differences.  Unlike `assoc', this
     function can also match elements of the alist that are strings or
     symbols rather than conses.  In particular, ALIST can be a list of
     strings or symbols rather than an actual alist.  *Note Association
     Lists::.

   See also the function `compare-buffer-substrings' in *note Comparing
Text::, for a way to compare text in buffers.  The function
`string-match', which matches a regular expression against a string,
can be used for a kind of string comparison; see *note Regexp Search::.


File: elisp,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

4.6 Conversion of Characters and Strings
========================================

This section describes functions for converting between characters,
strings and integers.  `format' (*note Formatting Strings::) and
`prin1-to-string' (*note Output Functions::) can also convert Lisp
objects into strings.  `read-from-string' (*note Input Functions::) can
"convert" a string representation of a Lisp object into an object.  The
functions `string-to-multibyte' and `string-to-unibyte' convert the
text representation of a string (*note Converting Representations::).

   *Note Documentation::, for functions that produce textual
descriptions of text characters and general input events
(`single-key-description' and `text-char-description').  These are used
primarily for making help messages.

 -- Function: number-to-string number
     This function returns a string consisting of the printed base-ten
     representation of NUMBER, which may be an integer or a floating
     point number.  The returned value starts with a minus sign if the
     argument is negative.

          (number-to-string 256)
               => "256"
          (number-to-string -23)
               => "-23"
          (number-to-string -23.5)
               => "-23.5"

     `int-to-string' is a semi-obsolete alias for this function.

     See also the function `format' in *note Formatting Strings::.

 -- Function: string-to-number string &optional base
     This function returns the numeric value of the characters in
     STRING.  If BASE is non-`nil', it must be an integer between 2 and
     16 (inclusive), and integers are converted in that base.  If BASE
     is `nil', then base ten is used.  Floating point conversion only
     works in base ten; we have not implemented other radices for
     floating point numbers, because that would be much more work and
     does not seem useful.  If STRING looks like an integer but its
     value is too large to fit into a Lisp integer, `string-to-number'
     returns a floating point result.

     The parsing skips spaces and tabs at the beginning of STRING, then
     reads as much of STRING as it can interpret as a number in the
     given base.  (On some systems it ignores other whitespace at the
     beginning, not just spaces and tabs.)  If the first character after
     the ignored whitespace is neither a digit in the given base, nor a
     plus or minus sign, nor the leading dot of a floating point number,
     this function returns 0.

          (string-to-number "256")
               => 256
          (string-to-number "25 is a perfect square.")
               => 25
          (string-to-number "X256")
               => 0
          (string-to-number "-4.5")
               => -4.5
          (string-to-number "1e5")
               => 100000.0

     `string-to-int' is an obsolete alias for this function.

 -- Function: char-to-string character
     This function returns a new string containing one character,
     CHARACTER.  This function is semi-obsolete because the function
     `string' is more general.  *Note Creating Strings::.

 -- Function: string-to-char string
     This function returns the first character in STRING.  This mostly
     identical to `(aref string 0)', except that it returns 0 if the
     string is empty.  (The value is also 0 when the first character of
     STRING is the null character, ASCII code 0.)  This function may be
     eliminated in the future if it does not seem useful enough to
     retain.

   Here are some other functions that can convert to or from a string:

`concat'
     This function converts a vector or a list into a string.  *Note
     Creating Strings::.

`vconcat'
     This function converts a string into a vector.  *Note Vector
     Functions::.

`append'
     This function converts a string into a list.  *Note Building
     Lists::.

`byte-to-string'
     This function converts a byte of character data into a unibyte
     string.  *Note Converting Representations::.


File: elisp,  Node: Formatting Strings,  Next: Case Conversion,  Prev: String Conversion,  Up: Strings and Characters

4.7 Formatting Strings
======================

"Formatting" means constructing a string by substituting computed
values at various places in a constant string.  This constant string
controls how the other values are printed, as well as where they
appear; it is called a "format string".

   Formatting is often useful for computing messages to be displayed.
In fact, the functions `message' and `error' provide the same
formatting feature described here; they differ from `format' only in
how they use the result of formatting.

 -- Function: format string &rest objects
     This function returns a new string that is made by copying STRING
     and then replacing any format specification in the copy with
     encodings of the corresponding OBJECTS.  The arguments OBJECTS are
     the computed values to be formatted.

     The characters in STRING, other than the format specifications,
     are copied directly into the output, including their text
     properties, if any.

   A format specification is a sequence of characters beginning with a
`%'.  Thus, if there is a `%d' in STRING, the `format' function
replaces it with the printed representation of one of the values to be
formatted (one of the arguments OBJECTS).  For example:

     (format "The value of fill-column is %d." fill-column)
          => "The value of fill-column is 72."

   Since `format' interprets `%' characters as format specifications,
you should _never_ pass an arbitrary string as the first argument.
This is particularly true when the string is generated by some Lisp
code.  Unless the string is _known_ to never include any `%'
characters, pass `"%s"', described below, as the first argument, and
the string as the second, like this:

       (format "%s" ARBITRARY-STRING)

   If STRING contains more than one format specification, the format
specifications correspond to successive values from OBJECTS.  Thus, the
first format specification in STRING uses the first such value, the
second format specification uses the second such value, and so on.  Any
extra format specifications (those for which there are no corresponding
values) cause an error.  Any extra values to be formatted are ignored.

   Certain format specifications require values of particular types.  If
you supply a value that doesn't fit the requirements, an error is
signaled.

   Here is a table of valid format specifications:

`%s'
     Replace the specification with the printed representation of the
     object, made without quoting (that is, using `princ', not
     `prin1'--*note Output Functions::).  Thus, strings are represented
     by their contents alone, with no `"' characters, and symbols appear
     without `\' characters.

     If the object is a string, its text properties are copied into the
     output.  The text properties of the `%s' itself are also copied,
     but those of the object take priority.

`%S'
     Replace the specification with the printed representation of the
     object, made with quoting (that is, using `prin1'--*note Output
     Functions::).  Thus, strings are enclosed in `"' characters, and
     `\' characters appear where necessary before special characters.

`%o'
     Replace the specification with the base-eight representation of an
     integer.

`%d'
     Replace the specification with the base-ten representation of an
     integer.

`%x'
`%X'
     Replace the specification with the base-sixteen representation of
     an integer.  `%x' uses lower case and `%X' uses upper case.

`%c'
     Replace the specification with the character which is the value
     given.

`%e'
     Replace the specification with the exponential notation for a
     floating point number.

`%f'
     Replace the specification with the decimal-point notation for a
     floating point number.

`%g'
     Replace the specification with notation for a floating point
     number, using either exponential notation or decimal-point
     notation, whichever is shorter.

`%%'
     Replace the specification with a single `%'.  This format
     specification is unusual in that it does not use a value.  For
     example, `(format "%% %d" 30)' returns `"% 30"'.

   Any other format character results in an `Invalid format operation'
error.

   Here are several examples:

     (format "The name of this buffer is %s." (buffer-name))
          => "The name of this buffer is strings.texi."

     (format "The buffer object prints as %s." (current-buffer))
          => "The buffer object prints as strings.texi."

     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          => "The octal value of 18 is 22,
              and the hex value is 12."

   A specification can have a "width", which is a decimal number
between the `%' and the specification character.  If the printed
representation of the object contains fewer characters than this width,
`format' extends it with padding.  The width specifier is ignored for
the `%%' specification.  Any padding introduced by the width specifier
normally consists of spaces inserted on the left:

     (format "%5d is padded on the left with spaces" 123)
          => "  123 is padded on the left with spaces"

If the width is too small, `format' does not truncate the object's
printed representation.  Thus, you can use a width to specify a minimum
spacing between columns with no risk of losing information.  In the
following three examples, `%7s' specifies a minimum width of 7.  In the
first case, the string inserted in place of `%7s' has only 3 letters,
and needs 4 blank spaces as padding.  In the second case, the string
`"specification"' is 13 letters wide but is not truncated.

     (format "The word `%7s' has %d letters in it."
             "foo" (length "foo"))
          => "The word `    foo' has 3 letters in it."
     (format "The word `%7s' has %d letters in it."
             "specification" (length "specification"))
          => "The word `specification' has 13 letters in it."

   Immediately after the `%' and before the optional width specifier,
you can also put certain "flag characters".

   The flag `+' inserts a plus sign before a positive number, so that
it always has a sign.  A space character as flag inserts a space before
a positive number.  (Otherwise, positive numbers start with the first
digit.)  These flags are useful for ensuring that positive numbers and
negative numbers use the same number of columns.  They are ignored
except for `%d', `%e', `%f', `%g', and if both flags are used, `+'
takes precedence.

   The flag `#' specifies an "alternate form" which depends on the
format in use.  For `%o', it ensures that the result begins with a `0'.
For `%x' and `%X', it prefixes the result with `0x' or `0X'.  For `%e',
`%f', and `%g', the `#' flag means include a decimal point even if the
precision is zero.

   The flag `0' ensures that the padding consists of `0' characters
instead of spaces.  This flag is ignored for non-numerical
specification characters like `%s', `%S' and `%c'.  These specification
characters accept the `0' flag, but still pad with _spaces_.

   The flag `-' causes the padding inserted by the width specifier, if
any, to be inserted on the right rather than the left.  If both `-' and
`0' are present, the `0' flag is ignored.

     (format "%06d is padded on the left with zeros" 123)
          => "000123 is padded on the left with zeros"

     (format "%-6d is padded on the right" 123)
          => "123    is padded on the right"

     (format "The word `%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `foo    ' actually has 3 letters in it."

   All the specification characters allow an optional "precision"
before the character (after the width, if present).  The precision is a
decimal-point `.' followed by a digit-string.  For the floating-point
specifications (`%e', `%f', `%g'), the precision specifies how many
decimal places to show; if zero, the decimal-point itself is also
omitted.  For `%s' and `%S', the precision truncates the string to the
given width, so `%.3s' shows only the first three characters of the
representation for OBJECT.  Precision has no effect for other
specification characters.


File: elisp,  Node: Case Conversion,  Next: Case Tables,  Prev: Formatting Strings,  Up: Strings and Characters

4.8 Case Conversion in Lisp
===========================

The character case functions change the case of single characters or of
the contents of strings.  The functions normally convert only
alphabetic characters (the letters `A' through `Z' and `a' through `z',
as well as non-ASCII letters); other characters are not altered.  You
can specify a different case conversion mapping by specifying a case
table (*note Case Tables::).

   These functions do not modify the strings that are passed to them as
arguments.

   The examples below use the characters `X' and `x' which have ASCII
codes 88 and 120 respectively.

 -- Function: downcase string-or-char
     This function converts STRING-OR-CHAR, which should be either a
     character or a string, to lower case.

     When STRING-OR-CHAR is a string, this function returns a new
     string in which each letter in the argument that is upper case is
     converted to lower case.  When STRING-OR-CHAR is a character, this
     function returns the corresponding lower case character (an
     integer); if the original character is lower case, or is not a
     letter, the return value is equal to the original character.

          (downcase "The cat in the hat")
               => "the cat in the hat"

          (downcase ?X)
               => 120

 -- Function: upcase string-or-char
     This function converts STRING-OR-CHAR, which should be either a
     character or a string, to upper case.

     When STRING-OR-CHAR is a string, this function returns a new
     string in which each letter in the argument that is lower case is
     converted to upper case.  When STRING-OR-CHAR is a character, this
     function returns the corresponding upper case character (an
     integer); if the original character is upper case, or is not a
     letter, the return value is equal to the original character.

          (upcase "The cat in the hat")
               => "THE CAT IN THE HAT"

          (upcase ?x)
               => 88

 -- Function: capitalize string-or-char
     This function capitalizes strings or characters.  If
     STRING-OR-CHAR is a string, the function returns a new string
     whose contents are a copy of STRING-OR-CHAR in which each word has
     been capitalized.  This means that the first character of each
     word is converted to upper case, and the rest are converted to
     lower case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When STRING-OR-CHAR is a character, this function does the same
     thing as `upcase'.

          (capitalize "The cat in the hat")
               => "The Cat In The Hat"

          (capitalize "THE 77TH-HATTED CAT")
               => "The 77th-Hatted Cat"

          (capitalize ?x)
               => 88

 -- Function: upcase-initials string-or-char
     If STRING-OR-CHAR is a string, this function capitalizes the
     initials of the words in STRING-OR-CHAR, without altering any
     letters other than the initials.  It returns a new string whose
     contents are a copy of STRING-OR-CHAR, in which each word has had
     its initial letter converted to upper case.

     The definition of a word is any sequence of consecutive characters
     that are assigned to the word constituent syntax class in the
     current syntax table (*note Syntax Class Table::).

     When the argument to `upcase-initials' is a character,
     `upcase-initials' has the same result as `upcase'.

          (upcase-initials "The CAT in the hAt")
               => "The CAT In The HAt"

   *Note Text Comparison::, for functions that compare strings; some of
them ignore case differences, or can optionally ignore case differences.


File: elisp,  Node: Case Tables,  Prev: Case Conversion,  Up: Strings and Characters

4.9 The Case Table
==================

You can customize case conversion by installing a special "case table".
A case table specifies the mapping between upper case and lower case
letters.  It affects both the case conversion functions for Lisp
objects (see the previous section) and those that apply to text in the
buffer (*note Case Changes::).  Each buffer has a case table; there is
also a standard case table which is used to initialize the case table
of new buffers.

   A case table is a char-table (*note Char-Tables::) whose subtype is
`case-table'.  This char-table maps each character into the
corresponding lower case character.  It has three extra slots, which
hold related tables:

UPCASE
     The upcase table maps each character into the corresponding upper
     case character.

CANONICALIZE
     The canonicalize table maps all of a set of case-related characters
     into a particular member of that set.

EQUIVALENCES
     The equivalences table maps each one of a set of case-related
     characters into the next character in that set.

   In simple cases, all you need to specify is the mapping to
lower-case; the three related tables will be calculated automatically
from that one.

   For some languages, upper and lower case letters are not in
one-to-one correspondence.  There may be two different lower case
letters with the same upper case equivalent.  In these cases, you need
to specify the maps for both lower case and upper case.

   The extra table CANONICALIZE maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character.  For example, since `a' and
`A' are related by case-conversion, they should have the same canonical
equivalent character (which should be either `a' for both of them, or
`A' for both of them).

   The extra table EQUIVALENCES is a map that cyclically permutes each
equivalence class (of characters with the same canonical equivalent).
(For ordinary ASCII, this would map `a' into `A' and `A' into `a', and
likewise for each set of equivalent characters.)

   When constructing a case table, you can provide `nil' for
CANONICALIZE; then Emacs fills in this slot from the lower case and
upper case mappings.  You can also provide `nil' for EQUIVALENCES; then
Emacs fills in this slot from CANONICALIZE.  In a case table that is
actually in use, those components are non-`nil'.  Do not try to specify
EQUIVALENCES without also specifying CANONICALIZE.

   Here are the functions for working with case tables:

 -- Function: case-table-p object
     This predicate returns non-`nil' if OBJECT is a valid case table.

 -- Function: set-standard-case-table table
     This function makes TABLE the standard case table, so that it will
     be used in any buffers created subsequently.

 -- Function: standard-case-table
     This returns the standard case table.

 -- Function: current-case-table
     This function returns the current buffer's case table.

 -- Function: set-case-table table
     This sets the current buffer's case table to TABLE.

 -- Macro: with-case-table table body...
     The `with-case-table' macro saves the current case table, makes
     TABLE the current case table, evaluates the BODY forms, and
     finally restores the case table.  The return value is the value of
     the last form in BODY.  The case table is restored even in case of
     an abnormal exit via `throw' or error (*note Nonlocal Exits::).

   Some language environments modify the case conversions of ASCII
characters; for example, in the Turkish language environment, the ASCII
character `I' is downcased into a Turkish "dotless i".  This can
interfere with code that requires ordinary ASCII case conversion, such
as implementations of ASCII-based network protocols.  In that case, use
the `with-case-table' macro with the variable ASCII-CASE-TABLE, which
stores the unmodified case table for the ASCII character set.

 -- Variable: ascii-case-table
     The case table for the ASCII character set.  This should not be
     modified by any language environment settings.

   The following three functions are convenient subroutines for packages
that define non-ASCII character sets.  They modify the specified case
table CASE-TABLE; they also modify the standard syntax table.  *Note
Syntax Tables::.  Normally you would use these functions to change the
standard case table.

 -- Function: set-case-syntax-pair uc lc case-table
     This function specifies a pair of corresponding letters, one upper
     case and one lower case.

 -- Function: set-case-syntax-delims l r case-table
     This function makes characters L and R a matching pair of
     case-invariant delimiters.

 -- Function: set-case-syntax char syntax case-table
     This function makes CHAR case-invariant, with syntax SYNTAX.

 -- Command: describe-buffer-case-table
     This command displays a description of the contents of the current
     buffer's case table.


File: elisp,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

5 Lists
*******

A "list" represents a sequence of zero or more elements (which may be
any Lisp objects).  The important difference between lists and vectors
is that two or more lists can share part of their structure; in
addition, you can insert or delete elements in a list without copying
the whole list.

* Menu:

* Cons Cells::          How lists are made out of cons cells.
* List-related Predicates::        Is this object a list?  Comparing two lists.
* List Elements::       Extracting the pieces of a list.
* Building Lists::      Creating list structure.
* List Variables::      Modifying lists stored in variables.
* Modifying Lists::     Storing new pieces into an existing list.
* Sets And Lists::      A list can represent a finite mathematical set.
* Association Lists::   A list can represent a finite relation or mapping.


File: elisp,  Node: Cons Cells,  Next: List-related Predicates,  Up: Lists

5.1 Lists and Cons Cells
========================

Lists in Lisp are not a primitive data type; they are built up from
"cons cells" (*note Cons Cell Type::).  A cons cell is a data object
that represents an ordered pair.  That is, it has two slots, and each
slot "holds", or "refers to", some Lisp object.  One slot is known as
the CAR, and the other is known as the CDR.  (These names are
traditional; see *note Cons Cell Type::.)  CDR is pronounced "could-er".

   We say that "the CAR of this cons cell is" whatever object its CAR
slot currently holds, and likewise for the CDR.

   A list is a series of cons cells "chained together", so that each
cell refers to the next one.  There is one cons cell for each element
of the list.  By convention, the CARs of the cons cells hold the
elements of the list, and the CDRs are used to chain the list (this
asymmetry between CAR and CDR is entirely a matter of convention; at
the level of cons cells, the CAR and CDR slots have similar
properties).  Hence, the CDR slot of each cons cell in a list refers to
the following cons cell.

   Also by convention, the CDR of the last cons cell in a list is
`nil'.  We call such a `nil'-terminated structure a "true list".  In
Emacs Lisp, the symbol `nil' is both a symbol and a list with no
elements.  For convenience, the symbol `nil' is considered to have
`nil' as its CDR (and also as its CAR).

   Hence, the CDR of a true list is always a true list.  The CDR of a
nonempty true list is a true list containing all the elements except
the first.

   If the CDR of a list's last cons cell is some value other than
`nil', we call the structure a "dotted list", since its printed
representation would use dotted pair notation (*note Dotted Pair
Notation::).  There is one other possibility: some cons cell's CDR
could point to one of the previous cons cells in the list.  We call
that structure a "circular list".

   For some purposes, it does not matter whether a list is true,
circular or dotted.  If a program doesn't look far enough down the list
to see the CDR of the final cons cell, it won't care.  However, some
functions that operate on lists demand true lists and signal errors if
given a dotted list.  Most functions that try to find the end of a list
enter infinite loops if given a circular list.

   Because most cons cells are used as part of lists, we refer to any
structure made out of cons cells as a "list structure".


File: elisp,  Node: List-related Predicates,  Next: List Elements,  Prev: Cons Cells,  Up: Lists

5.2 Predicates on Lists
=======================

The following predicates test whether a Lisp object is an atom, whether
it is a cons cell or is a list, or whether it is the distinguished
object `nil'.  (Many of these predicates can be defined in terms of the
others, but they are used so often that it is worth having them.)

 -- Function: consp object
     This function returns `t' if OBJECT is a cons cell, `nil'
     otherwise.  `nil' is not a cons cell, although it _is_ a list.

 -- Function: atom object
     This function returns `t' if OBJECT is an atom, `nil' otherwise.
     All objects except cons cells are atoms.  The symbol `nil' is an
     atom and is also a list; it is the only Lisp object that is both.

          (atom OBJECT) == (not (consp OBJECT))

 -- Function: listp object
     This function returns `t' if OBJECT is a cons cell or `nil'.
     Otherwise, it returns `nil'.

          (listp '(1))
               => t
          (listp '())
               => t

 -- Function: nlistp object
     This function is the opposite of `listp': it returns `t' if OBJECT
     is not a list.  Otherwise, it returns `nil'.

          (listp OBJECT) == (not (nlistp OBJECT))

 -- Function: null object
     This function returns `t' if OBJECT is `nil', and returns `nil'
     otherwise.  This function is identical to `not', but as a matter
     of clarity we use `null' when OBJECT is considered a list and
     `not' when it is considered a truth value (see `not' in *note
     Combining Conditions::).

          (null '(1))
               => nil
          (null '())
               => t


File: elisp,  Node: List Elements,  Next: Building Lists,  Prev: List-related Predicates,  Up: Lists

5.3 Accessing Elements of Lists
===============================

 -- Function: car cons-cell
     This function returns the value referred to by the first slot of
     the cons cell CONS-CELL.  In other words, it returns the CAR of
     CONS-CELL.

     As a special case, if CONS-CELL is `nil', this function returns
     `nil'.  Therefore, any list is a valid argument.  An error is
     signaled if the argument is not a cons cell or `nil'.

          (car '(a b c))
               => a
          (car '())
               => nil

 -- Function: cdr cons-cell
     This function returns the value referred to by the second slot of
     the cons cell CONS-CELL.  In other words, it returns the CDR of
     CONS-CELL.

     As a special case, if CONS-CELL is `nil', this function returns
     `nil'; therefore, any list is a valid argument.  An error is
     signaled if the argument is not a cons cell or `nil'.

          (cdr '(a b c))
               => (b c)
          (cdr '())
               => nil

 -- Function: car-safe object
     This function lets you take the CAR of a cons cell while avoiding
     errors for other data types.  It returns the CAR of OBJECT if
     OBJECT is a cons cell, `nil' otherwise.  This is in contrast to
     `car', which signals an error if OBJECT is not a list.

          (car-safe OBJECT)
          ==
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 -- Function: cdr-safe object
     This function lets you take the CDR of a cons cell while avoiding
     errors for other data types.  It returns the CDR of OBJECT if
     OBJECT is a cons cell, `nil' otherwise.  This is in contrast to
     `cdr', which signals an error if OBJECT is not a list.

          (cdr-safe OBJECT)
          ==
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 -- Macro: pop listname
     This macro is a way of examining the CAR of a list, and taking it
     off the list, all at once.

     It operates on the list which is stored in the symbol LISTNAME.
     It removes this element from the list by setting LISTNAME to the
     CDR of its old value--but it also returns the CAR of that list,
     which is the element being removed.

          x
               => (a b c)
          (pop x)
               => a
          x
               => (b c)

     For the `pop' macro, which removes an element from a list, *Note
     List Variables::.

 -- Function: nth n list
     This function returns the Nth element of LIST.  Elements are
     numbered starting with zero, so the CAR of LIST is element number
     zero.  If the length of LIST is N or less, the value is `nil'.

     If N is negative, `nth' returns the first element of LIST.

          (nth 2 '(1 2 3 4))
               => 3
          (nth 10 '(1 2 3 4))
               => nil
          (nth -3 '(1 2 3 4))
               => 1

          (nth n x) == (car (nthcdr n x))

     The function `elt' is similar, but applies to any kind of sequence.
     For historical reasons, it takes its arguments in the opposite
     order.  *Note Sequence Functions::.

 -- Function: nthcdr n list
     This function returns the Nth CDR of LIST.  In other words, it
     skips past the first N links of LIST and returns what follows.

     If N is zero or negative, `nthcdr' returns all of LIST.  If the
     length of LIST is N or less, `nthcdr' returns `nil'.

          (nthcdr 1 '(1 2 3 4))
               => (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               => nil
          (nthcdr -3 '(1 2 3 4))
               => (1 2 3 4)

 -- Function: last list &optional n
     This function returns the last link of LIST.  The `car' of this
     link is the list's last element.  If LIST is null, `nil' is
     returned.  If N is non-`nil', the Nth-to-last link is returned
     instead, or the whole of LIST if N is bigger than LIST's length.

 -- Function: safe-length list
     This function returns the length of LIST, with no risk of either
     an error or an infinite loop.  It generally returns the number of
     distinct cons cells in the list.  However, for circular lists, the
     value is just an upper bound; it is often too large.

     If LIST is not `nil' or a cons cell, `safe-length' returns 0.

   The most common way to compute the length of a list, when you are not
worried that it may be circular, is with `length'.  *Note Sequence
Functions::.

 -- Function: caar cons-cell
     This is the same as `(car (car CONS-CELL))'.

 -- Function: cadr cons-cell
     This is the same as `(car (cdr CONS-CELL))' or `(nth 1 CONS-CELL)'.

 -- Function: cdar cons-cell
     This is the same as `(cdr (car CONS-CELL))'.

 -- Function: cddr cons-cell
     This is the same as `(cdr (cdr CONS-CELL))' or `(nthcdr 2
     CONS-CELL)'.

 -- Function: butlast x &optional n
     This function returns the list X with the last element, or the
     last N elements, removed.  If N is greater than zero it makes a
     copy of the list so as not to damage the original list.  In
     general, `(append (butlast X N) (last X N))' will return a list
     equal to X.

 -- Function: nbutlast x &optional n
     This is a version of `butlast' that works by destructively
     modifying the `cdr' of the appropriate element, rather than making
     a copy of the list.


File: elisp,  Node: Building Lists,  Next: List Variables,  Prev: List Elements,  Up: Lists

5.4 Building Cons Cells and Lists
=================================

Many functions build lists, as lists reside at the very heart of Lisp.
`cons' is the fundamental list-building function; however, it is
interesting to note that `list' is used more times in the source code
for Emacs than `cons'.

 -- Function: cons object1 object2
     This function is the most basic function for building new list
     structure.  It creates a new cons cell, making OBJECT1 the CAR,
     and OBJECT2 the CDR.  It then returns the new cons cell.  The
     arguments OBJECT1 and OBJECT2 may be any Lisp objects, but most
     often OBJECT2 is a list.

          (cons 1 '(2))
               => (1 2)
          (cons 1 '())
               => (1)
          (cons 1 2)
               => (1 . 2)

     `cons' is often used to add a single element to the front of a
     list.  This is called "consing the element onto the list".  (1)
     For example:

          (setq list (cons newelt list))

     Note that there is no conflict between the variable named `list'
     used in this example and the function named `list' described below;
     any symbol can serve both purposes.

 -- Function: list &rest objects
     This function creates a list with OBJECTS as its elements.  The
     resulting list is always `nil'-terminated.  If no OBJECTS are
     given, the empty list is returned.

          (list 1 2 3 4 5)
               => (1 2 3 4 5)
          (list 1 2 '(3 4 5) 'foo)
               => (1 2 (3 4 5) foo)
          (list)
               => nil

 -- Function: make-list length object
     This function creates a list of LENGTH elements, in which each
     element is OBJECT.  Compare `make-list' with `make-string' (*note
     Creating Strings::).

          (make-list 3 'pigs)
               => (pigs pigs pigs)
          (make-list 0 'pigs)
               => nil
          (setq l (make-list 3 '(a b)))
               => ((a b) (a b) (a b))
          (eq (car l) (cadr l))
               => t

 -- Function: append &rest sequences
     This function returns a list containing all the elements of
     SEQUENCES.  The SEQUENCES may be lists, vectors, bool-vectors, or
     strings, but the last one should usually be a list.  All arguments
     except the last one are copied, so none of the arguments is
     altered.  (See `nconc' in *note Rearrangement::, for a way to join
     lists with no copying.)

     More generally, the final argument to `append' may be any Lisp
     object.  The final argument is not copied or converted; it becomes
     the CDR of the last cons cell in the new list.  If the final
     argument is itself a list, then its elements become in effect
     elements of the result list.  If the final element is not a list,
     the result is a dotted list since its final CDR is not `nil' as
     required in a true list.

   Here is an example of using `append':

     (setq trees '(pine oak))
          => (pine oak)
     (setq more-trees (append '(maple birch) trees))
          => (maple birch pine oak)

     trees
          => (pine oak)
     more-trees
          => (maple birch pine oak)
     (eq trees (cdr (cdr more-trees)))
          => t

   You can see how `append' works by looking at a box diagram.  The
variable `trees' is set to the list `(pine oak)' and then the variable
`more-trees' is set to the list `(maple birch pine oak)'.  However, the
variable `trees' continues to refer to the original list:

     more-trees                trees
     |                           |
     |     --- ---      --- ---   -> --- ---      --- ---
      --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
           --- ---      --- ---      --- ---      --- ---
            |            |            |            |
            |            |            |            |
             --> maple    -->birch     --> pine     --> oak

   An empty sequence contributes nothing to the value returned by
`append'.  As a consequence of this, a final `nil' argument forces a
copy of the previous argument:

     trees
          => (pine oak)
     (setq wood (append trees nil))
          => (pine oak)
     wood
          => (pine oak)
     (eq wood trees)
          => nil

This once was the usual way to copy a list, before the function
`copy-sequence' was invented.  *Note Sequences Arrays Vectors::.

   Here we show the use of vectors and strings as arguments to `append':

     (append [a b] "cd" nil)
          => (a b 99 100)

   With the help of `apply' (*note Calling Functions::), we can append
all the lists in a list of lists:

     (apply 'append '((a b c) nil (x y z) nil))
          => (a b c x y z)

   If no SEQUENCES are given, `nil' is returned:

     (append)
          => nil

   Here are some examples where the final argument is not a list:

     (append '(x y) 'z)
          => (x y . z)
     (append '(x y) [z])
          => (x y . [z])

The second example shows that when the final argument is a sequence but
not a list, the sequence's elements do not become elements of the
resulting list.  Instead, the sequence becomes the final CDR, like any
other non-list final argument.

 -- Function: reverse list
     This function creates a new list whose elements are the elements of
     LIST, but in reverse order.  The original argument LIST is _not_
     altered.

          (setq x '(1 2 3 4))
               => (1 2 3 4)
          (reverse x)
               => (4 3 2 1)
          x
               => (1 2 3 4)

 -- Function: copy-tree tree &optional vecp
     This function returns a copy of the tree `tree'.  If TREE is a
     cons cell, this makes a new cons cell with the same CAR and CDR,
     then recursively copies the CAR and CDR in the same way.

     Normally, when TREE is anything other than a cons cell,
     `copy-tree' simply returns TREE.  However, if VECP is non-`nil',
     it copies vectors too (and operates recursively on their elements).

 -- Function: number-sequence from &optional to separation
     This returns a list of numbers starting with FROM and incrementing
     by SEPARATION, and ending at or just before TO.  SEPARATION can be
     positive or negative and defaults to 1.  If TO is `nil' or
     numerically equal to FROM, the value is the one-element list
     `(FROM)'.  If TO is less than FROM with a positive SEPARATION, or
     greater than FROM with a negative SEPARATION, the value is `nil'
     because those arguments specify an empty sequence.

     If SEPARATION is 0 and TO is neither `nil' nor numerically equal
     to FROM, `number-sequence' signals an error, since those arguments
     specify an infinite sequence.

     All arguments can be integers or floating point numbers.  However,
     floating point arguments can be tricky, because floating point
     arithmetic is inexact.  For instance, depending on the machine, it
     may quite well happen that `(number-sequence 0.4 0.6 0.2)' returns
     the one element list `(0.4)', whereas `(number-sequence 0.4 0.8
     0.2)' returns a list with three elements.  The Nth element of the
     list is computed by the exact formula `(+ FROM (* N SEPARATION))'.
     Thus, if one wants to make sure that TO is included in the list,
     one can pass an expression of this exact type for TO.
     Alternatively, one can replace TO with a slightly larger value (or
     a slightly more negative value if SEPARATION is negative).

     Some examples:

          (number-sequence 4 9)
               => (4 5 6 7 8 9)
          (number-sequence 9 4 -1)
               => (9 8 7 6 5 4)
          (number-sequence 9 4 -2)
               => (9 7 5)
          (number-sequence 8)
               => (8)
          (number-sequence 8 5)
               => nil
          (number-sequence 5 8 -1)
               => nil
          (number-sequence 1.5 6 2)
               => (1.5 3.5 5.5)

   ---------- Footnotes ----------

   (1) There is no strictly equivalent way to add an element to the end
of a list.  You can use `(append LISTNAME (list NEWELT))', which
creates a whole new list by copying LISTNAME and adding NEWELT to its
end.  Or you can use `(nconc LISTNAME (list NEWELT))', which modifies
LISTNAME by following all the CDRs and then replacing the terminating
`nil'.  Compare this to adding an element to the beginning of a list
with `cons', which neither copies nor modifies the list.


File: elisp,  Node: List Variables,  Next: Modifying Lists,  Prev: Building Lists,  Up: Lists

5.5 Modifying List Variables
============================

These functions, and one macro, provide convenient ways to modify a
list which is stored in a variable.

 -- Macro: push newelt listname
     This macro provides an alternative way to write `(setq LISTNAME
     (cons NEWELT LISTNAME))'.

          (setq l '(a b))
               => (a b)
          (push 'c l)
               => (c a b)
          l
               => (c a b)

     For the `pop' macro, which removes the first element from a list,
     *Note List Elements::.

   Two functions modify lists that are the values of variables.

 -- Function: add-to-list symbol element &optional append compare-fn
     This function sets the variable SYMBOL by consing ELEMENT onto the
     old value, if ELEMENT is not already a member of that value.  It
     returns the resulting list, whether updated or not.  The value of
     SYMBOL had better be a list already before the call.
     `add-to-list' uses COMPARE-FN to compare ELEMENT against existing
     list members; if COMPARE-FN is `nil', it uses `equal'.

     Normally, if ELEMENT is added, it is added to the front of SYMBOL,
     but if the optional argument APPEND is non-`nil', it is added at
     the end.

     The argument SYMBOL is not implicitly quoted; `add-to-list' is an
     ordinary function, like `set' and unlike `setq'.  Quote the
     argument yourself if that is what you want.

   Here's a scenario showing how to use `add-to-list':

     (setq foo '(a b))
          => (a b)

     (add-to-list 'foo 'c)     ;; Add `c'.
          => (c a b)

     (add-to-list 'foo 'b)     ;; No effect.
          => (c a b)

     foo                       ;; `foo' was changed.
          => (c a b)

   An equivalent expression for `(add-to-list 'VAR VALUE)' is this:

     (or (member VALUE VAR)
         (setq VAR (cons VALUE VAR)))

 -- Function: add-to-ordered-list symbol element &optional order
     This function sets the variable SYMBOL by inserting ELEMENT into
     the old value, which must be a list, at the position specified by
     ORDER.  If ELEMENT is already a member of the list, its position
     in the list is adjusted according to ORDER.  Membership is tested
     using `eq'.  This function returns the resulting list, whether
     updated or not.

     The ORDER is typically a number (integer or float), and the
     elements of the list are sorted in non-decreasing numerical order.

     ORDER may also be omitted or `nil'.  Then the numeric order of
     ELEMENT stays unchanged if it already has one; otherwise, ELEMENT
     has no numeric order.  Elements without a numeric list order are
     placed at the end of the list, in no particular order.

     Any other value for ORDER removes the numeric order of ELEMENT if
     it already has one; otherwise, it is equivalent to `nil'.

     The argument SYMBOL is not implicitly quoted;
     `add-to-ordered-list' is an ordinary function, like `set' and
     unlike `setq'.  Quote the argument yourself if necessary.

     The ordering information is stored in a hash table on SYMBOL's
     `list-order' property.

   Here's a scenario showing how to use `add-to-ordered-list':

     (setq foo '())
          => nil

     (add-to-ordered-list 'foo 'a 1)     ;; Add `a'.
          => (a)

     (add-to-ordered-list 'foo 'c 3)     ;; Add `c'.
          => (a c)

     (add-to-ordered-list 'foo 'b 2)     ;; Add `b'.
          => (a b c)

     (add-to-ordered-list 'foo 'b 4)     ;; Move `b'.
          => (a c b)

     (add-to-ordered-list 'foo 'd)       ;; Append `d'.
          => (a c b d)

     (add-to-ordered-list 'foo 'e)       ;; Add `e'.
          => (a c b e d)

     foo                       ;; `foo' was changed.
          => (a c b e d)


File: elisp,  Node: Modifying Lists,  Next: Sets And Lists,  Prev: List Variables,  Up: Lists

5.6 Modifying Existing List Structure
=====================================

You can modify the CAR and CDR contents of a cons cell with the
primitives `setcar' and `setcdr'.  We call these "destructive"
operations because they change existing list structure.

     Common Lisp note: Common Lisp uses functions `rplaca' and `rplacd'
     to alter list structure; they change structure the same way as
     `setcar' and `setcdr', but the Common Lisp functions return the
     cons cell while `setcar' and `setcdr' return the new CAR or CDR.

* Menu:

* Setcar::          Replacing an element in a list.
* Setcdr::          Replacing part of the list backbone.
                      This can be used to remove or add elements.
* Rearrangement::   Reordering the elements in a list; combining lists.


File: elisp,  Node: Setcar,  Next: Setcdr,  Up: Modifying Lists

5.6.1 Altering List Elements with `setcar'
------------------------------------------

Changing the CAR of a cons cell is done with `setcar'.  When used on a
list, `setcar' replaces one element of a list with a different element.

 -- Function: setcar cons object
     This function stores OBJECT as the new CAR of CONS, replacing its
     previous CAR.  In other words, it changes the CAR slot of CONS to
     refer to OBJECT.  It returns the value OBJECT.  For example:

          (setq x '(1 2))
               => (1 2)
          (setcar x 4)
               => 4
          x
               => (4 2)

   When a cons cell is part of the shared structure of several lists,
storing a new CAR into the cons changes one element of each of these
lists.  Here is an example:

     ;; Create two lists that are partly shared.
     (setq x1 '(a b c))
          => (a b c)
     (setq x2 (cons 'z (cdr x1)))
          => (z b c)

     ;; Replace the CAR of a shared link.
     (setcar (cdr x1) 'foo)
          => foo
     x1                           ; Both lists are changed.
          => (a foo c)
     x2
          => (z foo c)

     ;; Replace the CAR of a link that is not shared.
     (setcar x1 'baz)
          => baz
     x1                           ; Only one list is changed.
          => (baz foo c)
     x2
          => (z foo c)

   Here is a graphical depiction of the shared structure of the two
lists in the variables `x1' and `x2', showing why replacing `b' changes
them both:

             --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

   Here is an alternative form of box diagram, showing the same
relationship:

     x1:
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   a   |   o------->|   b   |   o------->|   c   |  nil |
     |       |      |  -->|       |      |     |       |      |
      --------------  |    --------------       --------------
                      |
     x2:              |
      --------------  |
     | car   | cdr  | |
     |   z   |   o----
     |       |      |
      --------------


File: elisp,  Node: Setcdr,  Next: Rearrangement,  Prev: Setcar,  Up: Modifying Lists

5.6.2 Altering the CDR of a List
--------------------------------

The lowest-level primitive for modifying a CDR is `setcdr':

 -- Function: setcdr cons object
     This function stores OBJECT as the new CDR of CONS, replacing its
     previous CDR.  In other words, it changes the CDR slot of CONS to
     refer to OBJECT.  It returns the value OBJECT.

   Here is an example of replacing the CDR of a list with a different
list.  All but the first element of the list are removed in favor of a
different sequence of elements.  The first element is unchanged,
because it resides in the CAR of the list, and is not reached via the
CDR.

     (setq x '(1 2 3))
          => (1 2 3)
     (setcdr x '(4))
          => (4)
     x
          => (1 4)

   You can delete elements from the middle of a list by altering the
CDRs of the cons cells in the list.  For example, here we delete the
second element, `b', from the list `(a b c)', by changing the CDR of
the first cons cell:

     (setq x1 '(a b c))
          => (a b c)
     (setcdr x1 (cdr (cdr x1)))
          => (c)
     x1
          => (a c)

   Here is the result in box notation:

                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

The second cons cell, which previously held the element `b', still
exists and its CAR is still `b', but it no longer forms part of this
list.

   It is equally easy to insert a new element by changing CDRs:

     (setq x1 '(a b c))
          => (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          => (d b c)
     x1
          => (a d b c)

   Here is this result in box notation:

      --------------        -------------       -------------
     | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
     |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
     |      |   |   |  |   |      |      |     |      |      |
      --------- | --   |    -------------       -------------
                |      |
          -----         --------
         |                      |
         |    ---------------   |
         |   | car   | cdr   |  |
          -->|   d   |   o------
             |       |       |
              ---------------


File: elisp,  Node: Rearrangement,  Prev: Setcdr,  Up: Modifying Lists

5.6.3 Functions that Rearrange Lists
------------------------------------

Here are some functions that rearrange lists "destructively" by
modifying the CDRs of their component cons cells.  We call these
functions "destructive" because they chew up the original lists passed
to them as arguments, relinking their cons cells to form a new list that
is the returned value.

   See `delq', in *note Sets And Lists::, for another function that
modifies cons cells.

 -- Function: nconc &rest lists
     This function returns a list containing all the elements of LISTS.
     Unlike `append' (*note Building Lists::), the LISTS are _not_
     copied.  Instead, the last CDR of each of the LISTS is changed to
     refer to the following list.  The last of the LISTS is not
     altered.  For example:

          (setq x '(1 2 3))
               => (1 2 3)
          (nconc x '(4 5))
               => (1 2 3 4 5)
          x
               => (1 2 3 4 5)

     Since the last argument of `nconc' is not itself modified, it is
     reasonable to use a constant list, such as `'(4 5)', as in the
     above example.  For the same reason, the last argument need not be
     a list:

          (setq x '(1 2 3))
               => (1 2 3)
          (nconc x 'z)
               => (1 2 3 . z)
          x
               => (1 2 3 . z)

     However, the other arguments (all but the last) must be lists.

     A common pitfall is to use a quoted constant list as a non-last
     argument to `nconc'.  If you do this, your program will change
     each time you run it!  Here is what happens:

          (defun add-foo (x)            ; We want this function to add
            (nconc '(foo) x))           ;   `foo' to the front of its arg.

          (symbol-function 'add-foo)
               => (lambda (x) (nconc (quote (foo)) x))

          (setq xx (add-foo '(1 2)))    ; It seems to work.
               => (foo 1 2)
          (setq xy (add-foo '(3 4)))    ; What happened?
               => (foo 1 2 3 4)
          (eq xx xy)
               => t

          (symbol-function 'add-foo)
               => (lambda (x) (nconc (quote (foo 1 2 3 4) x)))

 -- Function: nreverse list
     This function reverses the order of the elements of LIST.  Unlike
     `reverse', `nreverse' alters its argument by reversing the CDRs in
     the cons cells forming the list.  The cons cell that used to be
     the last one in LIST becomes the first cons cell of the value.

     For example:

          (setq x '(a b c))
               => (a b c)
          x
               => (a b c)
          (nreverse x)
               => (c b a)
          ;; The cons cell that was first is now last.
          x
               => (a)

     To avoid confusion, we usually store the result of `nreverse' back
     in the same variable which held the original list:

          (setq x (nreverse x))

     Here is the `nreverse' of our favorite example, `(a b c)',
     presented graphically:

          Original list head:                       Reversed list:
           -------------        -------------        ------------
          | car  | cdr  |      | car  | cdr  |      | car | cdr  |
          |   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
          |      |      |   |  |      |   |  |   |  |     |   |  |
           -------------    |   --------- | -    |   -------- | -
                            |             |      |            |
                             -------------        ------------

 -- Function: sort list predicate
     This function sorts LIST stably, though destructively, and returns
     the sorted list.  It compares elements using PREDICATE.  A stable
     sort is one in which elements with equal sort keys maintain their
     relative order before and after the sort.  Stability is important
     when successive sorts are used to order elements according to
     different criteria.

     The argument PREDICATE must be a function that accepts two
     arguments.  It is called with two elements of LIST.  To get an
     increasing order sort, the PREDICATE should return non-`nil' if the
     first element is "less than" the second, or `nil' if not.

     The comparison function PREDICATE must give reliable results for
     any given pair of arguments, at least within a single call to
     `sort'.  It must be "antisymmetric"; that is, if A is less than B,
     B must not be less than A.  It must be "transitive"--that is, if A
     is less than B, and B is less than C, then A must be less than C.
     If you use a comparison function which does not meet these
     requirements, the result of `sort' is unpredictable.

     The destructive aspect of `sort' is that it rearranges the cons
     cells forming LIST by changing CDRs.  A nondestructive sort
     function would create new cons cells to store the elements in their
     sorted order.  If you wish to make a sorted copy without
     destroying the original, copy it first with `copy-sequence' and
     then sort.

     Sorting does not change the CARs of the cons cells in LIST; the
     cons cell that originally contained the element `a' in LIST still
     has `a' in its CAR after sorting, but it now appears in a
     different position in the list due to the change of CDRs.  For
     example:

          (setq nums '(1 3 2 6 5 4 0))
               => (1 3 2 6 5 4 0)
          (sort nums '<)
               => (0 1 2 3 4 5 6)
          nums
               => (1 2 3 4 5 6)

     *Warning*: Note that the list in `nums' no longer contains 0; this
     is the same cons cell that it was before, but it is no longer the
     first one in the list.  Don't assume a variable that formerly held
     the argument now holds the entire sorted list!  Instead, save the
     result of `sort' and use that.  Most often we store the result
     back into the variable that held the original list:

          (setq nums (sort nums '<))

     *Note Sorting::, for more functions that perform sorting.  See
     `documentation' in *note Accessing Documentation::, for a useful
     example of `sort'.


File: elisp,  Node: Sets And Lists,  Next: Association Lists,  Prev: Modifying Lists,  Up: Lists

5.7 Using Lists as Sets
=======================

A list can represent an unordered mathematical set--simply consider a
value an element of a set if it appears in the list, and ignore the
order of the list.  To form the union of two sets, use `append' (as
long as you don't mind having duplicate elements).  You can remove
`equal' duplicates using `delete-dups'.  Other useful functions for
sets include `memq' and `delq', and their `equal' versions, `member'
and `delete'.

     Common Lisp note: Common Lisp has functions `union' (which avoids
     duplicate elements) and `intersection' for set operations.
     Although standard GNU Emacs Lisp does not have them, the `cl'
     library provides versions.  *Note Overview: (cl)Top.

 -- Function: memq object list
     This function tests to see whether OBJECT is a member of LIST.  If
     it is, `memq' returns a list starting with the first occurrence of
     OBJECT.  Otherwise, it returns `nil'.  The letter `q' in `memq'
     says that it uses `eq' to compare OBJECT against the elements of
     the list.  For example:

          (memq 'b '(a b c b a))
               => (b c b a)
          (memq '(2) '((1) (2)))    ; `(2)' and `(2)' are not `eq'.
               => nil

 -- Function: delq object list
     This function destructively removes all elements `eq' to OBJECT
     from LIST.  The letter `q' in `delq' says that it uses `eq' to
     compare OBJECT against the elements of the list, like `memq' and
     `remq'.

   When `delq' deletes elements from the front of the list, it does so
simply by advancing down the list and returning a sublist that starts
after those elements:

     (delq 'a '(a b c)) == (cdr '(a b c))

   When an element to be deleted appears in the middle of the list,
removing it involves changing the CDRs (*note Setcdr::).

     (setq sample-list '(a b c (4)))
          => (a b c (4))
     (delq 'a sample-list)
          => (b c (4))
     sample-list
          => (a b c (4))
     (delq 'c sample-list)
          => (a b (4))
     sample-list
          => (a b (4))

   Note that `(delq 'c sample-list)' modifies `sample-list' to splice
out the third element, but `(delq 'a sample-list)' does not splice
anything--it just returns a shorter list.  Don't assume that a variable
which formerly held the argument LIST now has fewer elements, or that
it still holds the original list!  Instead, save the result of `delq'
and use that.  Most often we store the result back into the variable
that held the original list:

     (setq flowers (delq 'rose flowers))

   In the following example, the `(4)' that `delq' attempts to match
and the `(4)' in the `sample-list' are not `eq':

     (delq '(4) sample-list)
          => (a c (4))

   If you want to delete elements that are `equal' to a given value,
use `delete' (see below).

 -- Function: remq object list
     This function returns a copy of LIST, with all elements removed
     which are `eq' to OBJECT.  The letter `q' in `remq' says that it
     uses `eq' to compare OBJECT against the elements of `list'.

          (setq sample-list '(a b c a b c))
               => (a b c a b c)
          (remq 'a sample-list)
               => (b c b c)
          sample-list
               => (a b c a b c)

 -- Function: memql object list
     The function `memql' tests to see whether OBJECT is a member of
     LIST, comparing members with OBJECT using `eql', so floating point
     elements are compared by value.  If OBJECT is a member, `memql'
     returns a list starting with its first occurrence in LIST.
     Otherwise, it returns `nil'.

     Compare this with `memq':

          (memql 1.2 '(1.1 1.2 1.3))  ; `1.2' and `1.2' are `eql'.
               => (1.2 1.3)
          (memq 1.2 '(1.1 1.2 1.3))  ; `1.2' and `1.2' are not `eq'.
               => nil

   The following three functions are like `memq', `delq' and `remq',
but use `equal' rather than `eq' to compare elements.  *Note Equality
Predicates::.

 -- Function: member object list
     The function `member' tests to see whether OBJECT is a member of
     LIST, comparing members with OBJECT using `equal'.  If OBJECT is a
     member, `member' returns a list starting with its first occurrence
     in LIST.  Otherwise, it returns `nil'.

     Compare this with `memq':

          (member '(2) '((1) (2)))  ; `(2)' and `(2)' are `equal'.
               => ((2))
          (memq '(2) '((1) (2)))    ; `(2)' and `(2)' are not `eq'.
               => nil
          ;; Two strings with the same contents are `equal'.
          (member "foo" '("foo" "bar"))
               => ("foo" "bar")

 -- Function: delete object sequence
     If `sequence' is a list, this function destructively removes all
     elements `equal' to OBJECT from SEQUENCE.  For lists, `delete' is
     to `delq' as `member' is to `memq': it uses `equal' to compare
     elements with OBJECT, like `member'; when it finds an element that
     matches, it cuts the element out just as `delq' would.

     If `sequence' is a vector or string, `delete' returns a copy of
     `sequence' with all elements `equal' to `object' removed.

     For example:

          (setq l '((2) (1) (2)))
          (delete '(2) l)
               => ((1))
          l
               => ((2) (1))
          ;; If you want to change `l' reliably,
          ;; write `(setq l (delete '(2) l))'.
          (setq l '((2) (1) (2)))
          (delete '(1) l)
               => ((2) (2))
          l
               => ((2) (2))
          ;; In this case, it makes no difference whether you set `l',
          ;; but you should do so for the sake of the other case.
          (delete '(2) [(2) (1) (2)])
               => [(1)]

 -- Function: remove object sequence
     This function is the non-destructive counterpart of `delete'.  It
     returns a copy of `sequence', a list, vector, or string, with
     elements `equal' to `object' removed.  For example:

          (remove '(2) '((2) (1) (2)))
               => ((1))
          (remove '(2) [(2) (1) (2)])
               => [(1)]

     Common Lisp note: The functions `member', `delete' and `remove' in
     GNU Emacs Lisp are derived from Maclisp, not Common Lisp.  The
     Common Lisp versions do not use `equal' to compare elements.

 -- Function: member-ignore-case object list
     This function is like `member', except that OBJECT should be a
     string and that it ignores differences in letter-case and text
     representation: upper-case and lower-case letters are treated as
     equal, and unibyte strings are converted to multibyte prior to
     comparison.

 -- Function: delete-dups list
     This function destructively removes all `equal' duplicates from
     LIST, stores the result in LIST and returns it.  Of several
     `equal' occurrences of an element in LIST, `delete-dups' keeps the
     first one.

   See also the function `add-to-list', in *note List Variables::, for
a way to add an element to a list stored in a variable and used as a
set.


File: elisp,  Node: Association Lists,  Prev: Sets And Lists,  Up: Lists

5.8 Association Lists
=====================

An "association list", or "alist" for short, records a mapping from
keys to values.  It is a list of cons cells called "associations": the
CAR of each cons cell is the "key", and the CDR is the "associated
value".(1)

   Here is an example of an alist.  The key `pine' is associated with
the value `cones'; the key `oak' is associated with `acorns'; and the
key `maple' is associated with `seeds'.

     ((pine . cones)
      (oak . acorns)
      (maple . seeds))

   Both the values and the keys in an alist may be any Lisp objects.
For example, in the following alist, the symbol `a' is associated with
the number `1', and the string `"b"' is associated with the _list_ `(2
3)', which is the CDR of the alist element:

     ((a . 1) ("b" 2 3))

   Sometimes it is better to design an alist to store the associated
value in the CAR of the CDR of the element.  Here is an example of such
an alist:

     ((rose red) (lily white) (buttercup yellow))

Here we regard `red' as the value associated with `rose'.  One
advantage of this kind of alist is that you can store other related
information--even a list of other items--in the CDR of the CDR.  One
disadvantage is that you cannot use `rassq' (see below) to find the
element containing a given value.  When neither of these considerations
is important, the choice is a matter of taste, as long as you are
consistent about it for any given alist.

   The same alist shown above could be regarded as having the
associated value in the CDR of the element; the value associated with
`rose' would be the list `(red)'.

   Association lists are often used to record information that you might
otherwise keep on a stack, since new associations may be added easily to
the front of the list.  When searching an association list for an
association with a given key, the first one found is returned, if there
is more than one.

   In Emacs Lisp, it is _not_ an error if an element of an association
list is not a cons cell.  The alist search functions simply ignore such
elements.  Many other versions of Lisp signal errors in such cases.

   Note that property lists are similar to association lists in several
respects.  A property list behaves like an association list in which
each key can occur only once.  *Note Property Lists::, for a comparison
of property lists and association lists.

 -- Function: assoc key alist
     This function returns the first association for KEY in ALIST,
     comparing KEY against the alist elements using `equal' (*note
     Equality Predicates::).  It returns `nil' if no association in
     ALIST has a CAR `equal' to KEY.  For example:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assoc 'oak trees)
               => (oak . acorns)
          (cdr (assoc 'oak trees))
               => acorns
          (assoc 'birch trees)
               => nil

     Here is another example, in which the keys and values are not
     symbols:

          (setq needles-per-cluster
                '((2 "Austrian Pine" "Red Pine")
                  (3 "Pitch Pine")
                  (5 "White Pine")))

          (cdr (assoc 3 needles-per-cluster))
               => ("Pitch Pine")
          (cdr (assoc 2 needles-per-cluster))
               => ("Austrian Pine" "Red Pine")

   The function `assoc-string' is much like `assoc' except that it
ignores certain differences between strings.  *Note Text Comparison::.

 -- Function: rassoc value alist
     This function returns the first association with value VALUE in
     ALIST.  It returns `nil' if no association in ALIST has a CDR
     `equal' to VALUE.

     `rassoc' is like `assoc' except that it compares the CDR of each
     ALIST association instead of the CAR.  You can think of this as
     "reverse `assoc'", finding the key for a given value.

 -- Function: assq key alist
     This function is like `assoc' in that it returns the first
     association for KEY in ALIST, but it makes the comparison using
     `eq' instead of `equal'.  `assq' returns `nil' if no association
     in ALIST has a CAR `eq' to KEY.  This function is used more often
     than `assoc', since `eq' is faster than `equal' and most alists
     use symbols as keys.  *Note Equality Predicates::.

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assq 'pine trees)
               => (pine . cones)

     On the other hand, `assq' is not usually useful in alists where the
     keys may not be symbols:

          (setq leaves
                '(("simple leaves" . oak)
                  ("compound leaves" . horsechestnut)))

          (assq "simple leaves" leaves)
               => nil
          (assoc "simple leaves" leaves)
               => ("simple leaves" . oak)

 -- Function: rassq value alist
     This function returns the first association with value VALUE in
     ALIST.  It returns `nil' if no association in ALIST has a CDR `eq'
     to VALUE.

     `rassq' is like `assq' except that it compares the CDR of each
     ALIST association instead of the CAR.  You can think of this as
     "reverse `assq'", finding the key for a given value.

     For example:

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

          (rassq 'acorns trees)
               => (oak . acorns)
          (rassq 'spores trees)
               => nil

     `rassq' cannot search for a value stored in the CAR of the CDR of
     an element:

          (setq colors '((rose red) (lily white) (buttercup yellow)))

          (rassq 'white colors)
               => nil

     In this case, the CDR of the association `(lily white)' is not the
     symbol `white', but rather the list `(white)'.  This becomes
     clearer if the association is written in dotted pair notation:

          (lily white) == (lily . (white))

 -- Function: assoc-default key alist &optional test default
     This function searches ALIST for a match for KEY.  For each
     element of ALIST, it compares the element (if it is an atom) or
     the element's CAR (if it is a cons) against KEY, by calling TEST
     with two arguments: the element or its CAR, and KEY.  The
     arguments are passed in that order so that you can get useful
     results using `string-match' with an alist that contains regular
     expressions (*note Regexp Search::).  If TEST is omitted or `nil',
     `equal' is used for comparison.

     If an alist element matches KEY by this criterion, then
     `assoc-default' returns a value based on this element.  If the
     element is a cons, then the value is the element's CDR.
     Otherwise, the return value is DEFAULT.

     If no alist element matches KEY, `assoc-default' returns `nil'.

 -- Function: copy-alist alist
     This function returns a two-level deep copy of ALIST: it creates a
     new copy of each association, so that you can alter the
     associations of the new alist without changing the old one.

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . ("Pitch Pine"))
                  (5 . ("White Pine"))))
          =>
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (setq copy (copy-alist needles-per-cluster))
          =>
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (eq needles-per-cluster copy)
               => nil
          (equal needles-per-cluster copy)
               => t
          (eq (car needles-per-cluster) (car copy))
               => nil
          (cdr (car (cdr needles-per-cluster)))
               => ("Pitch Pine")
          (eq (cdr (car (cdr needles-per-cluster)))
              (cdr (car (cdr copy))))
               => t

     This example shows how `copy-alist' makes it possible to change
     the associations of one copy without affecting the other:

          (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
          (cdr (assq 3 needles-per-cluster))
               => ("Pitch Pine")

 -- Function: assq-delete-all key alist
     This function deletes from ALIST all the elements whose CAR is
     `eq' to KEY, much as if you used `delq' to delete each such
     element one by one.  It returns the shortened alist, and often
     modifies the original list structure of ALIST.  For correct
     results, use the return value of `assq-delete-all' rather than
     looking at the saved value of ALIST.

          (setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
               => ((foo 1) (bar 2) (foo 3) (lose 4))
          (assq-delete-all 'foo alist)
               => ((bar 2) (lose 4))
          alist
               => ((foo 1) (bar 2) (lose 4))

 -- Function: rassq-delete-all value alist
     This function deletes from ALIST all the elements whose CDR is
     `eq' to VALUE.  It returns the shortened alist, and often modifies
     the original list structure of ALIST.  `rassq-delete-all' is like
     `assq-delete-all' except that it compares the CDR of each ALIST
     association instead of the CAR.

   ---------- Footnotes ----------

   (1) This usage of "key" is not related to the term "key sequence";
it means a value used to look up an item in a table.  In this case, the
table is the alist, and the alist associations are the items.


File: elisp,  Node: Sequences Arrays Vectors,  Next: Hash Tables,  Prev: Lists,  Up: Top

6 Sequences, Arrays, and Vectors
********************************

The "sequence" type is the union of two other Lisp types: lists and
arrays.  In other words, any list is a sequence, and any array is a
sequence.  The common property that all sequences have is that each is
an ordered collection of elements.

   An "array" is a fixed-length object with a slot for each of its
elements.  All the elements are accessible in constant time.  The four
types of arrays are strings, vectors, char-tables and bool-vectors.

   A list is a sequence of elements, but it is not a single primitive
object; it is made of cons cells, one cell per element.  Finding the
Nth element requires looking through N cons cells, so elements farther
from the beginning of the list take longer to access.  But it is
possible to add elements to the list, or remove elements.

   The following diagram shows the relationship between these types:

               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

* Menu:

* Sequence Functions::    Functions that accept any kind of sequence.
* Arrays::                Characteristics of arrays in Emacs Lisp.
* Array Functions::       Functions specifically for arrays.
* Vectors::               Special characteristics of Emacs Lisp vectors.
* Vector Functions::      Functions specifically for vectors.
* Char-Tables::           How to work with char-tables.
* Bool-Vectors::          How to work with bool-vectors.
* Rings::                 Managing a fixed-size ring of objects.


File: elisp,  Node: Sequence Functions,  Next: Arrays,  Up: Sequences Arrays Vectors

6.1 Sequences
=============

This section describes functions that accept any kind of sequence.

 -- Function: sequencep object
     This function returns `t' if OBJECT is a list, vector, string,
     bool-vector, or char-table, `nil' otherwise.

 -- Function: length sequence
     This function returns the number of elements in SEQUENCE.  If
     SEQUENCE is a dotted list, a `wrong-type-argument' error is
     signaled.  Circular lists may cause an infinite loop.  For a
     char-table, the value returned is always one more than the maximum
     Emacs character code.

     *Note Definition of safe-length::, for the related function
     `safe-length'.

          (length '(1 2 3))
              => 3
          (length ())
              => 0
          (length "foobar")
              => 6
          (length [1 2 3])
              => 3
          (length (make-bool-vector 5 nil))
              => 5

See also `string-bytes', in *note Text Representations::.

   If you need to compute the width of a string on display, you should
use `string-width' (*note Width::), not `length', since `length' only
counts the number of characters, but does not account for the display
width of each character.

 -- Function: elt sequence index
     This function returns the element of SEQUENCE indexed by INDEX.
     Legitimate values of INDEX are integers ranging from 0 up to one
     less than the length of SEQUENCE.  If SEQUENCE is a list,
     out-of-range values behave as for `nth'.  *Note Definition of
     nth::.  Otherwise, out-of-range values trigger an
     `args-out-of-range' error.

          (elt [1 2 3 4] 2)
               => 3
          (elt '(1 2 3 4) 2)
               => 3
          ;; We use `string' to show clearly which character `elt' returns.
          (string (elt "1234" 2))
               => "3"
          (elt [1 2 3 4] 4)
               error--> Args out of range: [1 2 3 4], 4
          (elt [1 2 3 4] -1)
               error--> Args out of range: [1 2 3 4], -1

     This function generalizes `aref' (*note Array Functions::) and
     `nth' (*note Definition of nth::).

 -- Function: copy-sequence sequence
     This function returns a copy of SEQUENCE.  The copy is the same
     type of object as the original sequence, and it has the same
     elements in the same order.

     Storing a new element into the copy does not affect the original
     SEQUENCE, and vice versa.  However, the elements of the new
     sequence are not copies; they are identical (`eq') to the elements
     of the original.  Therefore, changes made within these elements, as
     found via the copied sequence, are also visible in the original
     sequence.

     If the sequence is a string with text properties, the property
     list in the copy is itself a copy, not shared with the original's
     property list.  However, the actual values of the properties are
     shared.  *Note Text Properties::.

     This function does not work for dotted lists.  Trying to copy a
     circular list may cause an infinite loop.

     See also `append' in *note Building Lists::, `concat' in *note
     Creating Strings::, and `vconcat' in *note Vector Functions::, for
     other ways to copy sequences.

          (setq bar '(1 2))
               => (1 2)
          (setq x (vector 'foo bar))
               => [foo (1 2)]
          (setq y (copy-sequence x))
               => [foo (1 2)]

          (eq x y)
               => nil
          (equal x y)
               => t
          (eq (elt x 1) (elt y 1))
               => t

          ;; Replacing an element of one sequence.
          (aset x 0 'quux)
          x => [quux (1 2)]
          y => [foo (1 2)]

          ;; Modifying the inside of a shared element.
          (setcar (aref x 1) 69)
          x => [quux (69 2)]
          y => [foo (69 2)]



Local Variables:
coding: iso-8859-1
End:
